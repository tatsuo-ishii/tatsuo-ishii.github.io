<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. Restrictions</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="pgpool-II 3.6beta2 Documentation" /><link rel="up" href="preface.html" title="Preface" /><link rel="prev" href="resources.html" title="4. Further Information" /><link rel="next" href="bug-reporting.html" title="6. Bug Reporting Guidelines" /><link rel="copyright" href="legalnotice.html" title="Legal Notice" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Restrictions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="resources.html">Prev</a> </td><th width="60%" align="center">Preface</th><td width="20%" align="right"> <a accesskey="n" href="bug-reporting.html">Next</a></td></tr></table><hr /></div><div class="sect1" id="restrictions"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5. Restrictions</h2></div></div></div><p>  This section descibes current restrictions of <span class="productname">Pgpool-II</span>.

  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">Functionality of PostgreSQL</span></dt><dd><p>       If you use <code class="function">pg_terminate_backend()</code> to stop
       a backend, this will trigger a failover.  The reason why this
       happens is that <span class="productname">PostgreSQL</span> sends
       exactly the same message for a terminated backend as for a full
       postmaster shutdown.  There is no workaround prior of version
       3.6. From version 3.6, this limitation has been mitigated. If
       the argument to the function (that is a process id) is a
       constant, you can safely use the function. In extended protocol
       mode, you cannot use the function though.
     </p></dd><dt><span class="term">Authentication/Access Controls</span></dt><dd><p>	In the replication mode or master/slave mode, trust, clear
        text password, and pam methods are supported. md5 in also
        supported since <span class="productname">Pgpool-II</span> 3.0.  md5
        is supported by using a authencitaion file <code class="filename">pool_passwd</code>.
        <code class="filename">pool_passwd</code> is default name of the
        authentication file. Here are the
        steps to enable md5 authentication:
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>	    Login as the database's operating system user and type:
	    </p><pre class="programlisting">            pg_md5 --md5auth --username=<code class="literal">your_username</code> <code class="literal">your_passwd</code>
	    </pre><p>
            user name and md5 encrypted password are registered into
            pool_passwd.  If pool_passwd does not exist yet, pg_md5
            command will automatically create it for you.  The format
            of pool_passwd
            is <code class="literal">username:encrypted_passwd</code>.
	  </p></li><li class="listitem"><p>	    You also need to add an appropriate md5 entry to
            pool_hba.conf.  See <a class="xref" href="auth-pool-hba-conf.html" title="6.1. The pool_hba.conf File">Section 6.1, “The <code class="filename">pool_hba.conf</code> File”</a> for more details.
	  </p></li><li class="listitem"><p>            Please note that the user name and password must be
            identical to those registered
            in <span class="productname">PostgreSQL</span>.
	  </p></li><li class="listitem"><p>            After changing md5 password (in both pool_passwd and
            PostgreSQL of course), you need to
            execute <span class="application">pgpool reload</span>.
	  </p></li></ol></div></dd><dt><span class="term">Large objects</span></dt><dd><p>	In streaming replication
	mode, <span class="productname">Pgpool-II</span> supports large
	objects.
      </p><p>	In native replication
	mode, <span class="productname">Pgpool-II</span> supports large
	objects if the backend
	is <span class="productname">PostgreSQL</span> 8.1 or later.  For
	this, you need to enable lobj_lock_table directive
	in <code class="filename">pgpool.conf</code>.  Large object replication
	using backend function <code class="function">lo_import</code> is not
	supported, however.
      </p><p>	In other mode, including Slony mode, large
	objects are not supported.
      </p></dd><dt><span class="term">Temporary tables</span></dt><dd><p>	Creating/inserting/updating/deleting temporary tables are
	always executed on the master (primary) in master slave mode.
	SELECT on these tables is executed on master as well.  However
	if the temporary table name is used as a literal in SELECT,
	there's no way to detect it, and the SELECT will be load
	balanced.  That will trigger a "not found the table" error or
	will find another table having same name.  To avoid the
	problem, use /*NO LOAD BALANCE*/ SQL comment.
      </p><p>	Note that such literal table names used in queries to access
	system catalogs do cause problems described above.  psql's \d
	command produces such that query:
	</p><pre class="programlisting">SELECT 't1'::regclass::oid;
	</pre><p>
	In such that case <span class="productname">Pgpool-II</span> always
	sends the query to master and will not cause the problem.
      </p><p>	Tables created by <code class="command">CREATE TEMP TABLE</code> will be
	deleted at the end of the session by specifying DISCARD ALL in
	reset_query_list if you are using PostgreSQL 8.3 or later.
      </p><p>	For 8.2.x or earlier, tables created by <code class="command">CREATE TEMP
	TABLE</code> will not be deleted after exiting a
	session. It is because of the connection pooling which, from
	PostgreSQL's backend point of view, keeps the session
	alive. To avoid this, you must explicitly drop the temporary
	tables by issuing <code class="command">DROP TABLE</code>, or
	use <code class="command">CREATE TEMP TABLE ... ON COMMIT DROP</code>
	inside the transaction block.
      </p></dd><dt><span class="term">Functions, etc. In Native Replication mode</span></dt><dd><p>	There is no guarantee that any data provided using a
	context-dependent mechanism (e.g. random number, transaction
	ID, OID, SERIAL, sequence), will be replicated correctly on
	multiple backends. For SERIAL, enabling insert_lock will help
	replicating data.  insert_lock also helps SELECT setval() and
	SELECT nextval().
      </p><p>	INSERT/UPDATE
	using <code class="function">CURRENT_TIMESTAMP</code>, <code class="function">CURRENT_DATE</code>,
	<code class="function">now()</code> will be replicated
	correctly. INSERT/UPDATE for tables
	using <code class="function">CURRENT_TIMESTAMP</code>, <code class="function">CURRENT_DATE</code>,
	<code class="function">now()</code> as their DEFAULT values will also
	be replicated correctly.  This is done by replacing those
	functions by constants fetched from master at query execution
	time.  There are a few limitations however:
      </p><p>	In <span class="productname">Pgpool-II</span> 3.0 or before, the
        calculation of temporal data in table default value is not
        accurate in some cases. For example, the following table
        definition:
	</p><pre class="programlisting">CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE + 1
)
	</pre><p>
	is treated the same as:
	</p><pre class="programlisting">CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE
)
	</pre><p>
	<span class="productname">Pgpool-II</span> 3.1 or later handles
	these cases correctly.  Thus the column "d1" will have
	tomorrow as the default value.  However this enhancement does
	not apply if extended protocols (used in JDBC, PHP PDO for
	example) or PREPARE are used.
      </p><p>	Please note that if the column type is not a temporal one,
	rewriting is not performed. Such example:
	</p><pre class="programlisting">foo bigint default (date_part('epoch'::text,('now'::text)::timestamp(3) with time zone) * (1000)::double precision)
	</pre><p>
	Suppose we have the following table:
	</p><pre class="programlisting">CREATE TABLE rel1(
  c1 int,
  c2 timestamp default now()
)
	</pre><p>
	We can replicate
	</p><pre class="programlisting">INSERT INTO rel1(c1) VALUES(1)
	</pre><p>

    since this turn into

	</p><pre class="programlisting">INSERT INTO rel1(c1, c2) VALUES(1, '2009-01-01 23:59:59.123456+09')
	</pre><p>

    However,
	</p><pre class="programlisting">INSERT INTO rel1(c1) SELECT 1
	</pre><p>
    cannot to be transformed, thus cannot be properly replicated in the current implementation.
    Values will still be inserted, with no transformation at all.
      </p></dd></dl></div><p>
 </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="resources.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="preface.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="bug-reporting.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">4. Further Information </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 6. Bug Reporting Guidelines</td></tr></table></div></body></html>
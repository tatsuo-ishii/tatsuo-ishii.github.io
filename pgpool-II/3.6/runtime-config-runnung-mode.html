<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.3. Running mode</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="pgpool-II 3.6beta2 Documentation" /><link rel="up" href="runtime-config.html" title="Chapter 5. Server Configuration" /><link rel="prev" href="runtime-config-connection.html" title="5.2. Connections and Authentication" /><link rel="next" href="runtime-config-backend-settings.html" title="5.4. Backend Settings" /><link rel="copyright" href="legalnotice.html" title="Legal Notice" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5.3. Running mode</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="runtime-config-connection.html">Prev</a> </td><th width="60%" align="center">Chapter 5. Server Configuration</th><td width="20%" align="right"> <a accesskey="n" href="runtime-config-backend-settings.html">Next</a></td></tr></table><hr /></div><div class="sect1" id="runtime-config-runnung-mode"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.3. Running mode</h2></div></div></div><div class="sect2" id="runtime-config-master-slave-mode"><div class="titlepage"><div><div><h3 class="title">5.3.1. Master slave mode</h3></div></div></div><p>			This mode is used to couple <span class="productname">Pgpool-II</span>
			with another master/slave replication software (like <acronym class="acronym">Slony-I</acronym>
			and Streaming replication), that is responsible for doing the actual data replication.
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>				The number of slave nodes are not limited to 1 and
				<span class="productname">Pgpool-II</span> can have up to 127 slave nodes.
				master/slave mode can also work just master node without any slave nodes.
			</p></div><p>			Load balancing (see <a class="xref" href="runtime-config-load-balancing.html" title="5.7. Load Balancing">Section 5.7, “Load Balancing”</a> ) can
			also be used with master/slave mode to distribute the read load on the
			standby backend nodes.
		</p><p>				 Following options are required to be specified for master/slave mode.
		</p><div class="variablelist"><dl class="variablelist"><dt id="guc-master-slave-mode"><span class="term"><code class="varname">master_slave_mode</code> (<code class="type">boolean</code>)
					<a id="idp56738032" class="indexterm"></a>
				</span></dt><dd><p>						Setting to on enables the master/slave mode.
						Default is off.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>							<a class="xref" href="runtime-config-runnung-mode.html#guc-master-slave-mode">master_slave_mode</a> and <a class="xref" href="runtime-config-runnung-mode.html#guc-replication-mode">replication_mode</a>
							are mutually exclusive and only one can be enabled at a time.
						</p></div><p>						This parameter can only be set at server start.
					</p></dd><dt id="guc-master-slave-sub-mode"><span class="term"><code class="varname">master_slave_sub_mode</code> (<code class="type">enum</code>)
					<a id="idp56742832" class="indexterm"></a>
				</span></dt><dd><p>						Specifies the external replication system used for data replication between
						<span class="productname">PostgreSQL</span> nodes.
						Below table contains the list of valid values for the parameter.
					</p><div class="table" id="master-slave-sub-mode-table"><p class="title"><strong>Table 5.1. master slave sub mode options</strong></p><div class="table-contents"><table summary="master slave sub mode options" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>Value</th><th>Description</th></tr></thead><tbody><tr><td><code class="literal">'slony'</code></td><td>Suitable for <acronym class="acronym">Slony-I</acronym></td></tr><tr><td><code class="literal">'stream'</code></td><td>Suitable for <span class="productname">PostgreSQL</span>'s built-in replication system (Streaming Replication)</td></tr></tbody></table></div></div><br class="table-break" /><p>						Default is <code class="literal">'slony'</code>.
					</p><p>						This parameter can only be set at server start.
					</p></dd></dl></div></div><div class="sect2" id="runtime-config-replication-mode"><div class="titlepage"><div><div><h3 class="title">5.3.2. Replication mode</h3></div></div></div><p>			This mode makes the <span class="productname">Pgpool-II</span> to replicate data
			between <span class="productname">PostgreSQL</span> backends.
		</p><p>			Load balancing (see <a class="xref" href="runtime-config-load-balancing.html" title="5.7. Load Balancing">Section 5.7, “Load Balancing”</a> ) can
			also be used with replication mode to distribute the load to the
			attached backend nodes.
		</p><p>				 Following options affect the behavior of
				 <span class="productname">Pgpool-II</span> in the replication mode.
		</p><div class="variablelist"><dl class="variablelist"><dt id="guc-replication-mode"><span class="term"><code class="varname">replication_mode</code> (<code class="type">boolean</code>)
					<a id="idp56756576" class="indexterm"></a>
				</span></dt><dd><p>						Setting to on enables the replication mode.
						Default is off.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>							<a class="xref" href="runtime-config-runnung-mode.html#guc-replication-mode">replication_mode</a> and <a class="xref" href="runtime-config-runnung-mode.html#guc-master-slave-mode">master_slave_mode</a>
							are mutually exclusive and only one can be enabled at a time.
						</p></div><p>						This parameter can only be set at server start.
					</p></dd><dt id="guc-replication-stop-on-mismatch"><span class="term"><code class="varname">replication_stop_on_mismatch</code> (<code class="type">boolean</code>)
					<a id="idp56761376" class="indexterm"></a>
				</span></dt><dd><p>						When set to on, and all nodes do not reply with the same packet kind
						to the query that was sent to all <span class="productname">PostgreSQL</span> backend nodes, then the
						backend node whose reply differs from the majority is degenerated
						by the <span class="productname">Pgpool-II</span>.
						If <code class="varname">replication_stop_on_mismatch</code> is set to off and
						a similar situation happens then the <span class="productname">Pgpool-II</span>
						only terminates the current user session but does not degenerate a backend node.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>							<span class="productname">Pgpool-II</span> does not examine the data returned
							by the backends and takes the decision only by comparing the result packet
							types.
						</p></div><p>						A typical use case of enabling the <code class="varname">replication_stop_on_mismatch</code>
						is to guard against the data inconsistency among the backend nodes.
						For example, you may want to degenerate a backend node if an UPDATE statement
						fails on one backend node while passes on others.
					</p><p>						Default is off.
					</p><p>						This parameter can be changed by reloading the <span class="productname">Pgpool-II</span> configurations.
					</p></dd><dt id="guc-failover-if-affected-tuples-mismatch"><span class="term"><code class="varname">failover_if_affected_tuples_mismatch</code> (<code class="type">boolean</code>)
					<a id="idp56770160" class="indexterm"></a>
				</span></dt><dd><p>						When set to on, and all nodes do not reply with the same number of
						affected tuples to the INSERT/UPDATE/DELETE query, then the
						backend node whose reply differs from the majority is degenerated
						by the <span class="productname">Pgpool-II</span>.
						If <code class="varname">failover_if_affected_tuples_mismatch</code> is set to off and
						a similar situation happens then the <span class="productname">Pgpool-II</span>
						only terminates the current user session but does not degenerate a backend node.
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>							In case of a tie, when two or more groups have the same number of nodes,
							then the group containing the master node (backend node having
							the youngest node id) gets the precedence.
						</p></div><p>						Default is off.
					</p><p>						This parameter can be changed by reloading the <span class="productname">Pgpool-II</span> configurations.
					</p></dd><dt id="guc-replicate-select"><span class="term"><code class="varname">replicate_select</code> (<code class="type">boolean</code>)
					<a id="idp56776864" class="indexterm"></a>
				</span></dt><dd><p>						When set to on, <span class="productname">Pgpool-II</span> enables the
						SELECT query replication mode. i.e. The SELECT queries are sent
						to all backend nodes.
					</p><div class="table" id="replicate-select-affect-table"><p class="title"><strong>Table 5.2. replicate_select with <a class="xref" href="runtime-config-load-balancing.html#guc-load-balance-mode">load_balance_mode</a> affects on SELECT routing</strong></p><div class="table-contents"><table summary="replicate_select with  affects on SELECT routing" border="1"><colgroup><col align="center" class="_1" /><col align="center" class="_2" /><col align="center" class="_3" /><col align="center" class="_4" /><col align="center" class="_5" /><col align="center" class="_6" /></colgroup><tbody><tr><td align="center">replicate_select is true</td><td align="center">Y</td><td colspan="4" align="center">N</td></tr><tr><td align="center">load_balance_mode is true</td><td align="center">ANY</td><td align="center">Y</td><td colspan="3" align="center">N</td></tr><tr><td align="center">SELECT is inside a transaction block</td><td align="center">ANY</td><td colspan="2" align="center"> Y </td><td align="center">N</td><td align="center">ANY</td></tr><tr><td align="center">										Transaction isolation level is SERIALIZABLE and
										the transaction has issued a write query
									</td><td align="center">Y</td><td align="center">N</td><td align="center">ANY</td><td align="center">ANY</td><td align="center">ANY</td></tr><tr><td align="center">										results(R:replication, M: send only to master, L: load balance)
									</td><td align="center">R</td><td align="center">M</td><td align="center">L</td><td align="center">L</td><td align="center">M</td></tr></tbody></table></div></div><br class="table-break" /><p>						Default is off.
					</p><p>						This parameter can be changed by reloading the <span class="productname">Pgpool-II</span> configurations.
					</p></dd><dt id="guc-insert-lock"><span class="term"><code class="varname">insert_lock</code> (<code class="type">boolean</code>)
					<a id="idp56799920" class="indexterm"></a>
				</span></dt><dd><p>						When set to on, <span class="productname">Pgpool-II</span> will automatically lock
						the table on <span class="productname">PostgreSQL</span> before an INSERT statement is issued for that.
					</p><p>						When replicating a table with SERIAL data type,
						the SERIAL column value may get different values
						on the different backends.
						The workaround to this problem is to explicitly lock the table
						before issuing the INSERT.
					</p><p>						So for automatically locking the table <span class="productname">Pgpool-II</span> do the following transformation:
							</p><pre class="programlisting">INSERT INTO ...
							</pre><p>
						to
							</p><pre class="programlisting">BEGIN;
LOCK TABLE ...
INSERT INTO ...
COMMIT;
							</pre><p>
					</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>							This approach severely degrades the transactions' parallelism
						</p></div><p>						<span class="productname">Pgpool-II</span> <span class="emphasis"><em>V2.2</em></span> or later,
						automatically detects whether the table has a SERIAL columns or not,
						so it never  locks the table if it desn't have the SERIAL columns.
					</p><p>						<span class="productname">Pgpool-II</span> <span class="emphasis"><em>V3.0</em></span> until
						<span class="productname">Pgpool-II</span> <span class="emphasis"><em>V3.0.4</em></span> uses a row lock
						against the sequence relation, rather than table lock.
						This is intended to minimize lock conflict with <acronym class="acronym">VACUUM</acronym>
						(including autovacuum).
						However this can lead to another problem. After transaction wraparound happens,
						row locking against the sequence relation causes PostgreSQL internal error
						(more precisely, access error on pg_clog, which keeps transaction status).
						To prevent this, <span class="productname">PostgreSQL</span> core developers decided to disallow row locking
						against sequences and this broke the <span class="productname">Pgpool-II</span>,
						of course (the "fixed" version of PostgreSQL was released as
						9.0.5, 8.4.9, 8.3.16 and 8.2.22).
					</p><p>						<span class="productname">Pgpool-II</span> <span class="emphasis"><em>V3.0.5</em></span> or later
						uses a row lock against <code class="literal">pgpool_catalog.insert_lock</code> table
						because new PostgreSQL disallows a row lock against the sequence relation.
						So creating insert_lock table in all databases which are accessed via
						<span class="productname">Pgpool-II</span> beforehand is required.
						See <a class="xref" href="create-installlock-table.html" title="3.7. Creating insert_lock table">Section 3.7, “Creating insert_lock table”</a> for more details.
						If does not exist insert_lock table, <span class="productname">Pgpool-II</span>
						locks the insert target table.
						This behavior is same as <span class="productname">Pgpool-II</span> <span class="emphasis"><em>V2.2</em></span>
						and <span class="emphasis"><em>V2.3</em></span> series.
					</p><p>						If you want to use <code class="varname">insert_lock</code> which is compatible
						with older releases, you can specify lock method by configure script.
						See <a class="xref" href="install-pgpool.html" title="3.4. Installing Pgpool-II">Section 3.4, “Installing Pgpool-II”</a> for more details.
					</p><p>						For fine (per statement) control:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>								set insert_lock to true, and add /*NO INSERT LOCK*/ at the beginning of an
								INSERT statement for which you do not want to acquire the table lock.
							</p></li><li class="listitem"><p>								set insert_lock to false, and add /*INSERT LOCK*/ at the beginning of an
								INSERT statement for which you want to acquire the table lock.
							</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>							If insert_lock is enabled, the regression tests for PostgreSQL 8.0 gets fail
							in transactions, privileges, rules, and alter_table.
						</p><p>							The reason for this is that <span class="productname">Pgpool-II</span>
							tries to LOCK the VIEW for the rule test, and it produces the below error message:
								</p><pre class="programlisting">! ERROR: current transaction is aborted, commands ignored until
end of transaction block
							</pre><p>
								For example, the transactions test tries an INSERT into a table which does not exist,
								and <span class="productname">Pgpool-II</span> causes <span class="productname">PostgreSQL</span> to
								acquire the lock for the table. Of cause this results in an error.
								The transaction will be aborted, and the following INSERT statement produces the above error message.
						</p></div><p>						Default is off.
					</p><p>						This parameter can be changed by reloading the <span class="productname">Pgpool-II</span> configurations.
					</p></dd><dt id="guc-lobj-lock-table"><span class="term"><code class="varname">lobj_lock_table</code> (<code class="type">string</code>)
					<a id="idp56826400" class="indexterm"></a>
				</span></dt><dd><p>						Specifies a table name used for large object replication control.
						If it is specified, <span class="productname">Pgpool-II</span> will lock
						the table specified by <code class="varname">lobj_lock_table</code> and generate
						a large object id by looking into <code class="literal">pg_largeobject</code>
						system catalog and then call <code class="literal">lo_create</code> to create
						the large object.
						This procedure guarantees that <span class="productname">Pgpool-II</span>
						will get the same large object id in all DB nodes in replication mode.
						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>								<span class="productname">PostgreSQL</span> 8.0 and older does not have <code class="literal">lo_create</code>,
								so this feature does not work with PostgreSQL 8.0 and older versions.
							</p></div><p>							A call to the <code class="literal">libpq</code> function <code class="literal">lo_creat()</code>
							triggers this feature. Also large object creation through <acronym class="acronym">Java</acronym>
							API (<acronym class="acronym">JDBC</acronym> driver), <acronym class="acronym">PHP</acronym> API
							(<code class="literal">pg_lo_create</code>, or similar API in PHP library such as PDO),
							and this same API in various programming languages are known to use a
							similar protocol, and thus should work.
					</p><p>						This feature does not works with following operations on large objects.
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>								All APIs using <code class="literal">lo_create</code>, <code class="literal">lo_import_with_oid</code>.
							</p></li><li class="listitem"><p>								<code class="literal">lo_import</code> function in backend called in SELECT.
							</p></li><li class="listitem"><p>								<code class="literal">lo_create</code> function in backend called in SELECT.
							</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>							All <span class="productname">PostgreSQL</span> users must have a write access on <code class="varname">lobj_lock_table</code>
							and it can be created in any schema.
						</p></div><p>						Example to create a large object lock table:
						</p><pre class="programlisting">CREATE TABLE public.my_lock_table ();
GRANT ALL ON public.my_lock_table TO PUBLIC;
						</pre><p>
					</p><p>						Default is <code class="literal">''</code>(empty), which disables the feature.
					</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-connection.html">Prev</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html">Up</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-backend-settings.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">5.2. Connections and Authentication </td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top"> 5.4. Backend Settings</td></tr></table></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5.3. 動作モード</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Pgpool-II 3.7devel 文書" /><link rel="up" href="runtime-config.html" title="第5章 サーバの設定" /><link rel="prev" href="runtime-config-connection.html" title="5.2. 接続と認証" /><link rel="next" href="runtime-config-backend-settings.html" title="5.4. バックエンドの設定" /><link rel="copyright" href="legalnotice.html" title="Legal Notice" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">Pgpool-II 3.7devel 文書</a></th><td width="20%" align="right"></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="runtime-config-connection.html">前へ</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="runtime-config.html">上へ</a></td><td width="60%" align="center">5.3. 動作モード</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="runtime-config-backend-settings.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="runtime-config-runnung-mode"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5.3. 動作モード</h2></div></div></div><div class="sect2" id="runtime-config-master-slave-mode"><div class="titlepage"><div><div><h3 class="title">5.3.1. マスタースレーブモード</h3></div></div></div><p>このモードは<span class="productname">Pgpool-II</span>と（<acronym class="acronym">Slony-I</acronym>やストリームレプリケーションのような）他のマスター/スレーブ型のレプリケーションソフトウェアと組み合わせるのに使用されます。
実際にデータレプリケーションを行うのはこれらのソフトウェアに任されます。
		</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>スレーブノードの数は1つに限定されず、<span class="productname">Pgpool-II</span>は127個までのスレーブノードを持つことができます。
マスター/スレーブモードは、スレーブノードが1つも存在しない場合マスターノードのみを動作させることができます。
			</p></div><p>参照負荷をスタンバイバックエンドノードに振り分ける負荷分散（<a class="xref" href="runtime-config-load-balancing.html" title="5.7. 負荷分散">5.7. 負荷分散</a>を参照）もマスター/スレーブモードと共に使用可能です。
		</p><p>マスター/スレーブモードでは以下のオプションを設定する必要があります。
		</p><div class="variablelist"><dl class="variablelist"><dt id="guc-master-slave-mode"><span class="term"><code class="varname">master_slave_mode</code> (<code class="type">boolean</code>)
					<a id="idm45645430933680" class="indexterm"></a>
				</span></dt><dd><p>マスタースレーブモードを有効にします。
デフォルトはoffです。
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p><a class="xref" href="runtime-config-runnung-mode.html#guc-master-slave-mode">master_slave_mode</a>と<a class="xref" href="runtime-config-runnung-mode.html#guc-replication-mode">replication_mode</a>は相互に排他的で、一度に一方しか有効にすることができません。
						</p></div><p>このパラメータはサーバ起動時にのみ設定可能です。
					</p></dd><dt id="guc-master-slave-sub-mode"><span class="term"><code class="varname">master_slave_sub_mode</code> (<code class="type">enum</code>)
					<a id="idm45645430928960" class="indexterm"></a>
				</span></dt><dd><p><span class="productname">PostgreSQL</span>ノード間のデータレプリケーションに用いる外部のレプリケーションシステムを指定します。
以下の表にこのパラメータで有効な値のリストを示します。

					</p><div class="table" id="master-slave-sub-mode-table"><p class="title"><strong>表5.1 master_slave_sub_modeオプション</strong></p><div class="table-contents"><table class="table" summary="master_slave_sub_modeオプション" border="1"><colgroup><col /><col /></colgroup><thead><tr><th>値</th><th>説明</th></tr></thead><tbody><tr><td><code class="literal">'slony'</code></td><td> <acronym class="acronym">Slony-I</acronym>に適合</td></tr><tr><td><code class="literal">'stream'</code></td><td><span class="productname">PostgreSQL</span>の組み込みレプリケーションシステム（ストリーミングレプリケーション）に適合</td></tr></tbody></table></div></div><br class="table-break" /><p>デフォルトは<code class="literal">'slony'</code>です。
					</p><p>このパラメータはサーバ起動時にのみ設定可能です。
					</p></dd></dl></div></div><div class="sect2" id="runtime-config-replication-mode"><div class="titlepage"><div><div><h3 class="title">5.3.2. レプリケーションモード</h3></div></div></div><p>このモードでは<span class="productname">PostgreSQL</span>間のデータレプリケーションを<span class="productname">Pgpool-II</span>に行わせます。
		</p><p>参照負荷をスタンバイバックエンドノードに振り分ける負荷分散（<a class="xref" href="runtime-config-load-balancing.html" title="5.7. 負荷分散">5.7. 負荷分散</a>を参照）もレプリケーションモードと共に使用可能です。
		</p><p>以下のオプションがプリケーションモードにおける<span class="productname">Pgpool-II</span>の動作に影響します。
		</p><div class="variablelist"><dl class="variablelist"><dt id="guc-replication-mode"><span class="term"><code class="varname">replication_mode</code> (<code class="type">boolean</code>)
					<a id="idm45645430914928" class="indexterm"></a>
				</span></dt><dd><p>レプリケーションモードを有効にします。
デフォルトはoffです。
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p><a class="xref" href="runtime-config-runnung-mode.html#guc-replication-mode">replication_mode</a>と<a class="xref" href="runtime-config-runnung-mode.html#guc-master-slave-mode">master_slave_mode</a>は相互に排他的で、一度に一方しか有効にすることができません。
						</p></div><p>このパラメータはサーバ起動時にのみ設定可能です。
					</p></dd><dt id="guc-replication-stop-on-mismatch"><span class="term"><code class="varname">replication_stop_on_mismatch</code> (<code class="type">boolean</code>)
					<a id="idm45645430910208" class="indexterm"></a>
				</span></dt><dd><p>
これがonで、全ての<span class="productname">PostgreSQL</span>バックエンドノードに送られたクエリに対して、全てのノードが同じパケット種類で応答しなかった場合、多数派とは異なる応答したバックエンドノードは<span class="productname">Pgpool-II</span>による切り離されます。
<code class="varname">replication_stop_on_mismatch</code>がoffの場合に同様の状況が発生したときには、<span class="productname">Pgpool-II</span>は現在のユーザセッションを強制終了するだけにとどめ、バックエンドの切り離しは行いません。

					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p><span class="productname">Pgpool-II</span>はバックエンドから返されたデータは調べずに、結果パケットの種類の比較のみにより決断します。
						</p></div><p><code class="varname">replication_stop_on_mismatch</code>を有効にする典型的なユースケースは、バックエンドノード間のデータ不整合の防止です。
例えば、UPDATE文が他のノードでは成功しているのにあるバックエンドノードでは失敗した場合、そのバックエンドノードを切り離したいかもしれません。
					</p><p>デフォルトはoffです。
					</p><p>このパラメータは<span class="productname">Pgpool-II</span>の設定を再読み込みすることで変更可能です。
					</p></dd><dt id="guc-failover-if-affected-tuples-mismatch"><span class="term"><code class="varname">failover_if_affected_tuples_mismatch</code> (<code class="type">boolean</code>)
					<a id="idm45645430901136" class="indexterm"></a>
				</span></dt><dd><p>これがonで、全てのノードの応答でINSERT/UPDATE/DELETEクエリの影響を受けたタプルの数が同じでなかった場合、多数派とは異なる応答したバックエンドノードは<span class="productname">Pgpool-II</span>による切り離されます。
<code class="varname">failover_if_affected_tuples_mismatch</code>がoffの場合に同様の状況が発生したときには、<span class="productname">Pgpool-II</span>は現在のユーザセッションを強制終了するだけにとどめ、バックエンドの切り離しは行いません。
					</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>もし同票で、2つ以上のグループで同じノード数だった場合は、マスターノード(最も若いDBノード番号のバックエンドノード)を含むグループが優先されます。
						</p></div><p>デフォルトはoffです。

					</p><p>このパラメータは<span class="productname">Pgpool-II</span>の設定を再読み込みすることで変更可能です。
					</p></dd><dt id="guc-replicate-select"><span class="term"><code class="varname">replicate_select</code> (<code class="type">boolean</code>)
					<a id="idm45645430894304" class="indexterm"></a>
				</span></dt><dd><p>onを設定すると、<span class="productname">Pgpool-II</span>はSELECTクエリのレプリケーションモードを有効にします。
すなわち、SELECTクエリが全てのバックエンドノードに送信されます。
					</p><div class="table" id="replicate-select-affect-table"><p class="title"><strong>表5.2 replicate_selectと<a class="xref" href="runtime-config-load-balancing.html#guc-load-balance-mode">load_balance_mode</a>がSELECTのルーティングに与える影響</strong></p><div class="table-contents"><table class="table" summary="replicate_selectとがSELECTのルーティングに与える影響" border="1"><colgroup><col align="center" class="_1" /><col align="center" class="_2" /><col align="center" class="_3" /><col align="center" class="_4" /><col align="center" class="_5" /><col align="center" class="_6" /></colgroup><tbody><tr><td align="center">replicate_selectがtrue</td><td align="center">Y</td><td colspan="4" align="center">N</td></tr><tr><td align="center">load_balance_modeがtrue</td><td align="center">ANY</td><td align="center">Y</td><td colspan="3" align="center">N</td></tr><tr><td align="center">SELECTがトランザクションブロックの内部にある</td><td align="center">ANY</td><td colspan="2" align="center"> Y </td><td align="center">N</td><td align="center">ANY</td></tr><tr><td align="center">										トランザクション分離レベルがSERIALIZABLEで、トランザクションが更新クエリを発行済
									</td><td align="center">Y</td><td align="center">N</td><td align="center">ANY</td><td align="center">ANY</td><td align="center">ANY</td></tr><tr><td align="center">										結果（R:レプリケーション、M:マスターのみに送信、L:負荷分散）
									</td><td align="center">R</td><td align="center">M</td><td align="center">L</td><td align="center">L</td><td align="center">M</td></tr></tbody></table></div></div><br class="table-break" /><p>デフォルトはoffです。
					</p><p>このパラメータは<span class="productname">Pgpool-II</span>の設定を再読み込みすることで変更可能です。
					</p></dd><dt id="guc-insert-lock"><span class="term"><code class="varname">insert_lock</code> (<code class="type">boolean</code>)
					<a id="idm45645430870672" class="indexterm"></a>
				</span></dt><dd><p>onに設定すると、<span class="productname">Pgpool-II</span>はINSERT文が発行される前に<span class="productname">PostgreSQL</span>上のテーブルを自動的にロックします。
					</p><p>SERIAL型を使っているテーブルをレプリケーションすると、SERIAL型の列の値がDBノードの間で一致しなくなることがあります。
この問題の回避策は、INSERT実行前に該当テーブルを明示的にロックすることです。
					</p><p>テーブルの自動ロックのため、<span class="productname">Pgpool-II</span>は以下の変換を行います。
							</p><pre class="programlisting">INSERT INTO ...
							</pre><p>
これを次のように変換します。

							</p><pre class="programlisting">BEGIN;
LOCK TABLE ...
INSERT INTO ...
COMMIT;
							</pre><p>
					</p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注意</h3><p>この方法はトランザクションの並列実行性が大きく劣化させます。
						</p></div><p><span class="productname">Pgpool-II</span> <span class="emphasis"><em>V2.2</em></span>以降では、テーブルがSERIAL列を持つかどうか自動判別するため、SERIAL列がなければ決してテーブルをロックしません。
					</p><p><span class="productname">Pgpool-II</span> <span class="emphasis"><em>V3.0.4</em></span>までの<span class="productname">Pgpool-II</span> <span class="emphasis"><em>V3.0</em></span>では、テーブルロックではなシーケンステーブルに対して行ロックをかけます。
これはVACUUM(autovacuumを含む)とのロック競合を最小化することを意図しています。
しかし、これは他の問題を引き起こします。
トランザクション周回が起きた後、シーケンステーブルに対する行ロックはPostgreSQLの内部エラー (詳細には、トランザクション状態を保持するpg_clogへのアクセスエラー)を起こします。
これを防ぐため、PostgreSQLのコア開発者はシーケンステーブルに対する行ロックを許可しないことを決定しました。
これはもちろん<span class="productname">Pgpool-II</span>を動作不能にします(修正されたPostgreSQLはバージョン 9.0.5, 8.4.9, 8.3.16そして8.2.22としてリリースされました)。

					</p><p><span class="productname">Pgpool-II</span> <span class="emphasis"><em>V3.0.5</em></span>以降では、新しいPostgreSQLがシーケンステーブルに対するロックを許可しなくなったため、<code class="literal">pgpool_catalog.insert_lock</code>テーブルに対して行ロックをかけます。
したがって、<span class="productname">Pgpool-II</span>経由でアクセスするすべてのデータベースにinsert_lockテーブルをあらかじめ作成しておく必要があります。
詳細は<a class="xref" href="create-installlock-table.html" title="3.7. insert_lockテーブルの作成">3.7. insert_lockテーブルの作成</a>をご覧ください。
もし、insert_lockテーブルが存在しない場合は、挿入対象のテーブルに対してロックを行います。
これは、<span class="productname">Pgpool-II</span> <span class="emphasis"><em>V2.2</em></span>と<span class="emphasis"><em>V2.3</em></span>シリーズと同じ動作です。
					</p><p>過去のバージョンと互換性のある<code class="varname">insert_lock</code>を使用したい場合は、configureスクリプトでロック方法を指定できます。
詳細は<a class="xref" href="install-pgpool.html" title="3.4. Pgpool-IIのインストール">3.4. Pgpool-IIのインストール</a>をご覧下さい。
					</p><p>（文ごとの）細かい制御:
					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>insert_lockをtrueにして、テーブルロックを獲得してほしくないINSERT文には、先頭に/*NO INSERT LOCK*/コメントを追加します。
							</p></li><li class="listitem"><p>insert_lockをfalseにして、テーブルロックを獲得してほしいINSERT文には、先頭に/*INSERT LOCK*/コメントを追加します。
							</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>insert_lockを有効にしてregression testを実行すると、PostgreSQL 8.0では transactions, privileges, rules, alter_tableがfailします。
						</p><p>その理由は、ruleテストで<span class="productname">Pgpool-II</span>がビューにLOCKを実行しようとするため、そして以下のエラーメッセージが出てしまうためです。
								</p><pre class="programlisting">! ERROR: current transaction is aborted, commands ignored until
end of transaction block
							</pre><p>
たとえば、transactionsテストでは、存在しないテーブルに対してINSERTを試みており、<span class="productname">Pgpool-II</span>は<span class="productname">PostgerSQL</span>にそのテーブルのロックを獲得させることになります。
これはもちろんエラーとなります。
トランザクションがアボート状態になり、続くINSERTでは上記エラーが出てしまいます。
						</p></div><p>デフォルトはoffです。
					</p><p>このパラメータは<span class="productname">Pgpool-II</span>の設定を再読み込みすることで変更可能です。
					</p></dd><dt id="guc-lobj-lock-table"><span class="term"><code class="varname">lobj_lock_table</code> (<code class="type">string</code>)
					<a id="idm45645430843936" class="indexterm"></a>
				</span></dt><dd><p>ラージオブジェクトのレプリケーションを行いたいときにロック管理に使うためのテーブル名を指定します。
このテーブルが指定されてる場合、<span class="productname">Pgpool-II</span>は、<code class="varname">lobj_lock_table</code>で指定されているテーブルをロックした後、<code class="literal">pg_largeobject</code>システムカタログを参照してラージオブジェクトIDを生成し、<code class="literal">lo_create()</code>を呼び出してラージオブジェクトの作成を行います。
この方法により、レプリケーションモードにおいて<span class="productname">Pgpool-II</span>が全てのDBノードで同じラージオブジェクトIDを得られることが保証されます。

						</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p><span class="productname">PostgreSQL</span> 8.0以前は<code class="literal">lo_create</code>を持たないため、<span class="productname">PostgreSQL</span> 8.0以前のバージョンではこの処理は行われません。
							</p></div><p><code class="literal">libpq</code>の関数<code class="literal">lo_creat()</code>の呼び出しがこの機能の契機となります。
<acronym class="acronym">Java</acronym> API（<acronym class="acronym">JDBC</acronym>ドライバ）、<acronym class="acronym">PHP</acronym> API（<code class="literal">pg_lo_create</code>、またはPDOといったPHPライブラリの同様のAPI）、様々なプログラミング言語の同様のAPIを経由したラージオブジェクトの生成においても同じプロトコルが使われることがわかっているので、この機能は動作するはずです。
					</p><p>この機能はラージオブジェクトに対する以下の操作では動作しません。

					</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>								<code class="literal">lo_create</code>、<code class="literal">lo_import_with_oid</code>を使う全てのAPI。
							</p></li><li class="listitem"><p>								バックエンドの<code class="literal">lo_import</code>関数をSELECTで呼び出す場合
							</p></li><li class="listitem"><p>								バックエンドの<code class="literal">lo_create</code>関数をSELECTで呼び出す場合
							</p></li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">注記</h3><p>全ての<span class="productname">PostgreSQL</span>ユーザは<code class="varname">lobj_lock_table</code>へ書き込み可能ある必要が有ります。
また、これはどのスキーマに作成されてかまいません。
						</p></div><p>ラージオブジェクトロックテーブルを作る例を示します。
						</p><pre class="programlisting">CREATE TABLE public.my_lock_table ();
GRANT ALL ON public.my_lock_table TO PUBLIC;
						</pre><p>
					</p><p>デフォルトは<code class="literal">''</code>（空文字列）で、この機能は無効です。
					</p></dd></dl></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="runtime-config-connection.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="runtime-config.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="runtime-config-backend-settings.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">5.2. 接続と認証 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 5.4. バックエンドの設定</td></tr></table></div></body></html>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. 制限事項</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /><link rel="home" href="index.html" title="Pgpool-II 3.7devel 文書" /><link rel="up" href="preface.html" title="はじめに" /><link rel="prev" href="resources.html" title="4. 更なる情報" /><link rel="next" href="bug-reporting.html" title="6. バグ報告の指針" /><link rel="copyright" href="legalnotice.html" title="Legal Notice" /><meta name="viewport" content="width=device-width,initial-scale=1.0" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><td width="20%" align="left" colspan="2"></td><th width="60%" align="center"><a accesskey="h" href="index.html">Pgpool-II 3.7devel 文書</a></th><td width="20%" align="right"></td></tr><tr><td width="10%" align="left" valign="top"><a accesskey="p" href="resources.html">前へ</a> </td><td width="10%" align="left" valign="top"><a accesskey="u" href="preface.html">上へ</a></td><td width="60%" align="center">5. 制限事項</td><td width="20%" align="right" valign="top"> <a accesskey="n" href="bug-reporting.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="restrictions"><div class="titlepage"><div><div><h2 class="title" style="clear: both">5. 制限事項</h2></div></div></div><p>この章では、<span class="productname">Pgpool-II</span>の現在の制限事項について説明します。

  </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">PostgreSQLの機能</span></dt><dd><p><code class="function">pg_terminate_backend()</code>を使ってバックエンドを停止すると、フェイルオーバが起こります。
これは、<span class="productname">PostgreSQL</span>が、postmasterの停止と全く同じメッセージをバックエンド停止時に送るためです。
3.6より前のバージョンには回避策はありません。
3.6以降では、この制限は緩和されています。
その関数の引数（プロセスIDです）が定数なら、その関数を使っても安全です。
しかし、拡張プロトコルでは、その関数は使えません。
     </p></dd><dt><span class="term">認証/アクセス制御</span></dt><dd><p>レプリケーションモードまたマスタ/スレーブモード時にはtrust、reject、clear text password、pam認証方式が利用できます。
crypt認証は利用できません。
<span class="productname">Pgpool-II</span> 3.0以降では、<code class="filename">pool_passwd</code>というファイルを使ってmd5認証も使えます。
<code class="filename">pool_passwd</code>はデフォルトの認証ファイル名です。
md5認証を有効にする手順を示します。
      </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>DBユーザのOSアカウントでログインし、以下を実行します。
	    </p><pre class="programlisting">            pg_md5 --md5auth --username=<code class="literal">your_username</code> <code class="literal">your_passwd</code>
	    </pre><p>
&gt;md5により暗号化されたユーザ名とパスワードがpool_passwdに登録されます。
pool_passwdがまだ存在しなければ、pg_md5コマンドは、自動的にpgpool.confと同じディレクトリ内にpool_passwdwを作成します。
pool_passwdのフォーマットは、<code class="literal">username:encrypted_passwd</code>です。
	  </p></li><li class="listitem"><p>また、pool_hba.confに適当なmd5のエントリを作成する必要があります。
詳細は<a class="xref" href="auth-pool-hba-conf.html" title="6.1. pool_hba.confファイル">6.1. <code class="filename">pool_hba.conf</code>ファイル</a>を見てください。
	  </p></li><li class="listitem"><p>pool_passwdに登録するパスワードは、<span class="productname">PostgreSQL</span>に登録したパスワードと完全に同じでなければなりません。
	  </p></li><li class="listitem"><p>md5パスワード（もちろんpool_passwdとPostgreSQLの両方）を変更したら、pgpool reload を実行してください。
	  </p></li></ol></div></dd><dt><span class="term">ラージオブジェクト</span></dt><dd><p>ストリーミングレプリケーションモードでは、<span class="productname">Pgpool-II</span>はラージオブジェクトをサポートしています。
      </p><p>ネィティブレプリケーションモードでは、<span class="productname">PostgreSQL</span> 8.1以降ならばラージオブジェクトをサポートします。
その際には、<code class="filename">pgpool.conf</code>のlobj_lock_tableを有効にしてください。
なお、バックエンド関数の<code class="function">lo_import</code>を使ったラージオブジェクトのレプリケーションはサポートされていません。
      </p><p>Slonyモードも含め、その他のモードではラージオブジェクトはサポートされていません。
      </p></dd><dt><span class="term">一時テーブル</span></dt><dd><p>一時テーブルの作成、挿入、更新、削除は、常にマスター（プライマリ）で実行されます。
テーブルに対するSELECTもマスター上で実行されます。
しかし、一時テーブル名が文字列としてSELECTで使われると、それを検知する方法がないため、SELECTは負荷分散されます。
これにより、「テーブルが見つからない」エラーになったり、同じ名前を持つ別のテーブルを検索することになります。
この問題を回避するには、/*NO LOAD BALANCE*/ SQLコメントを使ってください。
      </p><p>ちなみに、psqlの\dコマンドのように、システムカタログを問い合わせる中で
文字列としてのテーブル名を使っている場合:
	</p><pre class="programlisting">SELECT 't1'::regclass::oid;
	</pre><p>
pgpool-II 3.0以降ではマスタで検索が行なわれるので、問題になりません。
なぜなら、システムカタログへの検索は常にマスタで行なわれるからです。
      </p><p>PostgreSQL 8.3以後を使っているのであれば、<code class="command">CREATE TEMP TABLE</code>によって作成されたテーブルは、reset_query_list中のDISCARD ALLを指定することによってセッションの最後で削除されます。
      </p><p>8.2.x以前では、<code class="command">CREATE TEMP TABLE</code>によって作成されたテーブルは、セッションを終了した後に削除されません。
PostgreSQLバックエンドから見ると、コネクションプールによってセッションが維持されているからです。
これを回避するには、明示的に<code class="command">DROP TABLE</code>を発行するか、トランザクションブロックの内側で<code class="command">CREATE TEMP TABLE ... ON COMMIT DROP</code>を実施します。
      </p></dd><dt><span class="term">ネィティブレプリケーションモードにおける関数などの扱い</span></dt><dd><p>文脈依存の仕組み（たとえば乱数やトランザクションID、OID、SERIAL、シーケンス）を使って提供されるデータが複数のバックエンドに正しくレプリケーションされる保証はありません。
SERIALに対しては、insert_lockを使って対応できます。
SELECT setval()とSELECT nextval()に対してもinsert_lockで対応できます。
      </p><p><code class="function">CURRENT_TIMESTAMP</code>、<code class="function">CURRENT_DATE</code>、<code class="function">now()</code>を含むINSERT/UPDATEは正しくレプリケーションされます。
<code class="function">CURRENT_TIMESTAMP</code>、<code class="function">CURRENT_DATE</code>、<code class="function">now()</code>をデフォルト値として使うINSERT/UPDATEも正しくレプリケーションされます。
これは、関数を、クエリ実行時にマスターから取得した定数に置き換えることで達成されています。
しかし、いくつか制限事項があります。
      </p><p><span class="productname">Pgpool-II</span> 3.0以前では、テーブルのデフォルト値としての時制データが正しく計算されない場合があります。
例として以下のテーブル定義を示します。
	</p><pre class="programlisting">CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE + 1
)
	</pre><p>
これは次と同じに扱われます。
	</p><pre class="programlisting">CREATE TABLE rel1(
  d1 date DEFAULT CURRENT_DATE
)
	</pre><p>
<span class="productname">Pgpool-II</span> 3.1以降はこのケースを正しく扱います。
ですのでd1列はtomorrowがデフォルト値になります。
しかし、この改善は拡張プロトコル（たとえばJDBC、PHP PDO）やPREPAREが使用されている場合には適用されません。
      </p><p>列の型が時制ではない場合は書き換えは行われないことに注意してください。
そのような例を示します。
	</p><pre class="programlisting">foo bigint default (date_part('epoch'::text,('now'::text)::timestamp(3) with time zone) * (1000)::double precision)
	</pre><p>
以下のテーブルがあるとします。
	</p><pre class="programlisting">CREATE TABLE rel1(
  c1 int,
  c2 timestamp default now()
)
	</pre><p>
	</p><pre class="programlisting">INSERT INTO rel1(c1) VALUES(1)
	</pre><p>
これは以下に書き換えられるものの、
	</p><pre class="programlisting">INSERT INTO rel1(c1, c2) VALUES(1, '2009-01-01 23:59:59.123456+09')
	</pre><p>
	</p><pre class="programlisting">INSERT INTO rel1(c1) SELECT 1
	</pre><p>
は変換されません。
ですので現在の実装では正しくレプリケーションされません。
値は挿入されますが、全く変換が行われません。
      </p></dd><dt><span class="term">SQL型コマンド</span></dt><dd><p><a class="link" href="sql-commands.html" title="SQL 型コマンド">SQL型コマンド</a>は、拡張クエリモードでは使用できません。
      </p></dd></dl></div><p>
 </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="resources.html">前へ</a> </td><td width="20%" align="center"><a accesskey="u" href="preface.html">上へ</a></td><td width="40%" align="right"> <a accesskey="n" href="bug-reporting.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">4. 更なる情報 </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 6. バグ報告の指針</td></tr></table></div></body></html>
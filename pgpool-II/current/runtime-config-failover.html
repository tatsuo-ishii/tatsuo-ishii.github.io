<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Failover and Failback</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="pgpool-II 4.1devel Documentation"
HREF="index.html"><LINK
REL="UP"
TITLE="Server Configuration"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="Health Check"
HREF="runtime-config-health-check.html"><LINK
REL="NEXT"
TITLE="Online Recovery"
HREF="runtime-online-recovery.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=ISO-8859-1"><META
NAME="creation"
CONTENT="2019-04-11T08:42:49"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>pgpool-II 4.1devel Documentation</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="Health Check"
HREF="runtime-config-health-check.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>Chapter 5. Server Configuration</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="Online Recovery"
HREF="runtime-online-recovery.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-FAILOVER"
>5.9. Failover and Failback</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-FAILOVER-SETTINGS"
>5.9.1. Failover and Failback Settings</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-FAILOVER-COMMAND"
></A
><TT
CLASS="VARNAME"
>failover_command</TT
> (<TT
CLASS="TYPE"
>string</TT
>)
        </DT
><DD
><P
>          Specifies a user command to run when a <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> backend node gets detached.
          <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> replaces the following special characters
          with the backend specific information.
        </P
><DIV
CLASS="TABLE"
><A
NAME="FAILOVER-COMMAND-TABLE"
></A
><P
><B
>Table 5-6. failover command options</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Special character</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>%d</TD
><TD
>DB node ID of the detached node</TD
></TR
><TR
><TD
>%h</TD
><TD
>Hostname of the detached node</TD
></TR
><TR
><TD
>%p</TD
><TD
>Port number of the detached node</TD
></TR
><TR
><TD
>%D</TD
><TD
>Database cluster directory of the detached node</TD
></TR
><TR
><TD
>%M</TD
><TD
>Old master node ID</TD
></TR
><TR
><TD
>%m</TD
><TD
>	New master node ID</TD
></TR
><TR
><TD
>%H</TD
><TD
>Hostname of the new master node</TD
></TR
><TR
><TD
>%P</TD
><TD
>	Old primary node ID</TD
></TR
><TR
><TD
>%r</TD
><TD
>Port number of the new master node</TD
></TR
><TR
><TD
>%R</TD
><TD
>Database cluster directory of the new master node</TD
></TR
><TR
><TD
>%%</TD
><TD
>	'%' character</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>	    The "master node" referes to a node which has the
	    "youngest (or the smallest) node id" among live the
	    database nodes. In <A
HREF="configuring-pgpool.html#RUNNING-MODE"
>streaming
	    replication mode</A
>, this may be different from
	    primary node. In <A
HREF="runtime-config-failover.html#FAILOVER-COMMAND-TABLE"
>Table 5-6</A
>,
	    %m is the new master node chosen
	    by <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>. It is the node
	    being assigned the youngest (smallest) node id which is
	    alive. For example if you have 3 nodes, namely node 0, 1,
	    2. Suppose node 1 the primary and all of them are healthy
	    (no down node). If node 1 fails, failover_command is
	    called with %m = 0.
	  </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>            When a failover is performed,
            basically <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> kills all
            its child processes, which will in turn terminate all the
            active sessions to
            <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>. After that <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>
            invokes the <TT
CLASS="COMMAND"
>failover_command</TT
> and after the command completion
            <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> starts new child processes
            which makes it ready again to accept client connections.
          </P
><P
>	    However from <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> 3.6, in
	    the steaming replication mode, client sessions will not be
	    disconnected when a failover occurs any more if the
	    session does not use the failed standby server. If the
	    primary server goes down, still all sessions will be
	    disconnected. Health check timeout case will also cause
	    the full session disconnection. Other health check error,
	    including retry over case does not trigger full session
	    disconnection.
	  </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>	    You can run <TT
CLASS="COMMAND"
>psql</TT
> (or whatever command)
	    against backend to retrieve some information in the
	    script, but you cannot run <TT
CLASS="COMMAND"
>psql</TT
> against
	    <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> itself, since the
	    script is called from <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>
	    and it needs to run
	    while <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> is working on
	    failover.
	  </P
></BLOCKQUOTE
></DIV
><P
>	  A complete failover_command example can be found
	  in <A
HREF="example-cluster.html"
>Section 8.3</A
>.
        </P
><P
>          This parameter can be changed by reloading the <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> configurations.
        </P
></DD
><DT
><A
NAME="GUC-FAILBACK-COMMAND"
></A
><TT
CLASS="VARNAME"
>failback_command</TT
> (<TT
CLASS="TYPE"
>string</TT
>)
        </DT
><DD
><P
>          Specifies a user command to run when a <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> backend node gets attached to
          <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>. <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>
          replaces the following special characters with the backend specific information.
          before excuting the command.
        </P
><DIV
CLASS="TABLE"
><A
NAME="FFAILBACK-COMMAND-TABLE"
></A
><P
><B
>Table 5-7. failback command options</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Special character</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>%d</TD
><TD
>DB node ID of the attached node</TD
></TR
><TR
><TD
>%h</TD
><TD
>Hostname of the attached node</TD
></TR
><TR
><TD
>%p</TD
><TD
>Port number of the attached node</TD
></TR
><TR
><TD
>%D</TD
><TD
>Database cluster directory of the attached node</TD
></TR
><TR
><TD
>%M</TD
><TD
>Old master node ID</TD
></TR
><TR
><TD
>%m</TD
><TD
>	New master node ID</TD
></TR
><TR
><TD
>%H</TD
><TD
>Hostname of the new master node</TD
></TR
><TR
><TD
>%P</TD
><TD
>	Old primary node ID</TD
></TR
><TR
><TD
>%r</TD
><TD
>Port number of the new master node</TD
></TR
><TR
><TD
>%R</TD
><TD
>Database cluster directory of the new master node</TD
></TR
><TR
><TD
>%%</TD
><TD
>	'%' character</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>	    You can run <TT
CLASS="COMMAND"
>psql</TT
> (or whatever command)
	    against backend to retrieve some information in the
	    script, but you cannot run <TT
CLASS="COMMAND"
>psql</TT
> against
	    <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> itself, since the
	    script is called from <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>
	    and it needs to run
	    while <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> is working on
	    failover.
	  </P
></BLOCKQUOTE
></DIV
><P
>          This parameter can be changed by reloading the <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> configurations.
        </P
></DD
><DT
><A
NAME="GUC-FOLLOW-MASTER-COMMAND"
></A
><TT
CLASS="VARNAME"
>follow_master_command</TT
> (<TT
CLASS="TYPE"
>string</TT
>)
        </DT
><DD
><P
>          Specifies a user command to run after failover on the
	  primary node failover. In case of standby node failover, the
	  command will not be executed. This command also runs if a
	  node promote request is issued by
	  <A
HREF="pcp-promote-node.html"
>pcp_promote_node</A
> command. This works only
	  in Master Replication mode with streaming replication.
	</P
><P
>	  Since the command is executed within a child process forked
	  off by <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> after failover
	  is completed, execution of follow master command does not
	  block the service
	  of <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>. Here is a pseud
	  code to illustrate how the command is executed:
	  </P><PRE
CLASS="PROGRAMLISTING"
>for each backend node
{
    if (the node is not the new primary)
        set down node status to shared memory status
        memorize that folllow master command is needed to execute
}
if (we need to executed follow master command)
    fork a child process
    (within the child process)

    for each backend node
        if (the node status in shared memory is down)
            execute follow master command
	  </PRE
><P>
	</P
><P
>          <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> replaces the following special characters
          with the backend specific information before excuting the command.
        </P
><DIV
CLASS="TABLE"
><A
NAME="FOLLOW-MASTER-COMMAND-TABLE"
></A
><P
><B
>Table 5-8. follow master command options</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>Special character</TH
><TH
>Description</TH
></TR
></THEAD
><TBODY
><TR
><TD
>%d</TD
><TD
>DB node ID of the detached node</TD
></TR
><TR
><TD
>%h</TD
><TD
>Hostname of the detached node</TD
></TR
><TR
><TD
>%p</TD
><TD
>Port number of the detached node</TD
></TR
><TR
><TD
>%D</TD
><TD
>Database cluster directory of the detached node</TD
></TR
><TR
><TD
>%M</TD
><TD
>Old master node ID</TD
></TR
><TR
><TD
>%m</TD
><TD
>	New primary node ID</TD
></TR
><TR
><TD
>%H</TD
><TD
>Hostname of the new primary node</TD
></TR
><TR
><TD
>%P</TD
><TD
>	Old primary node ID</TD
></TR
><TR
><TD
>%r</TD
><TD
>Port number of the new primary node</TD
></TR
><TR
><TD
>%R</TD
><TD
>Database cluster directory of the new primary node</TD
></TR
><TR
><TD
>%%</TD
><TD
>	'%' character</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>          If <TT
CLASS="VARNAME"
>follow_master_command</TT
> is not empty, then after failover
          on the primary node gets completed in Master Slave mode with streaming replication,
          <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> degenerates all nodes except the new primary
          and starts new child processes to be ready again to accept connections from the clients.
          After this, <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> executes the command configured
          in the <TT
CLASS="VARNAME"
>follow_master_command</TT
> for each degenerated backend nodes.
        </P
></BLOCKQUOTE
></DIV
><P
>          Typically <TT
CLASS="VARNAME"
>follow_master_command</TT
> command
          is used to recover the slave from the new primary by calling
          the pcp_recovery_node command.  In
          the <TT
CLASS="VARNAME"
>follow_master_command</TT
>, it is
          recommended to check whether
          target <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> node is running
          or not using pg_ctl since already stopped node usually has a
          reason to be stopped: for example, it's broken by hardware
          problems or administrator is maintaining the node.  If the
          node is stopped, skip the node. If the node is running, stop
          the node first and recovery it.  A
          complete <TT
CLASS="VARNAME"
>follow_master_command</TT
> example
          can be found in <A
HREF="example-cluster.html"
>Section 8.3</A
>.
        </P
><P
>          This parameter can be changed by reloading the <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> configurations.
        </P
></DD
><DT
><A
NAME="GUC-FAILOVER-ON-BACKEND-ERROR"
></A
><TT
CLASS="VARNAME"
>failover_on_backend_error</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
        </DT
><DD
><P
>          When set to on, <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> considers the reading/writing
          errors on the PostgreSQL backend connection as the backend node failure and trigger the
          failover on that node after disconnecting the current session.
          When this is set to off, <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> only report an error
          and disconnect the session in case of such errors.
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>            It is recommended to turn on the backend health checking
            (see <A
HREF="runtime-config-health-check.html"
>Section 5.8</A
>)
            when <TT
CLASS="VARNAME"
>failover_on_backend_error</TT
> is set to off.
            Note, however, that <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> still triggers the
            failover when it detects the administrative shutdown of
            <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> backend server.
            If you want to avoid a fail over even in this case, you need to specify DISALLOW_TO_FAILOVER on <A
HREF="runtime-config-backend-settings.html#GUC-BACKEND-FLAG"
>backend_flag</A
>.
          </P
></BLOCKQUOTE
></DIV
><P
>          This parameter can be changed by reloading the <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> configurations.
        </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>            Prior to <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>V4.0</I
></SPAN
>,
            this configuration parameter name was <TT
CLASS="VARNAME"
>fail</TT
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>_</I
></SPAN
><TT
CLASS="VARNAME"
>over_on_backend_error</TT
>.
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="GUC-SEARCH-PRIMARY-NODE-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>search_primary_node_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
        </DT
><DD
><P
>          Specifies the maximum amount of time in seconds to search for the
          primary node when a failover scenario occurs.
          <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> will give up looking for the primary
          node if it is not found with-in this configured time.
          Default is 300 and Setting this parameter to 0 means keep trying forever.
        </P
><P
>          This parameter is only applicable in the streaming replication mode.
        </P
><P
>          This parameter can be changed by reloading the <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> configurations.
        </P
></DD
><DT
><A
NAME="GUC-DETACH-FALSE-PRIMARY"
></A
><TT
CLASS="VARNAME"
>detach_false_primary</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
        </DT
><DD
><P
>	  If set to on, detach false primary node. The default is
          off. This parameter is only valid in streaming replication
          mode and for <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.6 or
          after since this feature
          uses <CODE
CLASS="FUNCTION"
>pg_stat_wal_receiver</CODE
>.
          If <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.5.x or older
          version is used, no error is raised, just the feature is
          ignored.
	</P
><P
>	  If there's no primary node, no checking will be performed.
	</P
><P
>	  If there's no standby node, and there's only one primary
	  node, no checking will be performed.
	</P
><P
>	  If there's no standby node, and there's multiple primary
	  nodes, leave the primary node which has the youngest node
	  id and detach rest of primary nodes.
	</P
><P
>	  If there are one or more primaries and one or more standbys,
	  check the connectivity between primary and standby nodes by
	  using <CODE
CLASS="FUNCTION"
>pg_stat_wal_receiver</CODE
>
	  if <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.6 or after. In
	  this case if a primary node connects to all standby nodes,
	  the primary is regarded as "true" primary. Other primaries
	  are regarded as "false" primary and the false primaries will
	  be detached if <TT
CLASS="VARNAME"
>detach_false_primary</TT
> is
	  true.  If no "true" primary is found, nothing will happen.
        </P
><P
>	  When <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> starts, the
	  checking of false primaries are performed only once in
	  the <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> main
	  process. If <A
HREF="runtime-streaming-replication-check.html#GUC-SR-CHECK-PERIOD"
>sr_check_period</A
> is greater
	  than 0, the false primaries checking will be performed at
	  the same timing of streaming replication delay checking.
	</P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Note: </B
>	    <A
HREF="runtime-streaming-replication-check.html#GUC-SR-CHECK-USER"
>sr_check_user</A
> must
	      be <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> super user or
	      in "pg_monitor" group to use this feature. To
	      make <A
HREF="runtime-streaming-replication-check.html#GUC-SR-CHECK-USER"
>sr_check_user</A
> in pg_monitor
	      group, execute following SQL command
	      by <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> super user
	      (replace "sr_check_user" with the setting
	      of <A
HREF="runtime-streaming-replication-check.html#GUC-SR-CHECK-USER"
>sr_check_user</A
>):
	      </P><PRE
CLASS="PROGRAMLISTING"
>GRANT pg_monitor TO sr_check_user;
	      </PRE
><P>
	      For <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.6, there's
	      no pg_monitor group
	      and <A
HREF="runtime-streaming-replication-check.html#GUC-SR-CHECK-USER"
>sr_check_user</A
> must
	      be <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> super user.
	  </P
></BLOCKQUOTE
></DIV
><P
>          This parameter is only applicable in the streaming replication mode.
        </P
><P
>          This parameter can be changed by reloading
          the <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> configurations.
        </P
><P
>	  <DIV
CLASS="FIGURE"
><A
NAME="AEN3275"
></A
><P
><B
>Figure 5-1. Detecting false primaries</B
></P
><DIV
CLASS="MEDIAOBJECT"
><P
><IMG
SRC="detach_false_primary.gif"></P
></DIV
></DIV
>
	</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-FAILOVER-IN-THE-RAW-MODE"
>5.9.2. Failover in the raw Mode</A
></H2
><P
>  Failover can be performed in raw mode if multiple backend servers are defined.
  <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> usually accesses the backend specified by
  <TT
CLASS="LITERAL"
>backend_hostname0</TT
> during normal operation. If the
  <TT
CLASS="LITERAL"
>backend_hostname0</TT
> fails for some reason,
  <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
> tries to access the backend specified by
  <TT
CLASS="LITERAL"
>backend_hostname1</TT
>. If that fails, <SPAN
CLASS="PRODUCTNAME"
>Pgpool-II</SPAN
>
  tries the <TT
CLASS="LITERAL"
>backend_hostname2, 3</TT
> and so on.
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-health-check.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-online-recovery.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Health Check</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Online Recovery</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!-- MHonArc v2.1.0 -->
<!--X-Subject: [postgres95 587] Re: OBJECT&#45;RELATIONAL DBMSs -->
<!--X-From: Akio Tokaji <tokaji@db.nm.fujitsu.co.jp> -->
<!--X-Date: Mon, 19 Aug 1996 11:32:28 &#45;&#45;900 -->
<!--X-Message-Id: 9608190232.AA02750@zaurus.db.nm.fujitsu.co.jp -->
<!--X-ContentType: text/plain -->
<!--X-Reference-Id: Pine.LNX.3.91LJ1.0.4.960812231317.228D&#45;100000@penty.rccm.co.jp -->
<!--X-Head-End-->
<HTML>
<HEAD>
<TITLE>[postgres95 587] Re: OBJECT-RELATIONAL DBMSs </TITLE>
<LINK REV="made" HREF="mailto:tokaji@db.nm.fujitsu.co.jp">
</HEAD>
<BODY BGCOLOR="#ffffff">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00057.html">Date Prev</A>][<A HREF="msg00048.html">Date Next</A>][<A HREF="msg00021.html">Thread Prev</A>][<A HREF="msg00048.html">Thread Next</A>][<A HREF="index.html#00047">Date Index</A>][<A HREF="threads.html#00047">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>[postgres95 587] Re: OBJECT-RELATIONAL DBMSs</H1>
<HR>
<!--X-Subject-Header-End-->
<UL>
<LI><em>From</em>: Akio Tokaji &lt;<A HREF="mailto:tokaji@db.nm.fujitsu.co.jp">tokaji@db.nm.fujitsu.co.jp</A>&gt;</LI>
<LI><em>Date</em>: Mon, 19 Aug 1996 11:32:28 --900</LI>
</UL>
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
戸梶＠富士通です。

&gt; &gt; 先日、書店をぶらついていたら
&gt; &gt; 
&gt; &gt; 「オブジェクトリレーショナルＤＢＭＳｓ」
&gt; &gt; 訳者：太田佳伸
&gt; &gt; 発売元：株式会社ビー・エヌ・エヌ
&gt; &gt; ISBN4-89369-436-7
&gt; &gt; \3,800
&gt; &gt; 
&gt; &gt; という本を見つけました。
&gt; &gt; 
&gt; &gt; 著者は Michael Stonebraker です。
&gt; &gt; 
&gt; &gt; Illustra の機能がメインで解説されていますが、postgresユーザにも
&gt; &gt; 基本部分は役にたつかもしれませんので参考までに．．．
&gt; 
&gt;   早速、帰りに買いました。８月１０日初版発行となってました。
&gt;   Illustra の宣伝もいいのですが、なんとなくしか理解していなかったオブ
&gt; ジェクト・リレーショナルという位置付けがマトリックス表示のイラスト上で
&gt; 示されていて、わかりやすそうな気がします。

Stonebraker が Illustra の良さを宣伝するために(?)、書いた論文を以前訳
したものがあります。誤訳があるかもしれませんが、意味は通じていると思い
ます。

----------------------------------------------------------------------
last modified: 95/08/24

                  OBJECT-RELATIONAL DATABASE SYSTEMS

                         Michael Stonebraker
                 Illustra Information Technologies, Inc.
                      1111 Broadway, Suite 2000
                         Oakland, CA. 94607

1. Introduction

     この論文では、データベース管理の問題を Figure 1 のマトリックスの
中の４つの箱の中に当てはまるように分類する。ここでは、問題は、扱われる
データが simple(単純)か complex(複雑) かということと、データに対する
query(問合せ)の能力が必要とされるか否かということに分類される。この論
文の２節では、４つの箱のそれぞれに当てはまるような例を提示することによ
り Figure 1 を詳細に説明する。そして、Figure 1 のそれぞれの箱に示され
た方法(solution)が適切であるのかを説明する。箱の中の３つには、市場で多
くの商用製品が存在し、定義がきちんとされている方法が入っている。４つ目
の箱(complex data に対する query 能力)は、オブジェクト・リレーショナル
ＤＢＭＳという、新しい種類のＤＢＭＳとして名前を付ける。ということで、
この用語が何を意味するかについても、きちんと定義することにする。

     ３節では、Figure 1 のそれぞれの区分のＤＢＭＳが、自分の箱のアプリ
ケーションに対して持つ利点を短くまとめる。同時に、それぞれのシステムが
他の箱のアプリケーションを実行する際の困難を示す。

     一般に全てのＤＢＭＳアプリは、４つの箱のそれぞれに当てはまるコンポ
ーネントを持っている。この論文の４節では、右上の箱は、これからの数年に
わたって、劇的に重要性を増すであろうということを議論する。ということで、
オブジェクト・リレーショナルＤＢＭＳは劇的に重要性を増すはずである。

     この市場にアプローチするために、リレーショナル・ベンダーおよびオブ
ジェクト指向ＤＢＭＳベンダーは、自分の製品を、オブジェクト・リレーショ
ナルＤＢＭＳになるように拡張することが可能である。５節では、このやり方
は、技術的に難しい試みであり、あまり良い製品ができない、という理由を示
す。ということで、Illustra Information Technologies, Inc. のようなオブ
ジェクト・リレーショナルＤＢＭＳの新規(参入)ベンダーに対して、かなりの
市場機会があると信じている。

______________________________________________________________________

          +----------+--------------+-----------------+
          |          |    simple    |   complex       |
          |          |     data     |    data         |
          |----------+--------------+-----------------|
          |  query   |  relational  |object-relational|
          |          |   vendors    |    vendors      |
          +----------+--------------+-----------------+
          | no query | file system  | object-oriented |
          |          |   vendors    |    vendors      |
          +----------+--------------+-----------------+

              A Classification of DBMS Applications
                            Figure 1
______________________________________________________________________


2. The Four Boxes of Figure 1

     まず、伝統的な、ビジネスデータ処理の例として、TP1 [ANON85](後に
Transaction Processing Council によって TPC-A として正式に取り込まれ
た)の例から始める。基本的に、これは、ATM マシンから引出を行ったり、
または、小切手を現金に引き換える、という業務をシミュレートする。とい
うことで、以下の４つのテーブルを使う：

        CUSTOMER(account_number, balance)          顧客テーブル
        TELLER(teller_id, cash)                    出納係テーブル
        BANK(balance)                              銀行テーブル
        HISTORY(account_number, check_amount)      履歴テーブル

ここでは、それぞれの顧客は、銀行に、口座番号と現在の残高を持っている。
銀行は、出納係の集団(集合)を持ち、それぞれの出納係は自分のひきだしに
ある額の現金を持っている。全ての出納係のひきだしに入っている全ての現
金の合計は、銀行の中で持ち合わせている現金の総額を表す。最後に、銀行
は全ての取引(transaction)の監査用記録(audit trail)を HISTORY(履歴)テ
ーブルに保存する。

     TP1 は、３つのパラメタを取り(THIS_CUSTOMER, THIS_TELLER, THIS_CHECK)、
これらのテーブルに対して一連の検索および更新を行う。以下に、擬似コードを
示す：

        select balance from CUSTOMER where account_number = THIS_CUSTOMER

        if balance &gt; THIS_CHECK {
          update CUSTOMER set balance=balance-THIS_CHECK
          update TELLER set cash=cash-THIS_CHECK where teller_id=THIS_TELLER
          update BANK set balance=balance-THIS_CHECK
          insert into HISTORY values (THIS_CUSTOMER, THIS_CHECK)
          commit
        }

TP1 で扱われるデータは全て simple である。つまり、全て数値だけで構成さ
れている。一般的に、アプリケーションで扱われるデータが文字列、整数、浮動
小数点数、time型 および money型 で構成されているような場合には、扱われる
データが simple である。別の言い方をすれば、 SQL-89 にあるデータ型を使っ
て記述できるならば、データは simple である。さらに、TP1 は、常に SQL で
表現される。すなわち、TP1 は、SQL-89 をサポートするＤＢＭＳで実行される
一連の query によって表現(記述)される。このように、TP1 は、simple データ
に対する query 能力が要求されるアプリケーションである。

     リレーショナルＤＢＭＳベンダー(例えば、Oracle, Informix, Sybase,
Ingres)は、それぞれのシステムを、TP1 に対して最適化するために、かなりの
力を投入してきた。この取り組みには以下の技術(技法)のいくつかまたは全て
が含まれている：

        database procedures
        server process
        locking small granularity objects   (granularity＝粒度)
        group commit to the log
        multiple logs
        logical logging
        lowering the "do nothing" overhead

     database procedure は、TP1 の演算(一連の処理)の全体を依頼するの
を、ＤＢＭＳに対して一つのコマンドで行える。これにより６つのＳＱＬ文
をそれぞれ、ＤＢＭＳに対して個別に送る必要性を取り除く。database
procedure は、TP1 の性能を、おそらく２５％程度改善し、ほとんどのリレ
ーショナルベンダーによって実現(サポート)されている。それぞれが、TP1 
を実行する、多数のクライアントをサポートするために、リレーショナルＤ
ＢＭＳベンダーは、典型的に、サーバー方式(implementation)へと移行した。
こうして、全てのＤＢＭＳクライアントプロセスは、単一のサーバープロセ
スでサポートされるようになり、これにより、最適なやり方で独自のスケジ
ューリングやメモリー管理を行うことができるようになる。複数の TP1トラ
ンザクションが、ロック要求で「衝突」して、それにより待たされる、とい
うことがないように保証するために、小さい(粒度の)オブジェクトをロック
することが要求される。複数のトランザクション(の集まり)を、いっしょに
して「バッチ処理」する(複数のトランザクションを一括してコミットする
ため)という概念のサポートというやり方で、ＤＢＭＳログに対して実行され
る I/O の回数を減らすことにより、性能を向上させる。複数のログをサポー
トするというのは、同じ効果を得るためのもう一つのやり方である。logical
logging は、それぞれのトランザクションに対して、ログレコードの中に格
納しなければならないバイト数を小さくする技法であり、これにより、TP1
ログのサイズを減らして性能を向上させる。最後に、一連の非常に単純なコ
マンド(いわゆる"do nothing" overhead)に直面した時の基本的な効率を上げ
るというのが、効率アップのための最後の手段である。

     これらの技術(技法)に基づいて、リレーショナルベンダーは、数年にわ
たって、TP1 性能を改善してきた。そして、TP1 に類似するアプリケーション
に対して、彼らが優秀なソリューションを提供できるということが、一般に認
められている。ビジネスデータ処理アプリの中には TP1 に似たものがあり、
simple なデータに対する query 能力が要求されており、Figure 1 の左上の
箱に当てはまる。

     Figure 1 の２番目の箱は、query 能力の要求されない simple なデータ
の場合である。テキストエディタ(基本的に全てのハードウェアプラットフォ
ーム上に存在する)は、テキスト・オブジェクトをメインメモリに読みこんで、
それから内容に対する編集を実行する。編集が完了したら、テキスト・オブジ
ェクトは、ディスクに書き戻される。著者の知る限りにおいては、全てのテキ
ストエディタは、ファイルシステムの上に実現されている。ファイルシステム
では、ほとんどのテキストエディタで操作するような、単純なテキスト文字列
に対するサポートが提供されている。さらに、テキストエディタはオブジェク
ト全体をメインメモリに読み込むので、ＤＢＭＳで SQL query を実行する必要
はない。従って、Figure 1 の左下の箱は、適切なソリューションとして、ファ
イルシステムと名付けている。テキスト・オブジェクトがより複雑になり、い
わゆるハイパーテキスト表現の方向へ移っていくと、ファイルシステムは、格
納手段(媒体)としては、適切ではなくなっていく。なぜなら、データはもはや
simple ではなくなり、アプリケーションは Figure 1 のもう一つの箱に移って
しまうからである。

     それでは、query 能力が必要とされない complex なデータの例に移ろう。
私達の例では、以下のテーブルを使う：

        BUILDING(floor_number, assignable_floor_plan)
        EMPLOYEE(name, floor_number, office_location)

ここでは、ある仮定上の会社が、ある建物(building)に入居しており、複数の
フロアを占めている。フロア毎には、利用できる assignable_floor_plan が
ある。このフロアプランは、建物の外形(outline)から、化粧室、廊下、柱、
などを除いたものである。ということで、これは、"swiss cheese" ポリゴン
である(???)。各従業員(employee)は名前とオフィスを持つ。そのオフィスは
あるフロア上にいくらかの(通常は、方形の)区画(real estate)を占めている。

     この会社の施設の計画担当者は、"圧縮"プログラムを実行して、建物の
中の未使用のスペースを開放したいと思っている。そうするために、彼は、
利用可能な全区画(real estate)を最大限に利用することができるように、オ
フィスを再配置したいと思うだろう。おそらく、未使用のスペースはまとめ
られて、後に効率的に割り当てることが可能になる。この圧縮プログラムは、
以下のような擬似コードとなる：

        {
        read floor plan for each floor
        read office location for each employee
        compact the employees
        write new office locations for all employees
        }

     このアプリケーションの特徴は、データのうちの多くが simple ではな
いということである。office_location と assignable_floor_plan の両方が
ポリゴン・データであり、SQL のデータタイプではない。従って、このよう
なデータは、complex と分類する。さらに、アプリケーションは、BUILDING
および EMPLOYEE オブジェクトを全てメインメモリに読み込んで、処理が完
了したら書き戻すようになっている。テキストエディタの例と同様に、検索
は要求されず、擬似コードの中には、SQL は出現しない。

     このアプリケーションの性能は、圧縮サブルーチンの性能に決定的に依
存する。この関数(典型的には、汎用プログラミング言語で書かれる)は、
office_location および assignable_floor_plan オブジェクトに対してくり
返しアクセスが行われる。このため、このようなデータの表現(形式)は、圧縮
ルーチンが含まれているプログラムに対して最適化することが重要である。仮
に、データオブジェクトに対するディスク上での表現形式が、最適なメインメ
モリ上での表現と一致しない場合には、データがディスクから読み込まれる際
に、メインメモリでの(最適な)フォーマットに変換するべきである。

     上記のプログラムを最も簡単に書けるようにするために、クライアント
(お客様？)は、汎用プログラミング言語による永続的な(persistent)プログラ
ムという概念を欲しいと考える。そのため、圧縮ルーチンで使う BUILDING と
EMPLOYEE のデータ構造は persistent にすることができ、ユーザは以下のよ
うなコードが必要なだけである：

        compact the employee

永続的(persistent)プログラミング言語は、データオブジェクトを、適切(な
時)に読み込んだり書き込んだりすることを(自動的、暗黙に)面倒を見て、さ
らに、ディスクとメインメモリの間でフォーマットの変換を行う。オブジェ
クト指向ＤＢＭＳベンダー(例えば、Object Design, Objectivity, Versant, 
Servio, Ontologic)は、全て C++言語に対して、永続性(persistence)を提供
している。彼らは、それぞれのシステムを、以下の技術(技法)のいくつかまた
は全てを使って最適化している：

        rich type system
        main memory cache in C++ format
        main memory cache in user space

ほとんどのオブジェクト指向ＤＢＭＳベンダーは、C++ に近い(データ)型シス
テムを実現している。これにより、office_location および 
assignable_floor_plan は、C++ の構造体として表現することができる。さら
に、これらの構造体の中にポインターが含まれている場合、オブジェクトがメ
インメモリに持ち込まれる時に(ポインターは)変換("攪はん")されて、圧縮ル
ーチンによる、続いてのアクセスは最も効率的になる。ということで、メイン
メモリーのデータキャッシュは C++のフォーマットである。最後に、メインメ
モリ・キャッシュは、圧縮ルーチンと同一のアドレス空間にあり、これもアク
セス性能の最適化に寄与する。

     ということで、オブジェクト指向ＤＢＭＳベンダーは、Figure 1 の右下
の箱を最もうまくサポートできるような技術(技法)に焦点を合わせている。リ
レーショナルＤＢＭＳベンダーと同様に、彼らは一つの箱に焦点を合わせてお
り、その箱に対してベストの技法を実現している。

     それでは、４種類目のアプリケーションに移ろう(Figure 1 の右上の箱)。
例では、以下の２つのテーブルを使う：

        PARCEL(parcel_id, location, owner, building_plans)    土地区画
        RIDGE(name, ridge_line)                               稜線

これは、自治体で使われているデータベースを簡略化したバージョンである。
行政当局は、管轄区内の土地の区画(land parcel)を記録する。同時に、それ
ぞれの区画の所在を示すポリゴンや、複数の人の集まった法的所有者(それぞ
れの名前やメールアドレスを含む)などの情報も記録する。そして、その区画
上のいかなる建築物の building_plans をも image の集合として記録する。

     さらに、カリフォルニアの多くの都市では、家から見おろす地元の渓谷
(valley)の稜線(ridge)の景観を保存することに配慮している。ということで、
これらの都市では、稜線の上の方の近くに建設することができる建築物の高さ
(の制限)に関する規則がある。従って、２つめのテーブルには、対象となる稜
線の名前と、その実際の稜線(のデータ)を記録する。明らかに、このアプリで
は、主に complex なデータを扱うことになる。なぜなら、大部分のフィール
ド(テーブルカラム)は、SQL-89 のデータ型ではないからである。

     ここで、このようなデータに対する２つの単純な query を示す。ある
地所(property)の所有者が、地域制特例的認可(zoning variance)を請求した
時には、市の当局は、ある距離(例えば1000フィート)以内の影響の及ぶ地所
の所有者全てに対して通告(notice)を送らなければならない。もし、XXXX と
いう区画に対して、地域制特例的認可が請求された場合には、以下の query
を実行しなければならない：

        select owner
        from PARCEL
        where location ~
        select location
        from PARCEL
        where parcel_identifier=XXXX

この query に ~ というオペレータが存在することに留意されたい。これは
２つのポリゴンを比較して、片方が他者から1000フィート以内にある場合に
true を返す。従って、この query は、ユーザ定義オペレータをサポートす
る SQL を前提(必要)としている。

     ２つ目の query も同じようにわかりやすい例である。市の計画担当者が、
特定の稜線(例えば、YYYY という名前の稜線)から1000フィート以内の全ての区
画を調べて、稜線より高く突き出ている住宅があるかを計算したい(割り出した
い)とする。そのような(稜線から突き出た)住宅は、きっと、下の方の区画の所
有者から「目障りなもの」と思われるであろう。query は以下のようになる：

        select parcel_id
        from PARCEL, RIDGE
        where name=YYYY
        and location ~ ridge_line
        and maximum_elevation(building_plans) &gt; 
            elevation(nearest_point(ridge_line.location))

ここでは、限定句(qualification, 条件指定部)の最初の節では、特定の(名前
の)稜線を検索するように制限を加えており、また、２つ目では、対象となる稜
線から1000フィート以内の区画を識別する。最後に３つ目の節では、目的にか
なうような意味を表現するために、３つのユーザー定義関数を想定している。
maximum_elevation という関数は、ある区画の building_plans を検査して、
その区画上にある建築物の最大の高度(標高)を割り出す。また、２つ目の
nearest_point は、稜線上で、対象区画に最も近い点(point)を割り出す。３つ
目の関数は、その後で、この空間上の点(spatial point)の高度(elevation)を
割り出す。このような場合を考えれば、３つ目の(条件)節では、稜線より高く
突き出た建築物を見つけることができる。

     ここで紹介したようなアプリケーションを表現(記述)するために、クライ
アント(お客様？)は、complex なデータに対しての検索能力を要求している。
そこで、このようなニーズに適合するＤＢＭＳとして、オブジェクト・リレー
ショナルＤＢＭＳを定義してみよう。特に、オブジェクト・リレーショナルＤ
ＢＭＳは、SQL に対して以下のようなオブジェクト指向の概念(concept)を追加
するＤＢＭＳである：

        1) unique identifiers
        2) user defined types
        3) user defined operators
        4) user defined access methods
        5) complex objects
        6) user defined functions
        7) overloading
        8) dynamic extendability
        9) inheritance of both data and functions
        10) arrays

     最初のオブジェクト指向の概念は、全てのテーブルの中の、おのおのの
レコードに対して、不変の(immutable)ユニークな識別子を与えるべきである、
というもの(いわゆる、ＯＩＤ)である。このような能力により、あるレコード
(そのもの)を他のレコードからユニークに参照することができる(この OID を
２つ目のレコードの中のフィールドとして用いることによって)。リレーショナ
ル・システムでは、クライアントは、このような目的のために、２つ目のテー
ブル中に、もう一つのテーブルの主キー(primary key)に対する値を格納する外
部キー(foreign key)を用いるという方法が推奨されている。OID は、本当に
不変(immutable)であり、データインテグリティの喪失が全くない、という点で
プライマリーキーに対する改良となる。

     上のオブジェクト・リレーショナルの例では、オブジェクト・リレーショ
ナルＤＢＭＳを定義付けるその他の概念(concept)について例を示している。ま
ず、新しい「ベース」データ型を定義して、SQL-89 のデータ型の集合を増やす
ことが可能でなければならない。例えば、我々の単純なアプリでも、ポリゴン
データ型が要求されている。さらに、点、線、方形、円、だ円、複素数、など
が必須の型として要求されるようなアプリを想像することも容易にできる。

     さらに、例では、ユーザ定義オペレータである ~ が要求された(２つのポ
リゴン型のオペランドを取り、boolean 型の値を返す)。１つ目の query の内側
の SQL ブロックが処理された後(の状態)を考える：

        select owner
        from PARCEL
        where location ~ LOCATION_XXXX

ここで、内側のブロックの結果は、区画 XXXX の位置(location)であり、それ
を LOCATION_XXXX と置き換えた。このような query は、B-tree アクセス法
では効率的に解決することができないということは有名である。なぜなら、１
次元(one-dimensional)のアクセス法では、２次元(two-dimensional)の検索を
実行できないからである。むしろ、このような query は、quad tree、R-tree、
または、Grid file といった、複数次元(multi-dimensional)のアクセス法を
用いてのみ解決できるのである。従って、上の query を効率的に実行するた
めには、ＤＢＭＳがユーザ定義のアクセス方法(user defined access method)
を許すことが必要となる。さらに、query のオプティマイザおよび実行エンジ
ンは、上の query について、適切なアクセス法をユーザがＤＢＭＳに対して
定義しておいた場合には、ユーザ定義のアクセス法を使うようにインプリメン
トされていなければならない。

     次のオブジェクト・リレーショナルの概念は、あるオブジェクト(型)の
集合であるような、complex なオブジェクトをサポートする能力である。
PARCEL(区画テーブル)内の building_permits および owner フィールドは、
両方とも、そのような complex オブジェクトである。もし、区画 XXXX の所
有者の名前(複数)を調べたい場合には、以下のようにして表現できるべきであ
る：

        select owner.name
        from PARCEL
        where parcel_identifier=XXXX

owner は、他のオブジェクトの集合から成る complex オブジェクトであるの
で、これらの他のオブジェクトに対しての参照が可能であるべきである。従っ
て、上の query の中の owner.name というのは、区画 XXXX を所有している
人物の集合のメンバーである人物の名前を意味する。この nested dot 記法
は、SQL の中で complex オブジェクトのサブフィールドを指定するために必
要とされている。

     上のアプリでは、ユーザ定義関数の必要性についても例を示した。２つ目
の query では、maximum_elevation、elevation、および nearest_point とい
う３つの関数が必要とされ、このような機構(ユーザ定義関数)のないシステム
では表現(記述)できない。

     ７番目の機構も、オブジェクト・リレーショナルの例で示された。２つの
query では、~ オペレータが２度使われた。最初の時は、２つのポリゴンがお
互いに1000フィート以内にあるかをチェックしたが、一方、２番目のケースで
は、あるポリゴンが、ある線から1000フィート以内にあるかをチェックした。
両方のオペレータや関数を overloading するというのは、オペランドや引数に
より、正しいもの(オペレータ/関数)をシステムが自動的に決定して使う、とい
うことである。

     ８番目の機構は、オブジェクト・リレーショナルＤＢＭＳでは、動的に、
つまり、ＤＢＭＳをダウンさせることなく、新しいデータ型、オペレータ、関
数、およびアクセス方法(access method)の追加ができなければならない、と
いうことを意味する。ほとんどのオブジェクト・リレーショナルのアプリケー
ションでは、頻繁に拡張されることが期待される。そのため、拡張を施すため
にＤＢＭＳをオフラインにすることが必須となるのは不適当と思われる。

     最後の２つの概念は、上のオブジェクト・リレーショナルの例では示さ
れていない。従って、これらの要件を例示するために、上の例を一般化
(generalize)する必要がある。ほとんどの自治体では、３種類の区画がある。
normal 区画(普通のやり方で課税される)。このような区画については、自治
体は、assessed_valuation(課税のための評価額) および 税金の支払いの 
deliquency(滞納)の状態を記録しなければならない。２つ目の種類の区画は、
tax-exempt 区画(教会、公立の大学、政府機関などが所有)である。tax-exempt
区画について、自治体は、税金の免除(exemption)の理由を記録しなければな
らない。３つ目の種類の区画は、agricultural(農業)保護区域として、申告
された区画である。このケースでは、農夫は、その区画を開発しないという
保証を行う代わりに、税金の率を引き下げてもらえる。結果として、Figure 2
のような inheritance(継承)の階層によって、この例のようなオブジェクト・
リレーショナルのデータは、もっともうまくモデル化できる。(つまり)９番目
の要件は、テーブルをこのような種類の継承の階層の中に組織化することを可
能にするものである。

     さらに、オブジェクト・リレーショナルＤＢＭＳは、関数の inheritance
(継承)もサポートしなければならない。例えば size(PARCEL) という関数を考
えてみよう。

この関数は、平方フィートで、区画の面積を返す。この関数は、PARCEL(区画)
型に対して定義されているのだが、３つの特別な種類の区画に対しても、継承
されるべきである。これにより、それぞれの(３つの)種類の区画に関しても、
size を割り出すことができる。つまり、inheritance は、データおよび関数
の両方に関して、サポートされなければならない。

     最後の要件は、array(配列)データに関するものである。例えば、normal
区画は、２つの部分に分割して、課税のための評価をされるということも考え
られる(片方が４月支払いで、もう他方は１２月支払い)。従って、tax_assessment
は、int[2] という配列型であるべきである。さらに、以下のようにして、２番
目の評価額を調べることが可能となるべきである：

        select tax_assessment[2]
        from NORMAL_PARCEL
        where parcel_identifier=XXXX

この要件では、SQL で array 記法をサポートすることを求めている。

     オブジェクト・リレーショナルＤＢＭＳの作成するために、SQL-89 を、
上の１０の概念をサポートして、拡張しなければならない。私達の頭の中に
あるものに最も近い定義は、SQL-3(現在は、ドラフトの形で available)であ
る。

______________________________________________________________________

                PARCEL

                TAX-EXEMPT     NORMAL     AGRICULTURAL
                PARCEL         PARCEL     PARCEL

                        An Inheritance Hierarchy
                                Figure 2
______________________________________________________________________


3. MERITS OF THE THREE KINDS OF SYSTEMS

     よくご存じのように、リレーショナルＤＢＭＳは、simple データに対す
る query ということに関して、ファイルシステムと比べて、たいへんな強みを
提供している。高レベルの問合せ言語(query language)により、アプリケーシ
ョン開発を「容易」にすると同時に、「データベース独立性」(database 
independence)を提供する。これにより、低レベルの格納やアクセス(法)の詳細
に関して変更を行っても、クライアント(側で)は、プログラムを書き直す必要
がない。リレーショナルＤＢＭＳは、階層型およびネットワーク型という前世
代のＤＢＭＳによって普及した、標準的なトランザクションおよび保護のサー
ビスを提供する。

     オブジェクト指向のＤＢＭＳは、query なしで complex データをサポー
トする。一般的にいって、オブジェクト指向ＤＢＭＳは、２つの機構を提供す
る。rich type system、これにより complex なデータが容易にモデル化でき
る。そして、関数の reusability(再利用性)である。method(関数)をＤＢＭＳ
のスキーマの一部として定義できるので、まず専門家(expert)によって記述し
ておき、その後に、他のＤＢＭＳユーザがそれを再利用することができる。例
えば、私達の多くは、上の elevation の例のような、関数が必要であり、会社
の中の誰かが既にその関数を書いたとする。しかしながら、伝統的なＤＢＭＳ
では、私達は、それを見つけることができないのである。

     complex データに対して query 能力が要求される場合には、オブジェクト・
リレーショナルＤＢＭＳは、リレーショナルとオブジェクト指向ＤＢＭＳの両方
の利点を備え、しかも、両者の欠点もない。オブジェクト・リレーショナルＤＢ
ＭＳは、SQL の 表現の容易さと、データ独立性を備え、同時に、rich type 
system と reusability をも備える。ということで、オブジェクト・リレーショ
ナルＤＢＭＳは、Figure 1 の右上のコーナーのアプリケーションに対する、ベス
トのソリューションである。

     リレーショナルＤＢＭＳを complex データ(つまり、Figure 1 の右半分)
に対して使おうとすれば、非常にみすぼらしい結果になると思われる。[CATT92]
で説明されているように、右下の箱のアプリケーションについては、リレーショ
ナルＤＢＭＳは、オブジェクト指向ＤＢＭＳの数倍遅い結果となる。さらに、
SQL-89 と C++ の間の impedance mismatch により、そのようなアプリケーショ
ンを書くのは、非常に難しい。このようなフラストレーションと性能の悪さは、
右下の箱のアプリケーションに対して、リレーショナルシステムを使おうと試み
た場合の結果となる見込みが高い。

     同様に、右上の箱のアプリに対して、リレーショナルシステムを使った
場合には、ユーザは、自分の(目的にあった) complex データを、SQL-89 の
simple なデータ型に合わせて、simulate しなければならなず、しかも、この
ような simulation は、単調(たいくつ)で、そして、通常は、非常に劣った
性能結果となる。リレーショナルシステムを別の箱のアプリケーションに対し
て使うと、フラストレーションと、劣悪な性能という結果になる見込みが高い。

     今度は、オブジェクト指向のＤＢＭＳ(Figure 1 の右下の箱に対して適
する)について考えてみよう。オブジェクト指向ＤＢＭＳは、SQL のサポート
や、先に議論した最大限の TP1 性能を得るために必要なトランザクションの
技法に対しては、焦点を合わせていない。その結果、オブジェクト指向ＤＢＭ
Ｓでは TP1 を記述することが非常に困難なだけでなく、劣悪な性能が予測さ
れる。オブジェクト指向ＤＢＭＳを別の箱のアプリケーションに対して使うと、
フラストレーションと、劣悪な性能という結果になる見込みが高い。

     さらに、オブジェクト指向ＤＢＭＳを右上の箱のアプリケーションに対
して使った場合には、SQL にオブジェクト指向の構造(construct)が存在しな
いことから、アプリケーションで query を書くことが極度に困難となる。し
かも、正しいアクセスパスを自動的に選択するようなオプティマイザがない
ので、非常に劣悪な性能結果となる。オブジェクト指向ＤＢＭＳを別の箱のア
プリケーションに対して使うと、フラストレーションと、劣悪な性能という結
果になる見込みが高い。

     今度は、Illustra のようなオブジェクト・リレーショナルＤＢＭＳを考
えてみよう。Illustra では、オブジェクト指向ＤＢＭＳベンダーで期待でき
るような、C++ との緊密な(tight)カップリングは提供されない。ということで、
Illustra は、右下の箱のアプリケーションに対しては、適当であるとは言えな
い。加えて、Illustra は、TP1 性能に対して焦点を合わせておらず、その結果、
このベンチマーク(TP1)に対して特にチューンされたリレーショナルシステムと
比べれば、性能が遅いかもしれない。

     要約すると、リレーショナル、オブジェクト指向ＤＢＭＳ、および、オブ
ジェクト・リレーショナルＤＢＭＳは、Figure 1 のそれぞれの箱のアプリに対
して最適化してきた。さらに、どのようなＤＢＭＳアプリも、４つの箱のそれ
ぞれに当てはまるようなコンポーネント(部分、要素)を持っている。従って、
ＤＢＭＳアプリというのは、simple および complex データについての、検索
あり、および検索なし、という要素(部分)を混ぜあわさったものである。お客
さん(client)は、利用可能なソリューション(製品(?))の種類の中から、一つ選
ばなくてはならず、Figure 1 のどの箱が自分のアプリケーションの「重心」を
表しているのかを決定しなければならない。現在は、ほとんどのアプリケーショ
ンは、Figure 1 の左上の箱に重心がある。しかしながら、この重心は、近い将
来、議論したように、となりのセクションにシフトしていくと期待している。


4. WHAT WILL THE FUTURE BRING

     リレーショナルＤＢＭＳ市場は、年間40億ドルの規模と推定される。それ
に対して、オブジェクト指向ＤＢＭＳの市場は、およそ、年間3000万ドルの規
模である。ということで、市場全体の中のたった１％だけが、左上のコーナー
の外ということになる。しかしながら、近い将来には、この焦点がシフトする
と私達が信じている２つの要因がある。

トレンド１：お客さんは、データベースの中に、だんだんと、イメージ、テキス
            ト、ビデオ、音声などを入れるようになっている。

ということで、平均的なアプリケーションの中で扱われる complex データの量
は、かなり増加するであろう。これにより、お客さんは、Figure 1 の右側へ向
かって動くことになるであろう。

トレンド２：ハードウェアの進歩により、トランザクション処理の問題は、か
            なり簡単になりつつある。これにより、ソフトウェア(自体)の絶
            対的な性能は、重要性が減ってきた。

伝統的に、ビジネスデータ処理の問題は、難しいものであると考えられてきた。
なぜなら、要求されたトランザクションの速度を達成するのが難しかったから
である。ということで、Figure 1 の左上のコーナーに対して、かなりの焦点
がおかれていた。しかしながら、高速な RISC マシーン(しばしば、共用メモ
リ、マルチプロセッサ構成)により、演算(パワー)は極度に安価になりつつあ
る。しかも、RAID スタイルのディスクアレイでは、I/O を実行するために利
用可能なディスクアームの数が増えてきて、それによりディスクシステムの
性能も向上している。ということで、一秒間に数百の TP1 を実行することは、
たいしたことではなくなった。1995年までには、20万ドル以下の値段のマシー
ンで、1000 の TP1 を実行することも可能になるはずである。ほとんどのお客
さんは、一秒間に100以下の TP1 を実行させるだけでよいので、ほんの20万ド
ルのマシーンでほとんど全てのビジネスデータ処理の問題を解決できるはずで
ある。これにより、Figure 1 の左側に対して重きを置くことも減少するはず
である。

     ということで、ＤＢＭＳ利用における焦点は、Figure 1 の右上のコーナー
にシフトしていくであろうという結論にたどり着いた。そこには、オブジェクト・
リレーショナルＤＢＭＳが属している。次のセクションでは、オブジェクト・リ
レーショナルＤＢＭＳを作成するための３つの方法を考える。


5. APPROACHES TO BUILDING OBJECT-RELATIONAL DBMSs

     右上の箱のアプリケーションのニーズに対してアプローチするために、オ
ブジェクト・リレーショナルＤＢＭＳを作成するための、もっともらしい３つ
の方法がある。それぞれについて順番に考える：

        1) build an object-relational DBMS engine from scratch
        2) build a "wrapper" on a relational engine
        3) build a "wrapper" on a object-oriented engine

     ２節で議論した能力(機構)を提供するために、ある人は、ＤＢＭＳエン
ジンが「テーブル駆動」(table driven)でなければならないと主張する。テー
ブル、型、関数、オペレータ、および、継承に関する情報を含む meta data 
のデータベースによって動作する。ＤＢＭＳの個々のモジュールは、この 
meta data と対話(interact)しなければならない。なぜなら、パーザは、query
が正しい(legal)かどうかを決定するために meta data に問い合わせなければ
ならないし、オプティマイザは、meta data 内に格納された、ユーザ定義関数
およびオペレータを使った query に対して適切なアクセスパスを決定するため
に meta data にアクセスしなければならないし、実行制御(executor)は、その
時の状況において実際に使うべき関数を決定するために meta data を調べなけ
ればならない。B-tree アクセス法のコードでは、B-tree データ構造を渡り歩
くために、&lt; オペレータ(比較オペレータ)のどのインスタンスを使うべきなの
かを見つけ出すために、meta data を調べなければならない。

     一言で言えば、ＤＢＭＳ全体が、このたくさんの数の meta data を使っ
た、テーブル駆動でなければならない。Illustra は、オブジェクト・リレーショ
ナルＤＢＭＳのエンジンを、スクラッチビルドで書いた。このエンジンは、要求
されているアーキテクチャーを備えている。

     ここで、現在のリレーショナルＤＢＭＳのアーキテクチャーに移ろう。
全てのＲＤＢＭＳは、テーブルの構成を記述する meta data を持っているが、
型、オペレータ、関数、または継承に関する情報は全く持っていない。さらに、
SQL-89 の型、オペレータ、および関数(の存在)は、エンジンに最初から作り
こまれている(hard-coded)。例えば、整数の比較のオペレータが、
{&lt;, &lt;=, =, &gt;=, &gt;} という集合であるという情報は、パーザーに最初から作り
こまれている。さらに、オプティマイザには、文字列、整数、および浮動小数
点数のオペランドに関して、オペレータが {&lt;, &lt;=, =, &gt;=, &gt;} の集合に含まれ
る場合には、B-tree がふさわしい(plausible)アクセスパスであるということ
が予め作りこまれている。さらに、実行制御では、２つの整数の定数を加算す
る時には、整数加算のマシンインストラクションを使うように作りこまれてい
る。従って、全ての関数およびオペレータの意味解釈は、実行制御に予め作り
こまれている。最後に、B-tree アクセス法は、文字列、整数、および浮動小数
点数に対する &lt; の概念を、内部コードとして予め持っている。

     このようなアーキテクチャーは、「拡張不可能」であり、前の節での概念
を実現していない。この困難を緩和するために、リレーショナルベンダーは、
次の２つの道のどちらかに従うことができる：

        1) rewrite their engines from scratch
        2) write a "wrapper" on top of their current products to
           simulate the required features

最初のオプションは、リスキーであり、困難で、しかも時間のかかる選択肢で
あり、非常に長い期間をかけてはじめて実現できるものである。その一方、オ
ブジェクトをサポートしようと動いているベンダーは、２番目のアプローチを
使って、オブジェクトサポートを行っているようである。つまり「包むもの」
(wrapper)によるアプローチである。

     一般的な考え方は、クライアントとリレーショナルエンジンの間に位置す
るコード・レイヤーを書くというものである。この wrapper により、既存のリ
ーショナルエンジンの上に、前の節の新しいコンセプトを simulate するであろ
う。Figure 1 の右上のコーナーのアプリケーションを持っているユーザは、現
在のリレーショナル製品に対する simulation レイヤを自分で書くこともできる
のだということは、きちんと認識しておくべきである。wrapper が行うことの全
ては、この simulation 機能を自動化することである。しかしながら、既存のシ
ステムにたいして自作の wrapper を書こうと試みたユーザのほとんどが、結局、
非常に劣悪な性能結果を見た。その結果、wrapper 技術は性能問題を「取り繕う」
ことはできるが、リレーショナルシステムで実行するように設計されていない
ような task を実行する場合の性能問題を解決することはできない。

     wrapper 技術は、現在、Hewlett Packard が利用している。HP の Open
RDB は、Allbase の上に wrapper として実現されている。Oracle の Version
8 も、Oracle Version 7 の上の wrapper を通じて、少なくともいくらかのオ
ブジェクト機能が含まれると期待されている。ユーザは、wrapper 技術に基づ
いた製品の性能にはとても耐えられないだろう。

     最後の選択肢は、オブジェクト・リレーショナルＤＢＭＳを現行のオブ
ジェクト指向ＤＢＭＳの上に構築することである。言い換えれば、永続的な
C++ のインプリメンテーションの上にＳＱＬエンジンの拡張を構築するので
ある。この種のインプリメンテーションにはいくつかの欠点がある。最初に、
これは非常に多くの作業が必要とされる。拡張ＳＱＬ言語のために、パーザ、
ビューサポートシステム、オプティマイザ、実行制御をインプリメントしな
ければならない。これがオブジェクト・リレーショナル製品の大半(の状況)
である。言い換えれば、現行のオブジェクト指向製品は、提供するべき機能
の中の少ない部分しか持っていない。

     ２番目に、全てのオブジェクト指向ＤＢＭＳベンダーは、ＤＢＭＳを
ユーザプログラムと同一のアドレス空間で実行している。言い換えれば、クラ
イアントアプリケーションと、ＤＢＭＳの間に「保護」障壁が全くないという
ことである。このように保護がないことは、永続的 C++ アプリケーションで
高性能を出すためには、このような緊密なカップリングが要求され、右下の
アプリケーションは、より良い性能を得るためには保護障壁をあきらめること
もいとわないという前提に立てば、正当化できる。しかしながら、保護障壁な
しでは、不当なアプリケーションがいかなるＤＢＭＳデータをも読むことが可
能であり、さらに悪いことに、データをゼロクリアしてしまったりすることも
あり得る。言い換えれば、永続的 C++ 上に作られたシステムには「基本的に
セキュリティは全くない」ということである。安全な(secure)システムを実現
するためには、オブジェクト指向ベンダーは、かなりの犠牲を払って、永続的
C++ 製品のアーキテクチャー変更を行わなければならないだろう。

     ３番目に、コンパイルの問題がある。永続的 C++ の環境では、ＤＢＭＳ
のルーチンは、ユーザーの C++ アプリケーションの中にコンパイルしなければ
ならない。もしＤＢＭＳに新しい関数、オペレータ、またはデータ型を追加し
たい場合には、ユーザプログラムを再コンパイルする必要があるか、もしくは、
再リンクする必要がある。動的な環境において、多くのユーザがたくさんのプロ
グラムを実行しているような場合には、これは厳しい管理作業となる。やはり、
動的な拡張性を可能にするためには、オブジェクト指向ベンダーは、かなりの犠
牲と困難を払って、製品のアーキテクチャーを変更しなければならないであろう。

     最後の行は、以下のように要約できる。リレーショナルベンダーは、左上
のコーナーから、右上のコーナーに移行するためには、製品を書き直さなけれ
ばならないであろう。これは、非常に長い時間がかかり、かつ、かなりの技術
的リスクとなる。なぜなら、機能性を提供するが、性能が非常に劣悪な wrapper
を書くようにみんなを動機付けなければならないからである。オブジェクト指向
ＤＢＭＳベンダーは、Figre 1 の下から上に上がるためには、多くの機能をイン
プリメントしなければならない。さらに、彼らの製品のアーキテクチャに関する
決定は、永続的 C++ に対する高性能のエンジンを用意することに動機付けられ
てきており、SQL ベースのオブジェクト・リレーショナルＤＢＭＳに対して適当
ではない。ということで、彼らも、頑強で、安全で、動的に拡張できるオブジェ
クト・リレーショナルＤＢＭＳを用意するのには困難がある。

    その一方で、高性能で、安全で、頑強で、動的に拡張可能なオブジェクト・
リレーショナルＤＢＭＳが、今日、Illustra Information Technologies から
入手可能である。


                            REFERENCES

[ANON85]      Anon et. al., "A Measure of Transaction Processing Power",
              Tandem Technical Report 85.1 Tandem Computers, Cupertino,
              Ca., August 1985.

[CATT92]      Cattell, R. and Skeen, J., "Engineering Database Benchmark,"
              ACM TODS, July 1992.

&lt;eof&gt;
</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<UL><LI><STRONG>Follow-Ups</STRONG>:
<UL>
<LI><STRONG><A NAME="00059" HREF="msg00059.html">[postgres95 599] Re: OBJECT-RELATIONAL DBMSs</A></STRONG>
<UL><LI><EM>From:</EM> Jun Kuwamura &lt;juk@rccm.co.jp&gt;</LI></UL></LI>
<LI><STRONG><A NAME="00048" HREF="msg00048.html">[postgres95 588] Re: OBJECT-RELATIONAL DBMSs</A></STRONG>
<UL><LI><EM>From:</EM> Akio Tokaji &lt;tokaji@db.nm.fujitsu.co.jp&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-Follow-Ups-End-->
<!--X-References-->
<UL><LI><STRONG>References</STRONG>:
<UL>
<LI><STRONG><A NAME="00015" HREF="msg00015.html">[postgres95 555] Re: OBJECT-RELATIONAL DBMSs</A></STRONG>
<UL><LI><EM>From:</EM> Jun Kuwamura &lt;juk@rccm.co.jp&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00057.html">[postgres95 597] Re: pg95-1.02-jp.patch</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00048.html">[postgres95 588] Re: OBJECT-RELATIONAL DBMSs</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00021.html">[postgres95 561] Re: OBJECT-RELATIONAL DBMSs</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00048.html">[postgres95 588] Re: OBJECT-RELATIONAL DBMSs</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00047"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00047"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>

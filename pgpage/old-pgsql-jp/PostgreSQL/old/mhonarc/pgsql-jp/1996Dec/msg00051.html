<!-- MHonArc v2.1.0 -->
<!--X-Subject: [postgres95 1142] Re: KANJI&#45;CODE on Postgres95 -->
<!--X-From: Mitsuhiro Maeda <mitsu@tramp.co.jp> -->
<!--X-Date: Mon, 09 Dec 1996 03:04:17 +0900 -->
<!--X-Message-Id: 199612081804.DAA00797@log.tramp.co.jp -->
<!--X-ContentType: text/plain -->
<!--X-Reference-Id: 199612060513.OAA27687@srashc.sra.co.jp -->
<!--X-Head-End-->
<HTML>
<HEAD>
<TITLE>[postgres95 1142] Re: KANJI-CODE on Postgres95 </TITLE>
<LINK REV="made" HREF="mailto:mitsu@tramp.co.jp">
</HEAD>
<BODY BGCOLOR="#ffffff">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00057.html">Date Prev</A>][<A HREF="msg00052.html">Date Next</A>][<A HREF="msg00035.html">Thread Prev</A>][<A HREF="msg00052.html">Thread Next</A>][<A HREF="index.html#00051">Date Index</A>][<A HREF="threads.html#00051">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>[postgres95 1142] Re: KANJI-CODE on Postgres95</H1>
<HR>
<!--X-Subject-Header-End-->
<UL>
<LI><em>From</em>: Mitsuhiro Maeda &lt;<A HREF="mailto:mitsu@tramp.co.jp">mitsu@tramp.co.jp</A>&gt;</LI>
<LI><em>Date</em>: Mon, 09 Dec 1996 03:04:17 +0900</LI>
<LI><em>References</em>: &lt;<A HREF="msg00035.html">199612060513.OAA27687@srashc.sra.co.jp</A>&gt;</LI>
</UL>
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
おみつ@Tramp です。

石井さんからの御提案を元に、
php-2.0b7 用の「内部 EUC -&gt; 出力漢字コード(ユーザー設定)」
というものを作ってみました。

前回のものとの相違点は、

 * 内部処理を EUC にすべて統一
 * 出力漢字コードを関数「SetKanjiOutput("コード名")」にて設定
 * 内部処理を統一したことで前回の関数「KanjiConv()」が
   機能しなくなりましたので、関数そのものを削除
 * mmap はよくわからなかったので (^^;;) コメントアウト

となっています。


このメールの後半を切り取って、kanji.patch に保存して下さい。

そして PHP/FI のソースのトップディレクトリ(???/php-2.0b7/)で

% patch -p1 &lt; kanji.patch 

を実行して、あとは 通常通りの ./install とします。

関数「SetKanjiOutput("モード")」を指定することで、
その出力コードを指定することができます。

[モード]
  モードは { EUC | JIS | SJIS } の 3種類 です。
  文字列として指定します。


確認済み動作環境は、
  Linux 1.2.13 (Slackware 3.0) + JE 0.9.7
 + postgres95-1.06 + pg95-1.06-jp.patch
 + apache_1.1.1 + php-2.0b7
のみです。

# mmap って動的にメモリをアロケートしてくれるんでしょうか ...
# ううむ。勉強不足でして ... ;-)


ここから
======================================================================

diff -c -r -N php-2.0b7/README.kanji.euc kanji-php/README.kanji.euc
*** php-2.0b7/README.kanji.euc	Thu Jan  1 09:00:00 1970
--- kanji-php/README.kanji.euc	Mon Dec  9 02:35:52 1996
***************
*** 0 ****
--- 1,96 ----
+ README.kanji  === PHP/FI 漢字コードハンドリング 第 2 版 ===
+ 
+ *** INTRO ***
+ 
+ PHP/FIにて漢字コードの変換を実現するパッケージを組んでみました。
+ ですが、このコードはほぼすべて「ぱくり」です ;-) 
+ 
+ ベースは、
+ 1. shige@csk.JUNET さんの filters-2.0
+ 2. 佐藤公彦(K.Sato)の qkc 1.0
+ から拝借いたしました。
+ 
+ 
+ PHP/FI のソースのトップディレクトリ(php-??)で
+ 
+ % patch -p1 &lt; kanji.patch 
+ 
+ を実行して、あとは 通常通りの ./install とします。
+ 
+ 
+ *** HOW-TO ***
+ 
+ このパッケージは、PHP/FI 上で漢字コードを使う際に
+ 内部コードを EUC に統一し、その出力コードをセット
+ するものです。
+ 
+ 関数「SetKanjiOutput("モード")」を指定することで、
+ その出力コードを指定することができます。
+ 
+ [モード]
+   モードは { EUC | JIS | SJIS } の 3種類 です。
+   文字列として指定します。
+ 
+ 
+ 
+ *** EXAMPLE ***
+ 
+ &lt;? 
+   ...
+   $str="おみつ"; /* この時点で内部コードは EUC になります */
+   pg_exec("select * from address where person='$str'");
+   ...
+ 
+   $res=" 検索結果 : $str ";
+ 
+   SetKanjiOutput("JIS"); /* ブラウザに JIS で表示 */
+   echo "&lt;h2&gt; $res &lt;/h2&gt;";
+   ...
+ 
+   SetKanjiOutput("SJIS"); /* ファイルへ SJIS で保存 */
+   $fp=fopen("/dos/result.txt","w");
+     fputs($fp,$res);
+   fclose($fp);
+   ...
+ 
+ &gt;
+ 
+ ブラウザのみならず、ファイルへの出力も制御できます。
+ デバイスへの出力前に使用して下さい。
+ 
+ デフォルトの出力コードは「EUC」です。
+ 
+ 
+ *** MACHINE ***
+ 
+ 確認済み動作環境は、
+   Linux 1.2.13 (Slackware 3.0) + JE 0.9.7
+  + postgres95-1.06 + pg95-1.06-jp.patch
+  + apache_1.1.1 + php-2.0b7
+ のみです。
+ 
+ 
+ *** BUGS ***
+ 
+ php-2.0b9 がリリースされ、パッチが当たらないらしいです。
+ もう少し待って下さい。( 今手元に 2.0b9 がないんです :-)
+ 
+ 
+ *** CHANGES ***
+ 
+ 前回流した「KanjiConv(文字列,モード)」は、内部コード
+ を統一したことによって機能しなくなりましたので、
+ 削除させて頂きました。
+ 
+ 
+ *** NOTICE ***
+ 
+ 「とりあえず動くもの」を大前提として組みましたので
+ なにかしら問題もあるかと思われますが、完全に無保証です。
+ 各人の責任において御使用ください。
+ 
+ ======================================================================
+ 12-09-1996 前田充宏
+ mitsu@tramp.co.jp
+ 
diff -c -r -N php-2.0b7/config.h.in kanji-php/config.h.in
*** php-2.0b7/config.h.in	Mon Sep 23 08:30:37 1996
--- kanji-php/config.h.in	Mon Dec  9 02:21:06 1996
***************
*** 37,43 ****
  #undef HAVE_STRCASECMP
  
  /* Define if you have the mmap function.  */
! #undef HAVE_MMAP
  
  /* Define if you have the putenv function.  */
  #undef HAVE_PUTENV
--- 37,43 ----
  #undef HAVE_STRCASECMP
  
  /* Define if you have the mmap function.  */
! /* #undef HAVE_MMAP */
  
  /* Define if you have the putenv function.  */
  #undef HAVE_PUTENV
diff -c -r -N php-2.0b7/src/Makefile.in kanji-php/src/Makefile.in
*** php-2.0b7/src/Makefile.in	Mon Sep 23 11:13:41 1996
--- kanji-php/src/Makefile.in	Mon Dec  9 02:20:59 1996
***************
*** 105,111 ****
  	  echo.o cond.o switch.o db.o while.o string.o msql.o \
  	  reg.o exec.o file.o crypt.o head.o info.o post.o \
  	  type.o conf.o acc.o local.o dns.o log.o sort.o dir.o rand.o \
! 	  gd.o mime.o fsock.o microtime.o pg95.o pool.o tmagic.o
  
  all: $(PHP_PROGS) @MODULE_TARGET@
  
--- 105,113 ----
  	  echo.o cond.o switch.o db.o while.o string.o msql.o \
  	  reg.o exec.o file.o crypt.o head.o info.o post.o \
  	  type.o conf.o acc.o local.o dns.o log.o sort.o dir.o rand.o \
! 	  gd.o mime.o fsock.o microtime.o pg95.o pool.o tmagic.o \
! 	  kanjiconv.o etoj.o etos.o jtoe.o jtos.o \
! 	  stoe.o stoj.o
  
  all: $(PHP_PROGS) @MODULE_TARGET@
  
diff -c -r -N php-2.0b7/src/etoj.c kanji-php/src/etoj.c
*** php-2.0b7/src/etoj.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/etoj.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,104 ----
+ /*								*/
+ /*	etoj.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	etoj	EUC code convert into JIS code.			*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$B	^[(B	JIS 83				*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC 	'\033'
+ #define KI1 	'$'
+ #define KI2 	'B'
+ #define KO1 	'('
+ #define KO2 	'B'
+ #define	KANAIN		0x0e
+ #define	KANAOUT		0x0f
+ #define	SS2		0x8e	/* Hankaku Kana */
+ 
+ void
+ etoj(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c;
+ 
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if(0xa1 &lt;= c &amp;&amp; c &lt;= 0xfe) { /* ZENKAKU */
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=KI2;
+ 	dest[pos++]=(c &amp; 0x7f);
+ 	stat = 1;
+       }
+       else if(c == SS2) { /* Hankaku Kana */
+ 	dest[pos++]=KANAIN;
+ 	c = src[i++];
+ 	dest[pos++]=(c &amp; 0x7f);
+ 	stat = 3;
+       }
+       else /* ASCII */
+ 	dest[pos++]=c;
+       break;
+     case 1:
+       stat = 2;
+       dest[pos++]=(c &amp; 0x7f);
+       break;
+     case 2:
+       if(0xa1 &lt;= c &amp;&amp; c &lt;= 0xfe) { /* ZENKAKU */
+ 	dest[pos++]=(c &amp; 0x7f);
+ 	stat = 1;
+       }
+       else {
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=KO2;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     case 3:				 /* hankaku kana */
+       if(c == SS2) {
+ 	c=src[i++];
+ 	dest[pos++]=(c &amp; 0x7f);
+       }
+       else {
+ 	dest[pos++]=KANAOUT;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     }
+   }
+   if ( stat == 1 || stat == 2 ) {
+     /* put KANJI-OUT */
+     dest[pos++]=ESC;
+     dest[pos++]=KO1;
+     dest[pos++]=KO2;
+   }
+   else if (stat == 3) 
+     dest[pos++]=KANAOUT;
+ 
+   /* terminate */
+   dest[pos]='\0';
+ }
diff -c -r -N php-2.0b7/src/etos.c kanji-php/src/etos.c
*** php-2.0b7/src/etos.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/etos.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,82 ----
+ /*
+  *	EUC --&gt; Sift_JIS  Convert Routine
+  */
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define	Z_BEGIN		0xa1	/* Zenkaku Begin */
+ #define	Z_END		0xfe	/* Zenkaku END */
+ #define SS2    		0x8e	/* Hankaku Kana */
+ 
+ static void
+ JIS_IBM(jis1,jis2,ibm1,ibm2)
+      register unsigned char jis1,jis2,*ibm1,*ibm2;
+ {
+   if(jis1 &gt;= 0x5f)    jis1 += 0x80;
+   
+   if((jis1 % 2) == 0) {
+     *ibm1 = (jis1 - 0x30)/2 + 0x88;
+     *ibm2 = jis2 + 0x7e;
+   }
+   else {
+     if(jis2 &gt;= 0x60)
+       jis2 = jis2 + 0x01;
+     *ibm1 = (jis1 - 0x31)/2 + 0x89;
+     *ibm2 = jis2 + 0x1f;
+   }
+   *ibm1 &amp;= 0xff;
+   *ibm2 &amp;= 0xff;
+ }
+ 
+ void
+ etos(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c,c1,c2;
+   unsigned char s1,s2;
+   
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if (Z_BEGIN &lt;= c  &amp;&amp; c &lt;= Z_END) { /* Zenkaku */
+ 	c1 = c &amp; 0x7f;
+ 	stat = 1;
+       }
+       else if (c == SS2) { /* Hankaku Kana */
+ 	c = src[i++];
+ 	dest[pos++]=c;
+       }
+       else /* ASCII */
+ 	dest[pos++]=c;
+       break;
+     case 1:
+       stat = 0;
+       c2 = c &amp; 0x7f;
+       JIS_IBM(c1,c2,&amp;s1,&amp;s2); /* Convert JIS to Sift_JIS */
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ }
+ 
diff -c -r -N php-2.0b7/src/file.c kanji-php/src/file.c
*** php-2.0b7/src/file.c	Mon Sep 23 07:11:05 1996
--- kanji-php/src/file.c	Mon Dec  9 02:21:01 1996
***************
*** 22,27 ****
--- 22,28 ----
  /* $Id: file.c,v 1.32 1996/09/22 22:07:51 rasmus Exp $ */
  #include "php.h"
  #include &lt;stdlib.h&gt;
+ #include &lt;string.h&gt;
  #ifdef HAVE_UNISTD_H
  #include &lt;unistd.h&gt;
  #endif
***************
*** 981,986 ****
--- 982,988 ----
  		Push("",STRING);
  		return;
  	}
+ 	conv2euc(buf);
  	Push((buf=AddSlashes(buf,1)),STRING);
  }
  
***************
*** 1016,1021 ****
--- 1018,1024 ----
  		Push("",STRING);
  		return;
  	}
+ 	conv2euc(buf);
  	rbuf=estrdup(1,buf);
  	c = *buf;
  	lc=(char)0;
***************
*** 1088,1094 ****
  	Stack *s;
  	FILE *fp;
  	int ret,id;
! 	char *buf;
  	char temp[8];
  
  	s = Pop();
--- 1091,1097 ----
  	Stack *s;
  	FILE *fp;
  	int ret,id;
! 	char *buf,*temp_buf;
  	char temp[8];
  
  	s = Pop();
***************
*** 1113,1119 ****
  	}
  	ParseEscapes(buf);
  	StripSlashes(buf);
! 	ret = fputs(buf,fp);
  	sprintf(temp,"%d",ret);
  	Push(temp,STRING);
  }	
--- 1116,1124 ----
  	}
  	ParseEscapes(buf);
  	StripSlashes(buf);
! 	temp_buf=emalloc(0,strlen(buf)*2+ECHO_BUF);
! 	(*function_table[output_kanji_code][EUC])(temp_buf,buf);
! 	ret = fputs(temp_buf,fp);
  	sprintf(temp,"%d",ret);
  	Push(temp,STRING);
  }	
diff -c -r -N php-2.0b7/src/jtoe.c kanji-php/src/jtoe.c
*** php-2.0b7/src/jtoe.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/jtoe.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,188 ----
+ /*								*/
+ /*	jtoe.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	jtoe	all JIS code convert into EUC code.		*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$@	^[(H	JIS 78  &amp;  (incorrect code)	*/
+ /*		^[$@	^[(J	JIS 78  &amp;  JIS_ROMAN		*/
+ /*		^[$@	^[(B	JIS 78  &amp;  ASCII		*/
+ /*		^[$B	^[(J	JIS 83  &amp;  JIS_ROMAN		*/
+ /*		^[$B	^[(B	JIS 83  &amp;  ASCII		*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC '\033'
+ #define KI1 '$'
+ #define KI2 '@'
+ #define KI3 'B'
+ #define KO1 '('
+ #define KO2 'J'
+ #define KO3 'H'
+ #define KO4 'B'
+ #define	KANAIN	0x0e
+ #define	KANAOUT	0x0f
+ #define	SS2	0x8e
+ 
+ static void 
+ JIS_EUC(jis1,jis2,euc1,euc2)
+      register unsigned char jis1,jis2,*euc1,*euc2;
+ {
+   *euc1 = jis1 | 0x80;
+   *euc2 = jis2 | 0x80;
+ }
+ 
+ void
+ jtoe(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c, c1, c2;
+   unsigned char s1, s2;
+   static int js78on = 0, js83on = 0;
+   
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+   
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if (c == ESC) 
+ 	stat = 1;
+       else if(c == KANAIN)
+ 	stat = 6;
+       else
+ 	dest[pos++]=c;
+       break;
+     case 1: /*  ESC ----&gt; ?  */
+       switch(c) {
+       case KO1:
+ 	stat = 2;
+ 	break;
+       case KI1:
+ 	stat = 3;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 2: /* ESC --&gt; KO1 --&gt; ? */
+       switch(c){
+       case KO2: /* ^[(J : KOUT (to JIS_ROMAN) */
+       case KO4: /* ^[(B : KOUT (to ASCII) */
+ 	if (js78on || js83on){ /* JIS 78 or JIS 83 KANJI */
+ 	  js83on = 0;
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KO3: /* ^[(H : incorrect but used */
+ 	if (js78on){ /* JIS 78 KANJI */
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 3: /* ESC --&gt; KI1 --&gt; ? */
+       switch(c){
+       case KI2: /* ^[$@ : JIS 78 KIN */
+ 	stat = 4;
+ 	js78on = 1;
+ 	break;
+       case KI3: /* ^[$B : JIS 83 KIN */
+ 	stat = 4;
+ 	js83on = 1;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 4: /* JIS KANJI 1st */
+       if (c == ESC)
+ 	stat = 1;
+       else if (c == KANAIN) ;
+       else {
+ 	c1 = c;
+ 	stat = 5;
+       }
+       break;
+     case 5: /* JIS KANJI 2nd */
+       c2 = c;
+       JIS_EUC(c1,c2,&amp;s1,&amp;s2);
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       stat = 4;
+       break;
+     case 6: /* HANKAKU KANA */
+       if(c == KANAIN) ;
+       else if(c == KANAOUT)
+ 	stat = 0;
+       else {
+ 	if((c &gt;=0x21) &amp;&amp; (c &lt;= 0x5f))
+ 	  c |= 0x80;
+ 	dest[pos++]=SS2;
+ 	dest[pos++]=c;
+       }
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ }
+ 
diff -c -r -N php-2.0b7/src/jtos.c kanji-php/src/jtos.c
*** php-2.0b7/src/jtos.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/jtos.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,200 ----
+ /*								*/
+ /*	jtos.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	jtos	all JIS code convert into SJIS code.		*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$@	^[(H	JIS 78  &amp;  (incorrect code)	*/
+ /*		^[$@	^[(J	JIS 78  &amp;  JIS_ROMAN		*/
+ /*		^[$@	^[(B	JIS 78  &amp;  ASCII		*/
+ /*		^[$B	^[(J	JIS 83  &amp;  JIS_ROMAN		*/
+ /*		^[$B	^[(B	JIS 83  &amp;  ASCII		*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC '\033'
+ #define KI1 '$'
+ #define KI2 '@'
+ #define KI3 'B'
+ #define KO1 '('
+ #define KO2 'J'
+ #define KO3 'H'
+ #define KO4 'B'
+ #define	KANAIN	0x0e
+ #define	KANAOUT	0x0f
+ 
+ static void
+ JIS_SJIS(jis1,jis2,sjis1,sjis2)
+      register unsigned char jis1,jis2,*sjis1,*sjis2;
+ {
+   if(jis1 &gt;= 0x5f)
+     jis1 += 0x80;
+   
+   if((jis1 % 2) == 0) {
+     *sjis1 = (jis1 - 0x30)/2 + 0x88;
+     *sjis2 = jis2 + 0x7e;
+   }
+   else {
+     if(jis2 &gt;= 0x60)
+       jis2 = jis2 + 0x01;
+     *sjis1 = (jis1 - 0x31)/2 + 0x89;
+     *sjis2 = jis2 + 0x1f;
+   }
+   *sjis1 &amp;= 0xff;
+   *sjis2 &amp;= 0xff;
+ }
+ 
+ void
+ jtos(char *dest, const char *src)
+ {
+   int stat;
+   register unsigned char c, c1, c2;
+   unsigned char s1, s2;
+   static int js78on=0, js83on=0;
+ 
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while((c = src[i++]) != '\0'){
+     switch (stat) {
+     case 0:
+       if (c == ESC) 
+ 	stat = 1;
+       else if(c == KANAIN)
+ 	stat = 6;
+       else
+ 	dest[pos++]=c;
+       break;
+     case 1: /*  ESC ----&gt; ?  */
+       switch (c) {
+       case KO1:
+ 	stat = 2;
+ 	break;
+       case KI1:
+ 	stat = 3;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 2: /* ESC --&gt; KO1 --&gt; ? */
+       switch(c){
+       case KO2: /* ^[(J : KOUT (to JIS_ROMAN) */
+       case KO4: /* ^[(B : KOUT (to ASCII) */
+ 	if (js78on || js83on){ /* JIS 78 or JIS 83 KANJI */
+ 	  js83on = 0;
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KO3: /* ^[(H : incorrect but used */
+ 	if(js78on){ /* JIS 78 KANJI */
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 3:			/* ESC --&gt; KI1 --&gt; ? */
+       switch(c){
+       case KI2:		/* ^[$@ : JIS 78 KIN */
+ 	stat = 4;
+ 	js78on = 1;
+ 	break;
+       case KI3:		/* ^[$B : JIS 83 KIN */
+ 	stat = 4;
+ 	js83on = 1;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 4:		/* JIS KANJI 1st */
+       if (c == ESC)
+ 	stat = 1;
+       else if (c == KANAIN) ;
+       else {
+ 	c1 = c;
+ 	stat = 5;
+       }
+       break;
+     case 5:		/* JIS KANJI 2nd */
+       c2 = c;
+       JIS_SJIS(c1,c2,&amp;s1,&amp;s2);
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       stat = 4;
+       break;
+     case 6:		/* HANKAKU KANA */
+       if(c == KANAIN) ;
+       else if(c == KANAOUT)
+ 	stat = 0;
+       else {
+ 	if((c &gt;=0x21) &amp;&amp; (c &lt;= 0x5f))
+ 	  c |= 0x80;
+ 	dest[pos++]=c;
+       }
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ 
+ }
+ 
diff -c -r -N php-2.0b7/src/kanjiconv.c kanji-php/src/kanjiconv.c
*** php-2.0b7/src/kanjiconv.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/kanjiconv.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,237 ----
+ /************************************************************************/
+ /*                                                                      */
+ /* kanjiconv.c                                                          */
+ /*                                                                      */
+ /* by o3(mitsu@tramp.co.jp)                                             */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /* Usage in PHP script :                                                */
+ /*   KanjiConv("&lt;strings&gt;", "&lt;mode&gt;");                                  */
+ /*                                                                      */
+ /* ARGS                                                                 */
+ /*   &lt;strings&gt;: strings to convert Kanji code                           */
+ /*    &lt;mode&gt;  : EUC | SJIS | JIS                                        */
+ /*                                                                      */
+ /* RETURN VALUE                                                         */
+ /*   type: string (in Kanji-code "mode")                                */
+ /*                                                                      */
+ /* EXAMPLE                                                              */
+ /*   $str = KanjiConv($input, "EUC");                                   */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ #include "php.h"
+ #include "parse.h"
+ 
+ /* Kanji Code for output */
+ int output_kanji_code=EUC;
+ 
+ /* (*function_table[dest][src])(dest,src) */
+ FUNC function_table[4][4]={
+   { (void*)strcpy, (void*)strcpy, (void*)strcpy, (void*)strcpy}, /* dest : NONE */
+   { (void*)strcpy, (void*)strcpy, jtoe, stoe}, /* dest :  EUC */
+   { (void*)strcpy, etoj, (void*)strcpy, stoj}, /* dest :  JIS */
+   { (void*)strcpy, etos, jtos, (void*)strcpy}  /* dest : SJIS */
+ };
+ 
+ 
+ static int
+ _checkforward(unsigned char *p)
+ {
+   unsigned char c;
+ 
+   if(*++p=='\0')
+     return EUC;
+   
+   while(1){
+     if(c=='\033'){
+       if((c=*p++)=='\0')
+ 	break;
+       if(c=='$'){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(c=='B' || c=='@')
+ 	  return JIS;
+ 	else
+ 	  continue;
+       }
+       else if(c=='K')
+ 	return JIS;
+       else
+ 	continue;
+     }
+     else if(c&gt;=0x81){
+       if(c==0x8e){
+ 	if((*++p)=='\0')
+ 	  break;
+       }
+       else if(c&lt;=0x9f){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskanji2nd(c))
+ 	  return SJIS;
+ 	else
+ 	  continue;
+       }
+       else if(c&gt;=0xa1 &amp;&amp; c&lt;=0xdf){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskana(c))
+ 	  continue;
+ 	else if (iseuc(c))
+ 	  return EUC;
+ 	else
+ 	  continue;
+       }
+       else if(c!=0xa0)
+ 	return EUC;
+     }
+     if((c=*p++)=='\0')
+       break;
+   }
+ 
+   return EUC;
+ }
+ 
+ static int 
+ _kanjicode(unsigned char *buf)
+ {
+   unsigned char *p,c;
+   int unknownstat = 0;
+ 
+   if(buf==NULL || buf[0]=='\0')
+     return NONE;
+ 
+   p=buf;
+   c=*p++;
+   while(1){
+     if(c=='\033'){
+       if((c=*p++)=='\0')
+ 	break;
+       if(c=='$'){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(c=='B' || c=='@')
+ 	  return JIS;
+ 	else
+ 	  continue;
+       }
+       else if(c=='K')
+ 	return JIS;
+       else
+ 	continue;
+     }
+     else if(c&gt;=0x81){
+       if(c==0x8e){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskana(c))
+ 	  unknownstat |= 2;
+ 	else if (iskanji2nd(c))
+ 	  return SJIS;
+ 	else
+ 	  continue;
+       }
+       else if(c&lt;=0x9f){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskanji2nd(c))
+ 	  return SJIS;
+ 	else
+ 	  continue;
+       }
+       else if(c&gt;=0xa1 &amp;&amp; c&lt;=0xdf || c==0xfd || c==0xfe){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iseuc(c))
+ 	  if(iskana(c))
+ 	    if(*(p+1)=='\0')
+ 	      return EUC;
+ 	    else
+ 	      return _checkforward(p);
+ 	  else
+ 	    return EUC;
+ 	else
+ 	  continue;
+       }
+       else if(c&gt;=0xe0 &amp;&amp; c&lt;=0xfc){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskanji2nd(c))
+ 	  if(iseuc(c))
+ 	    unknownstat |= 1;
+ 	  else
+ 	    return SJIS;
+ 	else
+ 	  if(iseuc(c))
+ 	    return EUC;
+ 	  else
+ 	    continue;
+       }
+     }
+     if((c=*p++)=='\0')
+       break;
+   }
+ 
+   if(unknownstat==2)
+     return SJIS;
+   else
+     return NONE;
+ 
+ }
+ 
+ void
+ conv2euc(char *src)
+ {
+   char *temp;
+   temp=emalloc(0,strlen(src)+1);
+   (*function_table[EUC][_kanjicode(src)])(temp,src);
+   strcpy(src,temp);
+ }
+ 
+ void
+ SetKanjiOutput(void)
+ {
+   Stack *s;
+   unsigned char *ret;
+ 
+   s=Pop();
+   if(!s){
+     Error("Stack error in KanjiConv");
+     return;
+   }
+ 
+   if(!strcasecmp(s-&gt;strval,"EUC"))
+     output_kanji_code=EUC;
+   else if(!strcasecmp(s-&gt;strval,"JIS"))
+     output_kanji_code=JIS;
+   else if(!strcasecmp(s-&gt;strval,"SJIS"))
+     output_kanji_code=SJIS;
+   else 
+     output_kanji_code=NONE;
+ 
+   return;
+ }
+ 
+ 
+ int
+ kanji_puts(char *str)
+ {
+   unsigned char *ret;
+ 
+   ret=(unsigned char*)emalloc(0,2*strlen(str)+1);
+ 
+   (*function_table[output_kanji_code][EUC])(ret,str);
+ 
+ #if APACHE
+ #if APACHE_NEWAPI
+   return rputs(str,php_rqst);
+ #else
+   return rprintf(php_rqst,"%s",ret);
+ #endif
+ #else
+   return fputs(ret,stdout);
+ #endif
+ 
+ }
diff -c -r -N php-2.0b7/src/lex.c kanji-php/src/lex.c
*** php-2.0b7/src/lex.c	Mon Sep 23 07:11:27 1996
--- kanji-php/src/lex.c	Mon Dec  9 02:20:59 1996
***************
*** 333,338 ****
--- 333,339 ----
  	  { "msql_tablename", INTFUNC2,MsqlTableName },
  	  { "pg_fieldprtlen", INTFUNC3,PGfieldPrtLen },
  	  { "escapeshellcmd", INTFUNC1,EscapeShellCmd },
+ 	  { "setkanjioutput", INTFUNC1,SetKanjiOutput },
  	  { NULL,0,NULL } },
  
  	{ { "msql_freeresult", INTFUNC1,MsqlFreeResult }, /* 15 */
***************
*** 1216,1221 ****
--- 1217,1223 ----
  		fp = fdopen(fd,"r");
  		pa = emalloc(0,file_size + 1);
  		fread(pa,1,file_size,fp);
+ 		conv2euc(pa);
  		pa_pos = 0L;
  		fclose(fp);
  		}
diff -c -r -N php-2.0b7/src/php.h kanji-php/src/php.h
*** php-2.0b7/src/php.h	Mon Sep 23 08:33:39 1996
--- kanji-php/src/php.h	Mon Dec  9 02:21:00 1996
***************
*** 964,966 ****
--- 964,1001 ----
  char *strerror(int);
  #endif
  
+ 
+ /* kanjiconv.c */
+ /* and other utils for kanji code */
+ #define NONE 0
+ #define EUC  1
+ #define JIS  2
+ #define SJIS 3
+ 
+ typedef void (*FUNC)();
+ 
+ #define iskanji1st(c) ((c) &gt;= 0x81 &amp;&amp; (c) &lt;= 0x9f ||\
+                        (c) &gt;= 0xe0 &amp;&amp; (c) &lt;= 0xfc)
+ #define iskanji2nd(c) ((c) &gt;= 0x40 &amp;&amp; (c) &lt;= 0xfc &amp;&amp; (c) != 0x7f)
+ #define iseuc(c) ((c) &gt;= 0xa1 &amp;&amp; (c) &lt;= 0xfe)
+ #define isjis(c) ((c) &gt;= 0x21 &amp;&amp; (c) &lt;= 0x7f)
+ #define iskana(c) ((c) &gt;= 0xa0 &amp;&amp; (c) &lt;= 0xdf)
+ 
+ extern int output_kanji_code;
+ 
+ void SetKanjiOutput(void);
+ void conv2euc(char *);
+ int kanji_puts(char*);
+ #undef PUTS(a)
+ #define PUTS(a) kanji_puts(a)
+ /* PUTC will be ok w/o conversion */
+ 
+ void etoj(unsigned char*,const unsigned char*); /*  EUC -&gt;  JIS */
+ void etos(unsigned char*,const unsigned char*); /*  EUC -&gt; SJIS */
+ void jtoe(unsigned char*,const unsigned char*); /*  JIS -&gt;  EUC */
+ void jtos(unsigned char*,const unsigned char*); /*  JIS -&gt; SJIS */
+ void stoe(unsigned char*,const unsigned char*); /* SJIS -&gt;  EUC */
+ void stoj(unsigned char*,const unsigned char*); /* SJIS -&gt;  JIS */
+ 
+ extern FUNC function_table[4][4];
+ 
diff -c -r -N php-2.0b7/src/php.h.org2 kanji-php/src/php.h.org2
*** php-2.0b7/src/php.h.org2	Thu Jan  1 09:00:00 1970
--- kanji-php/src/php.h.org2	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,969 ----
+ /***[php.h]*******************************************************[TAB=4]****\
+ *                                                                            *
+ * PHP/FI                                                                     *
+ *                                                                            *
+ * Copyright 1995,1996 Rasmus Lerdorf                                         *
+ *                                                                            *
+ *  This program is free software; you can redistribute it and/or modify      *
+ *  it under the terms of the GNU General Public License as published by      *
+ *  the Free Software Foundation; either version 2 of the License, or         *
+ *  (at your option) any later version.                                       *
+ *                                                                            *
+ *  This program is distributed in the hope that it will be useful,           *
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
+ *  GNU General Public License for more details.                              *
+ *                                                                            *
+ *  You should have received a copy of the GNU General Public License         *
+ *  along with this program; if not, write to the Free Software               *
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
+ *                                                                            *
+ \****************************************************************************/
+ /* $Id: php.h,v 1.105 1996/09/22 23:30:05 rasmus Exp $ */
+ #include &lt;stdio.h&gt;
+ #include &lt;time.h&gt;
+ #include &lt;sys/types.h&gt;
+ #include &lt;sys/stat.h&gt;
+ #include "../config.h"
+ #if HAVE_FCNTL_H
+ #include &lt;fcntl.h&gt;
+ #endif
+ #if HAVE_MEMORY_H
+ #include &lt;memory.h&gt;
+ #endif
+ #if HAVE_REGCOMP
+ #include &lt;regex.h&gt;
+ #else
+ #include "regex.h"
+ #endif
+ #if APACHE
+ #include "httpd.h"
+ #include "mod_php.h"
+ 
+ extern request_rec *php_rqst;
+ #endif
+ 
+ /* 
+  * This should be set to the same as the UserDir httpd setting from
+  * srm.conf on your system for proper ~username expansion 
+  */
+ #define PHP_PUB_DIRNAME	"public_html"
+ /*
+  * You can override this setting with the PHP_USERDIR env. var if you
+  * change your config.
+  *
+  */
+ #define PHP_PUB_DIRNAME_ENV	"PHP_USERDIR"
+ 
+ /* 
+  * Only define the following if you wish the ROOT_DIR for PHP loaded
+  * scripts to be different from the server's default ROOT_DIR.  
+  * Only really useful in non server-wide setups to help shorten the
+  * URL's from something like:
+  *
+  *   <A HREF="http://www.io.org/~rasmus/php.cgi/~rasmus/file.html">http://www.io.org/~rasmus/php.cgi/~rasmus/file.html</A>
+  *
+  * to:
+  *
+  *   <A HREF="http://www.io.org/~rasmus/php.cgi/file.html">http://www.io.org/~rasmus/php.cgi/file.html</A>
+  */ 
+ /* #define PHP_ROOT_DIR "/home/rasmus/public_html" */
+ 
+ /*
+  * If you are compiling PHP in DEBUG mode, make sure the following
+  * points to a valid path and that PHP is allowed to create/write to
+  * this file.
+  */
+ #define DEBUG_FILE	"/tmp/php.err"
+ 
+ /*
+  * If you are using a virtual domain on a braindead http server which
+  * sets the SCRIPT_NAME environment variable to the absolute path as
+  * opposed to the relative path to your virtual domain, then you need
+  * to define the following to be the relative path to your php.cgi
+  * program.  (include php.cgi in the path please)
+  */
+ /* #define VIRTUAL_PATH	"/cgi/php.cgi" */
+ 
+ /*
+  * If MAGIC_QUOTES is defined, then the single quote " ' " character
+  * will be automatically escaped if it is found in a posted form variable.
+  * This is useful when mSQL or Postgres95 support is enabled since the 
+  * single quote has to be escaped when it is part of an mSQL  or Postgres95
+  * query.  
+  */
+ #define MAGIC_QUOTES 1
+ 
+ /*
+  * If UPLOAD_TMPDIR is defined, then this directory will be used for storing
+  * uploaded files temporarily.  If undefined, the system's default temporary
+  * directory will be used.  You can check which directory is the default
+  * temporary directory by searching through your /usr/include directory and
+  * looking for the P_tmpdir variable.
+  *
+  * NOTE: For Apache module, set this via phpUploadTmpDir configuration
+  *       directive.
+  */
+ /* #define UPLOAD_TMPDIR "/tmp" */
+ 
+ /*
+  * If no matter what you do, you cannot get it to accept your ?config
+  * password, define the following variable.  Delete any files in your
+  * configuration directory, recompile PHP and try using the password: php
+  */
+ /* #define BROKEN_CONFIG_PW 1 */
+ 
+ /*
+  * SETLOCALE Support can be enabled by setting this to 1.  You will probably
+  * want to do this if you are designing non-English pages.  When SETLOCALE is
+  * enabled, PHP/FI will check your environment variables for the correct
+  * locale settings.  See your system man page for setlocale() for more details.
+  */
+ /* #define SETLOCALE 1 */
+ 
+ /*
+  * MSQLLOGDB should be set to the database name you wish to use to store
+  * log data if you are using PHP/FI with mSQL-based logging.  Remember
+  * to create this database before trying to run PHP/FI in mSQL logging mode.
+  *
+  * NOTE: For Apache module, set this via phpMsqlLogDB configuration directive
+  */
+ #define MSQLLOGDB "phpfi"
+ 
+ /*
+  * MSQLLOGTMP is set to the directory where you want temporary lock
+  * files created when MSQL LOGGING is used.  Since mSQL does not support
+  * atomic updates of counters, an external lock file unfortunately needs
+  * to be used.  With mSQL-2, these lock files can be eliminated, but at
+  * the time of this writing, mSQL-2 is not available as of yet.
+  */
+ #define MSQLLOGTMP "/tmp"
+ 
+ /*
+  * PATTERN_RESTRICT can be enabled for security reasons to restrict php/fi
+  * to only load files with certain patterns in their filenames.  If unset,
+  * php/fi will by default be allowed to open all files regardless of the
+  * presence of any .htaccess or other external security mechanisms
+  * NOTE: the pattern must be a valid regular expression.  The example,
+  * ".*\\.phtml$" causes php/fi to only be allowed to load files ending with
+  * the .phtml extension.
+  */
+ /* #define PATTERN_RESTRICT ".*\\.phtml$" */
+ 
+ /*
+  * Max size of a single line of input in the HTML files
+  */
+ #define LINEBUFSIZE	4096
+ 
+ /*
+  * ECHO_BUF sets the size of the echo overflow buffer
+  * (only used in Apache module version)
+  */
+ #define ECHO_BUF 64
+ 
+ /*
+  * DEFAULT_MAX_DATA_SPACE
+  *
+  * Set this to the maximum size a memory sub-pool is allowed to grow
+  * to.  (number of kilo bytes)
+  */
+ #define DEFAULT_MAX_DATA_SPACE 8192
+ 
+ /*
+  * PHP_TRACK_VARS
+  *
+  * If you define this, 3 arrays will be created in your scripts.  They are:
+  * 
+  *  $PHP_GETVARS
+  *  $PHP_POSTVARS
+  *  $PHP_COOKIEVARS
+  *
+  * These arrays will contain the GET/POST/Cookie variables respectively.
+  */
+ /* #define PHP_TRACK_VARS 1 */
+ 
+ /*
+  * PHP_AUTH_VARS
+  *
+  * If this is defined, the the Apache module version will be allowed to
+  * set the PHP_AUTH_USER, PHP_AUTH_PW and PHP_AUTH_TYPE variables.  
+  * This is a potential security concern.  See the HTTP Authentication
+  * section in the documentation for more details.
+  */
+ #define PHP_AUTH_VARS 1
+ 
+ /*-- Do not touch anything after this point unless you are very brave --*/
+ 
+ #define PHP_VERSION "2.0b7"
+ 
+ #define VAR_INIT_CHAR	'$'
+ 
+ #if APACHE
+ #if APACHE_NEWAPI
+ #define PUTS(a) rputs((a),php_rqst)
+ #define PUTC(a) rputc((a),php_rqst)
+ #else
+ #define PUTS(a) rprintf(php_rqst,"%s",(a))
+ #define PUTC(a) rprintf(php_rqst,"%c",(a))
+ #endif
+ #else
+ #define PUTS(a) fputs((a),stdout)
+ #define PUTC(a) fputc((a),stdout)
+ #endif
+ 
+ #if HAVE_FLOCK
+ #ifndef LOCK_SH
+ #define LOCK_SH 1
+ #endif
+ #ifndef LOCK_EX
+ #define LOCK_EX 2
+ #endif
+ #ifndef LOCK_NB
+ #define LOCK_NB 4
+ #endif
+ #ifndef LOCK_UN
+ #define LOCK_UN 8
+ #endif
+ #endif
+ 
+ #if DEBUG
+ #define emalloc(a,b)		php_pool_alloc(__FILE__,__LINE__,(a),(b))
+ #define estrdup(a,b)		php_pool_strdup(__FILE__,__LINE__,(a),(b))
+ #else
+ #define emalloc(a,b)		php_pool_alloc((a),(b))
+ #define estrdup(a,b)		php_pool_strdup((a),(b))
+ #endif
+ 
+ #if STDC_HEADERS
+ #include &lt;string.h&gt;
+ #else
+ #ifndef HAVE_MEMCPY
+ #define memcpy(d, s, n)		bcopy((s), (d), (n))
+ #endif
+ #endif
+ 
+ #define MAX_CMD_LEN 21
+ 
+ #define YYSTYPE long
+ 
+ #if GDBM
+ #define DBM_TYPE GDBM_FILE;
+ #else
+ #if NDBM
+ #define DBM_TYPE DBM*;
+ #else
+ #define DBM_TYPE FILE*;
+ typedef struct {
+ 	char *dptr;
+ 	int   dsize;
+ } datum;
+ #endif
+ #endif
+ 
+ /* Variable Tree */
+ typedef struct VarTree {
+ 	short type;
+ 	int count;
+ 	char *name;
+ 	char *strval;
+ 	char *iname;
+ 	long intval;
+ 	double douval;
+ 	int flag;
+ 	int scope;				/* 0=local to frame, 4=global, 8=static to frame */
+ 	struct VarTree *left;
+ 	struct VarTree *right;
+ 	struct VarTree *next;
+ 	struct VarTree *prev;
+ 	struct VarTree *lacc;
+ 	struct VarTree *lastnode;
+ 	int deleted;
+ 	int allocated;
+ } VarTree;
+ 
+ /* Expression Stack */
+ typedef struct Stack {
+ 	short type;
+ 	char *strval;
+ 	long intval;
+ 	double douval;
+ 	VarTree *var;	
+ 	struct Stack *next;
+ 	int flag;
+ } Stack;
+ 
+ /* Conditional State Stack */
+ typedef struct CondStack {
+ 	int state;
+ 	int active;
+ 	struct CondStack *next;
+ } CondStack;
+ 
+ /* Entry point marker stack */
+ typedef struct CondMark {
+ 	struct CondStack *mark;
+ 	struct CondMark *next;
+ } CondMark;
+ 
+ /* Switch state stack */
+ typedef struct SwitchStack {
+ 	int type;
+ 	int matched;
+ 	long intval;
+ 	double douval;
+ 	char *strval;
+ 	struct SwitchStack *next;
+ } SwitchStack;
+ 
+ /* Entry point marker stack */
+ typedef struct SwitchMark {
+ 	struct SwitchStack *mark;
+ 	struct SwitchMark *next;
+ } SwitchMark;
+ 
+ /* Match Stack */
+ typedef struct MatchStack {
+ 	int val;
+ 	struct MatchStack *next;
+ } MatchStack;
+ 
+ /* Entry point marker stack */
+ typedef struct MatchMark {
+ 	struct MatchStack *mark;
+ 	struct MatchMark *next;
+ } MatchMark;
+ 
+ /* While loop stack */
+ typedef struct WhileStack {
+ 	long seekpos;
+ 	int offset;
+ 	int state;
+ 	int lineno;
+ 	struct WhileStack *next;
+ } WhileStack;
+ 
+ /* Entry point marker stack */
+ typedef struct WhileMark {
+ 	struct WhileStack *mark;
+ 	struct WhileMark *next;
+ } WhileMark;
+ 
+ typedef struct EndBraceStack {
+ 	int token;
+ 	struct EndBraceStack *next;
+ } EndBraceStack;
+ 
+ typedef struct EndBraceMark {
+ 	struct EndBraceStack *mark;
+ 	struct EndBraceMark *next;
+ } EndBraceMark;
+ 
+ typedef struct dbmStack {
+ 	char *filename;
+ 	char *lockfn;
+ 	int lockfd;
+ 	void *dbf;
+ 	struct dbmStack *next;
+ } dbmStack;
+ 
+ typedef struct FileStack {
+ #if PHP_HAVE_MMAP
+ 	caddr_t pa;
+ #else
+ 	FILE *fp;
+ 	char *pa;
+ #endif
+ 	int fd;
+ 	long size;
+ 	long pos;
+ 	int state;
+ 	int lstate;
+ 	int lineno;
+ 	char *filename;
+ 	struct FileStack *next;
+ } FileStack;
+ 
+ typedef struct FrameStack {
+ 	VarTree *frame;
+ 	struct FrameStack *next;
+ } FrameStack;
+ 
+ typedef struct FuncArgList {
+ 	char *arg;
+ 	struct FuncArgList *next;
+ 	struct FuncArgList *prev;
+ } FuncArgList;
+ 
+ typedef struct FuncStack {
+ 	char *name;
+ 	long size;
+ 	char *buf;
+ 	VarTree *frame;
+ 	FuncArgList *params;	
+ 	struct FuncStack *next;
+ } FuncStack;
+ 
+ typedef struct CounterStack {
+ 	int inif;
+ 	int inwhile;
+ 	struct CounterStack *next;
+ } CounterStack;
+ 
+ typedef struct FpStack {
+ 	FILE *fp;
+ 	char *filename;
+ 	int id;
+ 	int type;
+ 	struct FpStack *next;
+ } FpStack;
+ 
+ typedef struct AccessInfo {
+ 	int def;
+ 	int mode;
+ 	char *password;
+ 	int type;
+ 	char *patt;
+ 	struct AccessInfo *next;
+ } AccessInfo;
+ 
+ typedef struct PtrStack {
+ 	void *ptr;
+ 	struct PtrStack *next;
+ } PtrStack;
+ 
+ typedef struct CookieList {
+ 	char *name;
+ 	char *value;
+ 	time_t expires;
+ 	char *path;
+ 	char *domain;
+ 	int secure;		
+ 	struct CookieList *next;
+ } CookieList;
+ 
+ #ifndef APACHE
+ typedef struct pool {
+   union php_block_hdr *first;
+   union php_block_hdr *last;
+   struct cleanup *cleanups;
+   struct process_chain *subprocesses;
+   struct pool *sub_pools;
+   struct pool *sub_next;
+   struct pool *sub_prev;
+   struct pool *parent;
+   char *free_first_avail;
+ } pool;
+ #endif
+ /* Prototypes */
+ 
+ /* error.c */
+ void Debug(char *, ...);
+ void Error(char *, ...);
+ void CloseDebug(void);
+ int  ErrorPrintState(int);
+ void SetErrorReporting(void);
+ void php_init_error(void);
+ 
+ /* lex.c */
+ void ParserInit(int, long, int, char *);
+ int yylex(YYSTYPE *);
+ void yyerror(char *);
+ void WhileAgain(long, int, int);
+ void Include(void);
+ void Exit(int);
+ char *GetCurrentLexLine(int *, int *);
+ void InitFunc(void);
+ void DefineFunc(char *);
+ FuncStack *FindFunc(char *, long *, VarTree **);
+ void RunFunc(char *);
+ VarTree *GetFuncFrame(void);
+ void AddToArgList(char *);
+ FuncArgList *GetFuncArgList(void);
+ void ClearFuncArgList(void);
+ void Return(void);
+ void php_init_lex(void);
+ void IntFunc(char *);
+ int NewWhileIteration(long);
+ void Eval(void);
+ void set_text_magic(int);
+ void PushCounters(void);
+ void PopCounters(void);
+ void SetHeaderCalled(void);
+ long GetSeekPos(void);
+ 
+ /* date.c */
+ void Date(int, int);
+ void UnixTime(void);
+ void MkTime(int);
+ char *std_date(time_t);
+ 
+ /* parse.c */
+ int yyparse(void);
+ void php_init_yacc(void);
+ 
+ /* calc.c */
+ int Calc(int);
+ int CalcInc(int);
+ void Neg(void);
+ void BinDec(void);
+ void DecBin(void);
+ void DecHex(void);
+ long _HexDec(char *);
+ void HexDec(void);
+ long _OctDec(char *);
+ void OctDec(void);
+ void DecOct(void);
+ void Sin(void);
+ void Cos(void);
+ void Tan(void);
+ void Sqrt(void);
+ void Exp(void);
+ void mathLog(void);
+ void mathLog10(void);
+ void Abs(void);
+ void Pow(void);
+ 
+ /* stack.c */
+ void Push(char *, int);
+ Stack *Pop(void);
+ void ClearStack(void);
+ void php_init_stack(void);
+ 
+ /* var.c */
+ void php_init_symbol_tree(void);
+ void SetVar(char *, int, int);
+ VarTree *GetVar(char *, char *, int);
+ void IsSet(char *);
+ char *SubVar(char *);
+ void Count(void);
+ void ArrayMax(void);
+ void ArrayMin(void);
+ void PutEnv(void);
+ void GetEnv(void);
+ void PtrPush(void *);
+ void *PtrPop(void);
+ void SecureVar(void);
+ void Reset(char *);
+ void Key(char *);
+ void Next(char *);
+ void Prev(char *);
+ void End(char *);
+ void PushStackFrame(void);
+ void PopStackFrame(void);
+ void Global(void);
+ void copyarray(VarTree *, VarTree *);
+ void deletearray(VarTree *);
+ void UnSet(char *);
+ 
+ /* echo.c */
+ void Echo(char *, int);
+ void StripSlashes(char *);
+ void StripDollarSlashes(char *);
+ char *AddSlashes(char *, int);
+ void ParseEscapes(char *);
+ void HtmlSpecialChars(void);
+ int FormatCheck(char **, char **, char **);
+ void _AddSlashes(void);
+ void _StripSlashes(void);
+ 
+ /* cond.c */
+ int Compare(int);
+ void If(void);
+ void Else(void);
+ void ElseIf(void);
+ void EndIf(void);
+ void Not(void);
+ int Logic(int);
+ int GetCurrentState(int *);
+ int GetCurrentActive(void);
+ void ClearCondStack(void);
+ void CondPush(int, int);
+ void CondChange(int, int);
+ int CondPop(int *);
+ int CondPeek(int *);
+ int CheckCond(Stack *);
+ void PushCondMatchMarks(void);
+ void PopCondMatchMarks(void);
+ void php_init_cond(void);
+ void BracePush(int);
+ int BracePop(void);
+ int BraceCheck(void);
+ 
+ /* switch.c */
+ void Switch(void);
+ void EndSwitch(void);
+ void Case(void);
+ void Break(void);
+ void Default(void);
+ void PushSwitchMark(void);
+ void PopSwitchMark(void);
+ void php_init_switch(void);
+ 
+ /* alloc.c */
+ void *Emalloc(char *, int, int);
+ void Efree(char *, int, void *);
+ char *Estrdup(char *, int, char *);
+ 
+ /* db.c */
+ void ListSupportedDBs(void);
+ void dbmOpen(void);
+ int _dbmOpen(char *, char *);
+ void dbmClose(void);
+ int _dbmClose(char *);
+ void dbmCloseAll(void);
+ void dbmInsert(void);
+ int _dbmInsert(char *, char *, char *);
+ void dbmReplace(void);
+ int _dbmReplace(char *, char *, char *);
+ void dbmFetch(void);
+ char *_dbmFetch(char *, char *);
+ void dbmExists(void);
+ int _dbmExists(char *, char *);
+ void dbmDelete(void);
+ int _dbmDelete(char *, char *);
+ void dbmFirstKey(void);
+ char *_dbmFirstKey(char *);
+ void dbmNextKey(void);
+ char *_dbmNextKey(char *, char *);
+ void php_init_db(void);
+ 
+ /* while.c */
+ void WhilePush(long, int, int);
+ WhileStack *WhilePop(void);
+ void While(long);
+ void EndWhile(void);
+ void PushWhileMark(void);
+ void PopWhileMark(void);
+ void php_init_while(void);
+ void WhileFinish(void);
+ 
+ /* string.c */
+ void StrLen(void);
+ void StrVal(void);
+ void IntVal(void);
+ void DoubleVal(void);
+ void StrTok(int);
+ char *_strtoupper(char *);
+ void StrToUpper(void);
+ char *_strtolower(char *);
+ void StrToLower(void);
+ void StrStr(void);
+ void StrrChr(void);
+ void SetType(void);
+ void GetType(void);
+ void SubStr(void);
+ void UrlEncode(void);
+ void UrlDecode(void);
+ char *php_urlencode(char *);
+ void Ord(void);
+ void QuoteMeta(void);
+ void UcFirst(void);
+ void Sprintf(void);
+ void Chr(void);
+ 
+ /* msql.c */
+ void Msql(void);
+ void MsqlResult(void);
+ void MsqlClose(void);
+ void MsqlConnect(void);
+ void MsqlFreeResult(void);
+ void MsqlNumRows(void);
+ void MsqlNumFields(void);
+ void MsqlField(int);
+ void MsqlRegCase(void);
+ int  msqlGetDbSock(void);
+ void msqlSetCurrent(int, char *);
+ void MsqlListTables(void);
+ void MsqlListFields(void);
+ void MsqlTableName(void);
+ void MsqlListDBs(void);
+ void MsqlDBName(void);
+ void MsqlDropDB(void);
+ void MsqlCreateDB(void);
+ void php_init_msql(void);
+ 
+ /* pg95.c */
+ void PGcloseAll(void);
+ void PGexec(void);
+ void PG_result(void);
+ void PGconnect(void);
+ void PGclose(void);
+ void PGnumRows(void);
+ void PGnumFields(void);
+ void PGfieldName(void);
+ void PgfieldNum(void);
+ void PGfieldType(void);
+ void PGfieldLen(void);
+ void PGhost(void);
+ void PGdbName(void);
+ void PGoptions(void);
+ void PGport(void);
+ void PGtty(void);
+ void PGfreeResult(void);
+ void PGfieldNum(void);
+ void PGfieldPrtLen(void);
+ void PGfieldSize(void);
+ void PGgetlastoid(void);
+ void PGerrorMessage(void);
+ void php_init_pg95(void);
+ 
+ /* reg.c */
+ void RegMatch(char *, int);
+ void RegReplace(void);
+ char *_RegReplace(char *, char *, char *);
+ void EReg(char *, int);
+ void ERegReplace(void);
+ void ERegiReplace(void);
+ char *_ERegReplace(char *, char *, char *, int);
+ char *reg_eprint(int);
+ 
+ /* exec.c */
+ void Exec(char *, char *, int);
+ void EscapeShellCmd(void);
+ 
+ /* file.c */
+ int OpenFile(char *, int, long *);
+ char *GetCurrentFilename(void);
+ void SetCurrentFilename(char *);
+ long GetCurrentFileSize(void);
+ void SetCurrentFileSize(long);
+ char *FixFilename(char *, int, int *);
+ char *getfilename(char *, int);
+ void FileFunc(int);
+ void TempNam(void);
+ void Link(void);
+ void SymLink(void);
+ void ReadLink(void);
+ void LinkInfo(void);
+ void Unlink(void);
+ void Rename(void);
+ void Sleep(void);
+ void USleep(void);
+ void Fopen(void);
+ void Fclose(void);
+ void Fputs(void);
+ void Fgets(void);
+ void Fgetss(void);
+ void Rewind(void);
+ void Fseek(void);
+ void Ftell(void);
+ char *GetCurrentPI(void);
+ void SetCurrentPI(char *);
+ void SetCurrentPD(char *);
+ void ChMod(void);
+ void ChOwn(void);
+ void ChGrp(void);
+ void MkDir(void);
+ void RmDir(void);
+ int  FpPush(FILE *, char *, int);
+ void File(void);
+ void php_init_file(void);
+ void set_path_dir(char *);
+ void Popen(void);
+ void Pclose(void);
+ void Feof(void);
+ void FpCloseAll(void);
+ #if APACHE
+ void Virtual(void);
+ #endif
+ 
+ /* crypt.c */
+ void Crypt(int);
+ 
+ /* head.c */
+ void Header(void);
+ void php_header(int, char *);
+ void php_init_head(void);
+ void SetCookie(int);
+ void PushCookieList(char *, char *, time_t, char *, char *, int);
+ CookieList *PopCookieList(void);
+ 
+ /* info.c */
+ void Info(void);
+ void ShowPageInfo(void);
+ void PHPVersion(void);
+ 
+ /* post.c */
+ void TreatData(int);
+ void parse_url(char *);
+ void TreatHeaders(void);
+ 
+ /* type.c */
+ int CheckType(char *);
+ int CheckIdentType(char *);
+ char *GetIdentIndex(char *);
+ 
+ /* conf.c */
+ #if APACHE
+ void Configuration(void);
+ #else
+ void Configuration(int, char **);
+ #endif
+ 
+ /* acc.c */
+ AccessInfo *StrtoAccess(char *);
+ void PostToAccessStr(char *);
+ void AddRule(char *);
+ void AddFile(char *, char *);
+ void ChkPostVars(char *);
+ int CheckAccess(char *, long);
+ void ShowBanPage(char *);
+ void ShowEmailPage(char *);
+ void ShowPasswordPage(char *);
+ char *getremotehostname(void);
+ char *getemailaddr(void);
+ char *getrefdoc(void);
+ char *getbrowser(void);
+ int getlogging(void);
+ void setlogging(int);
+ void SetLogging(void);
+ int getshowinfo(void);
+ void setshowinfo(int);
+ void SetShowInfo(void);
+ void GetAccDir(void);
+ char *getaccdir(void);
+ #if APACHE
+ void php_init_acc(php_module_conf *);
+ #else
+ void php_init_acc(void);
+ #endif
+ 
+ /* dns.c */
+ void GetHostByAddr(void);
+ const char *_GetHostByAddr(char *);
+ void GetHostByName(void);
+ char *_GetHostByName(char *);
+ 
+ /* log.c */
+ void Log(char *);
+ char *getlastemailaddr(void);
+ char *getlasthost(void);
+ char *getlastbrowser(void);
+ char *getlastref(void);
+ char *getlogfile(void);
+ time_t getlastaccess(void);
+ time_t getstartlogging(void);
+ time_t getlastmod(void);
+ int gettotal(void);
+ int gettoday(void);
+ void loadlastinfo(char *, char *);
+ void GetLastEmail(void);
+ void GetLastBrowser(void);
+ void GetLastHost(void);
+ void GetLastAccess(void);
+ void GetStartLogging(void);
+ void GetLastRef(void);
+ void GetLogFile(void);
+ void GetLastMod(void);
+ void GetTotal(void);
+ void GetToday(void);
+ void GetLogDir(void);
+ char *getlogdir(void);
+ void GetMyUid(void);
+ void GetMyInode(void);
+ void SetStatInfo(struct stat *);
+ void GetMyPid(void);
+ long getmyuid(void);
+ void MsqlLog(char *);
+ void msqlloadlastinfo(char *);
+ #if APACHE
+ void php_init_log(php_module_conf *);
+ #else
+ void php_init_log(void);
+ #endif
+ 
+ /* sort.c */
+ void Sort(void);
+ 
+ /* dir.c */
+ void OpenDir(void);
+ void CloseDir(void);
+ void RewindDir(void);
+ void ReadDir(void);
+ void ChDir(void);
+ void php_init_dir(void);
+ 
+ /* rand.c */
+ void Srand(void);
+ void Rand(void);
+ void GetRandMax(void);
+ 
+ /* gd.c */
+ void ImageCreate(void);
+ void ImageCreateFromGif(void);
+ void ImageDestroy(void);
+ void ImageGif(int);
+ void ImageSetPixel(void);
+ void ImageLine(void);
+ void ImageRectangle(void);
+ void ImageFilledRectangle(void);
+ void ImageArc(void);
+ void ImageFillToBorder(void);
+ void ImageFill(void);
+ void ImageColorAllocate(void);
+ void ImageColorTransparent(void);
+ void ImageInterlace(void);
+ void ImagePolygon(int);
+ void ImageChar(int);
+ void ImageCopyResized(void);
+ void php_init_gd(void);
+ void ImageSXFN(void);
+ void ImageSYFN(void);
+ 
+ /* mime.c */
+ void mime_split(char *, int, char *);
+ #if APACHE
+ void php_init_mime(php_module_conf *);
+ #endif
+ 
+ /* fsock.c */
+ void FSockOpen(void);
+ 
+ /* microtime.c */
+ void MicroTime(void);
+ 
+ /* pool.c */
+ void *php_pool_alloc(
+ #if DEBUG
+ char *, int,
+ #endif
+ int,int);
+ char *php_pool_strdup(
+ #if DEBUG
+ char *, int,
+ #endif
+ int,char *);
+ #ifndef APACHE
+ void php_pool_free(int);
+ #endif
+ void php_pool_clear(int);
+ #if DEBUG
+ void php_pool_show(void);
+ #endif
+ #if APACHE
+ void php_init_pool(php_module_conf *);
+ #else
+ void php_init_pool(void);
+ void *php_palloc(struct pool *, int nbytes);
+ void *php_pcalloc(struct pool *, int nbytes);
+ char *php_pstrdup(struct pool *, const char *s);
+ struct pool *php_make_sub_pool(struct pool *);
+ void php_clear_pool(struct pool *);
+ void php_destroy_pool(struct pool *);
+ #endif
+ 
+ /* local.c */
+ #ifndef HAVE_STRCASECMP
+ int strcasecmp(char *, char *);
+ int strncasecmp(char *, char *, int);
+ #endif
+ #ifndef HAVE_STRDUP
+ char *strdup(char *);
+ #endif
+ #ifndef HAVE_STRERROR
+ char *strerror(int);
+ #endif
+ 
+ /* kanjiconv.c */
+ void KanjiConv(void);
+ 
diff -c -r -N php-2.0b7/src/post.c kanji-php/src/post.c
*** php-2.0b7/src/post.c	Mon Sep 23 07:11:52 1996
--- kanji-php/src/post.c	Mon Dec  9 02:21:01 1996
***************
*** 259,264 ****
--- 259,265 ----
  			}
  			parse_url(s);
  			dot_to_underscore(s);
+ 			conv2euc(s);
  			itype = CheckIdentType(s);
  			if(itype==2) {
  				ind=GetIdentIndex(s);
diff -c -r -N php-2.0b7/src/stoe.c kanji-php/src/stoe.c
*** php-2.0b7/src/stoe.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/stoe.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,80 ----
+ /*
+  *	Sift_JIS ----&gt; EUC  Convert Routine
+  */
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ 
+ #include &lt;string.h&gt;
+ 
+ #define	SS2		0x8e	/* Hankaku Kana */
+ 
+ static
+ sj_to_euc(sj1,sj2,euc1,euc2)
+      register unsigned char sj1,sj2,*euc1,*euc2;
+ {
+   if (sj1 &gt;= 0xe0) /* The 2nd standard of JIS */
+     sj1 -=  0x40;
+   
+   if (sj2 &gt;= 0x9f) {
+     *euc1 = (sj1 - 0x88)*2 + 0xb0;
+     *euc2 = sj2 + 0x02;
+   }
+   else {
+     if (sj2 &gt;= 0x7f)
+       sj2 -= 0x01;
+     *euc1 = (sj1 - 0x89)*2 + 0xb1;
+     *euc2 = sj2 + 0x61;
+   }
+ }
+ 
+ void
+ stoe(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c,c1;
+   unsigned char s1,s2;
+   
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if((c&gt;=0x81 &amp;&amp; c&lt;=0x9f) || (c&gt;=0xe0 &amp;&amp; c&lt;=0xfc)) {
+ 	c1 = c; /* ZENKAKU */
+ 	stat = 1;
+       }
+       else if((0xa1 &lt;= c) &amp;&amp; (c &lt;= 0xdf)){ /* Hankaku Kana */
+ 	dest[pos++]=SS2;
+ 	dest[pos++]=c;
+       }
+       else /* ASCII */
+ 	dest[pos++]=c;
+       break;
+     case 1:
+       stat = 0;
+       sj_to_euc(c1,c,&amp;s1,&amp;s2); /* Change Shift_JIS into EUC */
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ 
+ }
+ 
diff -c -r -N php-2.0b7/src/stoj.c kanji-php/src/stoj.c
*** php-2.0b7/src/stoj.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/stoj.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,127 ----
+ /*								*/
+ /*	stoj.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	stoj	SJIS code convert into JIS code.		*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$B	^[(B	JIS 83				*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC '\033'
+ #define KI1 '$'
+ #define KI2 'B'
+ #define KO1 '('
+ #define KO2 'B'
+ #define	KANAIN	0x0e
+ #define	KANAOUT	0x0f
+ 
+ static void
+ SJIS_JIS(sjis1,sjis2,jis1,jis2)
+      register unsigned char sjis1,sjis2,*jis1,*jis2;
+ {
+   if (sjis1 &gt;= 0xe0)	/* The 2nd standard of JIS */
+     sjis1 -=  0x40;
+ 	
+   if (sjis2 &gt;= 0x9f) {
+     *jis1 = (sjis1 - 0x88)*2 + 0x30;
+     *jis2 = sjis2 - 0x7e;
+   }
+   else {
+     if (sjis2 &gt;= 0x7f)
+       sjis2 -= 0x01;
+     *jis1 = (sjis1 - 0x89)*2 + 0x31;
+     *jis2 = sjis2 - 0x1f;
+   }
+ }
+ 
+ void
+ stoj(char *dest, const char *src)
+ {
+   register int stat;
+   register unsigned char c,c1,c2;
+   unsigned char s1,s2;
+ 
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if((c&gt;=0x81 &amp;&amp; c&lt;=0x9f) || (c&gt;=0xe0 &amp;&amp; c&lt;=0xfc)) {
+ 	c1 = c;	           
+ 	stat = 1;
+ 	dest[pos++]=ESC; /* put KANJI-IN */
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=KI2;
+       }
+       else if((0xa1 &lt;= c) &amp;&amp; (c &lt;= 0xdf)) { /* hankaku kana */
+ 	dest[pos++]=KANAIN;
+ 	c &amp;= 0x7f;
+ 	dest[pos++]=c;
+ 	stat = 3;
+       }
+       else
+ 	dest[pos++]=c; /* put ASCII code */
+       break;
+     case 1:
+       stat = 2;
+       c2 = c;
+       SJIS_JIS(c1,c2,&amp;s1,&amp;s2);  /* change shift-JIS into JIS */
+       dest[pos++]=s1; /* put KANJI code */
+       dest[pos++]=s2;
+       break;
+     case 2:
+       if((c&gt;=0x81 &amp;&amp; c&lt;=0x9f) || (c&gt;=0xe0 &amp;&amp; c&lt;=0xfc)) {
+ 	c1 = c;	           
+ 	stat = 1;
+       } else {
+ 	dest[pos++]=ESC; /* put KANJI-OUT */
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=KO2;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     case 3:				 /* hankaku kana */
+       if((0xa1 &lt;= c) &amp;&amp; (c &lt;= 0xdf)) {
+ 	c &amp;= 0x7f;
+ 	dest[pos++]=c;
+       }
+       else {
+ 	dest[pos++]=KANAOUT;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     }
+   }
+   if ( stat == 1 || stat == 2 ) {
+     /* put KANJI-OUT */
+     dest[pos++]=ESC;
+     dest[pos++]=KO1;
+     dest[pos++]=KO2;
+   }
+   else if (stat == 3)
+     dest[pos++]=KANAOUT;
+ 
+   /* terminate */
+   dest[pos]='\0';
+ 
+ }
+ 

======================================================================
ここまで

== おみつ
</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<UL><LI><STRONG>Follow-Ups</STRONG>:
<UL>
<LI><STRONG><A NAME="00053" HREF="msg00053.html">[postgres95 1144] Re: KANJI-CODE on Postgres95</A></STRONG>
<UL><LI><EM>From:</EM> 杉田研治&lt;sugita@sra.co.jp&gt;</LI></UL></LI>
<LI><STRONG><A NAME="00052" HREF="msg00052.html">[postgres95 1143] Re: KANJI-CODE on Postgres95</A></STRONG>
<UL><LI><EM>From:</EM> Mitsuhiro Maeda &lt;mitsu@tramp.co.jp&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-Follow-Ups-End-->
<!--X-References-->
<UL><LI><STRONG>References</STRONG>:
<UL>
<LI><STRONG><A NAME="00035" HREF="msg00035.html">[postgres95 1126] Re: KANJI-CODE on Postgres95</A></STRONG>
<UL><LI><EM>From:</EM> Tatsuo Ishii &lt;t-ishii@sra.co.jp&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00057.html">[postgres95 1148] (No Subject in original)</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00052.html">[postgres95 1143] Re: KANJI-CODE on Postgres95</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00035.html">[postgres95 1126] Re: KANJI-CODE on Postgres95</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00052.html">[postgres95 1143] Re: KANJI-CODE on Postgres95</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00051"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00051"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>

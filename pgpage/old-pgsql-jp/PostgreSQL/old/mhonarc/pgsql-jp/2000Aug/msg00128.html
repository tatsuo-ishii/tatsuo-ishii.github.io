<!-- MHonArc v2.1.0 -->
<!--X-Subject: [pgsql&#45;jp 16514] Re: man Pgの邦訳&#45;FUNCTIONSのConnections -->
<!--X-From: Mika Ohtsuki <mika@rc.kyushu&#45;u.ac.jp> -->
<!--X-Date: Mon, 07 Aug 2000 12:03:49 +0900 -->
<!--X-Message-Id: 20000807120349F.mika@rc.kyushu&#45;u.ac.jp -->
<!--X-ContentType: text/plain -->
<!--X-Reference-Id: 001301bffecd$06f47ca0$0a01a8c0@gk.net -->
<!--X-Head-End-->
<HTML>
<HEAD>
<TITLE>[pgsql-jp 16514] Re: man Pgの邦訳-FUNCTIONSのConnections </TITLE>
<LINK REV="made" HREF="mailto:mika@rc.kyushu-u.ac.jp">
</HEAD>
<BODY BGCOLOR="#ffffff">
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<HR>
[<A HREF="msg00127.html">Date Prev</A>][<A HREF="msg00129.html">Date Next</A>][<A HREF="msg00119.html">Thread Prev</A>][<A HREF="msg00135.html">Thread Next</A>][<A HREF="index.html#00128">Date Index</A>][<A HREF="threads.html#00128">Thread Index</A>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<H1>[pgsql-jp 16514] Re: man Pgの邦訳-FUNCTIONSのConnections</H1>
<HR>
<!--X-Subject-Header-End-->
<UL>
<LI><em>From</em>: Mika Ohtsuki &lt;<A HREF="mailto:mika@rc.kyushu-u.ac.jp">mika@rc.kyushu-u.ac.jp</A>&gt;</LI>
<LI><em>Date</em>: Mon, 07 Aug 2000 12:03:49 +0900</LI>
<LI><em>References</em>: &lt;<A HREF="msg00119.html">001301bffecd$06f47ca0$0a01a8c0@gk.net</A>&gt;</LI>
</UL>
<!--X-Head-Body-Sep-Begin-->
<HR>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<PRE>
みかまま、こと大月(み)＠福岡です。

From: かどわき しろう &lt;gate@blue.b-city.net&gt;
Subject: [pgsql-jp 16505] man Pg の邦訳 - FUNCTIONSのConnections
Date: Sat, 5 Aug 2000 20:04:21 +0900
Message-ID: &lt;<A HREF="msg00119.html">001301bffecd$06f47ca0$0a01a8c0@gk.net</A>&gt;

gate&gt; 門脇です。

お疲れ様です。眺めるのも苦労したので、翻訳におかけになった労力はさぞか
しだったろうと存じます。以下、気がついたことをずらずらと書きました。

gate&gt;  Perlの関数が対応するCの関数と異なるものが少しだけあります。
gate&gt;  PQprint、PQnotifies、PQconndefaultsです。

There are few exceptions, where the perl-functions differs
from the C-counterpart: PQprint, PQnotifies and
PQconndefaults.  

few がちょっと気になりますけど、別に間違いではないですね。
ほとんどの関数は libpq と同じという意味が含まれているのですね。

gate&gt;  これらの関数はCでは構造体を扱っていますが、Perlではリストやハッシュを
gate&gt;  使って実装されています。

These functions deal with structures,
which have been implemented in perl using lists or hash.

おそらく、そういう意味なのでしょうね。
have been は、これまでずっとそうだったという意味があるのでしょうか。

gate&gt; 関数
gate&gt;  この「関数」の章は3つのセクションに区切られています。
gate&gt;  「接続」、「結果」、「ラージオブジェクト」です。

他の部分でも result object とかで出てきますが、問い合わせの結果という
意味の「結果」なのですよね。他の部分と用語を統一する必要がありそうです
ね。

(略)

gate&gt;   適切な関数を使うことで、PGconn構造体に含まれるほぼ全てのデータ
gate&gt;   にアクセスできます。

Using appropriate methods you can access almost all fields of the
returned PGconn structure.

フィールドよりデータの方が分かりやすい？
英文には PGconn に returned 「返ってきた」もしくは「返り値の」という修
飾がかかっているようですが、良いのでしょうか。

gate&gt;    $conn = Pg::setdbLogin($pghost, $pgport, $pgoptions, $pgtty,
gate&gt;            $dbname, $login, $pwd)
$conn = Pg::setdbLogin($pghost, $pgport, $pgoptions, $pgtty, $dbname,
        $login, $pwd)

gate&gt;   バックエンドに対して新規に接続します。$conn（PGconn構造体に対
gate&gt;   するポインター）をバックエンドに対する接続のIDとして、その後の
gate&gt;   関数で使用します。

Opens a new connection to the backend. The connection identifier
$conn ( a pointer to the PGconn structure ) must be used in
subsequent commands for unique identification. 

意味的にもう少し強いような気がしますが、下のようだとかえって分かりにく
いかな。
「この後の命令(関数？)で(接続を)唯一に識別するためには、この接続ID
$conn (PGconn 構造体に対するポインター)を使用しなくてはなりません。」

いくつか並列して接続するというのはやったことはないのですが、できるので
しょうね…。今度試してみよう。

(略)

gate&gt;    $conn = Pg::connectdb("option1=value option2=value ...")
gate&gt;   文字列でパラメーターを指定してバックエンドに接続します。有効な
gate&gt;   パラメーターは host、port、options、tty、dbname、user、
gate&gt;   passwordです。

$conn = Pg::connectdb("option1=value option2=value ...")
Opens a new connection to the backend using connection information in
a string. Possible options are: host, port, options, tty, dbname,
user, password.

下の方では、パラメータをオプションと言っているのが気になります。

gate&gt;   $conn（PGconn構造体に対するポインター）
gate&gt;   をバックエンドに対する接続のIDとして、その後の関数で使用します。

The connection identifier $conn (a pointer to the
PGconn structure) must be used in subsequent commands for unique
identification. Before using $conn you should call $conn-&gt;status to
ensure, that the connection was properly made.

ここは上と同じですね。

gate&gt;    $Option_ref = Pg::conndefaults()

gate&gt;    例)
gate&gt;     $Option_ref = Pg::conndefaults();

$Option_ref = Pg::conndefaults()

while(($key, $val) = each %$Option_ref) {
  print "$key, $val\n";
}

二重になっているようです。

gate&gt;   connectdb()に渡すことのできるオプションをキーとして持つハッシュ
gate&gt;   への参照を返します。

Returns a reference to a hash containing as keys all possible options
for connectdb(). The values are the current defaults. 

上ではパラメータと書いてありましたが、どちらかに統一されるのがよろしい
かと。

gate&gt;   ハッシュの値は現在のデフォルトの値です。この関数は対応するCの
gate&gt;   関数と異なります。
gate&gt;   （Cの関数ではconninfoOption構造体を返します。）

This function
differs from his C-counterpart, which returns the complete
conninfoOption structure.

「（Cの関数ではconninfoOption構造体をまるごと返します。）」
complete の訳は何がいいでしょうね。perl の実装では結局その一部しか返さ
ないという意味でしょうか。

手元にある、libpq-fe.h (ver. 6.3.2)では、PQconninfoOption の配列を返す
ようです。PQconninfoOption 自体は確かに他にも色々属性を持つようです。

gate&gt;    PQfinish($conn)
gate&gt;   古い方の形式のみです！ バックエンドとの接続を解除し、接続を表
gate&gt; す構造体を解放します。

PQfinish($conn)

Old style only !  Closes the connection to the backend and frees the
connection data structure.

「古い方の形式でしか使いません！」ではいかがでしょうか。
なんにしろ、old style の訳語の統一の問題がありますね。

gate&gt;    $conn-&gt;reset
gate&gt;   バックエンドに接続しているポートを一度切断して、再び新規の接続
gate&gt;   を試みます。

$conn-&gt;reset

Resets the communication port with the backend and tries to establish
a new connection.

この関数、<A HREF="http://www5.big.or.jp/~aya/UNIX/Pg.html">http://www5.big.or.jp/~aya/UNIX/Pg.html</A> の方にはないのですね。

gate&gt;    $ret = $conn-&gt;requestCancel
gate&gt;   現在の処理を中断します。requestCancelの返り値に関わらず、アプ
(略)

 $ret = $conn-&gt;requestCancel
Abandon processing of the current query. Regardless  of the return

「現在のクエリー(もしくは問い合わせ)の処理」ではないでしょうか？

gate&gt;    $pguser = $conn-&gt;user
gate&gt;   接続しているのPostgreSQLユーザー名を返します。

ささいなことですが、「の」が余計。

gate&gt;    $pgpass = $conn-&gt;pass
gate&gt;   接続しているPostgreSQLパスワードを返します。

$pguser = $conn-&gt;pass
Returns the Postgres password of the connection.

いや、単に日本語として違和感があるだけですが、「接続に用いられた」か何
かの方がいいかな、と。統一感は無くなりますが。「この接続に用いられた
(or 用いられている)」に統一するとか。

gate&gt;    $pgoptions = $conn-&gt;options
gate&gt;   接続で使われているオプションを返します。

$pgoptions = $conn-&gt;options
Returns the options used in the connection.
これは、もとの英文が「used」になってるのですね。

gate&gt;    $result = $conn-&gt;exec($query)

gate&gt;   クエリー（PostgreSQLが解釈して実行できるコマンド）$query を

クエリーを説明する必要があるということでしたら、前に出てきたところで説
明するか、他の用語と合わせて、対訳一覧を先頭に置くべきかもしれません。
new style, old style, query, result あたりが分かりにくいでしょうか。

gate&gt;   バックエンドに送って実行します。返り値はPGresult構造体へのポイ
gate&gt;   ンターであり、バックエンドから返された結果を全て持っています。

Submits a query to the backend. The return value is a pointer to the
PGresult structure, which contains the complete query-result returned
by the backend. 

「クエリー(もしくは問い合わせ)の結果」の方が良くないでしょうか。
query-result というのが良くわからなかったので、libpq-fe.h を眺めてみま
した。＃はじめ、query と result の組かと思った…

/* PGresult encapsulates the result of a query */
/* unlike the old libpq, we assume that queries only return in one
group */
        typedef struct pg_result
        {
                int                     ntups;
                int                     numAttributes;
                PGresAttDesc *attDescs;
                PGresAttValue **tuples; /* each PGresTuple is an array of
                                                                 *PGresAttValue
's */
                int                     tupArrSize; /* size of tuples array allocated */
                ExecStatusType resultStatus;
                char            cmdStatus[CMDSTATUS_LEN];       /* cmd status from the
                 * last insert query */
                int                     binary;         /* binary tuple values if binary == 1,
                                                                 * otherwise ASCII */
                PGconn     *conn;
        } PGresult;

タップルだけでなく、クエリー(もしくは問い合わせ)の結果の全てなわけですね。

(略)

gate&gt;    $ret = $conn-&gt;sendQuery($string, $query)
gate&gt;   PostgreSQLバックエンドに対してクエリーを発行しますが、結果が帰っ
gate&gt;   てくるのを待ちません。

$ret = $conn-&gt;sendQuery($string, $query)
Submit a query to Postgres without waiting for the result(s). 

gate&gt;   sendQuery を実行した後に、その結果を得るには getResult 関数を1
gate&gt;   回以上呼び出します。

After successfully calling PQsendQuery, call PQgetResult one or more
times to obtain the query results. 

「そのクエリー(問い合わせ)の結果」はくどい？

gate&gt;   getResult が NULL を返すのはコマンドの実行が終了したことを表す
gate&gt;   ので、それまではさらに別の sendQuery を呼び出してはいけません。

PQsendQuery may not be called again until getResult has returned NULL,
indicating that the query is done.

query をコマンドと訳すのは抵抗があります。以下でもずっとコマンドになっ
てますけど。

gate&gt;    $result = $conn-&gt;getResult
gate&gt;   前に呼び出された sendQuery の結果が帰ってくるのを待ち、その結
gate&gt;   果を返します。

$result = $conn-&gt;getResult
Wait for the next result from a prior PQsendQuery, and return it.

gate&gt;   sendQuery によるコマンドが完了して、これ以上返す結果がないとき
gate&gt;   は NULL を返します。

NULL is returned when the query is complete and there will be no more
results.  

gate&gt;   getResultはコマンドが実行中で、consumeInput による必要なデータ
gate&gt;   読み出しが完了していない時しかアプリケーションの実行を中断しま
gate&gt;   せん。

getResult  will block only if a query is active and the
necessary response data has not yet been read by PQconsumeInput.

block は中断ではなくそこで止まったままになることですよね。
中断だと返ってしまいそうです。
「getResult は、クエリーが実行中かつPQconsumeInput (consumeInput) によ
る必要なデータ読み出しが完了していない場合にのみ、止まったままになりま
す(つまり、ブロックします)。
なんで、ここで PQconsumeImput と書かれているのかは謎ですね。元の訳のよ
うに consumeInput の方が混乱しないかと思います。

gate&gt;    $ret = $conn-&gt;isBusy
gate&gt;   コマンドが実行中の時は TRUE を返します。この時はgetResultは入
gate&gt;   力を待ってアプリケーションの実行を中断します。

$ret = $conn-&gt;isBusy
Returns TRUE if a query is busy, that is, PQgetResult would block
waiting for input.  

ここも同様に、block について。
「このとき PQgetResult (getResult) を呼ぶと、入力を待って止まったまま
になり(つまり、ブロックし)ます。」
でしょうか。

gate&gt;   FALSE が返ってき
gate&gt;   た場合はgetResult によってアプリケーションの実行を中断すること
gate&gt;   なく結果を得られることが保証されます。

A FALSE  return indicates that PQgetResult can be
called with assurance of not blocking.

これも、「FALSE が返って来た場合は、ブロックしないという保証の元に 
PQgetResult (getResult) を呼び出すことができます。」のような。

(略)

gate&gt;    $ret = $conn-&gt;getline($string,$length)
gate&gt;   バックエンドから文字列を最大 ($length-1) 文字（訳者注：バイト？）
gate&gt;   読み込みます。

$ret = $conn-&gt;getline($string, $length)
Reads a string up to $length - 1 characters from the backend.

PQgetline は、
extern int      PQgetline(PGconn *conn, char *string, int length);
のように char * なので、文字といえば文字ですね。

(略)

gate&gt;    $ret = $conn-&gt;getlineAsync($buffer, $bufsize)
gate&gt;   getline のアプリケーション実行を中断しない版です。この関数はバッ
gate&gt;   クエンドから最大 $bufsize 文字（訳者注：バイト？）を $buffer 
gate&gt;   に読み込みます。getlineAsync は「読み込み終わりの印」が見つかっ
gate&gt;   たときは -1 を、読み込むデータがないときは 0 を、データを読み
gate&gt;   込んだときは読み込んだバイト数を（この時は当然正の値を）返します。

$ret = $conn-&gt;getlineAsync($buffer, $bufsize)
Non-blocking version of getline. It reads up to $bufsize characters
from the backend. getlineAsync returns -1 if the end-of-copy-marker
has been recognized, 0 if no data is avilable, and &gt;0 the number of
bytes returned.

手元の libpq-fe.h には該当する関数が見当たりません。
Pg.pm にもないので、7 になって新しく追加されたのでしょうか。

gate&gt;    $ret = $conn-&gt;putnbytes($buffer, $nbytes)
gate&gt;   バックエンドに $nbytes バイトのデータを $buffer から送ります。
gate&gt;   成功したときは 0 を、そうでないときは EOF を返します。

$ret = $conn-&gt;putnbytes($buffer, $nbytes)
Sends n bytes to the backend. Returns 0 if OK, EOF if not.

(略)

gate&gt;    $result = $conn-&gt;makeEmptyPGresult($status)
gate&gt;   $status で表された状態において新規に確保されて初期化された、結
gate&gt;   果を表す構造体を返します。

$result = $conn-&gt;makeEmptyPGresult($status);
Returns a newly allocated, initialized result with given status.

これも、result という用語(と status という用語)に苦労されていますね。

以上、長かったので、勘違い等あるかもしれません。その場合は申し訳ありま
せん。何かのお役に立ちましたら幸いです。

それでは。
-------------------------------------------------------------------
＊＊＊＊＊ ---------------&gt;&gt; 大月 美佳 &lt;&lt;--------------- ＊＊＊＊＊
＊                 九州大学 大学教育研究センター                 ＊
＊   tel: (092)726-4567(仮) e-mail: mika@rc.kyushu-u.ac.jp       ＊
＊    wwwhome: <A HREF="http://web.rc.kyushu-u.ac.jp/~mika/index.html">http://web.rc.kyushu-u.ac.jp/~mika/index.html</A>     ＊
-------------------------------------------------------------------
</PRE>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<HR>
<UL><LI><STRONG>Follow-Ups</STRONG>:
<UL>
<LI><STRONG><A NAME="00138" HREF="msg00138.html">[pgsql-jp 16524] man Pgの邦訳</A></STRONG>
<UL><LI><EM>From:</EM> かどわき しろう&lt;gate@blue.b-city.net&gt;</LI></UL></LI>
<LI><STRONG><A NAME="00135" HREF="msg00135.html">[pgsql-jp 16521] old style/new style の邦訳</A></STRONG>
<UL><LI><EM>From:</EM> 綾乃介 &lt;aya@big.or.jp&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-Follow-Ups-End-->
<!--X-References-->
<UL><LI><STRONG>References</STRONG>:
<UL>
<LI><STRONG><A NAME="00119" HREF="msg00119.html">[pgsql-jp 16505] man Pg の邦訳 - FUNCTIONSのConnections</A></STRONG>
<UL><LI><EM>From:</EM> かどわき しろう&lt;gate@blue.b-city.net&gt;</LI></UL></LI>
</UL></LI></UL>
<!--X-References-End-->
<!--X-BotPNI-->
<UL>
<LI>Prev by Date:
<STRONG><A HREF="msg00127.html">[pgsql-jp 16513] Re: man Pg の邦訳- GUIDELINES -</A></STRONG>
</LI>
<LI>Next by Date:
<STRONG><A HREF="msg00129.html">[pgsql-jp 16515] pg_dumpのオプションとデータ型について</A></STRONG>
</LI>
<LI>Prev by thread:
<STRONG><A HREF="msg00119.html">[pgsql-jp 16505] man Pg の邦訳 - FUNCTIONSのConnections</A></STRONG>
</LI>
<LI>Next by thread:
<STRONG><A HREF="msg00135.html">[pgsql-jp 16521] old style/new style の邦訳</A></STRONG>
</LI>
<LI>Index(es):
<UL>
<LI><A HREF="index.html#00128"><STRONG>Date</STRONG></A></LI>
<LI><A HREF="threads.html#00128"><STRONG>Thread</STRONG></A></LI>
</UL>
</LI>
</UL>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</BODY>
</HTML>

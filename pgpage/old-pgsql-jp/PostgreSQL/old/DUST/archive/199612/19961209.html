<A NAME="6">
<PRE><B>
From: &quot;kawamoto, keiichi&quot; &lt;kawamoto@st.rim.or.jp&gt;
Date: Sun, 08 Dec 1996 15:28:09 +0900
Subject: [postgres95 1148] (No Subject in original)
Message-Id: &lt;199612091404.XAA23371@mail.st.rim.or.jp&gt;
</A>
</B></PRE>
<PRE>

# help
# end

<HR>
</PRE>
<A NAME="5">
<PRE><B>
From: Tatsuo Ishii &lt;t-ishii@sra.co.jp&gt;
Date: Mon, 09 Dec 1996 14:13:37 +0900
Subject: [postgres95 1147] Re: view and aggregate 
Message-Id: &lt;199612090513.OAA19955@srashc.sra.co.jp&gt;
</A>
</B></PRE>
<PRE>

石井です。

&gt;こんばんは、たてやま＠JSTでございます。

おお、久しぶりですね。愛用のMac は元気ですか？

&gt;&gt; &gt; それと、where 句に aggregate が使えないのもなんとかして欲しい。
&gt;&gt; &gt; 
&gt;&gt; &gt; 	select name from people where max(age) = age;
&gt;&gt; &gt; 
&gt;&gt; &gt; とかやりたいんです。
&gt;&gt; 
&gt;&gt; これは是非やりたいですね :-)
&gt;&gt; # 結局私は、1 度目に max() をして、その結果を変数に入れて... 
&gt;&gt; # と 2度呼び出しています
&gt;
&gt; 私はここ2年ほど、RDBとは全く縁のない暮らしをしているのですが、
&gt; 最近は石井さんの書かれたようなSQLを解釈してくれるようになったのでしょうか。

そのようです。手近にある Oracle v7/Solaris 2.4 ではOKでした。

&gt;&gt; でも、
&gt;&gt;     create function o3() returns int4 as 'select max(age) from people' ...
&gt;&gt;     select name from people where age=o3();
&gt;&gt; はきれいに動くんですよね。不思議です。
&gt;&gt; # 私には同じことをやってるように見えますが ;-)

本当に不思議ですが、ということは、データベースエンジン自体は

&gt;&gt; &gt; 	select name from people where max(age) = age;

こういうことを実行する能力があるのだが、パーサーが駄目ということなんで
しょうね。
---
t-ishii@sra.co.jp	石井達夫
（株）ＳＲＡ
<HR>
</PRE>
<A NAME="4">
<PRE><B>
From: 杉田研治 &lt;sugita@sra.co.jp&gt;
Date: Mon, 09 Dec 1996 12:38:11 +0900
Subject: [postgres95 1146] Re: KANJI-CODE on Postgres95 
Message-Id: &lt;199612090338.DAA03386@sran362.sra.co.jp&gt;
</A>
</B></PRE>
<PRE>

;;; From: Mitsuhiro Maeda &lt;mitsu@tramp.co.jp&gt;
;;; 
;;; # どんどんと PG95 から離れてしまってますが ...

  mmap は高速化のためなので後回しでもいいですね。

;;; JIS -&gt; EUC の変換をすると、file_size(JIS) &gt; file_size(EUC) と
;;; なってしまいますので、

  こうならば、

;;;			  私の頭では malloc して変換後の文字を
;;; 格納した方が扱いやすいように思ってしまいますが、
;;; うまくすれば mmap でマップしたメモリ領域のコピーとかで
;;; 高速化できるのかもしれませんね。

    oflags = O_RDWR;			/* For open */
    mprot = PROT_READ | PROT_WRITE;	/* For mmap */
    mflags = MAP_PRIVATE;		/* For mmap */
  
で、マップした領域をプライベートにメモリ上で R/W して大丈夫ですね。

;;; # 段々とドツボにはまりそう ...

  よろしくお願いします。


Kenji Sugita
sugita@sra.co.jp


<HR>
</PRE>
<A NAME="3">
<PRE><B>
From: Mitsuhiro Maeda &lt;mitsu@tramp.co.jp&gt;
Date: Mon, 09 Dec 1996 12:17:54 +0900
Subject: [postgres95 1145] Re: KANJI-CODE on Postgres95 
Message-Id: &lt;199612090317.MAA01316@log.tramp.co.jp&gt;
</A>
</B></PRE>
<PRE>

おみつ@Tramp です。

# どんどんと PG95 から離れてしまってますが ...

ご回答ありがとうございます。


From: 杉田研治&lt;sugita@sra.co.jp&gt;
Subject: [postgres95 1144] Re: KANJI-CODE on Postgres95 
Date: Mon, 09 Dec 1996 10:20:47 +0900

&gt;   ファイルをメモリにマップしてファイルの内容をポインタアクセスできるようにな
&gt; る、と考えていいです。手軽に高速 I/O ができてコードも単純になるので、手放せ
&gt; ません。

なるほどなるほど。これは便利ですね、速そうですし。


&gt;   PHP/FI では単に読み込みのために mmap を使っているだけですね。mmap がないと
&gt; malloc して全部のファイルを読み込んでます。mmap を使えば、少なくとも stdio
&gt; のバッファリングと fread でのコピーがなくなります。

JIS -&gt; EUC の変換をすると、file_size(JIS) &gt; file_size(EUC) と
なってしまいますので、私の頭では malloc して変換後の文字を
格納した方が扱いやすいように思ってしまいますが、
うまくすれば mmap でマップしたメモリ領域のコピーとかで
高速化できるのかもしれませんね。

# あくまで推測ですが :-)


# 段々とドツボにはまりそう ...

== おみつ
<HR>
</PRE>
<A NAME="2">
<PRE><B>
From: 杉田研治 &lt;sugita@sra.co.jp&gt;
Date: Mon, 09 Dec 1996 10:20:47 +0900
Subject: [postgres95 1144] Re: KANJI-CODE on Postgres95 
Message-Id: &lt;199612090120.BAA02634@sran362.sra.co.jp&gt;
</A>
</B></PRE>
<PRE>

;;; From: Mitsuhiro Maeda &lt;mitsu@tramp.co.jp&gt;
...
;;; * mmap はよくわからなかったので (^^;;) コメントアウト

  ファイルをメモリにマップしてファイルの内容をポインタアクセスできるようにな
る、と考えていいです。手軽に高速 I/O ができてコードも単純になるので、手放せ
ません。

  PHP/FI では単に読み込みのために mmap を使っているだけですね。mmap がないと
malloc して全部のファイルを読み込んでます。mmap を使えば、少なくとも stdio
のバッファリングと fread でのコピーがなくなります。

;;; # mmap って動的にメモリをアロケートしてくれるんでしょうか ...

  はい、してくれます。


Kenji Sugita
sugita@sra.co.jp


  
<HR>
</PRE>
<A NAME="1">
<PRE><B>
From: Mitsuhiro Maeda &lt;mitsu@tramp.co.jp&gt;
Date: Mon, 09 Dec 1996 07:32:39 +0900
Subject: [postgres95 1143] Re: KANJI-CODE on Postgres95 
Message-Id: &lt;199612082232.HAA01053@log.tramp.co.jp&gt;
</A>
</B></PRE>
<PRE>

おみつ@Tramp です。

大変申し訳ありません _0_

実は、このメールの前に流させて頂いた 
「内部 EUC -&gt; 出力漢字コード(ユーザー設定)」
のプログラムは、とてもバグバグしておりました。

只今一生懸命デバッグと修正をしておりますので、
前回のメールは削除して頂くようお願い申し上げます。


ゴミメールとなってしまい、
重ねて大変申し訳ありませんでした m_0_m


P.S.
 調べれば調べるほど深みにはまっていく ... ^^;;

== おみつ
<HR>
</PRE>
<A NAME="0">
<PRE><B>
From: Mitsuhiro Maeda &lt;mitsu@tramp.co.jp&gt;
Date: Mon, 09 Dec 1996 03:04:17 +0900
Subject: [postgres95 1142] Re: KANJI-CODE on Postgres95 
Message-Id: &lt;199612081804.DAA00797@log.tramp.co.jp&gt;
</A>
</B></PRE>
<PRE>

おみつ@Tramp です。

石井さんからの御提案を元に、
php-2.0b7 用の「内部 EUC -&gt; 出力漢字コード(ユーザー設定)」
というものを作ってみました。

前回のものとの相違点は、

 * 内部処理を EUC にすべて統一
 * 出力漢字コードを関数「SetKanjiOutput(&quot;コード名&quot;)」にて設定
 * 内部処理を統一したことで前回の関数「KanjiConv()」が
   機能しなくなりましたので、関数そのものを削除
 * mmap はよくわからなかったので (^^;;) コメントアウト

となっています。


このメールの後半を切り取って、kanji.patch に保存して下さい。

そして PHP/FI のソースのトップディレクトリ(???/php-2.0b7/)で

% patch -p1 &lt; kanji.patch 

を実行して、あとは 通常通りの ./install とします。

関数「SetKanjiOutput(&quot;モード&quot;)」を指定することで、
その出力コードを指定することができます。

[モード]
  モードは { EUC | JIS | SJIS } の 3種類 です。
  文字列として指定します。


確認済み動作環境は、
  Linux 1.2.13 (Slackware 3.0) + JE 0.9.7
 + postgres95-1.06 + pg95-1.06-jp.patch
 + apache_1.1.1 + php-2.0b7
のみです。

# mmap って動的にメモリをアロケートしてくれるんでしょうか ...
# ううむ。勉強不足でして ... ;-)


ここから
======================================================================

diff -c -r -N php-2.0b7/README.kanji.euc kanji-php/README.kanji.euc
*** php-2.0b7/README.kanji.euc	Thu Jan  1 09:00:00 1970
--- kanji-php/README.kanji.euc	Mon Dec  9 02:35:52 1996
***************
*** 0 ****
--- 1,96 ----
+ README.kanji  === PHP/FI 漢字コードハンドリング 第 2 版 ===
+ 
+ *** INTRO ***
+ 
+ PHP/FIにて漢字コードの変換を実現するパッケージを組んでみました。
+ ですが、このコードはほぼすべて「ぱくり」です ;-) 
+ 
+ ベースは、
+ 1. shige@csk.JUNET さんの filters-2.0
+ 2. 佐藤公彦(K.Sato)の qkc 1.0
+ から拝借いたしました。
+ 
+ 
+ PHP/FI のソースのトップディレクトリ(php-??)で
+ 
+ % patch -p1 &lt; kanji.patch 
+ 
+ を実行して、あとは 通常通りの ./install とします。
+ 
+ 
+ *** HOW-TO ***
+ 
+ このパッケージは、PHP/FI 上で漢字コードを使う際に
+ 内部コードを EUC に統一し、その出力コードをセット
+ するものです。
+ 
+ 関数「SetKanjiOutput(&quot;モード&quot;)」を指定することで、
+ その出力コードを指定することができます。
+ 
+ [モード]
+   モードは { EUC | JIS | SJIS } の 3種類 です。
+   文字列として指定します。
+ 
+ 
+ 
+ *** EXAMPLE ***
+ 
+ &lt;? 
+   ...
+   $str=&quot;おみつ&quot;; /* この時点で内部コードは EUC になります */
+   pg_exec(&quot;select * from address where person='$str'&quot;);
+   ...
+ 
+   $res=&quot; 検索結果 : $str &quot;;
+ 
+   SetKanjiOutput(&quot;JIS&quot;); /* ブラウザに JIS で表示 */
+   echo &quot;&lt;h2&gt; $res &lt;/h2&gt;&quot;;
+   ...
+ 
+   SetKanjiOutput(&quot;SJIS&quot;); /* ファイルへ SJIS で保存 */
+   $fp=fopen(&quot;/dos/result.txt&quot;,&quot;w&quot;);
+     fputs($fp,$res);
+   fclose($fp);
+   ...
+ 
+ &gt;
+ 
+ ブラウザのみならず、ファイルへの出力も制御できます。
+ デバイスへの出力前に使用して下さい。
+ 
+ デフォルトの出力コードは「EUC」です。
+ 
+ 
+ *** MACHINE ***
+ 
+ 確認済み動作環境は、
+   Linux 1.2.13 (Slackware 3.0) + JE 0.9.7
+  + postgres95-1.06 + pg95-1.06-jp.patch
+  + apache_1.1.1 + php-2.0b7
+ のみです。
+ 
+ 
+ *** BUGS ***
+ 
+ php-2.0b9 がリリースされ、パッチが当たらないらしいです。
+ もう少し待って下さい。( 今手元に 2.0b9 がないんです :-)
+ 
+ 
+ *** CHANGES ***
+ 
+ 前回流した「KanjiConv(文字列,モード)」は、内部コード
+ を統一したことによって機能しなくなりましたので、
+ 削除させて頂きました。
+ 
+ 
+ *** NOTICE ***
+ 
+ 「とりあえず動くもの」を大前提として組みましたので
+ なにかしら問題もあるかと思われますが、完全に無保証です。
+ 各人の責任において御使用ください。
+ 
+ ======================================================================
+ 12-09-1996 前田充宏
+ mitsu@tramp.co.jp
+ 
diff -c -r -N php-2.0b7/config.h.in kanji-php/config.h.in
*** php-2.0b7/config.h.in	Mon Sep 23 08:30:37 1996
--- kanji-php/config.h.in	Mon Dec  9 02:21:06 1996
***************
*** 37,43 ****
  #undef HAVE_STRCASECMP
  
  /* Define if you have the mmap function.  */
! #undef HAVE_MMAP
  
  /* Define if you have the putenv function.  */
  #undef HAVE_PUTENV
--- 37,43 ----
  #undef HAVE_STRCASECMP
  
  /* Define if you have the mmap function.  */
! /* #undef HAVE_MMAP */
  
  /* Define if you have the putenv function.  */
  #undef HAVE_PUTENV
diff -c -r -N php-2.0b7/src/Makefile.in kanji-php/src/Makefile.in
*** php-2.0b7/src/Makefile.in	Mon Sep 23 11:13:41 1996
--- kanji-php/src/Makefile.in	Mon Dec  9 02:20:59 1996
***************
*** 105,111 ****
  	  echo.o cond.o switch.o db.o while.o string.o msql.o \
  	  reg.o exec.o file.o crypt.o head.o info.o post.o \
  	  type.o conf.o acc.o local.o dns.o log.o sort.o dir.o rand.o \
! 	  gd.o mime.o fsock.o microtime.o pg95.o pool.o tmagic.o
  
  all: $(PHP_PROGS) @MODULE_TARGET@
  
--- 105,113 ----
  	  echo.o cond.o switch.o db.o while.o string.o msql.o \
  	  reg.o exec.o file.o crypt.o head.o info.o post.o \
  	  type.o conf.o acc.o local.o dns.o log.o sort.o dir.o rand.o \
! 	  gd.o mime.o fsock.o microtime.o pg95.o pool.o tmagic.o \
! 	  kanjiconv.o etoj.o etos.o jtoe.o jtos.o \
! 	  stoe.o stoj.o
  
  all: $(PHP_PROGS) @MODULE_TARGET@
  
diff -c -r -N php-2.0b7/src/etoj.c kanji-php/src/etoj.c
*** php-2.0b7/src/etoj.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/etoj.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,104 ----
+ /*								*/
+ /*	etoj.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	etoj	EUC code convert into JIS code.			*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$B	^[(B	JIS 83				*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC 	'\033'
+ #define KI1 	'$'
+ #define KI2 	'B'
+ #define KO1 	'('
+ #define KO2 	'B'
+ #define	KANAIN		0x0e
+ #define	KANAOUT		0x0f
+ #define	SS2		0x8e	/* Hankaku Kana */
+ 
+ void
+ etoj(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c;
+ 
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if(0xa1 &lt;= c &amp;&amp; c &lt;= 0xfe) { /* ZENKAKU */
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=KI2;
+ 	dest[pos++]=(c &amp; 0x7f);
+ 	stat = 1;
+       }
+       else if(c == SS2) { /* Hankaku Kana */
+ 	dest[pos++]=KANAIN;
+ 	c = src[i++];
+ 	dest[pos++]=(c &amp; 0x7f);
+ 	stat = 3;
+       }
+       else /* ASCII */
+ 	dest[pos++]=c;
+       break;
+     case 1:
+       stat = 2;
+       dest[pos++]=(c &amp; 0x7f);
+       break;
+     case 2:
+       if(0xa1 &lt;= c &amp;&amp; c &lt;= 0xfe) { /* ZENKAKU */
+ 	dest[pos++]=(c &amp; 0x7f);
+ 	stat = 1;
+       }
+       else {
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=KO2;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     case 3:				 /* hankaku kana */
+       if(c == SS2) {
+ 	c=src[i++];
+ 	dest[pos++]=(c &amp; 0x7f);
+       }
+       else {
+ 	dest[pos++]=KANAOUT;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     }
+   }
+   if ( stat == 1 || stat == 2 ) {
+     /* put KANJI-OUT */
+     dest[pos++]=ESC;
+     dest[pos++]=KO1;
+     dest[pos++]=KO2;
+   }
+   else if (stat == 3) 
+     dest[pos++]=KANAOUT;
+ 
+   /* terminate */
+   dest[pos]='\0';
+ }
diff -c -r -N php-2.0b7/src/etos.c kanji-php/src/etos.c
*** php-2.0b7/src/etos.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/etos.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,82 ----
+ /*
+  *	EUC --&gt; Sift_JIS  Convert Routine
+  */
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define	Z_BEGIN		0xa1	/* Zenkaku Begin */
+ #define	Z_END		0xfe	/* Zenkaku END */
+ #define SS2    		0x8e	/* Hankaku Kana */
+ 
+ static void
+ JIS_IBM(jis1,jis2,ibm1,ibm2)
+      register unsigned char jis1,jis2,*ibm1,*ibm2;
+ {
+   if(jis1 &gt;= 0x5f)    jis1 += 0x80;
+   
+   if((jis1 % 2) == 0) {
+     *ibm1 = (jis1 - 0x30)/2 + 0x88;
+     *ibm2 = jis2 + 0x7e;
+   }
+   else {
+     if(jis2 &gt;= 0x60)
+       jis2 = jis2 + 0x01;
+     *ibm1 = (jis1 - 0x31)/2 + 0x89;
+     *ibm2 = jis2 + 0x1f;
+   }
+   *ibm1 &amp;= 0xff;
+   *ibm2 &amp;= 0xff;
+ }
+ 
+ void
+ etos(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c,c1,c2;
+   unsigned char s1,s2;
+   
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if (Z_BEGIN &lt;= c  &amp;&amp; c &lt;= Z_END) { /* Zenkaku */
+ 	c1 = c &amp; 0x7f;
+ 	stat = 1;
+       }
+       else if (c == SS2) { /* Hankaku Kana */
+ 	c = src[i++];
+ 	dest[pos++]=c;
+       }
+       else /* ASCII */
+ 	dest[pos++]=c;
+       break;
+     case 1:
+       stat = 0;
+       c2 = c &amp; 0x7f;
+       JIS_IBM(c1,c2,&amp;s1,&amp;s2); /* Convert JIS to Sift_JIS */
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ }
+ 
diff -c -r -N php-2.0b7/src/file.c kanji-php/src/file.c
*** php-2.0b7/src/file.c	Mon Sep 23 07:11:05 1996
--- kanji-php/src/file.c	Mon Dec  9 02:21:01 1996
***************
*** 22,27 ****
--- 22,28 ----
  /* $Id: file.c,v 1.32 1996/09/22 22:07:51 rasmus Exp $ */
  #include &quot;php.h&quot;
  #include &lt;stdlib.h&gt;
+ #include &lt;string.h&gt;
  #ifdef HAVE_UNISTD_H
  #include &lt;unistd.h&gt;
  #endif
***************
*** 981,986 ****
--- 982,988 ----
  		Push(&quot;&quot;,STRING);
  		return;
  	}
+ 	conv2euc(buf);
  	Push((buf=AddSlashes(buf,1)),STRING);
  }
  
***************
*** 1016,1021 ****
--- 1018,1024 ----
  		Push(&quot;&quot;,STRING);
  		return;
  	}
+ 	conv2euc(buf);
  	rbuf=estrdup(1,buf);
  	c = *buf;
  	lc=(char)0;
***************
*** 1088,1094 ****
  	Stack *s;
  	FILE *fp;
  	int ret,id;
! 	char *buf;
  	char temp[8];
  
  	s = Pop();
--- 1091,1097 ----
  	Stack *s;
  	FILE *fp;
  	int ret,id;
! 	char *buf,*temp_buf;
  	char temp[8];
  
  	s = Pop();
***************
*** 1113,1119 ****
  	}
  	ParseEscapes(buf);
  	StripSlashes(buf);
! 	ret = fputs(buf,fp);
  	sprintf(temp,&quot;%d&quot;,ret);
  	Push(temp,STRING);
  }	
--- 1116,1124 ----
  	}
  	ParseEscapes(buf);
  	StripSlashes(buf);
! 	temp_buf=emalloc(0,strlen(buf)*2+ECHO_BUF);
! 	(*function_table[output_kanji_code][EUC])(temp_buf,buf);
! 	ret = fputs(temp_buf,fp);
  	sprintf(temp,&quot;%d&quot;,ret);
  	Push(temp,STRING);
  }	
diff -c -r -N php-2.0b7/src/jtoe.c kanji-php/src/jtoe.c
*** php-2.0b7/src/jtoe.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/jtoe.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,188 ----
+ /*								*/
+ /*	jtoe.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	jtoe	all JIS code convert into EUC code.		*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$@	^[(H	JIS 78  &amp;  (incorrect code)	*/
+ /*		^[$@	^[(J	JIS 78  &amp;  JIS_ROMAN		*/
+ /*		^[$@	^[(B	JIS 78  &amp;  ASCII		*/
+ /*		^[$B	^[(J	JIS 83  &amp;  JIS_ROMAN		*/
+ /*		^[$B	^[(B	JIS 83  &amp;  ASCII		*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC '\033'
+ #define KI1 '$'
+ #define KI2 '@'
+ #define KI3 'B'
+ #define KO1 '('
+ #define KO2 'J'
+ #define KO3 'H'
+ #define KO4 'B'
+ #define	KANAIN	0x0e
+ #define	KANAOUT	0x0f
+ #define	SS2	0x8e
+ 
+ static void 
+ JIS_EUC(jis1,jis2,euc1,euc2)
+      register unsigned char jis1,jis2,*euc1,*euc2;
+ {
+   *euc1 = jis1 | 0x80;
+   *euc2 = jis2 | 0x80;
+ }
+ 
+ void
+ jtoe(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c, c1, c2;
+   unsigned char s1, s2;
+   static int js78on = 0, js83on = 0;
+   
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+   
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if (c == ESC) 
+ 	stat = 1;
+       else if(c == KANAIN)
+ 	stat = 6;
+       else
+ 	dest[pos++]=c;
+       break;
+     case 1: /*  ESC ----&gt; ?  */
+       switch(c) {
+       case KO1:
+ 	stat = 2;
+ 	break;
+       case KI1:
+ 	stat = 3;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 2: /* ESC --&gt; KO1 --&gt; ? */
+       switch(c){
+       case KO2: /* ^[(J : KOUT (to JIS_ROMAN) */
+       case KO4: /* ^[(B : KOUT (to ASCII) */
+ 	if (js78on || js83on){ /* JIS 78 or JIS 83 KANJI */
+ 	  js83on = 0;
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KO3: /* ^[(H : incorrect but used */
+ 	if (js78on){ /* JIS 78 KANJI */
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 3: /* ESC --&gt; KI1 --&gt; ? */
+       switch(c){
+       case KI2: /* ^[$@ : JIS 78 KIN */
+ 	stat = 4;
+ 	js78on = 1;
+ 	break;
+       case KI3: /* ^[$B : JIS 83 KIN */
+ 	stat = 4;
+ 	js83on = 1;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 4: /* JIS KANJI 1st */
+       if (c == ESC)
+ 	stat = 1;
+       else if (c == KANAIN) ;
+       else {
+ 	c1 = c;
+ 	stat = 5;
+       }
+       break;
+     case 5: /* JIS KANJI 2nd */
+       c2 = c;
+       JIS_EUC(c1,c2,&amp;s1,&amp;s2);
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       stat = 4;
+       break;
+     case 6: /* HANKAKU KANA */
+       if(c == KANAIN) ;
+       else if(c == KANAOUT)
+ 	stat = 0;
+       else {
+ 	if((c &gt;=0x21) &amp;&amp; (c &lt;= 0x5f))
+ 	  c |= 0x80;
+ 	dest[pos++]=SS2;
+ 	dest[pos++]=c;
+       }
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ }
+ 
diff -c -r -N php-2.0b7/src/jtos.c kanji-php/src/jtos.c
*** php-2.0b7/src/jtos.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/jtos.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,200 ----
+ /*								*/
+ /*	jtos.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	jtos	all JIS code convert into SJIS code.		*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$@	^[(H	JIS 78  &amp;  (incorrect code)	*/
+ /*		^[$@	^[(J	JIS 78  &amp;  JIS_ROMAN		*/
+ /*		^[$@	^[(B	JIS 78  &amp;  ASCII		*/
+ /*		^[$B	^[(J	JIS 83  &amp;  JIS_ROMAN		*/
+ /*		^[$B	^[(B	JIS 83  &amp;  ASCII		*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC '\033'
+ #define KI1 '$'
+ #define KI2 '@'
+ #define KI3 'B'
+ #define KO1 '('
+ #define KO2 'J'
+ #define KO3 'H'
+ #define KO4 'B'
+ #define	KANAIN	0x0e
+ #define	KANAOUT	0x0f
+ 
+ static void
+ JIS_SJIS(jis1,jis2,sjis1,sjis2)
+      register unsigned char jis1,jis2,*sjis1,*sjis2;
+ {
+   if(jis1 &gt;= 0x5f)
+     jis1 += 0x80;
+   
+   if((jis1 % 2) == 0) {
+     *sjis1 = (jis1 - 0x30)/2 + 0x88;
+     *sjis2 = jis2 + 0x7e;
+   }
+   else {
+     if(jis2 &gt;= 0x60)
+       jis2 = jis2 + 0x01;
+     *sjis1 = (jis1 - 0x31)/2 + 0x89;
+     *sjis2 = jis2 + 0x1f;
+   }
+   *sjis1 &amp;= 0xff;
+   *sjis2 &amp;= 0xff;
+ }
+ 
+ void
+ jtos(char *dest, const char *src)
+ {
+   int stat;
+   register unsigned char c, c1, c2;
+   unsigned char s1, s2;
+   static int js78on=0, js83on=0;
+ 
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while((c = src[i++]) != '\0'){
+     switch (stat) {
+     case 0:
+       if (c == ESC) 
+ 	stat = 1;
+       else if(c == KANAIN)
+ 	stat = 6;
+       else
+ 	dest[pos++]=c;
+       break;
+     case 1: /*  ESC ----&gt; ?  */
+       switch (c) {
+       case KO1:
+ 	stat = 2;
+ 	break;
+       case KI1:
+ 	stat = 3;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 2: /* ESC --&gt; KO1 --&gt; ? */
+       switch(c){
+       case KO2: /* ^[(J : KOUT (to JIS_ROMAN) */
+       case KO4: /* ^[(B : KOUT (to ASCII) */
+ 	if (js78on || js83on){ /* JIS 78 or JIS 83 KANJI */
+ 	  js83on = 0;
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KO3: /* ^[(H : incorrect but used */
+ 	if(js78on){ /* JIS 78 KANJI */
+ 	  js78on = 0;
+ 	  stat = 0;
+ 	}
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 3:			/* ESC --&gt; KI1 --&gt; ? */
+       switch(c){
+       case KI2:		/* ^[$@ : JIS 78 KIN */
+ 	stat = 4;
+ 	js78on = 1;
+ 	break;
+       case KI3:		/* ^[$B : JIS 83 KIN */
+ 	stat = 4;
+ 	js83on = 1;
+ 	break;
+       case KANAIN:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 6;
+ 	break;
+       case ESC:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	stat = 1;
+ 	break;
+       default:
+ 	dest[pos++]=ESC;
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=c;
+ 	stat = 0;
+ 	break;
+       }
+       break;
+     case 4:		/* JIS KANJI 1st */
+       if (c == ESC)
+ 	stat = 1;
+       else if (c == KANAIN) ;
+       else {
+ 	c1 = c;
+ 	stat = 5;
+       }
+       break;
+     case 5:		/* JIS KANJI 2nd */
+       c2 = c;
+       JIS_SJIS(c1,c2,&amp;s1,&amp;s2);
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       stat = 4;
+       break;
+     case 6:		/* HANKAKU KANA */
+       if(c == KANAIN) ;
+       else if(c == KANAOUT)
+ 	stat = 0;
+       else {
+ 	if((c &gt;=0x21) &amp;&amp; (c &lt;= 0x5f))
+ 	  c |= 0x80;
+ 	dest[pos++]=c;
+       }
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ 
+ }
+ 
diff -c -r -N php-2.0b7/src/kanjiconv.c kanji-php/src/kanjiconv.c
*** php-2.0b7/src/kanjiconv.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/kanjiconv.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,237 ----
+ /************************************************************************/
+ /*                                                                      */
+ /* kanjiconv.c                                                          */
+ /*                                                                      */
+ /* by o3(mitsu@tramp.co.jp)                                             */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /* Usage in PHP script :                                                */
+ /*   KanjiConv(&quot;&lt;strings&gt;&quot;, &quot;&lt;mode&gt;&quot;);                                  */
+ /*                                                                      */
+ /* ARGS                                                                 */
+ /*   &lt;strings&gt;: strings to convert Kanji code                           */
+ /*    &lt;mode&gt;  : EUC | SJIS | JIS                                        */
+ /*                                                                      */
+ /* RETURN VALUE                                                         */
+ /*   type: string (in Kanji-code &quot;mode&quot;)                                */
+ /*                                                                      */
+ /* EXAMPLE                                                              */
+ /*   $str = KanjiConv($input, &quot;EUC&quot;);                                   */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ #include &quot;php.h&quot;
+ #include &quot;parse.h&quot;
+ 
+ /* Kanji Code for output */
+ int output_kanji_code=EUC;
+ 
+ /* (*function_table[dest][src])(dest,src) */
+ FUNC function_table[4][4]={
+   { (void*)strcpy, (void*)strcpy, (void*)strcpy, (void*)strcpy}, /* dest : NONE */
+   { (void*)strcpy, (void*)strcpy, jtoe, stoe}, /* dest :  EUC */
+   { (void*)strcpy, etoj, (void*)strcpy, stoj}, /* dest :  JIS */
+   { (void*)strcpy, etos, jtos, (void*)strcpy}  /* dest : SJIS */
+ };
+ 
+ 
+ static int
+ _checkforward(unsigned char *p)
+ {
+   unsigned char c;
+ 
+   if(*++p=='\0')
+     return EUC;
+   
+   while(1){
+     if(c=='\033'){
+       if((c=*p++)=='\0')
+ 	break;
+       if(c=='$'){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(c=='B' || c=='@')
+ 	  return JIS;
+ 	else
+ 	  continue;
+       }
+       else if(c=='K')
+ 	return JIS;
+       else
+ 	continue;
+     }
+     else if(c&gt;=0x81){
+       if(c==0x8e){
+ 	if((*++p)=='\0')
+ 	  break;
+       }
+       else if(c&lt;=0x9f){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskanji2nd(c))
+ 	  return SJIS;
+ 	else
+ 	  continue;
+       }
+       else if(c&gt;=0xa1 &amp;&amp; c&lt;=0xdf){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskana(c))
+ 	  continue;
+ 	else if (iseuc(c))
+ 	  return EUC;
+ 	else
+ 	  continue;
+       }
+       else if(c!=0xa0)
+ 	return EUC;
+     }
+     if((c=*p++)=='\0')
+       break;
+   }
+ 
+   return EUC;
+ }
+ 
+ static int 
+ _kanjicode(unsigned char *buf)
+ {
+   unsigned char *p,c;
+   int unknownstat = 0;
+ 
+   if(buf==NULL || buf[0]=='\0')
+     return NONE;
+ 
+   p=buf;
+   c=*p++;
+   while(1){
+     if(c=='\033'){
+       if((c=*p++)=='\0')
+ 	break;
+       if(c=='$'){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(c=='B' || c=='@')
+ 	  return JIS;
+ 	else
+ 	  continue;
+       }
+       else if(c=='K')
+ 	return JIS;
+       else
+ 	continue;
+     }
+     else if(c&gt;=0x81){
+       if(c==0x8e){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskana(c))
+ 	  unknownstat |= 2;
+ 	else if (iskanji2nd(c))
+ 	  return SJIS;
+ 	else
+ 	  continue;
+       }
+       else if(c&lt;=0x9f){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskanji2nd(c))
+ 	  return SJIS;
+ 	else
+ 	  continue;
+       }
+       else if(c&gt;=0xa1 &amp;&amp; c&lt;=0xdf || c==0xfd || c==0xfe){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iseuc(c))
+ 	  if(iskana(c))
+ 	    if(*(p+1)=='\0')
+ 	      return EUC;
+ 	    else
+ 	      return _checkforward(p);
+ 	  else
+ 	    return EUC;
+ 	else
+ 	  continue;
+       }
+       else if(c&gt;=0xe0 &amp;&amp; c&lt;=0xfc){
+ 	if((c=*p++)=='\0')
+ 	  break;
+ 	if(iskanji2nd(c))
+ 	  if(iseuc(c))
+ 	    unknownstat |= 1;
+ 	  else
+ 	    return SJIS;
+ 	else
+ 	  if(iseuc(c))
+ 	    return EUC;
+ 	  else
+ 	    continue;
+       }
+     }
+     if((c=*p++)=='\0')
+       break;
+   }
+ 
+   if(unknownstat==2)
+     return SJIS;
+   else
+     return NONE;
+ 
+ }
+ 
+ void
+ conv2euc(char *src)
+ {
+   char *temp;
+   temp=emalloc(0,strlen(src)+1);
+   (*function_table[EUC][_kanjicode(src)])(temp,src);
+   strcpy(src,temp);
+ }
+ 
+ void
+ SetKanjiOutput(void)
+ {
+   Stack *s;
+   unsigned char *ret;
+ 
+   s=Pop();
+   if(!s){
+     Error(&quot;Stack error in KanjiConv&quot;);
+     return;
+   }
+ 
+   if(!strcasecmp(s-&gt;strval,&quot;EUC&quot;))
+     output_kanji_code=EUC;
+   else if(!strcasecmp(s-&gt;strval,&quot;JIS&quot;))
+     output_kanji_code=JIS;
+   else if(!strcasecmp(s-&gt;strval,&quot;SJIS&quot;))
+     output_kanji_code=SJIS;
+   else 
+     output_kanji_code=NONE;
+ 
+   return;
+ }
+ 
+ 
+ int
+ kanji_puts(char *str)
+ {
+   unsigned char *ret;
+ 
+   ret=(unsigned char*)emalloc(0,2*strlen(str)+1);
+ 
+   (*function_table[output_kanji_code][EUC])(ret,str);
+ 
+ #if APACHE
+ #if APACHE_NEWAPI
+   return rputs(str,php_rqst);
+ #else
+   return rprintf(php_rqst,&quot;%s&quot;,ret);
+ #endif
+ #else
+   return fputs(ret,stdout);
+ #endif
+ 
+ }
diff -c -r -N php-2.0b7/src/lex.c kanji-php/src/lex.c
*** php-2.0b7/src/lex.c	Mon Sep 23 07:11:27 1996
--- kanji-php/src/lex.c	Mon Dec  9 02:20:59 1996
***************
*** 333,338 ****
--- 333,339 ----
  	  { &quot;msql_tablename&quot;, INTFUNC2,MsqlTableName },
  	  { &quot;pg_fieldprtlen&quot;, INTFUNC3,PGfieldPrtLen },
  	  { &quot;escapeshellcmd&quot;, INTFUNC1,EscapeShellCmd },
+ 	  { &quot;setkanjioutput&quot;, INTFUNC1,SetKanjiOutput },
  	  { NULL,0,NULL } },
  
  	{ { &quot;msql_freeresult&quot;, INTFUNC1,MsqlFreeResult }, /* 15 */
***************
*** 1216,1221 ****
--- 1217,1223 ----
  		fp = fdopen(fd,&quot;r&quot;);
  		pa = emalloc(0,file_size + 1);
  		fread(pa,1,file_size,fp);
+ 		conv2euc(pa);
  		pa_pos = 0L;
  		fclose(fp);
  		}
diff -c -r -N php-2.0b7/src/php.h kanji-php/src/php.h
*** php-2.0b7/src/php.h	Mon Sep 23 08:33:39 1996
--- kanji-php/src/php.h	Mon Dec  9 02:21:00 1996
***************
*** 964,966 ****
--- 964,1001 ----
  char *strerror(int);
  #endif
  
+ 
+ /* kanjiconv.c */
+ /* and other utils for kanji code */
+ #define NONE 0
+ #define EUC  1
+ #define JIS  2
+ #define SJIS 3
+ 
+ typedef void (*FUNC)();
+ 
+ #define iskanji1st(c) ((c) &gt;= 0x81 &amp;&amp; (c) &lt;= 0x9f ||\
+                        (c) &gt;= 0xe0 &amp;&amp; (c) &lt;= 0xfc)
+ #define iskanji2nd(c) ((c) &gt;= 0x40 &amp;&amp; (c) &lt;= 0xfc &amp;&amp; (c) != 0x7f)
+ #define iseuc(c) ((c) &gt;= 0xa1 &amp;&amp; (c) &lt;= 0xfe)
+ #define isjis(c) ((c) &gt;= 0x21 &amp;&amp; (c) &lt;= 0x7f)
+ #define iskana(c) ((c) &gt;= 0xa0 &amp;&amp; (c) &lt;= 0xdf)
+ 
+ extern int output_kanji_code;
+ 
+ void SetKanjiOutput(void);
+ void conv2euc(char *);
+ int kanji_puts(char*);
+ #undef PUTS(a)
+ #define PUTS(a) kanji_puts(a)
+ /* PUTC will be ok w/o conversion */
+ 
+ void etoj(unsigned char*,const unsigned char*); /*  EUC -&gt;  JIS */
+ void etos(unsigned char*,const unsigned char*); /*  EUC -&gt; SJIS */
+ void jtoe(unsigned char*,const unsigned char*); /*  JIS -&gt;  EUC */
+ void jtos(unsigned char*,const unsigned char*); /*  JIS -&gt; SJIS */
+ void stoe(unsigned char*,const unsigned char*); /* SJIS -&gt;  EUC */
+ void stoj(unsigned char*,const unsigned char*); /* SJIS -&gt;  JIS */
+ 
+ extern FUNC function_table[4][4];
+ 
diff -c -r -N php-2.0b7/src/php.h.org2 kanji-php/src/php.h.org2
*** php-2.0b7/src/php.h.org2	Thu Jan  1 09:00:00 1970
--- kanji-php/src/php.h.org2	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,969 ----
+ /***[php.h]*******************************************************[TAB=4]****\
+ *                                                                            *
+ * PHP/FI                                                                     *
+ *                                                                            *
+ * Copyright 1995,1996 Rasmus Lerdorf                                         *
+ *                                                                            *
+ *  This program is free software; you can redistribute it and/or modify      *
+ *  it under the terms of the GNU General Public License as published by      *
+ *  the Free Software Foundation; either version 2 of the License, or         *
+ *  (at your option) any later version.                                       *
+ *                                                                            *
+ *  This program is distributed in the hope that it will be useful,           *
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the             *
+ *  GNU General Public License for more details.                              *
+ *                                                                            *
+ *  You should have received a copy of the GNU General Public License         *
+ *  along with this program; if not, write to the Free Software               *
+ *  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
+ *                                                                            *
+ \****************************************************************************/
+ /* $Id: php.h,v 1.105 1996/09/22 23:30:05 rasmus Exp $ */
+ #include &lt;stdio.h&gt;
+ #include &lt;time.h&gt;
+ #include &lt;sys/types.h&gt;
+ #include &lt;sys/stat.h&gt;
+ #include &quot;../config.h&quot;
+ #if HAVE_FCNTL_H
+ #include &lt;fcntl.h&gt;
+ #endif
+ #if HAVE_MEMORY_H
+ #include &lt;memory.h&gt;
+ #endif
+ #if HAVE_REGCOMP
+ #include &lt;regex.h&gt;
+ #else
+ #include &quot;regex.h&quot;
+ #endif
+ #if APACHE
+ #include &quot;httpd.h&quot;
+ #include &quot;mod_php.h&quot;
+ 
+ extern request_rec *php_rqst;
+ #endif
+ 
+ /* 
+  * This should be set to the same as the UserDir httpd setting from
+  * srm.conf on your system for proper ~username expansion 
+  */
+ #define PHP_PUB_DIRNAME	&quot;public_html&quot;
+ /*
+  * You can override this setting with the PHP_USERDIR env. var if you
+  * change your config.
+  *
+  */
+ #define PHP_PUB_DIRNAME_ENV	&quot;PHP_USERDIR&quot;
+ 
+ /* 
+  * Only define the following if you wish the ROOT_DIR for PHP loaded
+  * scripts to be different from the server's default ROOT_DIR.  
+  * Only really useful in non server-wide setups to help shorten the
+  * URL's from something like:
+  *
+  *   http://www.io.org/~rasmus/php.cgi/~rasmus/file.html
+  *
+  * to:
+  *
+  *   http://www.io.org/~rasmus/php.cgi/file.html
+  */ 
+ /* #define PHP_ROOT_DIR &quot;/home/rasmus/public_html&quot; */
+ 
+ /*
+  * If you are compiling PHP in DEBUG mode, make sure the following
+  * points to a valid path and that PHP is allowed to create/write to
+  * this file.
+  */
+ #define DEBUG_FILE	&quot;/tmp/php.err&quot;
+ 
+ /*
+  * If you are using a virtual domain on a braindead http server which
+  * sets the SCRIPT_NAME environment variable to the absolute path as
+  * opposed to the relative path to your virtual domain, then you need
+  * to define the following to be the relative path to your php.cgi
+  * program.  (include php.cgi in the path please)
+  */
+ /* #define VIRTUAL_PATH	&quot;/cgi/php.cgi&quot; */
+ 
+ /*
+  * If MAGIC_QUOTES is defined, then the single quote &quot; ' &quot; character
+  * will be automatically escaped if it is found in a posted form variable.
+  * This is useful when mSQL or Postgres95 support is enabled since the 
+  * single quote has to be escaped when it is part of an mSQL  or Postgres95
+  * query.  
+  */
+ #define MAGIC_QUOTES 1
+ 
+ /*
+  * If UPLOAD_TMPDIR is defined, then this directory will be used for storing
+  * uploaded files temporarily.  If undefined, the system's default temporary
+  * directory will be used.  You can check which directory is the default
+  * temporary directory by searching through your /usr/include directory and
+  * looking for the P_tmpdir variable.
+  *
+  * NOTE: For Apache module, set this via phpUploadTmpDir configuration
+  *       directive.
+  */
+ /* #define UPLOAD_TMPDIR &quot;/tmp&quot; */
+ 
+ /*
+  * If no matter what you do, you cannot get it to accept your ?config
+  * password, define the following variable.  Delete any files in your
+  * configuration directory, recompile PHP and try using the password: php
+  */
+ /* #define BROKEN_CONFIG_PW 1 */
+ 
+ /*
+  * SETLOCALE Support can be enabled by setting this to 1.  You will probably
+  * want to do this if you are designing non-English pages.  When SETLOCALE is
+  * enabled, PHP/FI will check your environment variables for the correct
+  * locale settings.  See your system man page for setlocale() for more details.
+  */
+ /* #define SETLOCALE 1 */
+ 
+ /*
+  * MSQLLOGDB should be set to the database name you wish to use to store
+  * log data if you are using PHP/FI with mSQL-based logging.  Remember
+  * to create this database before trying to run PHP/FI in mSQL logging mode.
+  *
+  * NOTE: For Apache module, set this via phpMsqlLogDB configuration directive
+  */
+ #define MSQLLOGDB &quot;phpfi&quot;
+ 
+ /*
+  * MSQLLOGTMP is set to the directory where you want temporary lock
+  * files created when MSQL LOGGING is used.  Since mSQL does not support
+  * atomic updates of counters, an external lock file unfortunately needs
+  * to be used.  With mSQL-2, these lock files can be eliminated, but at
+  * the time of this writing, mSQL-2 is not available as of yet.
+  */
+ #define MSQLLOGTMP &quot;/tmp&quot;
+ 
+ /*
+  * PATTERN_RESTRICT can be enabled for security reasons to restrict php/fi
+  * to only load files with certain patterns in their filenames.  If unset,
+  * php/fi will by default be allowed to open all files regardless of the
+  * presence of any .htaccess or other external security mechanisms
+  * NOTE: the pattern must be a valid regular expression.  The example,
+  * &quot;.*\\.phtml$&quot; causes php/fi to only be allowed to load files ending with
+  * the .phtml extension.
+  */
+ /* #define PATTERN_RESTRICT &quot;.*\\.phtml$&quot; */
+ 
+ /*
+  * Max size of a single line of input in the HTML files
+  */
+ #define LINEBUFSIZE	4096
+ 
+ /*
+  * ECHO_BUF sets the size of the echo overflow buffer
+  * (only used in Apache module version)
+  */
+ #define ECHO_BUF 64
+ 
+ /*
+  * DEFAULT_MAX_DATA_SPACE
+  *
+  * Set this to the maximum size a memory sub-pool is allowed to grow
+  * to.  (number of kilo bytes)
+  */
+ #define DEFAULT_MAX_DATA_SPACE 8192
+ 
+ /*
+  * PHP_TRACK_VARS
+  *
+  * If you define this, 3 arrays will be created in your scripts.  They are:
+  * 
+  *  $PHP_GETVARS
+  *  $PHP_POSTVARS
+  *  $PHP_COOKIEVARS
+  *
+  * These arrays will contain the GET/POST/Cookie variables respectively.
+  */
+ /* #define PHP_TRACK_VARS 1 */
+ 
+ /*
+  * PHP_AUTH_VARS
+  *
+  * If this is defined, the the Apache module version will be allowed to
+  * set the PHP_AUTH_USER, PHP_AUTH_PW and PHP_AUTH_TYPE variables.  
+  * This is a potential security concern.  See the HTTP Authentication
+  * section in the documentation for more details.
+  */
+ #define PHP_AUTH_VARS 1
+ 
+ /*-- Do not touch anything after this point unless you are very brave --*/
+ 
+ #define PHP_VERSION &quot;2.0b7&quot;
+ 
+ #define VAR_INIT_CHAR	'$'
+ 
+ #if APACHE
+ #if APACHE_NEWAPI
+ #define PUTS(a) rputs((a),php_rqst)
+ #define PUTC(a) rputc((a),php_rqst)
+ #else
+ #define PUTS(a) rprintf(php_rqst,&quot;%s&quot;,(a))
+ #define PUTC(a) rprintf(php_rqst,&quot;%c&quot;,(a))
+ #endif
+ #else
+ #define PUTS(a) fputs((a),stdout)
+ #define PUTC(a) fputc((a),stdout)
+ #endif
+ 
+ #if HAVE_FLOCK
+ #ifndef LOCK_SH
+ #define LOCK_SH 1
+ #endif
+ #ifndef LOCK_EX
+ #define LOCK_EX 2
+ #endif
+ #ifndef LOCK_NB
+ #define LOCK_NB 4
+ #endif
+ #ifndef LOCK_UN
+ #define LOCK_UN 8
+ #endif
+ #endif
+ 
+ #if DEBUG
+ #define emalloc(a,b)		php_pool_alloc(__FILE__,__LINE__,(a),(b))
+ #define estrdup(a,b)		php_pool_strdup(__FILE__,__LINE__,(a),(b))
+ #else
+ #define emalloc(a,b)		php_pool_alloc((a),(b))
+ #define estrdup(a,b)		php_pool_strdup((a),(b))
+ #endif
+ 
+ #if STDC_HEADERS
+ #include &lt;string.h&gt;
+ #else
+ #ifndef HAVE_MEMCPY
+ #define memcpy(d, s, n)		bcopy((s), (d), (n))
+ #endif
+ #endif
+ 
+ #define MAX_CMD_LEN 21
+ 
+ #define YYSTYPE long
+ 
+ #if GDBM
+ #define DBM_TYPE GDBM_FILE;
+ #else
+ #if NDBM
+ #define DBM_TYPE DBM*;
+ #else
+ #define DBM_TYPE FILE*;
+ typedef struct {
+ 	char *dptr;
+ 	int   dsize;
+ } datum;
+ #endif
+ #endif
+ 
+ /* Variable Tree */
+ typedef struct VarTree {
+ 	short type;
+ 	int count;
+ 	char *name;
+ 	char *strval;
+ 	char *iname;
+ 	long intval;
+ 	double douval;
+ 	int flag;
+ 	int scope;				/* 0=local to frame, 4=global, 8=static to frame */
+ 	struct VarTree *left;
+ 	struct VarTree *right;
+ 	struct VarTree *next;
+ 	struct VarTree *prev;
+ 	struct VarTree *lacc;
+ 	struct VarTree *lastnode;
+ 	int deleted;
+ 	int allocated;
+ } VarTree;
+ 
+ /* Expression Stack */
+ typedef struct Stack {
+ 	short type;
+ 	char *strval;
+ 	long intval;
+ 	double douval;
+ 	VarTree *var;	
+ 	struct Stack *next;
+ 	int flag;
+ } Stack;
+ 
+ /* Conditional State Stack */
+ typedef struct CondStack {
+ 	int state;
+ 	int active;
+ 	struct CondStack *next;
+ } CondStack;
+ 
+ /* Entry point marker stack */
+ typedef struct CondMark {
+ 	struct CondStack *mark;
+ 	struct CondMark *next;
+ } CondMark;
+ 
+ /* Switch state stack */
+ typedef struct SwitchStack {
+ 	int type;
+ 	int matched;
+ 	long intval;
+ 	double douval;
+ 	char *strval;
+ 	struct SwitchStack *next;
+ } SwitchStack;
+ 
+ /* Entry point marker stack */
+ typedef struct SwitchMark {
+ 	struct SwitchStack *mark;
+ 	struct SwitchMark *next;
+ } SwitchMark;
+ 
+ /* Match Stack */
+ typedef struct MatchStack {
+ 	int val;
+ 	struct MatchStack *next;
+ } MatchStack;
+ 
+ /* Entry point marker stack */
+ typedef struct MatchMark {
+ 	struct MatchStack *mark;
+ 	struct MatchMark *next;
+ } MatchMark;
+ 
+ /* While loop stack */
+ typedef struct WhileStack {
+ 	long seekpos;
+ 	int offset;
+ 	int state;
+ 	int lineno;
+ 	struct WhileStack *next;
+ } WhileStack;
+ 
+ /* Entry point marker stack */
+ typedef struct WhileMark {
+ 	struct WhileStack *mark;
+ 	struct WhileMark *next;
+ } WhileMark;
+ 
+ typedef struct EndBraceStack {
+ 	int token;
+ 	struct EndBraceStack *next;
+ } EndBraceStack;
+ 
+ typedef struct EndBraceMark {
+ 	struct EndBraceStack *mark;
+ 	struct EndBraceMark *next;
+ } EndBraceMark;
+ 
+ typedef struct dbmStack {
+ 	char *filename;
+ 	char *lockfn;
+ 	int lockfd;
+ 	void *dbf;
+ 	struct dbmStack *next;
+ } dbmStack;
+ 
+ typedef struct FileStack {
+ #if PHP_HAVE_MMAP
+ 	caddr_t pa;
+ #else
+ 	FILE *fp;
+ 	char *pa;
+ #endif
+ 	int fd;
+ 	long size;
+ 	long pos;
+ 	int state;
+ 	int lstate;
+ 	int lineno;
+ 	char *filename;
+ 	struct FileStack *next;
+ } FileStack;
+ 
+ typedef struct FrameStack {
+ 	VarTree *frame;
+ 	struct FrameStack *next;
+ } FrameStack;
+ 
+ typedef struct FuncArgList {
+ 	char *arg;
+ 	struct FuncArgList *next;
+ 	struct FuncArgList *prev;
+ } FuncArgList;
+ 
+ typedef struct FuncStack {
+ 	char *name;
+ 	long size;
+ 	char *buf;
+ 	VarTree *frame;
+ 	FuncArgList *params;	
+ 	struct FuncStack *next;
+ } FuncStack;
+ 
+ typedef struct CounterStack {
+ 	int inif;
+ 	int inwhile;
+ 	struct CounterStack *next;
+ } CounterStack;
+ 
+ typedef struct FpStack {
+ 	FILE *fp;
+ 	char *filename;
+ 	int id;
+ 	int type;
+ 	struct FpStack *next;
+ } FpStack;
+ 
+ typedef struct AccessInfo {
+ 	int def;
+ 	int mode;
+ 	char *password;
+ 	int type;
+ 	char *patt;
+ 	struct AccessInfo *next;
+ } AccessInfo;
+ 
+ typedef struct PtrStack {
+ 	void *ptr;
+ 	struct PtrStack *next;
+ } PtrStack;
+ 
+ typedef struct CookieList {
+ 	char *name;
+ 	char *value;
+ 	time_t expires;
+ 	char *path;
+ 	char *domain;
+ 	int secure;		
+ 	struct CookieList *next;
+ } CookieList;
+ 
+ #ifndef APACHE
+ typedef struct pool {
+   union php_block_hdr *first;
+   union php_block_hdr *last;
+   struct cleanup *cleanups;
+   struct process_chain *subprocesses;
+   struct pool *sub_pools;
+   struct pool *sub_next;
+   struct pool *sub_prev;
+   struct pool *parent;
+   char *free_first_avail;
+ } pool;
+ #endif
+ /* Prototypes */
+ 
+ /* error.c */
+ void Debug(char *, ...);
+ void Error(char *, ...);
+ void CloseDebug(void);
+ int  ErrorPrintState(int);
+ void SetErrorReporting(void);
+ void php_init_error(void);
+ 
+ /* lex.c */
+ void ParserInit(int, long, int, char *);
+ int yylex(YYSTYPE *);
+ void yyerror(char *);
+ void WhileAgain(long, int, int);
+ void Include(void);
+ void Exit(int);
+ char *GetCurrentLexLine(int *, int *);
+ void InitFunc(void);
+ void DefineFunc(char *);
+ FuncStack *FindFunc(char *, long *, VarTree **);
+ void RunFunc(char *);
+ VarTree *GetFuncFrame(void);
+ void AddToArgList(char *);
+ FuncArgList *GetFuncArgList(void);
+ void ClearFuncArgList(void);
+ void Return(void);
+ void php_init_lex(void);
+ void IntFunc(char *);
+ int NewWhileIteration(long);
+ void Eval(void);
+ void set_text_magic(int);
+ void PushCounters(void);
+ void PopCounters(void);
+ void SetHeaderCalled(void);
+ long GetSeekPos(void);
+ 
+ /* date.c */
+ void Date(int, int);
+ void UnixTime(void);
+ void MkTime(int);
+ char *std_date(time_t);
+ 
+ /* parse.c */
+ int yyparse(void);
+ void php_init_yacc(void);
+ 
+ /* calc.c */
+ int Calc(int);
+ int CalcInc(int);
+ void Neg(void);
+ void BinDec(void);
+ void DecBin(void);
+ void DecHex(void);
+ long _HexDec(char *);
+ void HexDec(void);
+ long _OctDec(char *);
+ void OctDec(void);
+ void DecOct(void);
+ void Sin(void);
+ void Cos(void);
+ void Tan(void);
+ void Sqrt(void);
+ void Exp(void);
+ void mathLog(void);
+ void mathLog10(void);
+ void Abs(void);
+ void Pow(void);
+ 
+ /* stack.c */
+ void Push(char *, int);
+ Stack *Pop(void);
+ void ClearStack(void);
+ void php_init_stack(void);
+ 
+ /* var.c */
+ void php_init_symbol_tree(void);
+ void SetVar(char *, int, int);
+ VarTree *GetVar(char *, char *, int);
+ void IsSet(char *);
+ char *SubVar(char *);
+ void Count(void);
+ void ArrayMax(void);
+ void ArrayMin(void);
+ void PutEnv(void);
+ void GetEnv(void);
+ void PtrPush(void *);
+ void *PtrPop(void);
+ void SecureVar(void);
+ void Reset(char *);
+ void Key(char *);
+ void Next(char *);
+ void Prev(char *);
+ void End(char *);
+ void PushStackFrame(void);
+ void PopStackFrame(void);
+ void Global(void);
+ void copyarray(VarTree *, VarTree *);
+ void deletearray(VarTree *);
+ void UnSet(char *);
+ 
+ /* echo.c */
+ void Echo(char *, int);
+ void StripSlashes(char *);
+ void StripDollarSlashes(char *);
+ char *AddSlashes(char *, int);
+ void ParseEscapes(char *);
+ void HtmlSpecialChars(void);
+ int FormatCheck(char **, char **, char **);
+ void _AddSlashes(void);
+ void _StripSlashes(void);
+ 
+ /* cond.c */
+ int Compare(int);
+ void If(void);
+ void Else(void);
+ void ElseIf(void);
+ void EndIf(void);
+ void Not(void);
+ int Logic(int);
+ int GetCurrentState(int *);
+ int GetCurrentActive(void);
+ void ClearCondStack(void);
+ void CondPush(int, int);
+ void CondChange(int, int);
+ int CondPop(int *);
+ int CondPeek(int *);
+ int CheckCond(Stack *);
+ void PushCondMatchMarks(void);
+ void PopCondMatchMarks(void);
+ void php_init_cond(void);
+ void BracePush(int);
+ int BracePop(void);
+ int BraceCheck(void);
+ 
+ /* switch.c */
+ void Switch(void);
+ void EndSwitch(void);
+ void Case(void);
+ void Break(void);
+ void Default(void);
+ void PushSwitchMark(void);
+ void PopSwitchMark(void);
+ void php_init_switch(void);
+ 
+ /* alloc.c */
+ void *Emalloc(char *, int, int);
+ void Efree(char *, int, void *);
+ char *Estrdup(char *, int, char *);
+ 
+ /* db.c */
+ void ListSupportedDBs(void);
+ void dbmOpen(void);
+ int _dbmOpen(char *, char *);
+ void dbmClose(void);
+ int _dbmClose(char *);
+ void dbmCloseAll(void);
+ void dbmInsert(void);
+ int _dbmInsert(char *, char *, char *);
+ void dbmReplace(void);
+ int _dbmReplace(char *, char *, char *);
+ void dbmFetch(void);
+ char *_dbmFetch(char *, char *);
+ void dbmExists(void);
+ int _dbmExists(char *, char *);
+ void dbmDelete(void);
+ int _dbmDelete(char *, char *);
+ void dbmFirstKey(void);
+ char *_dbmFirstKey(char *);
+ void dbmNextKey(void);
+ char *_dbmNextKey(char *, char *);
+ void php_init_db(void);
+ 
+ /* while.c */
+ void WhilePush(long, int, int);
+ WhileStack *WhilePop(void);
+ void While(long);
+ void EndWhile(void);
+ void PushWhileMark(void);
+ void PopWhileMark(void);
+ void php_init_while(void);
+ void WhileFinish(void);
+ 
+ /* string.c */
+ void StrLen(void);
+ void StrVal(void);
+ void IntVal(void);
+ void DoubleVal(void);
+ void StrTok(int);
+ char *_strtoupper(char *);
+ void StrToUpper(void);
+ char *_strtolower(char *);
+ void StrToLower(void);
+ void StrStr(void);
+ void StrrChr(void);
+ void SetType(void);
+ void GetType(void);
+ void SubStr(void);
+ void UrlEncode(void);
+ void UrlDecode(void);
+ char *php_urlencode(char *);
+ void Ord(void);
+ void QuoteMeta(void);
+ void UcFirst(void);
+ void Sprintf(void);
+ void Chr(void);
+ 
+ /* msql.c */
+ void Msql(void);
+ void MsqlResult(void);
+ void MsqlClose(void);
+ void MsqlConnect(void);
+ void MsqlFreeResult(void);
+ void MsqlNumRows(void);
+ void MsqlNumFields(void);
+ void MsqlField(int);
+ void MsqlRegCase(void);
+ int  msqlGetDbSock(void);
+ void msqlSetCurrent(int, char *);
+ void MsqlListTables(void);
+ void MsqlListFields(void);
+ void MsqlTableName(void);
+ void MsqlListDBs(void);
+ void MsqlDBName(void);
+ void MsqlDropDB(void);
+ void MsqlCreateDB(void);
+ void php_init_msql(void);
+ 
+ /* pg95.c */
+ void PGcloseAll(void);
+ void PGexec(void);
+ void PG_result(void);
+ void PGconnect(void);
+ void PGclose(void);
+ void PGnumRows(void);
+ void PGnumFields(void);
+ void PGfieldName(void);
+ void PgfieldNum(void);
+ void PGfieldType(void);
+ void PGfieldLen(void);
+ void PGhost(void);
+ void PGdbName(void);
+ void PGoptions(void);
+ void PGport(void);
+ void PGtty(void);
+ void PGfreeResult(void);
+ void PGfieldNum(void);
+ void PGfieldPrtLen(void);
+ void PGfieldSize(void);
+ void PGgetlastoid(void);
+ void PGerrorMessage(void);
+ void php_init_pg95(void);
+ 
+ /* reg.c */
+ void RegMatch(char *, int);
+ void RegReplace(void);
+ char *_RegReplace(char *, char *, char *);
+ void EReg(char *, int);
+ void ERegReplace(void);
+ void ERegiReplace(void);
+ char *_ERegReplace(char *, char *, char *, int);
+ char *reg_eprint(int);
+ 
+ /* exec.c */
+ void Exec(char *, char *, int);
+ void EscapeShellCmd(void);
+ 
+ /* file.c */
+ int OpenFile(char *, int, long *);
+ char *GetCurrentFilename(void);
+ void SetCurrentFilename(char *);
+ long GetCurrentFileSize(void);
+ void SetCurrentFileSize(long);
+ char *FixFilename(char *, int, int *);
+ char *getfilename(char *, int);
+ void FileFunc(int);
+ void TempNam(void);
+ void Link(void);
+ void SymLink(void);
+ void ReadLink(void);
+ void LinkInfo(void);
+ void Unlink(void);
+ void Rename(void);
+ void Sleep(void);
+ void USleep(void);
+ void Fopen(void);
+ void Fclose(void);
+ void Fputs(void);
+ void Fgets(void);
+ void Fgetss(void);
+ void Rewind(void);
+ void Fseek(void);
+ void Ftell(void);
+ char *GetCurrentPI(void);
+ void SetCurrentPI(char *);
+ void SetCurrentPD(char *);
+ void ChMod(void);
+ void ChOwn(void);
+ void ChGrp(void);
+ void MkDir(void);
+ void RmDir(void);
+ int  FpPush(FILE *, char *, int);
+ void File(void);
+ void php_init_file(void);
+ void set_path_dir(char *);
+ void Popen(void);
+ void Pclose(void);
+ void Feof(void);
+ void FpCloseAll(void);
+ #if APACHE
+ void Virtual(void);
+ #endif
+ 
+ /* crypt.c */
+ void Crypt(int);
+ 
+ /* head.c */
+ void Header(void);
+ void php_header(int, char *);
+ void php_init_head(void);
+ void SetCookie(int);
+ void PushCookieList(char *, char *, time_t, char *, char *, int);
+ CookieList *PopCookieList(void);
+ 
+ /* info.c */
+ void Info(void);
+ void ShowPageInfo(void);
+ void PHPVersion(void);
+ 
+ /* post.c */
+ void TreatData(int);
+ void parse_url(char *);
+ void TreatHeaders(void);
+ 
+ /* type.c */
+ int CheckType(char *);
+ int CheckIdentType(char *);
+ char *GetIdentIndex(char *);
+ 
+ /* conf.c */
+ #if APACHE
+ void Configuration(void);
+ #else
+ void Configuration(int, char **);
+ #endif
+ 
+ /* acc.c */
+ AccessInfo *StrtoAccess(char *);
+ void PostToAccessStr(char *);
+ void AddRule(char *);
+ void AddFile(char *, char *);
+ void ChkPostVars(char *);
+ int CheckAccess(char *, long);
+ void ShowBanPage(char *);
+ void ShowEmailPage(char *);
+ void ShowPasswordPage(char *);
+ char *getremotehostname(void);
+ char *getemailaddr(void);
+ char *getrefdoc(void);
+ char *getbrowser(void);
+ int getlogging(void);
+ void setlogging(int);
+ void SetLogging(void);
+ int getshowinfo(void);
+ void setshowinfo(int);
+ void SetShowInfo(void);
+ void GetAccDir(void);
+ char *getaccdir(void);
+ #if APACHE
+ void php_init_acc(php_module_conf *);
+ #else
+ void php_init_acc(void);
+ #endif
+ 
+ /* dns.c */
+ void GetHostByAddr(void);
+ const char *_GetHostByAddr(char *);
+ void GetHostByName(void);
+ char *_GetHostByName(char *);
+ 
+ /* log.c */
+ void Log(char *);
+ char *getlastemailaddr(void);
+ char *getlasthost(void);
+ char *getlastbrowser(void);
+ char *getlastref(void);
+ char *getlogfile(void);
+ time_t getlastaccess(void);
+ time_t getstartlogging(void);
+ time_t getlastmod(void);
+ int gettotal(void);
+ int gettoday(void);
+ void loadlastinfo(char *, char *);
+ void GetLastEmail(void);
+ void GetLastBrowser(void);
+ void GetLastHost(void);
+ void GetLastAccess(void);
+ void GetStartLogging(void);
+ void GetLastRef(void);
+ void GetLogFile(void);
+ void GetLastMod(void);
+ void GetTotal(void);
+ void GetToday(void);
+ void GetLogDir(void);
+ char *getlogdir(void);
+ void GetMyUid(void);
+ void GetMyInode(void);
+ void SetStatInfo(struct stat *);
+ void GetMyPid(void);
+ long getmyuid(void);
+ void MsqlLog(char *);
+ void msqlloadlastinfo(char *);
+ #if APACHE
+ void php_init_log(php_module_conf *);
+ #else
+ void php_init_log(void);
+ #endif
+ 
+ /* sort.c */
+ void Sort(void);
+ 
+ /* dir.c */
+ void OpenDir(void);
+ void CloseDir(void);
+ void RewindDir(void);
+ void ReadDir(void);
+ void ChDir(void);
+ void php_init_dir(void);
+ 
+ /* rand.c */
+ void Srand(void);
+ void Rand(void);
+ void GetRandMax(void);
+ 
+ /* gd.c */
+ void ImageCreate(void);
+ void ImageCreateFromGif(void);
+ void ImageDestroy(void);
+ void ImageGif(int);
+ void ImageSetPixel(void);
+ void ImageLine(void);
+ void ImageRectangle(void);
+ void ImageFilledRectangle(void);
+ void ImageArc(void);
+ void ImageFillToBorder(void);
+ void ImageFill(void);
+ void ImageColorAllocate(void);
+ void ImageColorTransparent(void);
+ void ImageInterlace(void);
+ void ImagePolygon(int);
+ void ImageChar(int);
+ void ImageCopyResized(void);
+ void php_init_gd(void);
+ void ImageSXFN(void);
+ void ImageSYFN(void);
+ 
+ /* mime.c */
+ void mime_split(char *, int, char *);
+ #if APACHE
+ void php_init_mime(php_module_conf *);
+ #endif
+ 
+ /* fsock.c */
+ void FSockOpen(void);
+ 
+ /* microtime.c */
+ void MicroTime(void);
+ 
+ /* pool.c */
+ void *php_pool_alloc(
+ #if DEBUG
+ char *, int,
+ #endif
+ int,int);
+ char *php_pool_strdup(
+ #if DEBUG
+ char *, int,
+ #endif
+ int,char *);
+ #ifndef APACHE
+ void php_pool_free(int);
+ #endif
+ void php_pool_clear(int);
+ #if DEBUG
+ void php_pool_show(void);
+ #endif
+ #if APACHE
+ void php_init_pool(php_module_conf *);
+ #else
+ void php_init_pool(void);
+ void *php_palloc(struct pool *, int nbytes);
+ void *php_pcalloc(struct pool *, int nbytes);
+ char *php_pstrdup(struct pool *, const char *s);
+ struct pool *php_make_sub_pool(struct pool *);
+ void php_clear_pool(struct pool *);
+ void php_destroy_pool(struct pool *);
+ #endif
+ 
+ /* local.c */
+ #ifndef HAVE_STRCASECMP
+ int strcasecmp(char *, char *);
+ int strncasecmp(char *, char *, int);
+ #endif
+ #ifndef HAVE_STRDUP
+ char *strdup(char *);
+ #endif
+ #ifndef HAVE_STRERROR
+ char *strerror(int);
+ #endif
+ 
+ /* kanjiconv.c */
+ void KanjiConv(void);
+ 
diff -c -r -N php-2.0b7/src/post.c kanji-php/src/post.c
*** php-2.0b7/src/post.c	Mon Sep 23 07:11:52 1996
--- kanji-php/src/post.c	Mon Dec  9 02:21:01 1996
***************
*** 259,264 ****
--- 259,265 ----
  			}
  			parse_url(s);
  			dot_to_underscore(s);
+ 			conv2euc(s);
  			itype = CheckIdentType(s);
  			if(itype==2) {
  				ind=GetIdentIndex(s);
diff -c -r -N php-2.0b7/src/stoe.c kanji-php/src/stoe.c
*** php-2.0b7/src/stoe.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/stoe.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,80 ----
+ /*
+  *	Sift_JIS ----&gt; EUC  Convert Routine
+  */
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ 
+ #include &lt;string.h&gt;
+ 
+ #define	SS2		0x8e	/* Hankaku Kana */
+ 
+ static
+ sj_to_euc(sj1,sj2,euc1,euc2)
+      register unsigned char sj1,sj2,*euc1,*euc2;
+ {
+   if (sj1 &gt;= 0xe0) /* The 2nd standard of JIS */
+     sj1 -=  0x40;
+   
+   if (sj2 &gt;= 0x9f) {
+     *euc1 = (sj1 - 0x88)*2 + 0xb0;
+     *euc2 = sj2 + 0x02;
+   }
+   else {
+     if (sj2 &gt;= 0x7f)
+       sj2 -= 0x01;
+     *euc1 = (sj1 - 0x89)*2 + 0xb1;
+     *euc2 = sj2 + 0x61;
+   }
+ }
+ 
+ void
+ stoe(unsigned char *dest, const unsigned char *src)
+ {
+   register int stat;
+   register unsigned char c,c1;
+   unsigned char s1,s2;
+   
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if((c&gt;=0x81 &amp;&amp; c&lt;=0x9f) || (c&gt;=0xe0 &amp;&amp; c&lt;=0xfc)) {
+ 	c1 = c; /* ZENKAKU */
+ 	stat = 1;
+       }
+       else if((0xa1 &lt;= c) &amp;&amp; (c &lt;= 0xdf)){ /* Hankaku Kana */
+ 	dest[pos++]=SS2;
+ 	dest[pos++]=c;
+       }
+       else /* ASCII */
+ 	dest[pos++]=c;
+       break;
+     case 1:
+       stat = 0;
+       sj_to_euc(c1,c,&amp;s1,&amp;s2); /* Change Shift_JIS into EUC */
+       dest[pos++]=s1;
+       dest[pos++]=s2;
+       break;
+     }
+   }
+ 
+   /* terminate */
+   dest[pos]='\0';
+ 
+ }
+ 
diff -c -r -N php-2.0b7/src/stoj.c kanji-php/src/stoj.c
*** php-2.0b7/src/stoj.c	Thu Jan  1 09:00:00 1970
--- kanji-php/src/stoj.c	Mon Dec  9 02:21:02 1996
***************
*** 0 ****
--- 1,127 ----
+ /*								*/
+ /*	stoj.c	2.0	62.06.17	by shige@csk.JUNET	*/
+ /*								*/
+ /*	stoj	SJIS code convert into JIS code.		*/
+ /*								*/
+ /*		KI	KO					*/
+ /*		^[$B	^[(B	JIS 83				*/
+ /*								*/
+ 
+ /************************************************************************/
+ /*                                                                      */
+ /* Modified (a lot ;-) by o3(mitsu@tramp.co.jp)                         */
+ /*   adding this to PHP/FI as internal function                         */
+ /*                                                                      */
+ /************************************************************************/
+ 
+ #include &lt;string.h&gt;
+ 
+ #define ESC '\033'
+ #define KI1 '$'
+ #define KI2 'B'
+ #define KO1 '('
+ #define KO2 'B'
+ #define	KANAIN	0x0e
+ #define	KANAOUT	0x0f
+ 
+ static void
+ SJIS_JIS(sjis1,sjis2,jis1,jis2)
+      register unsigned char sjis1,sjis2,*jis1,*jis2;
+ {
+   if (sjis1 &gt;= 0xe0)	/* The 2nd standard of JIS */
+     sjis1 -=  0x40;
+ 	
+   if (sjis2 &gt;= 0x9f) {
+     *jis1 = (sjis1 - 0x88)*2 + 0x30;
+     *jis2 = sjis2 - 0x7e;
+   }
+   else {
+     if (sjis2 &gt;= 0x7f)
+       sjis2 -= 0x01;
+     *jis1 = (sjis1 - 0x89)*2 + 0x31;
+     *jis2 = sjis2 - 0x1f;
+   }
+ }
+ 
+ void
+ stoj(char *dest, const char *src)
+ {
+   register int stat;
+   register unsigned char c,c1,c2;
+   unsigned char s1,s2;
+ 
+   int i,pos;
+ 
+   if(src==NULL || !strlen(src)){
+     dest[0]='\0';
+     return;
+   }
+ 
+   i=0;
+   pos=0;
+   stat = 0;
+   while ((c = src[i++]) != '\0') {
+     switch (stat) {
+     case 0:
+       if((c&gt;=0x81 &amp;&amp; c&lt;=0x9f) || (c&gt;=0xe0 &amp;&amp; c&lt;=0xfc)) {
+ 	c1 = c;	           
+ 	stat = 1;
+ 	dest[pos++]=ESC; /* put KANJI-IN */
+ 	dest[pos++]=KI1;
+ 	dest[pos++]=KI2;
+       }
+       else if((0xa1 &lt;= c) &amp;&amp; (c &lt;= 0xdf)) { /* hankaku kana */
+ 	dest[pos++]=KANAIN;
+ 	c &amp;= 0x7f;
+ 	dest[pos++]=c;
+ 	stat = 3;
+       }
+       else
+ 	dest[pos++]=c; /* put ASCII code */
+       break;
+     case 1:
+       stat = 2;
+       c2 = c;
+       SJIS_JIS(c1,c2,&amp;s1,&amp;s2);  /* change shift-JIS into JIS */
+       dest[pos++]=s1; /* put KANJI code */
+       dest[pos++]=s2;
+       break;
+     case 2:
+       if((c&gt;=0x81 &amp;&amp; c&lt;=0x9f) || (c&gt;=0xe0 &amp;&amp; c&lt;=0xfc)) {
+ 	c1 = c;	           
+ 	stat = 1;
+       } else {
+ 	dest[pos++]=ESC; /* put KANJI-OUT */
+ 	dest[pos++]=KO1;
+ 	dest[pos++]=KO2;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     case 3:				 /* hankaku kana */
+       if((0xa1 &lt;= c) &amp;&amp; (c &lt;= 0xdf)) {
+ 	c &amp;= 0x7f;
+ 	dest[pos++]=c;
+       }
+       else {
+ 	dest[pos++]=KANAOUT;
+ 	i--;
+ 	stat = 0;
+       }
+       break;
+     }
+   }
+   if ( stat == 1 || stat == 2 ) {
+     /* put KANJI-OUT */
+     dest[pos++]=ESC;
+     dest[pos++]=KO1;
+     dest[pos++]=KO2;
+   }
+   else if (stat == 3)
+     dest[pos++]=KANAOUT;
+ 
+   /* terminate */
+   dest[pos]='\0';
+ 
+ }
+ 

======================================================================
ここまで

== おみつ
<HR>
</PRE>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>トランザクションの分離</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="同時実行制御"
HREF="mvcc.html"><LINK
REL="PREVIOUS"
TITLE="序文"
HREF="mvcc-intro.html"><LINK
REL="NEXT"
TITLE="明示的ロック"
HREF="explicit-locking.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="序文"
HREF="mvcc-intro.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 13章同時実行制御</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="明示的ロック"
HREF="explicit-locking.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TRANSACTION-ISO"
>13.2. トランザクションの分離</A
></H1
><P
><ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の標準規格では、トランザクションの分離について4つのレベルを定義しています。
標準規格で定義されているもののうち最も厳密なものはシリアライザブルです。
1セットのシリアライザブルなトランザクションを同時実行した場合には、ある順番でひとつずつそれらを実行した場合と同じ結果となることが保証されるものです。本文で詳しく述べます。
他の3レベルは、同時実行しているトランザクション間の相互作用に起因する、各レベルでは発生してはならない現象面に基づき定義されます。
標準規格のシリアライザブルの定義では、このレベルではこれらの現象が起こりえないと述べています。
(これは驚くことではありません。トランザクションの効果がひとつずつ実行された場合と一貫性を持たなければならないとしたら、相互作用によって発生した現象はどうやっても見つけ出すことはできないでしょう。)
   </P
><P
>各種レベルにおける禁止される現象を以下に示します。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>ダーティリード
       </DT
><DD
><P
>同時に実行されている他のトランザクションが書き込んで未だコミットしていないデータを読み込んでしまう。
       </P
></DD
><DT
>反復不能読み取り
       </DT
><DD
><P
>トランザクションが、以前読み込んだデータを再度読み込み、そのデータが(最初の読み込みの後にコミットした)別のトランザクションによって更新されたことを見出す。
       </P
></DD
><DT
>ファントムリード
       </DT
><DD
><P
>トランザクションが、複数行のある集合を返す検索条件で問い合わせを再実行した時、別のトランザクションがコミットしてしまったために、同じ検索条件で問い合わせを実行しても異なる結果を得てしまう。
       </P
></DD
><DT
>直列化異常
       </DT
><DD
><P
>複数のトランザクションを正常にコミットした結果が、それらのトランザクションを1つずつあらゆる可能な順序で実行する場合とは一貫性がない。
       </P
></DD
></DL
></DIV
><P>
   </P
><P
>    
標準SQLおよびPostgreSQLで実装されているトランザクション分離レベルを<A
HREF="transaction-iso.html#MVCC-ISOLEVEL-TABLE"
>表13-1</A
>に示します。
   </P
><DIV
CLASS="TABLE"
><A
NAME="MVCC-ISOLEVEL-TABLE"
></A
><P
><B
>表 13-1. トランザクション分離レベル</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>分離レベル
        </TH
><TH
>ダーティリード
        </TH
><TH
>反復不能読み取り
        </TH
><TH
>ファントムリード
        </TH
><TH
>直列化異常
        </TH
></TR
></THEAD
><TBODY
><TR
><TD
>リードアンコミッティド
        </TD
><TD
>許容されるが、PostgreSQLでは発生しない
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
></TR
><TR
><TD
>リードコミッティド
        </TD
><TD
>安全
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
></TR
><TR
><TD
>リピータブルリード
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
><TD
>許容されるが、PostgreSQLでは発生しない
        </TD
><TD
>可能性あり
        </TD
></TR
><TR
><TD
>シリアライザブル
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
></TR
></TBODY
></TABLE
></DIV
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、4つの標準トランザクション分離レベルを全て要求することができます。
しかし、内部的には3つの分離レベルしか実装されていません。
つまり、PostgreSQLのリードアンコミッティドモードは、リードコミッティドのように動作します。
これは、PostgreSQLの多版型同時実行制御という仕組みに標準の分離レベルを関連付ける実際的な方法がこれしかないからです。
   </P
><P
>このテーブルはまた、PostgreSQLのリピータブルリードの実装ではファントムリードが起こらないことを示しています。
より厳密な動作をすることは標準SQLでも許されています。
つまり、この4つの分離レベルでは、発生してはならない事象のみが定義され、発生<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>しなければならない</I
></SPAN
>事象は定義されていません。
利用可能な分離レベルでの動作については後で詳細に説明します。
   </P
><P
>トランザクションのトランザクション分離レベルを設定するには<A
HREF="sql-set-transaction.html"
>SET TRANSACTION</A
>コマンドを使用してください。
   </P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>重要項目: </B
>いくつかの<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>データ型と関数はトランザクションの振る舞いに関して特別の規則があります。
特に、シーケンスに対しての変更は（従い、<TT
CLASS="TYPE"
>serial</TT
>を使用して宣言された列のカウンタ）は直後に全ての他のトランザクションで可視となり、変更を行ったトランザクションが中止されるとロールバックはできません。
<A
HREF="functions-sequence.html"
>項9.16</A
>および<A
HREF="datatype-numeric.html#DATATYPE-SERIAL"
>項8.1.4</A
>を参照してください。
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-READ-COMMITTED"
>13.2.1. リードコミッティド分離レベル</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では<I
CLASS="FIRSTTERM"
>リードコミッティド</I
>がデフォルトの分離レベルです。
トランザクションがこの分離レベルを使用すると、<TT
CLASS="COMMAND"
>SELECT</TT
>問い合わせ（<TT
CLASS="LITERAL"
>FOR UPDATE/SHARE</TT
>句を伴わない）はその問い合わせが実行される直前までにコミットされたデータのみを参照し、まだコミットされていないデータや、その問い合わせの実行中に別の同時実行トランザクションがコミットした更新は参照しません。
結果として、<TT
CLASS="COMMAND"
>SELECT</TT
>問い合わせはその問い合わせが実行を開始した時点のデータベースのスナップショットを参照することになります。
しかし<TT
CLASS="COMMAND"
>SELECT</TT
>文は、自分自身のトランザクション内で実行され更新された結果はたとえまだコミットされていなくても参照します。
単一のトランザクション内であっても、<TT
CLASS="COMMAND"
>SELECT</TT
>文を2回連続して発行した場合、最初の<TT
CLASS="COMMAND"
>SELECT</TT
>文が開始した後で2番目の<TT
CLASS="COMMAND"
>SELECT</TT
>文が開始する前に他のトランザクションが更新をコミットすると、最初とその次に発行した<TT
CLASS="COMMAND"
>SELECT</TT
>問い合わせは異なるデータを参照してしまうことにも注意してください。
   </P
><P
><TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>、<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>、および<TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
>コマンドは対象行を検索する際に<TT
CLASS="COMMAND"
>SELECT</TT
>コマンドと同じように振舞います。
これらのコマンドは、問い合わせが開始された時点で既にコミットされた対象行のみを検出します。
しかし、その対象行は、検出されるまでに、同時実行中の他のトランザクションによって、既に更新（もしくは削除あるいはロック）されてしまっているかもしれません。
このような場合更新されるべき処理は、最初の更新トランザクションが（それがまだ進行中の場合）コミットもしくはロールバックするのを待ちます。
最初の更新処理がロールバックされるとその結果は無視されて、2番目の更新処理で元々検出した行の更新を続行することができます。
最初の更新処理がコミットされると、2番目の更新処理では、最初の更新処理により行が削除された場合はその行を無視します。
行が削除されなかった時の更新処理は、最初のコミットで更新された行に適用されます。
コマンドの検索条件（<TT
CLASS="LITERAL"
>WHERE</TT
>句）は、更新された行がまだその検索条件に一致するかどうかの確認のため再評価されます。
検索条件と一致している場合、2番目の更新処理は、更新された行を使用して処理を開始します。
<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>および<TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
>の場合、ロックされクライアントに返されるのは、更新されるバージョンの行であることを意味します。
   </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>句のある<TT
CLASS="COMMAND"
>INSERT</TT
>は同じように動作します。
リードコミッティドモードでは、挿入を提案された各行は挿入または更新されます。
無関係なエラーが発生しなければ、それら2つの結果のうち1つが保証されます。
まだその結果が<TT
CLASS="COMMAND"
>INSERT</TT
>に対して可視になっていない他のトランザクションに起因する競合では、慣習的な意味でそのコマンドに対して可視のバージョンの行が存在<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>しない</I
></SPAN
>にも関わらず、<TT
CLASS="COMMAND"
>UPDATE</TT
>句がその行に対して動作します。
   </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT DO NOTHING</TT
>句のある<TT
CLASS="COMMAND"
>INSERT</TT
>では、<TT
CLASS="COMMAND"
>INSERT</TT
>のスナップショットに対してその結果が可視になっていない他のトランザクションの結果のために、行の挿入が処理されないかもしれません。
ここでも、問題になるのはリードコミッティドモードのときだけです。
   </P
><P
>このような仕組みにより、更新コマンドが、互いに矛盾したスナップショットを参照する可能性があります。
それは更新を試みている同じ行に対する同時実行更新の結果を参照しますが、データベース中の他の行に対する同時実行の問い合わせの結果は参照できません。
このような動作をするために複合検索条件を含む問い合わせにリードコミッティドモードを使用することは適切ではありません。
しかし、より単純な検索条件の場合、このモードの使用が適しています。
例えば、銀行の残高を更新する以下のようなトランザクションを考えてみます。

</P><PRE
CLASS="SCREEN"
>BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;</PRE
><P>

同時に実行される2つのトランザクションが、口座番号12345の残高を変更しようとした場合、口座12345の行の更新に伴って２番目のトランザクションを開始することは明らかに望まれるところです。
各コマンドが事前に決定していた行にのみ処理を行うため、更新されたバージョンの行は問題となる不整合を引き起こしません。
   </P
><P
>より複雑な用法によりリードコミッティドモードでは好ましくない結果を生成します。例えば、別のコマンドによりその制約条件から追加・削除の両方が行われようとしているデータに作用する<TT
CLASS="COMMAND"
>DELETE</TT
>コマンドを考えます。例を挙げると、<TT
CLASS="LITERAL"
>website</TT
>は２行のテーブルで、そこに<TT
CLASS="LITERAL"
>9</TT
> と <TT
CLASS="LITERAL"
>10</TT
>の値を持つ<TT
CLASS="LITERAL"
>website.hits</TT
>があります。

</P><PRE
CLASS="SCREEN"
>BEGIN;
UPDATE website SET hits = hits + 1;
-- 別のセッションから DELETE FROM website WHERE hits = 10; を実行します
COMMIT;</PRE
><P>

<TT
CLASS="COMMAND"
>UPDATE</TT
>前後に<TT
CLASS="LITERAL"
>website.hits = 10</TT
>行が存在したとしても<TT
CLASS="COMMAND"
>DELETE</TT
>は効果を生みません。なぜこうなるのかと言うと、事前更新された行の値<TT
CLASS="LITERAL"
>9</TT
>は読み飛ばされ、<TT
CLASS="COMMAND"
>UPDATE</TT
>が完了し、<TT
CLASS="COMMAND"
>DELETE</TT
>がロックを取得した時点では、新規行の値はもはや<TT
CLASS="LITERAL"
>10</TT
>ではなく<TT
CLASS="LITERAL"
>11</TT
>となり、判定基準にもはや一致しません。
   </P
><P
>リードコミッティドモードは、それぞれのコマンドをその時点までにコミットされた全てのトランザクションを含む新規スナップショットを伴って開始するので、同一のトランザクション内でそれに続くコマンドは、いかなる場合でもコミットされた同時実行トランザクションの結果を参照します。
上記問題の要点は<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>単一の</I
></SPAN
>コマンドがデータベースの厳密に一貫性のある見え方を見るか否かです。
   </P
><P
>リードコミッティドモードで提供されている部分的なトランザクション分離は、多くのアプリケーションでは適切です。
またこのモードは高速で、使い方も簡単ですが、全ての場合に対して充分ではありません。
複雑な問い合わせや更新を行うアプリケーションは、リードコミッティドモードが提供する以上のより厳正なデータベースの厳密に一貫性のある見え方を必要とします。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-REPEATABLE-READ"
>13.2.2. リピータブルリード分離レベル</A
></H2
><P
><I
CLASS="FIRSTTERM"
>リピータブルリード</I
>分離レベルは、トランザクションが開始される前までにコミットされたデータのみを参照します。
コミットされていないデータや、そのトランザクションの実行中に別のトランザクションでコミットされた変更を参照しません。
（しかし、まだコミットされていないとしても、その問い合わせはそのトランザクション自身内で行われた過去の更新を参照します。）
これは<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の標準規格で求められるものよりもより強く保証するもので、<A
HREF="transaction-iso.html#MVCC-ISOLEVEL-TABLE"
>表13-1</A
>で述べている現象をすべて防ぎます。上で述べたように、これは標準規格によって特に許容されており、それぞれの分離レベルが提供しなくてはならない<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>最小</I
></SPAN
>の保護が示されています。
   </P
><P
>リピータブルリードのトランザクション内の問い合わせは、トランザクション内の現在の文の開始時点ではなく、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>トランザクション</I
></SPAN
>の最初のトランザクション制御以外の文の開始時点のスナップショットを見る、という点でこのレベルはリードコミッティドと異なります。
従って、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>単一</I
></SPAN
>トランザクション内の連続する<TT
CLASS="COMMAND"
>SELECT</TT
>文は、同じデータを参照します。つまり、自身のトランザクションが開始した後にコミットされた他のトランザクションによる変更を参照しません。
   </P
><P
>このレベルを使ったアプリケーションでは、直列化の失敗によるトランザクションの再実行に備えておく必要があります。

   </P
><P
><TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>、<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>、および<TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
>コマンドでは、<TT
CLASS="COMMAND"
>SELECT</TT
>と同じように対象行を検索します。
これらのコマンドでは、トランザクションが開始された時点で既にコミットされている対象行のみを検出します。
しかし、その対象行は、検出されるまでに、同時実行中の他のトランザクションによって、既に更新（もしくは削除あるいはロック）されている可能性があります。
このような場合、リピータブルリードトランザクションは、最初の更新トランザクションが（それらがまだ進行中の場合）コミットもしくはロールバックするのを待ちます。
最初の更新処理がロールバックされると、その結果は無視され、リピータブルリードトランザクションでは元々検出した行の更新を続行することができます。
しかし、最初の更新処理がコミット（かつ、単にロックされるだけでなく、実際に行が更新または削除）されると、リピータブルリードトランザクションでは、以下のようなメッセージを出力してロールバックを行います。

</P><PRE
CLASS="SCREEN"
>ERROR:  could not serialize access due to concurrent update</PRE
><P>

これは、リピータブルリードトランザクションでは、トランザクションが開始された後に別のトランザクションによって更新されたデータは変更またはロックすることができないためです。
   </P
><P
>アプリケーションがこのエラーメッセージを受け取った場合、現在のトランザクションを中断して、トランザクション全体を始めからやり直されなければなりません。
2回目では、トランザクションはコミットされた変更を含めてデータベースの最初の状態とみなすので、新しいバージョンの行を新しいトランザクションにおける更新の始点としても、論理的矛盾は起こりません。
   </P
><P
>更新トランザクションのみ再実行する必要があるかもしれません。
読み込み専用トランザクションでは直列化の衝突は決して起こりません。
   </P
><P
>リピータブルリードモードでは、全てのトランザクションがデータベースの一貫した不変のビューの状態を参照することが保証されます。
しかし、このビューは常にいくつかの同じレベルの同時実行トランザクションの並列（一度に一つずつの）実行で一貫性を持つ必要はありません。
例えば、このレベルの読み取りのみのトランザクションは、バッチが完了したことを示すために更新された制御レコードを参照することができますが、
制御レコードのより以前のバージョンを読み取るため、論理的にそのバッチの一部となる詳細なレコードの１つを参照することは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>できません</I
></SPAN
>。
この分離レベルで実行するトランザクションによりビジネスルールを強制しようとすることは、競合するトランザクションをブロックするために注意深く明示的なロックを持たないと、正確に動作しないことが多くあります。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> version 9.1より前まででは、シリアライザブル分離レベルの要求はここで説明した通りの動作をそのまま提供していました。
以前のシリアライザブルの動作を維持するためには、リピータブルリードを要求しなければならなくなりました。
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-SERIALIZABLE"
>13.2.3. シリアライザブル分離レベル</A
></H2
><P
><I
CLASS="FIRSTTERM"
>シリアライザブル</I
>分離レベルは、最も厳しいトランザクションの分離性を提供します。
このレベルではトランザクションが同時にではなく、次から次へと、あたかも順に実行されているように逐次的なトランザクションの実行を全てのコミットされたトランザクションに対しエミュレートします。
しかし、このレベルを使ったアプリケーションでは、リピータブルリードレベルと同様に、直列化の失敗によるトランザクションの再実行に備えておく必要があります。
実際、この分離レベルは、（ある時点で）逐次実行可能なすべてのトランザクションにおいて、シリアライザブルトランザクションの同時実行の組が一貫性のないような振る舞いをしていないか監視することを除き、リピータブルリードと全く同じ動きをします。
この監視では、リピータブルリードが示すものを越えてブロックすることはありませんが、監視によりいくらかのオーバーヘッドがあり、<I
CLASS="FIRSTTERM"
>直列化異常</I
>を引き起こすような状態の検知は、<I
CLASS="FIRSTTERM"
>直列化の失敗</I
>を引き起こすでしょう。
   </P
><P
>例えば、以下の初期データを持つ<TT
CLASS="STRUCTNAME"
>mytab</TT
>というテーブルを考えてみます。
</P><PRE
CLASS="SCREEN"
> class | value
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200</PRE
><P>
ここでシリアライザブルトランザクションAが以下を計算し、
</P><PRE
CLASS="SCREEN"
>SELECT SUM(value) FROM mytab WHERE class = 1;</PRE
><P>
そして、<TT
CLASS="STRUCTFIELD"
>value</TT
>にその結果（30）を、<TT
CLASS="STRUCTFIELD"
>class</TT
><TT
CLASS="LITERAL"
> = 2</TT
>の行として新たに挿入したとします。
同時にシリアライザブルトランザクションBが以下を計算し、
</P><PRE
CLASS="SCREEN"
>SELECT SUM(value) FROM mytab WHERE class = 2;</PRE
><P>
その結果300を得、そして、この結果を<TT
CLASS="STRUCTFIELD"
>class</TT
><TT
CLASS="LITERAL"
> = 1</TT
>の新たな行として挿入したとします。
その後、両方のトランザクションがコミットを試みます。
もし一方の処理がリピータブルリード分離レベルで実行していれば、両方のコミットが許されるでしょう。
しかし、結果と一致する順序で実行されたものがないため、シリアライザブルトランザクションを使用した場合は、ひとつのトランザクションがコミットを許され、他方はこのメッセージとともにロールバックされることになります。

</P><PRE
CLASS="SCREEN"
>ERROR:  could not serialize access due to read/write dependencies among transactions</PRE
><P>

この理由は、もしAがBよりも前に実行が完了していた場合、Bの総和は300ではなく330と計算されるためです。
同様に別の順序で実行されたとしてもAで計算される総和は異なる結果になります。
   </P
><P
>異常を防止するためシリアライザブルトランザクションを信頼するのであれば、トランザクションが有効にコミットされたとそのトランザクションが認められるまで、恒久的なユーザテーブルから読み取られたいかなるデータも有効とは認められない点は重要です。
読み込まれて直ぐに<I
CLASS="FIRSTTERM"
>deferrable</I
>読み取り専用トランザクション内で読み込まれたデータを除いて、このことは読み取り専用トランザクションであっても真実です。
何故かと言うと、それらのトランザクションは他のデータを読み込む前に言われる問題から免がれている保証付きのスナップショットを取得可能となるまで待機するからです。
その他の全ての場合、後に中断されるトランザクションにおいて読み込まれた結果をアプリケーションは信用してはならないことです。
その代わりとして、アプリケーションはトランザクションが成功するまで再試行すべきです。
   </P
><P
>真の直列性を保証するために<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、最初に走らせた、同時実行トランザクションより前に読み取った結果に対して、書き込みがいつ影響を及ぼしたかを断定可能にするロックを保持することを意味する、<I
CLASS="FIRSTTERM"
>述語ロック</I
>を使います。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、これらのロックはブロッキングを引き起こさないため、デッドロックの要因となら<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ない</I
></SPAN
>ものです。
それらは、同時実行中のシリアライザブルトランザクションが、直列化異常につながる組み合わせであることを識別しフラグを立てることに使用されます。

それとは対照的に、データの一貫性を保証したいリードコミッティドあるいはリピータブルリードトランザクションでは、(そのテーブルを使用しようとしている他のユーザをブロックすることができた)テーブル全体のロックを必要とするかもしれません。あるいは、他のトランザクションをブロックするだけでなくディスク・アクセスを引き起こす<TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
>あるいは<TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>を使用するかもしれません。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の述語ロックは、他のほとんどのデータベースシステムと同様、トランザクションによって実際にアクセスされたデータを元にしています。
これらは、<TT
CLASS="LITERAL"
>SIReadLock</TT
>の<TT
CLASS="LITERAL"
>mode</TT
>を持つ<A
HREF="view-pg-locks.html"
><TT
CLASS="STRUCTNAME"
>pg_locks</TT
></A
>システムビューで見ることができます。
問い合わせの実行期間中に獲得した特殊なロックは、問い合わせが使用した計画に依存するでしょう。また、ロックを追跡するために使用されるメモリの消耗を防ぐために、多数のよりきめの細かいロック(例えばタプル・ロック)はトランザクションの間に、より少数のよりきめの粗いロック(例えばページ・ロック)へ組み合わせられるかもしれません。
直列化異常につながるような競合が継続して生じないことを検知すると、<TT
CLASS="LITERAL"
>READ ONLY</TT
>トランザクションが完了する前にSIReadロックを解除するかもしれません。
実際、<TT
CLASS="LITERAL"
>READ ONLY</TT
>トランザクションは、よく開始時点でその事実を確証し、どんな述語ロックもとらないこともあります。<TT
CLASS="LITERAL"
>SERIALIZABLE READ ONLY DEFERRABLE</TT
>トランザクションを明示的に要求した場合には、この事実を確証できるまでブロックします。(これは、シリアライザブルトランザクションはブロックするけれども、リピータブルリードトランザクションはブロックしない<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>唯一</I
></SPAN
>のケースです。)
他方で、SIReadロックは、しばしば読み取りと書き込みが重なっているトランザクションが完了するまで、過去のトランザクションのコミットに保持される必要があります。
   </P
><P
>シリアライザブルトランザクションの一貫した使用は開発を単純化することができます。
同時実行したシリアライザブルトランザクションのどんなセットも同じ効果があるという保証は、あたかも、それらが一度に実行されたものだったかのように、単一のトランザクションとして証明できることを意味します。
これは、単独で実行された場合に正しく動作するよう書かれている場合、シリアライザブルトランザクションが混在していても正しく動作する確証を持つことができます。
この技術を使用する環境で、直列化の失敗('40001'のSQLSTATEの値で常に返る)を扱う場合、一般的な手段を持っていることは重要です。
なぜなら、トランザクションが読み取り/書き込みの依存性にどれだけ影響する可能性があるかということと、直列化異常を防ぐためにロールバックさせる必要があるかといこうとを、正確に予測することは非常に困難だからです。
読み取り/書き込みの依存性を監視したり、直列化異常で終了したトランザクションを再起動することはコストがかかります。
しかしながら、このコストと、明示的なロックと<TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
>または<TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>を使用したブロッキングとで比較検討すると、シリアライザブルトランザクションはいくつかの環境において最良な実行を選択することになります。
   </P
><P
>    While <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>'s Serializable transaction isolation
    level only allows concurrent transactions to commit if it can prove there
    is a serial order of execution that would produce the same effect, it
    doesn't always prevent errors from being raised that would not occur in
    true serial execution.  In particular, it is possible to see unique
    constraint violations caused by conflicts with overlapping Serializable
    transactions even after explicitly checking that the key isn't present
    before attempting to insert it.  This can be avoided by making sure
    that <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>all</I
></SPAN
> Serializable transactions that insert potentially
    conflicting keys explicitly check if they can do so first.  For example,
    imagine an application that asks the user for a new key and then checks
    that it doesn't exist already by trying to select it first, or generates
    a new key by selecting the maximum existing key and adding one.  If some
    Serializable transactions insert new keys directly without following this
    protocol, unique constraints violations might be reported even in cases
    where they could not occur in a serial execution of the concurrent
    transactions.
   </P
><P
>同時実行制御のためにシリアライザブルトランザクションを使用する場合、最適に実行するためには、以下の問題を考慮すべきです。

    <P
></P
></P><UL
><LI
><P
>できる限り<TT
CLASS="LITERAL"
>READ ONLY</TT
>として宣言してください。
      </P
></LI
><LI
><P
>もし必要ならばコネクションプールを使用して、活動中の接続数を制御してください。
これは常に重要な実行時の考慮点ですが、シリアライザブルトランザクションを使用した多忙なシステムにおいては、特に重要になる可能性があります。
      </P
></LI
><LI
><P
>完全性を目的とした必要以上の単一トランザクションを置かないようにしてください。
      </P
></LI
><LI
><P
>必要以上に長く<SPAN
CLASS="QUOTE"
>"トランザクション内で待機状態"</SPAN
>で接続したまま放置しておかないようにしてください。 ★変更あり
      </P
></LI
><LI
><P
>シリアライザブルトランザクションにより自動的に提供される保護により、不必要な、明示的なロック、<TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
>および<TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>を取り除いてください。
      </P
></LI
><LI
><P
>システムが、単一の関係レベルでの述語ロックに、多数のページレベルでの述語ロックを組み合わせることを強いられる場合、述語ロックのテーブルはメモリが不足するため、直列化失敗の割合が増加する恐れがあります。
これは、<A
HREF="runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-TRANSACTION"
>max_pred_locks_per_transaction</A
>を増やすことにより回避することができます。
      </P
></LI
><LI
><P
>シーケンシャルスキャンは常にリレーションレベルでの述語ロックを必要とします。
これによって、直列化失敗の頻度が増える可能性があります。
<A
HREF="runtime-config-query.html#GUC-RANDOM-PAGE-COST"
>random_page_cost</A
>を縮小および(または)<A
HREF="runtime-config-query.html#GUC-CPU-TUPLE-COST"
>cpu_tuple_cost</A
>を増加することによりインデックススキャンの使用を促進することは有用かもしれません。
問い合わせ実行時間の全体的な変化に不利となる、トランザクションのロールバックや再起動を減少させるように、必ず検討してください。
      </P
></LI
></UL
><P>
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="mvcc-intro.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="explicit-locking.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>序文</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>明示的ロック</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
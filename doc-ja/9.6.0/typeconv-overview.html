<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>概要</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="型変換"
HREF="typeconv.html"><LINK
REL="PREVIOUS"
TITLE="型変換"
HREF="typeconv.html"><LINK
REL="NEXT"
TITLE="演算子"
HREF="typeconv-oper.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="型変換"
HREF="typeconv.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 10章型変換</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="演算子"
HREF="typeconv-oper.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TYPECONV-OVERVIEW"
>10.1. 概要</A
></H1
><P
><ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>は強く型付けされた言語です。
つまり、各データ項目は、その動作と許される使用方法を決定するデータ型を所有しています。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>には、他の<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の実装よりもより一般的で柔軟性のある、拡張可能な型システムがあります。
このために、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>でのほとんどの型変換の動作は、特定の目的について<I
CLASS="FOREIGNPHRASE"
>勝手に作り上げられる</I
>ことなく一般的な規則で管理されています。
これにより、ユーザ定義型についても型の混在する式を使用できます。</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のスキャナ/パーサは字句要素を、整数、非整数値、文字列、識別子、キーワードという5個の基礎カテゴリに分解します。
ほとんどの非数値型定数は、まず文字列にクラス分けされます。
<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>言語定義では、文字列で型の名前を指定することを許していて、パーサが正しい手順に沿って処理を始められるように<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>も採用しています。
例えば、以下のような問い合わせを考えてみましょう。

</P><PRE
CLASS="SCREEN"
>SELECT text 'Origin' AS "label", point '(0,0)' AS "value";

 label  | value
--------+-------
 Origin | (0,0)
(1 row)</PRE
><P>

この問い合わせは、<TT
CLASS="TYPE"
>text</TT
>と<TT
CLASS="TYPE"
>point</TT
>という2つの型を指定したリテラル定数を持ちます。
文字列リテラルに型が指定されていない場合、後述するように、後の段階で解決されるようにとりあえず場所を確保するための型である<TT
CLASS="TYPE"
>unknown</TT
>が割り当てられます。</P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のパーサには、個別の型変換規則が必要な4つの基礎的な<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>構成要素があります。

<P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>関数呼び出し</DT
><DD
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>型システムの大部分は、高度な関数群によって構築されています。
関数は複数の引数を取ることができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では関数のオーバーロードが可能ですので、関数名だけでは呼び出すべき関数を一意に識別できません。
パーサは、提供される引数のデータ型に基づいて、正しい関数を選択しなければなりません。</P
></DD
><DT
>演算子</DT
><DD
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、（引数が2つの）二項演算子と同様に、（引数が1つの）前置、後置単項演算子を持つ式が使用できます。
関数と同様、演算子もオーバーロード可能ですので、正しい演算子を選択する時に同じ問題が存在します。</P
></DD
><DT
>値の格納</DT
><DD
><P
><ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の<TT
CLASS="COMMAND"
>INSERT</TT
>と<TT
CLASS="COMMAND"
>UPDATE</TT
>文は式の結果をテーブルの中に格納します。
文内の式は対象となる列の型に一致する、または、変換できるものである必要があります。</P
></DD
><DT
><TT
CLASS="LITERAL"
>UNION</TT
>、<TT
CLASS="LITERAL"
>CASE</TT
>、および関連する構文</DT
><DD
><P
>UNIONを構成する<TT
CLASS="COMMAND"
>SELECT</TT
>文からの選択結果は全て、ある1つの列集合として現れなければいけませんので、各<TT
CLASS="LITERAL"
>SELECT</TT
>句の結果型は統一された集合に一致し変換できる必要があります。
同様に、<TT
CLASS="COMMAND"
>CASE</TT
>構文が全体として既知の出力型を持つようになるために、<TT
CLASS="LITERAL"
>CASE</TT
>構文の結果式は共通の型に変換される必要があります。
これは<TT
CLASS="LITERAL"
>ARRAY</TT
>構文でも<CODE
CLASS="FUNCTION"
>GREATEST</CODE
>関数、<CODE
CLASS="FUNCTION"
>LEAST</CODE
>関数でも同じです。</P
></DD
></DL
></DIV
><P></P
><P
>システムカタログには、どのデータ型の間にどのような変換、すなわち<I
CLASS="FIRSTTERM"
>キャスト</I
>があるのか、また、その変換をどのように実行するのかに関する情報を格納します。
ユーザは<A
HREF="sql-createcast.html"
>CREATE CAST</A
>コマンドを使用してキャストを追加できます。
（これは通常新しいデータ型を定義する時にまとめて行われます。
組み込み型間のキャスト集合は注意深く作成されており、変更しないことが最善です。）</P
><P
>暗黙のキャストを持つデータ型間の処理において、適切なキャスト処理のより良い決定を行えるようパーサは追加の自律機構を備えています。
データ型は、<TT
CLASS="TYPE"
>boolean</TT
>、<TT
CLASS="TYPE"
>numeric</TT
>、<TT
CLASS="TYPE"
>string</TT
>、<TT
CLASS="TYPE"
>bitstring</TT
>、<TT
CLASS="TYPE"
>datetime</TT
>、<TT
CLASS="TYPE"
>timespan</TT
>、<TT
CLASS="TYPE"
>geometric</TT
>、<TT
CLASS="TYPE"
>network</TT
>、及びユーザ定義を含むいくつかの基本的な<I
CLASS="FIRSTTERM"
>型カテゴリ</I
>に分けられます。
(一覧は<A
HREF="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE"
>表50-56</A
>を参照してください。ですが、独自の型カテゴリを作成するのも可能なことに注意して下さい。)
各カテゴリには、候補となる型の選択があった場合に、優先される1つ以上の<I
CLASS="FIRSTTERM"
>優先される型</I
>がある場合があります。
優先される型と利用可能な暗黙のキャストを注意して選択すれば、曖昧な式(複数の解析結果候補を持つもの)が有効な方法で解決されることを保証することが可能です。</P
><P
>全ての型変換規則は次のようないくつかの基本的な考え方に基づいて設計されています。

<P
></P
></P><UL
><LI
><P
>暗黙的な変換は、意外な、あるいは予想できない結果を決して生成させてはなりません。</P
></LI
><LI
><P
>暗黙的な型変換を必要としない問い合わせの場合、パーサやエクゼキュータに余計なオーバーヘッドがあるべきではありません。
つまり、問い合わせ文がきちんとまとめられ、型が既に一致するものになっていれば、パーサ内で余計な時間を費やさず、また、問い合わせに不要な暗黙的な型変換関数が使用されないように、問い合わせは処理されるべきです。</P
></LI
><LI
><P
>さらに、もし問い合わせが関数のために暗黙的な変換を通常要求しており、そして、ユーザが正しい引数型を持つ関数を新しく定義した場合、パーサはこの新しい関数を使うべきであり、もはや古い関数を使うために暗黙的な変換を行わないようすべきです。</P
></LI
></UL
><P></P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="typeconv-oper.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>型変換</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="typeconv.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>演算子</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
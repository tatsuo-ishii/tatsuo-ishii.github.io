<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>SELECT</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="SECURITY LABEL"
HREF="sql-security-label.html"><LINK
REL="NEXT"
TITLE="SELECT INTO"
HREF="sql-selectinto.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="SECURITY LABEL"
HREF="sql-security-label.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="SELECT INTO"
HREF="sql-selectinto.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-SELECT"
></A
>SELECT</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN89950"
></A
><H2
>名前</H2
>SELECT, TABLE, WITH&nbsp;--&nbsp;テーブルもしくはビューから行を検索する</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN89955"
></A
><H2
>概要</H2
><PRE
CLASS="SYNOPSIS"
>[ WITH [ RECURSIVE ] <TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
> [, ...] ]
SELECT [ ALL | DISTINCT [ ON ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ) ] ]
    [ * | <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>output_name</I
></TT
> ] [, ...] ]
    [ FROM <TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
> [, ...] ]
    [ WHERE <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> ]
    [ GROUP BY <TT
CLASS="REPLACEABLE"
><I
>grouping_element</I
></TT
> [, ...] ]
    [ HAVING <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> [, ...] ]
    [ WINDOW <TT
CLASS="REPLACEABLE"
><I
>window_name</I
></TT
> AS ( <TT
CLASS="REPLACEABLE"
><I
>window_definition</I
></TT
> ) [, ...] ]
    [ { UNION | INTERSECT | EXCEPT } [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select</I
></TT
> ]
    [ ORDER BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...] ]
    [ LIMIT { <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> | ALL } ]
    [ OFFSET <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
> [ ROW | ROWS ] ]
    [ FETCH { FIRST | NEXT } [ <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> ] { ROW | ROWS } ONLY ]
    [ FOR { UPDATE | NO KEY UPDATE | SHARE | KEY SHARE } [ OF <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [, ...] ] [ NOWAIT | SKIP LOCKED ] [...] ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>ここで<TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
>は以下のいずれかです。</SPAN
></SPAN
>

    [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ * ] [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ] ]
                [ TABLESAMPLE <TT
CLASS="REPLACEABLE"
><I
>sampling_method</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ) [ REPEATABLE ( <TT
CLASS="REPLACEABLE"
><I
>seed</I
></TT
> ) ] ]
    [ LATERAL ] ( <TT
CLASS="REPLACEABLE"
><I
>select</I
></TT
> ) [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ]
    <TT
CLASS="REPLACEABLE"
><I
>with_query_name</I
></TT
> [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ] ]
    [ LATERAL ] <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ] )
                [ WITH ORDINALITY ] [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ] ]
    [ LATERAL ] <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ] ) [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>column_definition</I
></TT
> [, ...] )
    [ LATERAL ] <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ] ) AS ( <TT
CLASS="REPLACEABLE"
><I
>column_definition</I
></TT
> [, ...] )
    [ LATERAL ] ROWS FROM( <TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ] ) [ AS ( <TT
CLASS="REPLACEABLE"
><I
>column_definition</I
></TT
> [, ...] ) ] [, ...] )
                [ WITH ORDINALITY ] [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_alias</I
></TT
> [, ...] ) ] ]
    <TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
> [ NATURAL ] <TT
CLASS="REPLACEABLE"
><I
>join_type</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>from_item</I
></TT
> [ ON <TT
CLASS="REPLACEABLE"
><I
>join_condition</I
></TT
> | USING ( <TT
CLASS="REPLACEABLE"
><I
>join_column</I
></TT
> [, ...] ) ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>また<TT
CLASS="REPLACEABLE"
><I
>grouping_element</I
></TT
>は以下のいずれかです。</SPAN
></SPAN
>

    ( )
    <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>
    ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] )
    ROLLUP ( { <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ) } [, ...] )
    CUBE ( { <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ) } [, ...] )
    GROUPING SETS ( <TT
CLASS="REPLACEABLE"
><I
>grouping_element</I
></TT
> [, ...] )

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>また<TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
>は以下の通りです。</SPAN
></SPAN
>

    <TT
CLASS="REPLACEABLE"
><I
>with_query_name</I
></TT
> [ ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) ] AS ( <TT
CLASS="REPLACEABLE"
><I
>select</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>values</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>insert</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>update</I
></TT
> | <TT
CLASS="REPLACEABLE"
><I
>delete</I
></TT
> )

TABLE [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ * ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN90028"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>SELECT</TT
>は0個以上のテーブルから行を返します。
<TT
CLASS="COMMAND"
>SELECT</TT
>の一般的な処理は以下の通りです。

   <P
></P
></P><OL
TYPE="1"
><LI
><P
><TT
CLASS="LITERAL"
>WITH</TT
>リスト内のすべての問い合わせが計算されます。
これらは実質的には、<TT
CLASS="LITERAL"
>FROM</TT
>リスト内から参照可能な一時テーブルとして提供されます。
<TT
CLASS="LITERAL"
>FROM</TT
>内で2回以上参照される<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせは一度のみ計算されます。
（後述の<A
HREF="sql-select.html#SQL-WITH"
><I
><I
>WITH</I
>句</I
></A
>を参照してください。）
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>FROM</TT
>リストにある全要素が計算されます
（<TT
CLASS="LITERAL"
>FROM</TT
>リストの要素は実テーブルか仮想テーブルのいずれかです）。
<TT
CLASS="LITERAL"
>FROM</TT
>リストに複数の要素が指定された場合、それらはクロス結合されます
（後述の<A
HREF="sql-select.html#SQL-FROM"
><I
><I
>FROM</I
>句</I
></A
>を参照してください）。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>WHERE</TT
>句が指定された場合、条件を満たさない行は全て出力から取り除かれます
（後述の<A
HREF="sql-select.html#SQL-WHERE"
><I
><I
>WHERE</I
>句</I
></A
>を参照してください）。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>GROUP BY</TT
>句が指定された場合、および集約関数の呼び出しがある場合は、1つまたは複数の値が条件に合う行ごとにグループに組み合わせて出力され、また集約関数の結果が計算されます。
<TT
CLASS="LITERAL"
>HAVING</TT
>句が指定された場合、指定した条件を満たさないグループは取り除かれます
（後述の<A
HREF="sql-select.html#SQL-GROUPBY"
><I
><I
>GROUP BY</I
>句</I
></A
>と<A
HREF="sql-select.html#SQL-HAVING"
><I
><I
>HAVING</I
>句</I
></A
>を参照してください）。
     </P
></LI
><LI
><P
>実際には、選択された各行または行グループに対して、<TT
CLASS="COMMAND"
>SELECT</TT
>の出力式を使用して計算した結果の行が出力されます
（後述の<A
HREF="sql-select.html#SQL-SELECT-LIST"
><I
><I
>SELECT</I
>リスト</I
></A
>を参照してください）。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>SELECT DISTINCT</TT
>は結果から重複行を取り除きます。
<TT
CLASS="LITERAL"
>SELECT DISTINCT ON</TT
>は指定した全ての式に一致する行を取り除きます。
<TT
CLASS="LITERAL"
>SELECT ALL</TT
>では、重複行も含め、全ての候補行を返します（これがデフォルトです。
詳しくは、後述の<A
HREF="sql-select.html#SQL-DISTINCT"
><I
><I
>DISTINCT</I
>句</I
></A
>を参照してください）。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UNION</TT
>、<TT
CLASS="LITERAL"
>INTERSECT</TT
>、<TT
CLASS="LITERAL"
>EXCEPT</TT
>演算子を使用すると、複数の<TT
CLASS="COMMAND"
>SELECT</TT
>文の出力を1つの結果集合にまとめることができます。
<TT
CLASS="LITERAL"
>UNION</TT
>演算子は、両方の結果集合に存在する行と、片方の結果集合に存在する行を全て返します。
<TT
CLASS="LITERAL"
>INTERSECT</TT
>演算子は、両方の結果集合に存在する行を返します。
<TT
CLASS="LITERAL"
>EXCEPT</TT
>演算子は、最初の結果集合にあり、2番目の結果集合にない行を返します。
<TT
CLASS="LITERAL"
>ALL</TT
>が指定されない限り、いずれの場合も、重複する行は取り除かれます。
無意味な<TT
CLASS="LITERAL"
>DISTINCT</TT
>という単語を付けて、明示的に重複行を除去することを指定することができます。
<TT
CLASS="COMMAND"
>SELECT</TT
>自体は<TT
CLASS="LITERAL"
>ALL</TT
>がデフォルトですが、この場合は<TT
CLASS="LITERAL"
>DISTINCT</TT
>がデフォルトの動作であることに注意してください。
（後述の<A
HREF="sql-select.html#SQL-UNION"
><I
><I
>UNION</I
>句</I
></A
>、<A
HREF="sql-select.html#SQL-INTERSECT"
><I
><I
>INTERSECT</I
>句</I
></A
>、<A
HREF="sql-select.html#SQL-EXCEPT"
><I
><I
>EXCEPT</I
>句</I
></A
>を参照してください。）
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>ORDER BY</TT
>句が指定された場合、返される行は指定した順番でソートされます。
<TT
CLASS="LITERAL"
>ORDER BY</TT
>が指定されない場合は、システムが計算過程で見つけた順番で行が返されます
（後述の<A
HREF="sql-select.html#SQL-ORDERBY"
><I
><I
>ORDER BY</I
>句</I
></A
>を参照してください）。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>LIMIT</TT
>（または<TT
CLASS="LITERAL"
>FETCH FIRST</TT
>）あるいは<TT
CLASS="LITERAL"
>OFFSET</TT
>句が指定された場合、<TT
CLASS="COMMAND"
>SELECT</TT
>文は結果行の一部分のみを返します
（詳しくは、後述の<A
HREF="sql-select.html#SQL-LIMIT"
><I
><I
>LIMIT</I
>句</I
></A
>を参照してください）。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>または<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>句を指定すると、<TT
CLASS="COMMAND"
>SELECT</TT
>文は引き続き行われる更新に備えて選択行をロックします
（詳しくは、後述の<A
HREF="sql-select.html#SQL-FOR-UPDATE-SHARE"
><I
>ロック処理句</I
></A
>を参照してください）。
     </P
></LI
></OL
><P>
  </P
><P
><TT
CLASS="COMMAND"
>SELECT</TT
>コマンド内で使われる列それぞれに対する<TT
CLASS="LITERAL"
>SELECT</TT
>権限が必要です。
<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>または<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を使用するためには、さらに、（選択された各テーブルで少なくとも1列に対する）<TT
CLASS="LITERAL"
>UPDATE</TT
>権限が必要です。

  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN90112"
></A
><H2
>パラメータ</H2
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-WITH"
></A
><H3
><TT
CLASS="LITERAL"
>WITH</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>WITH</TT
>句により主問い合わせ内で名前により参照可能な、1つ以上の副問い合わせを指定することができます。
副問い合わせは実質的に主問い合わせの間の一時的なテーブルかビューのように動作します。
各副問い合わせは<TT
CLASS="COMMAND"
>SELECT</TT
>、<TT
CLASS="COMMAND"
>TABLE</TT
>、<TT
CLASS="COMMAND"
>VALUES</TT
>、<TT
CLASS="COMMAND"
>INSERT</TT
>、<TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>にすることができます。
<TT
CLASS="LITERAL"
>WITH</TT
>内でデータ変更文（<TT
CLASS="COMMAND"
>INSERT</TT
>、<TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>）を記述する場合は、<TT
CLASS="LITERAL"
>RETURNING</TT
>句を含めるのが普通です。
主問い合わせで読み取られる一時テーブルを形成するのは、<TT
CLASS="LITERAL"
>RETURNING</TT
>の出力であり、文が変更する背後のテーブルでは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ありません</I
></SPAN
>。
<TT
CLASS="LITERAL"
>RETURNING</TT
>を省いても文は実行されますが、出力を生成しませんので、主問い合わせでテーブルとして参照することができません。
   </P
><P
>（スキーマ修飾がない）名前を各<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせで指定しなければなりません。
列名のリストをオプションで指定することもできます。
これを省略すると、列名は副問い合わせから推定されます。
   </P
><P
><TT
CLASS="LITERAL"
>RECURSIVE</TT
>が指定されると、<TT
CLASS="COMMAND"
>SELECT</TT
>副問い合わせは自身で名前により参照することができます。
こうした副問い合わせは以下のような形式でなければなりません。
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>non_recursive_term</I
></TT
> UNION [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>recursive_term</I
></TT
></PRE
><P>
ここで再帰的な自己参照は<TT
CLASS="LITERAL"
>UNION</TT
>の右辺に現れなければなりません。
問い合わせ当たり1つの再帰的な自己参照のみが許されます。
再帰的なデータ変更文はサポートされていませんが、データ変更文で再帰的な<TT
CLASS="COMMAND"
>SELECT</TT
>の結果を使用することができます。
例は<A
HREF="queries-with.html"
>項7.8</A
>を参照してください。
   </P
><P
><TT
CLASS="LITERAL"
>RECURSIVE</TT
>には他にも、<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせが順序通りでなくても構わないという効果があります。
つまり、問い合わせはリストの後にある別のものを参照することができます。
（しかし巡回する参照や相互的な参照は実装されていません。）
<TT
CLASS="LITERAL"
>RECURSIVE</TT
>がないと、<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせは主問い合わせが共通する<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせのうち、<TT
CLASS="LITERAL"
>WITH</TT
>リストの前方にあるもののみを参照することができます。
   </P
><P
><TT
CLASS="LITERAL"
>WITH</TT
>問い合わせの重要な特性は、これらを主問い合わせが複数回参照していたとしても、主問い合わせの実行当たり一度のみ評価される点です。
特にデータ変更文は、主問い合わせがその出力のすべてまたは一部を読み取るかに関係なく、本当に一度のみ実行されることが保証されています。
   </P
><P
>主問い合わせと<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせは（理論上）同時にすべて実行されます。
<TT
CLASS="LITERAL"
>WITH</TT
>内のデータ変更文によりなされた影響は、<TT
CLASS="LITERAL"
>RETURNING</TT
>出力を読み取る以外、問い合わせの他の部分では参照できないことを意味します。
こうしたデータ変更文が２つあり、同じ行を変更しようとした場合、その結果は不定です。
   </P
><P
>追加情報については<A
HREF="queries-with.html"
>項7.8</A
>を参照してください。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-FROM"
></A
><H3
><TT
CLASS="LITERAL"
>FROM</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>FROM</TT
>句には<TT
CLASS="COMMAND"
>SELECT</TT
>の対象となるソーステーブルを1つ以上指定します。
複数のソースが指定された場合、結果は全てのソースの直積（クロス結合）となります。
しかし、通常は（<TT
CLASS="LITERAL"
>WHERE</TT
>を介して）制約条件を付けて、直積のごく一部を返すように結果行を限定します。
   </P
><P
><TT
CLASS="LITERAL"
>FROM</TT
>句には以下の要素を指定できます。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></DT
><DD
><P
>既存のテーブルもしくはビューの名前です（スキーマ修飾名も可）。
テーブル名の前に<TT
CLASS="LITERAL"
>ONLY</TT
>が指定された場合、そのテーブルのみがスキャンされます。
<TT
CLASS="LITERAL"
>ONLY</TT
>が指定されない場合、テーブルと（もしあれば）それを継承する全てのテーブルがスキャンされます。
省略することもできますが、テーブル名の後に<TT
CLASS="LITERAL"
>*</TT
>を指定することで、明示的に継承するテーブルも含まれることを示すことができます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
></DT
><DD
><P
>別名を含む<TT
CLASS="LITERAL"
>FROM</TT
>項目の代替名です。
別名は、指定を簡潔にするため、もしくは、自己結合（同じテーブルを複数回スキャンする結合）の曖昧さをなくすために使われます。
別名が指定されている場合は、その別名によって実際のテーブル名または関数名が完全に隠されます。
例えば、<TT
CLASS="LITERAL"
>FROM foo AS f</TT
>と指定されている場合、<TT
CLASS="COMMAND"
>SELECT</TT
>文の以降の部分ではこの<TT
CLASS="LITERAL"
>FROM</TT
>項目を<TT
CLASS="LITERAL"
>foo</TT
>ではなく<TT
CLASS="LITERAL"
>f</TT
>として参照する必要があります。
テーブルの別名があれば、そのテーブルの複数の列の名前を置き換える列の別名リストを記述することができます。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>TABLESAMPLE <TT
CLASS="REPLACEABLE"
><I
>sampling_method</I
></TT
> ( <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> [, ...] ) [ REPEATABLE ( <TT
CLASS="REPLACEABLE"
><I
>seed</I
></TT
> ) ]</TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>の後の<TT
CLASS="LITERAL"
>TABLESAMPLE</TT
>句は、そのテーブルの行の部分集合を取り出すときに、指定した<TT
CLASS="REPLACEABLE"
><I
>sampling_method</I
></TT
>を使うべきであることを示唆します。
このサンプリングは<TT
CLASS="LITERAL"
>WHERE</TT
>など他のすべてのフィルタの適用に先立って行われます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の標準ディストリビューションには、<TT
CLASS="LITERAL"
>BERNOULLI</TT
>と<TT
CLASS="LITERAL"
>SYSTEM</TT
>の2つのサンプリングメソッドが含まれています。
他のサンプリングメソッドも拡張(extension)によりデータベースにインストールすることができます。
       </P
><P
>サンプリングメソッド<TT
CLASS="LITERAL"
>BERNOULLI</TT
>と<TT
CLASS="LITERAL"
>SYSTEM</TT
>はいずれも1つだけ<TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>を取り、これはテーブルからサンプリングする割合で0から100までのパーセントで表現されます。
この引数は<TT
CLASS="TYPE"
>real</TT
>型の値を取る任意の式にできます。
（他のサンプリングメソッドは、複数の、あるいは異なる引数を受け取るかもしれません。）
これら2つの方法はいずれも、テーブルのうち指定された割合に近い行数を含む、ランダムに選択されたサンプルテーブルを返します。
<TT
CLASS="LITERAL"
>BERNOULLI</TT
>では、テーブル全体を走査し、個々の行を別々に、指定された確率に従って、選択あるいは無視します。
<TT
CLASS="LITERAL"
>SYSTEM</TT
>ではブロックレベルのサンプリングを行います。
各ブロックは指定された確率で選択され、選択されたブロック内のすべての行が返されます。
サンプリングに小さな割合が指定された場合、<TT
CLASS="LITERAL"
>SYSTEM</TT
>は<TT
CLASS="LITERAL"
>BERNOULLI</TT
>よりもかなり高速ですが、クラスタリング効果により、<TT
CLASS="LITERAL"
>BERNOULLI</TT
>に比べてランダムでないサンプルを返すかもしれません。
       </P
><P
>オプションの<TT
CLASS="LITERAL"
>REPEATABLE</TT
>句では、サンプリングメソッドで乱数を生成するための<TT
CLASS="REPLACEABLE"
><I
>seed</I
></TT
>の数あるいは式を指定します。
シード値はNULL以外の任意の浮動点小数値とすることができます。
シードと<TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>の値が同じ2つの問い合わせは、その間にテーブルに変更がなければ、同じサンプルテーブルを返します。
しかし、シードの値が異なれば、通常は異なるサンプルが生成されます。
<TT
CLASS="LITERAL"
>REPEATABLE</TT
>が指定されていなければ、システムが生成したシードに基づいて、問い合わせ毎に新しくランダムなサンプルが生成されます。
一部のアドオンのサンプリングメソッドでは<TT
CLASS="LITERAL"
>REPEATABLE</TT
>が利用できず、使用の度に常に新しいサンプルを生成することに注意してください。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>select</I
></TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>FROM</TT
>句では、副<TT
CLASS="COMMAND"
>SELECT</TT
>を使うことができます。
<TT
CLASS="COMMAND"
>SELECT</TT
>コマンドの実行中、副<TT
CLASS="COMMAND"
>SELECT</TT
>の出力は一時テーブルであるかのように動作します。
副<TT
CLASS="COMMAND"
>SELECT</TT
>は括弧で囲まれなければなりません。また、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>必ず</I
></SPAN
>別名を与えなければなりません。
<A
HREF="sql-values.html"
>VALUES</A
>コマンドをここで使用することもできます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>with_query_name</I
></TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>WITH</TT
>問い合わせは、問い合わせの名前があたかもテーブル名であるかのように、名前を記述することで参照されます。
（実際には<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせは主問い合わせの対象とするテーブルと同じ名前の実テーブルを隠蔽します。
必要ならばテーブル名をスキーマ修飾することで同じ名前の実テーブルを参照することができます。）
テーブルと同様の方法で別名を提供することができます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>function_name</I
></TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>FROM</TT
>句では、関数呼び出しを使用することができます
（これは特に関数が結果セットを返す場合に有用ですが、任意の関数を使用することもできます）。
<TT
CLASS="COMMAND"
>SELECT</TT
>コマンドの実行中は、この関数の結果は一時テーブルであるかのように動作します。
関数呼び出しに<TT
CLASS="COMMAND"
>WITH ORDINALITY</TT
>句を追加した時は、すべての関数の出力列の後に各行の番号の列が追加されます。
       </P
><P
>テーブルに対するのと同じように、別名を使用することができます。
別名が記述されていれば、列の別名リストを記述して、関数の複合型の戻り値の１つ以上の、<TT
CLASS="LITERAL"
>ORDINALITY</TT
>がある場合はそれが追加する列を含め、属性に対する代替名を提供することもできます。
       </P
><P
>複数の関数呼び出しを<TT
CLASS="LITERAL"
>ROWS FROM( ... )</TT
>で括ることにより、1つの<TT
CLASS="LITERAL"
>FROM</TT
>句の項目にまとめることができます。
このような項目の出力は各関数の最初の行を結合した項目、次いで各関数の2番目の行、といった具合になります。
一部の関数が他の関数より少ない行数を出力した場合は、存在しないデータについてNULL値が代用され、戻される行数はいつでも最大の行数を返した関数と同じになります。
       </P
><P
>関数が<TT
CLASS="TYPE"
>record</TT
>データ型を返すと定義されている場合は、別名すなわち<TT
CLASS="LITERAL"
>AS</TT
>キーワードと、それに続く<TT
CLASS="LITERAL"
>（<TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ... </SPAN
>]）</TT
>という形式の列定義リストが必要です。
列定義リストは、関数によって返される実際の列の数およびデータ型に一致していなければなりません。
       </P
><P
><TT
CLASS="LITERAL"
>ROWS FROM( ... )</TT
>の構文を使う時、関数の1つが列定義のリストを必要としている場合は、<TT
CLASS="LITERAL"
>ROWS FROM( ... )</TT
>内の関数呼び出しの後に列定義のリストを置くのが望ましいです。
関数が1つだけで、<TT
CLASS="LITERAL"
>WITH ORDINALITY</TT
>句がない場合に限り、列定義のリストを<TT
CLASS="LITERAL"
>ROWS FROM( ... )</TT
>の後に置くことができます。
       </P
><P
><TT
CLASS="LITERAL"
>ORDINALITY</TT
>を列定義のリストと一緒に使うには、<TT
CLASS="LITERAL"
>ROWS FROM( ... )</TT
>構文を使い、列定義のリストを<TT
CLASS="LITERAL"
>ROWS FROM( ... )</TT
>の内側に置かなければなりません。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>join_type</I
></TT
></DT
><DD
><P
>        以下のいずれかです。
        <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>[ INNER ] JOIN</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>LEFT [ OUTER ] JOIN</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>RIGHT [ OUTER ] JOIN</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>FULL [ OUTER ] JOIN</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>CROSS JOIN</TT
></P
></LI
></UL
><P>

<TT
CLASS="LITERAL"
>INNER</TT
>および<TT
CLASS="LITERAL"
>OUTER</TT
>結合型では、結合条件、すなわち、<TT
CLASS="LITERAL"
>NATURAL</TT
>, <TT
CLASS="LITERAL"
>ON <TT
CLASS="REPLACEABLE"
><I
>join_condition</I
></TT
></TT
>、<TT
CLASS="LITERAL"
>USING (<TT
CLASS="REPLACEABLE"
><I
>join_column</I
></TT
> [, ...])</TT
>のいずれか1つのみを指定する必要があります。
それぞれの意味は後述します。
<TT
CLASS="LITERAL"
>CROSS JOIN</TT
>では、これらの句を記述しなくても構いません。
       </P
><P
><TT
CLASS="LITERAL"
>JOIN</TT
>句は、2つの<TT
CLASS="LITERAL"
>FROM</TT
>項目を結び付けます。
便宜上<SPAN
CLASS="QUOTE"
>"テーブル"</SPAN
>と呼びますが、実際には任意の種類の<TT
CLASS="LITERAL"
>FROM</TT
>項目とすることができます。
入れ子の順番を決めるために、必要ならば括弧を使用してください。
括弧がないと、<TT
CLASS="LITERAL"
>JOIN</TT
>は左から右へ入れ子にします。
どのような場合でも<TT
CLASS="LITERAL"
>JOIN</TT
>は、カンマで分けられた<TT
CLASS="LITERAL"
>FROM</TT
>項目よりも強い結び付きを持ちます。
       </P
><P
><TT
CLASS="LITERAL"
>CROSS JOIN</TT
>と<TT
CLASS="LITERAL"
>INNER JOIN</TT
>は直積を1つ生成します。これは、<TT
CLASS="LITERAL"
>FROM</TT
>の最上位で2つのテーブルを結合した結果と同一です。
しかし、（指定すれば）結合条件によって制限をかけることができます。
<TT
CLASS="LITERAL"
>CROSS JOIN</TT
>は<TT
CLASS="LITERAL"
>INNER JOIN ON (TRUE)</TT
>と等価であり、条件によって削除される行はありません。
これらの結合型は記述上の便宜のためだけに用意されています。
なぜなら、通常の<TT
CLASS="LITERAL"
>FROM</TT
>と<TT
CLASS="LITERAL"
>WHERE</TT
>でできないことは何もしないからです。
       </P
><P
><TT
CLASS="LITERAL"
>LEFT OUTER JOIN</TT
>は、条件に合う直積の全ての行（つまり、その結合条件を満たす全ての組み合わせ）に加え、左側テーブルの中で、右側テーブルには結合条件を満たす行が存在しなかった行のコピーも返します。
この左側テーブルの行を結合結果のテーブルの幅に拡張するために、右側テーブルが入る列にはNULL値が挿入されます。
マッチする行を決める時は、<TT
CLASS="LITERAL"
>JOIN</TT
>句自身の条件のみが考慮されることに注意してください。
外部結合条件は後で適用されます。
       </P
><P
>逆に、<TT
CLASS="LITERAL"
>RIGHT OUTER JOIN</TT
>は、全ての結合行と、左側テーブルに当てはまるものがなかった右側の行（左側はNULLで拡張されています）の1行ずつを返します。
左右のテーブルを入れ替えれば<TT
CLASS="LITERAL"
>LEFT OUTER JOIN</TT
>に変換できるので、<TT
CLASS="LITERAL"
>RIGHT OUTER JOIN</TT
>は記述上の便宜を図るため用意されているに過ぎません。
       </P
><P
><TT
CLASS="LITERAL"
>FULL OUTER JOIN</TT
>は、全ての結合行に加え、一致しなかった左側の行（右側はNULLで拡張）、一致しなかった右側の行（左側はNULLで拡張）を全て返します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ON <TT
CLASS="REPLACEABLE"
><I
>join_condition</I
></TT
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>join_condition</I
></TT
>は、結合においてどの行が一致するかを指定する、<TT
CLASS="TYPE"
>boolean</TT
>型の値を返す式です（<TT
CLASS="LITERAL"
>WHERE</TT
>句に類似しています）。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>USING ( <TT
CLASS="REPLACEABLE"
><I
>join_column</I
></TT
> [, ...] )</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>USING ( a, b, ... )</TT
>という形式の句は<TT
CLASS="LITERAL"
>ON left_table.a = right_table.a AND left_table.b = right_table.b ...</TT
>の省略形です。
また<TT
CLASS="LITERAL"
>USING</TT
>は等価な列の両方ではなく片方のみが結合の出力に含まれることを意味します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>NATURAL</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>NATURAL</TT
>は、2つのテーブル内の同じ名前を持つ列を全て指定した<TT
CLASS="LITERAL"
>USING</TT
>リストの省略形です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>LATERAL</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>LATERAL</TT
>キーワードを副<TT
CLASS="COMMAND"
>SELECT</TT
>の<TT
CLASS="LITERAL"
>FROM</TT
>項目の前に付けることができます。
これにより、副<TT
CLASS="COMMAND"
>SELECT</TT
>が<TT
CLASS="LITERAL"
>FROM</TT
>リストの中で前に現れる<TT
CLASS="LITERAL"
>FROM</TT
>項目の列を参照することができます。
（<TT
CLASS="LITERAL"
>LATERAL</TT
>がないと、副<TT
CLASS="COMMAND"
>SELECT</TT
>それぞれが個別に評価され、他の<TT
CLASS="LITERAL"
>FROM</TT
>項目とのクロス参照を行うことができません。）
       </P
><P
><TT
CLASS="LITERAL"
>LATERAL</TT
>を関数を呼び出す<TT
CLASS="LITERAL"
>FROM</TT
>の前に付けることもできます。
しかしこの場合、無意味な単語になります。
関数式はどのような場合でもより前の<TT
CLASS="LITERAL"
>FROM</TT
>項目を参照することができるからです。
       </P
><P
><TT
CLASS="LITERAL"
>LATERAL</TT
>項目は<TT
CLASS="LITERAL"
>FROM</TT
>の最上位レベルや<TT
CLASS="LITERAL"
>JOIN</TT
>ツリー内に記述することができます。
後者の場合、<TT
CLASS="LITERAL"
>JOIN</TT
>の右辺にあれば、左辺にある任意の項目を参照することができます。
       </P
><P
><TT
CLASS="LITERAL"
>FROM</TT
>項目が<TT
CLASS="LITERAL"
>LATERAL</TT
>クロス参照を含む場合、評価は次のように行われます。
クロス参照される列を提供する<TT
CLASS="LITERAL"
>FROM</TT
>項目の各行、または、その列を提供する複数の<TT
CLASS="LITERAL"
>FROM</TT
>項目の行集合に対して、
<TT
CLASS="LITERAL"
>LATERAL</TT
>項目は列の行または行集合を使用して評価されます。
結果となる行は、計算された行と通常通り結合されます。
これが各行または列ソーステーブルからの行集合に対して繰り返されます。
       </P
><P
>列ソーステーブルは<TT
CLASS="LITERAL"
>LATERAL</TT
>項目と<TT
CLASS="LITERAL"
>INNER</TT
>または<TT
CLASS="LITERAL"
>LEFT</TT
>結合されていなければなりません。
さもないと、
<TT
CLASS="LITERAL"
>LATERAL</TT
>項目において各行集合を計算するための行集合が完全に定義することができません。
したがって<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
> RIGHT JOIN LATERAL <TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
></TT
>という式は構文としては有効ですが、実際には<TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>では<TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
>を参照することができません。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-WHERE"
></A
><H3
><TT
CLASS="LITERAL"
>WHERE</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>WHERE</TT
>句の一般的な構文は以下の通りです（この句は省略可能です）。
</P><PRE
CLASS="SYNOPSIS"
>WHERE <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
></PRE
><P>
<TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
>は、評価の結果として<TT
CLASS="TYPE"
>boolean</TT
>型を返す任意の式です。
この条件を満たさない行は全て出力から取り除かれます。
全ての変数に実際の行の値を代入して、式が真を返す場合、その行は条件を満たすとみなされます。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-GROUPBY"
></A
><H3
><TT
CLASS="LITERAL"
>GROUP BY</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>GROUP BY</TT
>句の一般的な構文は以下の通りです（この句は省略可能です）。
</P><PRE
CLASS="SYNOPSIS"
>GROUP BY <TT
CLASS="REPLACEABLE"
><I
>grouping_element</I
></TT
> [, ...]</PRE
><P>
   </P
><P
><TT
CLASS="LITERAL"
>GROUP BY</TT
>は、グループ化のために与えられた式を評価し、結果が同じ値になった行を1つの行にまとめる機能を持ちます。
<TT
CLASS="REPLACEABLE"
><I
>grouping_element</I
></TT
>の内側で使われる<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>には、入力列の名前、出力列（<TT
CLASS="COMMAND"
>SELECT</TT
>リスト項目）の名前/序数、あるいは入力列の値から計算される任意の式を取ることができます。
判断がつかない時は、<TT
CLASS="LITERAL"
>GROUP BY</TT
>の名前は出力列名ではなく入力列名として解釈されます。
   </P
><P
>グループ化の要素として<TT
CLASS="LITERAL"
>GROUPING SETS</TT
>、<TT
CLASS="LITERAL"
>ROLLUP</TT
>、<TT
CLASS="LITERAL"
>CUBE</TT
>のいずれかが指定されている場合、<TT
CLASS="LITERAL"
>GROUP BY</TT
>句は全体でいくつかの独立した<I
CLASS="FIRSTTERM"
>グループ化セット</I
>を定義します。
この効果は、個々のグループ化セットを<TT
CLASS="LITERAL"
>GROUP BY</TT
>句で定義する副問い合わせを<TT
CLASS="LITERAL"
>UNION ALL</TT
>するのと同等です。
グループ化セットの処理の詳細については、<A
HREF="queries-table-expressions.html#QUERIES-GROUPING-SETS"
>項7.2.4</A
>を参照してください。
   </P
><P
>集約関数が使用された場合、各グループ内の全ての行を対象に計算が行われ、グループごとに別々の値が生成されます
（集約関数が使われていて<TT
CLASS="LITERAL"
>GROUP BY</TT
>がない場合、その問い合わせは選択された全ての行からなる1つのグループを持つものとして扱われます）。
集約関数の入力となる行の集合は、集約関数の呼び出しに<TT
CLASS="LITERAL"
>FILTER</TT
>句を付けることで、さらに絞り込むことができます。
詳しくは<A
HREF="sql-expressions.html#SYNTAX-AGGREGATES"
>項4.2.7</A
>を参照してください。
<TT
CLASS="LITERAL"
>FILTER</TT
>句があると、その条件に適合する行だけが集約関数の入力行に取り込まれます。
   </P
><P
><TT
CLASS="LITERAL"
>GROUP BY</TT
>が存在する場合、あるいは集約関数が存在する場合、集約関数内部以外で、グループ化されていない列を参照する、あるいはグループ化されていない列がグループ化された列に関数依存する<TT
CLASS="COMMAND"
>SELECT</TT
>リストの式は無効になります。
こうしないとグループ化されていない列について返される値は複数の値になってしまう可能性があるからです。
グループ化された列(またはその部分集合)がグループ化されていない列を含むテーブルの主キーである場合、関数依存が存在します。
   </P
><P
>すべての集約関数は、<TT
CLASS="LITERAL"
>HAVING</TT
>句や<TT
CLASS="LITERAL"
>SELECT</TT
>リストのどの<SPAN
CLASS="QUOTE"
>"スカラー"</SPAN
>式よりも先に評価されることに注意してください。
これは例えば、<TT
CLASS="LITERAL"
>CASE</TT
>式を集約関数の評価をスキップするために使うことはできない、ということを意味します。
<A
HREF="sql-expressions.html#SYNTAX-EXPRESS-EVAL"
>項4.2.14</A
>を参照してください。
   </P
><P
>現在は、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を<TT
CLASS="LITERAL"
>GROUP BY</TT
>と合わせて使うことはできません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-HAVING"
></A
><H3
><TT
CLASS="LITERAL"
>HAVING</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>HAVING</TT
>句の一般的な構文は以下の通りです（この句は省略可能です）。
</P><PRE
CLASS="SYNOPSIS"
>HAVING <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
></PRE
><P>
<TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
>は<TT
CLASS="LITERAL"
>WHERE</TT
>句で指定するものと同じです。
   </P
><P
><TT
CLASS="LITERAL"
>HAVING</TT
>は、グループ化された行の中で、条件を満たさない行を取り除く機能を持ちます。
<TT
CLASS="LITERAL"
>HAVING</TT
>と<TT
CLASS="LITERAL"
>WHERE</TT
>は次の点が異なります。
<TT
CLASS="LITERAL"
>WHERE</TT
>が、<TT
CLASS="LITERAL"
>GROUP BY</TT
>の適用前に個々の行に対してフィルタを掛けるのに対し、<TT
CLASS="LITERAL"
>HAVING</TT
>は、<TT
CLASS="LITERAL"
>GROUP BY</TT
>の適用後に生成されたグループ化された行に対してフィルタをかけます。
<TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
>内で使用する列は、集約関数内で使用される場合とグループ化されない列がグループ化される列に関数依存する場合を除き、グループ化された列を一意に参照するものでなければなりません。
   </P
><P
><TT
CLASS="LITERAL"
>HAVING</TT
>句があると、<TT
CLASS="LITERAL"
>GROUP BY</TT
>句がなかったとしても問い合わせはグループ化された問い合わせになります。
<TT
CLASS="LITERAL"
>GROUP BY</TT
>句を持たない問い合わせが集約関数を含む場合と同様です。
選択された行はすべて、1つのグループを形成するものとみなされます。また、<TT
CLASS="COMMAND"
>SELECT</TT
>リストと<TT
CLASS="LITERAL"
>HAVING</TT
>句では、集約関数が出力するテーブル列しか参照することができません。
こうした問い合わせでは、<TT
CLASS="LITERAL"
>HAVING</TT
>が真の場合には単一の行を、真以外の場合は0行を出力します。
   </P
><P
>現在は、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を<TT
CLASS="LITERAL"
>HAVING</TT
>と合わせて使うことはできません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-WINDOW"
></A
><H3
><TT
CLASS="LITERAL"
>WINDOW</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>WINDOW</TT
>句(省略可能)の一般的な構文は以下の通りです。
</P><PRE
CLASS="SYNOPSIS"
>WINDOW <TT
CLASS="REPLACEABLE"
><I
>window_name</I
></TT
> AS ( <TT
CLASS="REPLACEABLE"
><I
>window_definition</I
></TT
> ) [, ...]</PRE
><P>
ここで<TT
CLASS="REPLACEABLE"
><I
>window_name</I
></TT
>は、<TT
CLASS="LITERAL"
>OVER</TT
>句やこの後のウィンドウ定義で参照することができる名前です。
また、<TT
CLASS="REPLACEABLE"
><I
>window_definition</I
></TT
>は以下の通りです。
</P><PRE
CLASS="SYNOPSIS"
>[ <TT
CLASS="REPLACEABLE"
><I
>existing_window_name</I
></TT
> ]
[ PARTITION BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] ]
[ ORDER BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...] ]
[ <TT
CLASS="REPLACEABLE"
><I
>frame_clause</I
></TT
> ]</PRE
><P>
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>existing_window_name</I
></TT
>を指定する場合、それは<TT
CLASS="LITERAL"
>WINDOW</TT
>リスト内のそれより前にある項目を参照しなければなりません。
新しいウィンドウはその<TT
CLASS="LITERAL"
>PARTITION BY</TT
>句をその項目からコピーします。
<TT
CLASS="LITERAL"
>ORDER BY</TT
>句があった場合も同様です。
この場合、新しいウィンドウでは独自の<TT
CLASS="LITERAL"
>PARTITION BY</TT
>句を指定することはできません。
また、コピーされたウィンドウが<TT
CLASS="LITERAL"
>ORDER BY</TT
>を持たない場合のみ<TT
CLASS="LITERAL"
>ORDER BY</TT
>を指定することができます。
新しいウィンドウは常に独自のフレーム句を使用します。
コピーされたウィンドウはフレーム句を指定してはなりません。
   </P
><P
><TT
CLASS="LITERAL"
>PARTITION BY</TT
>リストの要素は<A
HREF="sql-select.html#SQL-GROUPBY"
><I
><I
>GROUP BY</I
>句</I
></A
>の要素とほとんど同じように解釈されます。
ただし、こちらは常に単純な式であり、出力列の名前や番号ではないことが異なります。
他にも違いがあり、これらの式は、通常の<TT
CLASS="LITERAL"
>GROUP BY</TT
>句では許されない、集約関数を含めることができるという点です。
グループ化および集約処理の後にウィンドウ処理が動作するため、これらでは許されています。
   </P
><P
>同様に、<TT
CLASS="LITERAL"
>ORDER BY</TT
>リストの要素は<A
HREF="sql-select.html#SQL-ORDERBY"
><I
><I
>ORDER BY</I
>句</I
></A
>の要素とほとんど同じように解釈されます。
ただし、この式は常に単純な式であり、出力列の名前や番号ではないことが異なります。
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>frame_clause</I
></TT
>を指定すると、（すべてではありませんが）フレームに依存するウィンドウ関数用の<I
CLASS="FIRSTTERM"
>ウィンドウフレーム</I
>を定義できます。
ウィンドウフレームは、問い合わせの各行(<I
CLASS="FIRSTTERM"
>現在の行</I
>と呼ばれます)に関連する行の集合です。
<TT
CLASS="REPLACEABLE"
><I
>frame_clause</I
></TT
>は以下のいずれかを取ることができます。

</P><PRE
CLASS="SYNOPSIS"
>{ RANGE | ROWS } <TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
>
{ RANGE | ROWS } BETWEEN <TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
> AND <TT
CLASS="REPLACEABLE"
><I
>frame_end</I
></TT
></PRE
><P>

ここで<TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>frame_end</I
></TT
>は以下のいずれかを取ることができます。

</P><PRE
CLASS="SYNOPSIS"
>UNBOUNDED PRECEDING
<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> PRECEDING
CURRENT ROW
<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> FOLLOWING
UNBOUNDED FOLLOWING</PRE
><P>

<TT
CLASS="REPLACEABLE"
><I
>frame_end</I
></TT
>が省略された場合デフォルトで<TT
CLASS="LITERAL"
>CURRENT ROW</TT
>となります。
<TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
>は<TT
CLASS="LITERAL"
>UNBOUNDED FOLLOWING</TT
>とすることができない、<TT
CLASS="REPLACEABLE"
><I
>frame_end</I
></TT
>は<TT
CLASS="LITERAL"
>UNBOUNDED PRECEDING</TT
>とすることができない、および、上のリストで<TT
CLASS="REPLACEABLE"
><I
>frame_end</I
></TT
>の選択を<TT
CLASS="REPLACEABLE"
><I
>frame_start</I
></TT
>の選択より前に置くことができないという制限があります。
例えば<TT
CLASS="LITERAL"
>RANGE BETWEEN CURRENT ROW AND <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> PRECEDING</TT
>は許されません。
   </P
><P
>デフォルトのフレーム化オプションは<TT
CLASS="LITERAL"
>RANGE UNBOUNDED PRECEDING</TT
>です。
これは<TT
CLASS="LITERAL"
>RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW</TT
>と同じで、
パーティションの先頭から<TT
CLASS="LITERAL"
>ORDER BY</TT
>順序における現在の行の最後のピア(<TT
CLASS="LITERAL"
>ORDER BY</TT
>が現在の行の同等であるとみなす行、あるいは<TT
CLASS="LITERAL"
>ORDER BY</TT
>がなければすべての行)までのすべての行をフレームとします。
一般的に<TT
CLASS="LITERAL"
>UNBOUNDED PRECEDING</TT
>はフレームがパーティションの先頭から始まることを意味し、同様に<TT
CLASS="LITERAL"
>UNBOUNDED FOLLOWING</TT
>はフレームがパーティションの最終行で終わることを意味します(<TT
CLASS="LITERAL"
>RANGE</TT
>モードか<TT
CLASS="LITERAL"
>ROWS</TT
>かは関係ありません)。
<TT
CLASS="LITERAL"
>ROWS</TT
>モードでは、<TT
CLASS="LITERAL"
>CURRENT ROW</TT
>はフレームが現在の行で始まる、または終わることを意味しますが、<TT
CLASS="LITERAL"
>RANGE</TT
>モードでは、フレームが現在の行の<TT
CLASS="LITERAL"
>ORDER BY</TT
>順序における最初のピアまたは最後のピアで始まる、または終わることを意味します。
現時点では<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> <TT
CLASS="LITERAL"
>PRECEDING</TT
>および<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> <TT
CLASS="LITERAL"
>FOLLOWING</TT
>という場合わけは<TT
CLASS="LITERAL"
>ROWS</TT
>モードだけで許されます。
これらは、現在の行の何行前または何行後にフレームが始まるまたは終わることを示します。
<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>は整数式でなければならず、変数、集約関数、ウィンドウ関数を含めることはできません。
この値はNULLまたは負を取ることはできません。
しかし、現在の行自身を選択するゼロを取ることができます。
   </P
><P
><TT
CLASS="LITERAL"
>ORDER BY</TT
>順序によりその行を一意に順序付けできない場合、<TT
CLASS="LITERAL"
>ROWS</TT
>が予期できない結果をもたらす可能性があることに注意して下さい。
<TT
CLASS="LITERAL"
>RANGE</TT
>は、<TT
CLASS="LITERAL"
>ORDER BY</TT
>順序におけるピアとなる行が同等に扱われる、つまりすべてのピアは同じフレーム内に両方とも存在することが確実になるように設計されています。
   </P
><P
><TT
CLASS="LITERAL"
>WINDOW</TT
>句の目的は、問い合わせの<A
HREF="sql-select.html#SQL-SELECT-LIST"
><I
><I
>SELECT</I
>リスト</I
></A
>または<A
HREF="sql-select.html#SQL-ORDERBY"
><I
><I
>ORDER BY</I
>句</I
></A
>に記載される<I
CLASS="FIRSTTERM"
>ウィンドウ関数</I
>の動作を規定することです。
これらの関数はその<TT
CLASS="LITERAL"
>OVER</TT
>句において名前で<TT
CLASS="LITERAL"
>WINDOW</TT
>句の項目を参照することができます。
しかし<TT
CLASS="LITERAL"
>WINDOW</TT
>句の項目は他で参照される必要はありません。
問い合わせ内で使用されなかったものは、単に無視されます。
ウィンドウ関数呼び出しは<TT
CLASS="LITERAL"
>OVER</TT
>句でウィンドウ定義を直接規定することができますので、<TT
CLASS="LITERAL"
>WINDOW</TT
>句を全く使わずにウィンドウ関数を使用することができます。
しかし<TT
CLASS="LITERAL"
>WINDOW</TT
>句は、同じウィンドウ定義が複数のウィンドウ関数で必要とされる場合に入力量を省くことができます。
   </P
><P
>現在は、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を<TT
CLASS="LITERAL"
>WINDOW</TT
>と合わせて使うことはできません。
   </P
><P
>ウィンドウ関数に関する詳細については<A
HREF="tutorial-window.html"
>項3.5</A
>、<A
HREF="sql-expressions.html#SYNTAX-WINDOW-FUNCTIONS"
>項4.2.8</A
>、<A
HREF="queries-table-expressions.html#QUERIES-WINDOW"
>項7.2.5</A
>を参照してください。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-SELECT-LIST"
></A
><H3
><TT
CLASS="COMMAND"
>SELECT</TT
>リスト</H3
><P
><TT
CLASS="COMMAND"
>SELECT</TT
>リスト（<TT
CLASS="LITERAL"
>SELECT</TT
>キーワードと<TT
CLASS="LITERAL"
>FROM</TT
>キーワードの間にあるもの）は、<TT
CLASS="COMMAND"
>SELECT</TT
>文の出力行を形成する式を指定するものです。
この式では、<TT
CLASS="LITERAL"
>FROM</TT
>句で処理後の列を参照することができます（通常は実際に参照します）。
   </P
><P
>テーブルの場合と同様に、<TT
CLASS="COMMAND"
>SELECT</TT
>の出力列はすべて名前を持ちます。
簡単な<TT
CLASS="COMMAND"
>SELECT</TT
>では、この名前は列に表示用のラベルを付けるために使用されるだけです。
しかし<TT
CLASS="COMMAND"
>SELECT</TT
>が大規模な問い合わせの副問い合わせである場合、大規模な問い合わせ側で副問い合わせで生成された仮想のテーブルの列名としてこの名前が参照されます。
出力列として使用するための名前を指定するためには、列式の後に<TT
CLASS="LITERAL"
>AS</TT
> <TT
CLASS="REPLACEABLE"
><I
>output_name</I
></TT
>と記述してください。
（希望する列名が<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のキーワード（<A
HREF="sql-keywords-appendix.html"
>付録C</A
>を参照）に一致しない場合にのみ<TT
CLASS="LITERAL"
>AS</TT
>を省略することができます。
将来あり得るキーワードの追加に備えるために、常に<TT
CLASS="LITERAL"
>AS</TT
>を記述する、あるいは、出力名を二重引用符で括ることを推奨します。）
列名を指定しない場合、名前は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>により自動的に付けられます。
列式が単純な列参照であれば、つけられる名前はその列の名前と同じものです。
より複雑な場合では、関数名または型名が使用されるかもしれません。さもなければ<TT
CLASS="LITERAL"
>?column?</TT
>のように生成される名前になるかもしれません。
   </P
><P
><TT
CLASS="LITERAL"
>ORDER BY</TT
>句と<TT
CLASS="LITERAL"
>GROUP BY</TT
>句内で列の値を参照する時も、出力列名を使用できます。
しかし、<TT
CLASS="LITERAL"
>WHERE</TT
>や<TT
CLASS="LITERAL"
>HAVING</TT
>句では使用できません。これらでは式を書かなければなりません。
   </P
><P
>リストには、選択された行の全ての列を表す省略形として、式ではなく<TT
CLASS="LITERAL"
>*</TT
>と書くことができます。
また、そのテーブルに由来する列のみを表す省略形として、<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>.*</TT
>と書くこともできます。
このような場合、<TT
CLASS="LITERAL"
>AS</TT
>により新しい名前を指定することはできません。
出力列名はテーブルの列名と同一になります。
   </P
><P
>標準SQLによれば、出力リスト内の式は、<TT
CLASS="LITERAL"
>DISTINCT</TT
>、<TT
CLASS="LITERAL"
>ORDER BY</TT
>、<TT
CLASS="LITERAL"
>LIMIT</TT
>を適用する前に計算することになっています。
<TT
CLASS="LITERAL"
>DISTINCT</TT
>を使う場合は、これは明らかに必要です。
なぜなら、そうしなければどの値がDISTINCTであるかわからないからです。
しかし、多くの場合、<TT
CLASS="LITERAL"
>ORDER BY</TT
>や<TT
CLASS="LITERAL"
>LIMIT</TT
>の後で出力式を計算する方が便利です。
特に出力式が揮発性(volatile)あるいは高価な式を含んでいる場合はそうです。
この動作により、関数の評価順序はより直感的になり、出力に現れない行については評価されなくなります。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、式が<TT
CLASS="LITERAL"
>DISTINCT</TT
>、<TT
CLASS="LITERAL"
>ORDER BY</TT
>、<TT
CLASS="LITERAL"
>GROUP BY</TT
>の中で参照されていない限り、ソートと制限(limit)の後にそれらの式を実際に評価します。
（この反例として、<TT
CLASS="LITERAL"
>SELECT f(x) FROM tab ORDER BY 1</TT
> では明らかに<CODE
CLASS="FUNCTION"
>f(x)</CODE
>をソートの前に評価しなければなりません。）
集合を返す関数を含む出力式は、ソートの後、制限の前に実際の評価が行われ、これにより<TT
CLASS="LITERAL"
>LIMIT</TT
>が集合を返す関数の出力を制限することになります。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のバージョン9.6より前では、出力式がソートや制限に対して評価されるタイミングについて何の保証もしていませんでした。
それは選択された問い合わせの計画の形式に依存します。
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-DISTINCT"
></A
><H3
><TT
CLASS="LITERAL"
>DISTINCT</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>SELECT DISTINCT</TT
>が指定されると、重複する行は全て結果セットから削除されます
（重複するグループの中で1行が保持されます）。
<TT
CLASS="LITERAL"
>SELECT ALL</TT
>はこの反対で、全ての行が保持されます。
デフォルトはこちらです。
   </P
><P
><TT
CLASS="LITERAL"
>SELECT DISTINCT ON ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [, ...] )</TT
>は指定した式が等しいと評価した各行集合の中で、最初の行のみを保持します。
<TT
CLASS="LITERAL"
>DISTINCT ON</TT
>式は、<TT
CLASS="LITERAL"
>ORDER BY</TT
>（上述）と同じ規則で扱われます。
各集合の<SPAN
CLASS="QUOTE"
>"最初の行"</SPAN
>は、<TT
CLASS="LITERAL"
>ORDER BY</TT
>を使用して目的の行が確実に最初に現れるようにしない限り予測することはできないことに注意してください。
例えば、次の例は各地点の最新の気象情報を取り出します。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT DISTINCT ON (location) location, time, report
    FROM weather_reports
    ORDER BY location, time DESC;</PRE
><P>
しかし<TT
CLASS="LITERAL"
>ORDER BY</TT
>を使用して各地点を時間によって降順にソートしなければ、各地点について得られる情報がいつのものかはわかりません。
   </P
><P
><TT
CLASS="LITERAL"
>DISTINCT ON</TT
>に指定する式は<TT
CLASS="LITERAL"
>ORDER BY</TT
>の最も左側の式と一致しなければなりません。
<TT
CLASS="LITERAL"
>ORDER BY</TT
>句は、通常、各<TT
CLASS="LITERAL"
>DISTINCT ON</TT
>グループの中での行の優先順位を決定する追加的な式を含みます。
   </P
><P
>現在は、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を<TT
CLASS="LITERAL"
>DISTINCT</TT
>と合わせて使うことはできません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-UNION"
></A
><H3
><TT
CLASS="LITERAL"
>UNION</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>UNION</TT
>句の一般的な構文は以下の通りです。
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
> UNION [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
></PRE
><P><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
>には、<TT
CLASS="LITERAL"
>ORDER BY</TT
>、<TT
CLASS="LITERAL"
>LIMIT</TT
>、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>句を持たない任意の<TT
CLASS="COMMAND"
>SELECT</TT
>文が入ります
（<TT
CLASS="LITERAL"
>ORDER BY</TT
>と<TT
CLASS="LITERAL"
>LIMIT</TT
>は、括弧で囲めば副式として付与することができます。
括弧がない場合、これらの句は右側に置かれた入力式ではなく、<TT
CLASS="LITERAL"
>UNION</TT
>の結果に対して適用されてしまいます）。
   </P
><P
><TT
CLASS="LITERAL"
>UNION</TT
>演算子は、2つの<TT
CLASS="COMMAND"
>SELECT</TT
>文が返す行の和集合を作成します。
この和集合には、2つの<TT
CLASS="COMMAND"
>SELECT</TT
>文の結果集合のいずれか（または両方）に存在する行が全て含まれています。
<TT
CLASS="LITERAL"
>UNION</TT
>の直接のオペランドとなる2つの<TT
CLASS="COMMAND"
>SELECT</TT
>文が返す列数は、同じでなければなりません。また、対応する列のデータ型には互換性が存在する必要があります。
   </P
><P
><TT
CLASS="LITERAL"
>ALL</TT
>オプションが指定されていない限り、<TT
CLASS="LITERAL"
>UNION</TT
>の結果には重複行は含まれません。
<TT
CLASS="LITERAL"
>ALL</TT
>を指定するとこのような重複除去が行われません
（したがって、通常<TT
CLASS="LITERAL"
>UNION ALL</TT
>は<TT
CLASS="LITERAL"
>UNION</TT
>よりかなり高速です。
できれば<TT
CLASS="LITERAL"
>ALL</TT
>を使用してください）。
重複行を除去するデフォルトの動作を明示的に指定するために<TT
CLASS="LITERAL"
>DISTINCT</TT
>を記述することができます。
   </P
><P
>1つの<TT
CLASS="COMMAND"
>SELECT</TT
>文に複数の<TT
CLASS="LITERAL"
>UNION</TT
>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
   </P
><P
>現時点では、<TT
CLASS="LITERAL"
>UNION</TT
>の結果や<TT
CLASS="LITERAL"
>UNION</TT
>に対する入力に、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を指定することはできません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-INTERSECT"
></A
><H3
><TT
CLASS="LITERAL"
>INTERSECT</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>INTERSECT</TT
>句の一般的な構文は以下の通りです。
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
> INTERSECT [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
></PRE
><P><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
>には、<TT
CLASS="LITERAL"
>ORDER BY</TT
>、<TT
CLASS="LITERAL"
>LIMIT</TT
>、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>句を持たない、任意の<TT
CLASS="COMMAND"
>SELECT</TT
>文が入ります。
   </P
><P
><TT
CLASS="LITERAL"
>INTERSECT</TT
>は、2つの<TT
CLASS="COMMAND"
>SELECT</TT
>文が返す行の積集合を計算します。
この積集合に含まれるのは、2つの<TT
CLASS="COMMAND"
>SELECT</TT
>文の結果集合の両方に存在する行です。
   </P
><P
><TT
CLASS="LITERAL"
>ALL</TT
>オプションを指定しない限り、<TT
CLASS="LITERAL"
>INTERSECT</TT
>の結果に重複行は含まれません。
<TT
CLASS="LITERAL"
>ALL</TT
>が指定された場合、左側テーブルに<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
>個、右側テーブルに<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>個の重複がある行は、結果集合ではmin(<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
>,<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>)個出現します。
重複行を除去するデフォルトの動作を明示的に指定するために<TT
CLASS="LITERAL"
>DISTINCT</TT
>を記述することができます。
   </P
><P
>1つの<TT
CLASS="COMMAND"
>SELECT</TT
>文に複数の<TT
CLASS="LITERAL"
>INTERSECT</TT
>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
<TT
CLASS="LITERAL"
>INTERSECT</TT
>は<TT
CLASS="LITERAL"
>UNION</TT
>よりも強い結び付きを持ちます。
つまり、<TT
CLASS="LITERAL"
>A UNION B INTERSECT C</TT
> は<TT
CLASS="LITERAL"
>A UNION (B INTERSECT C)</TT
>と解釈されます。
   </P
><P
>現時点では、<TT
CLASS="LITERAL"
>INTERSECT</TT
>の結果や<TT
CLASS="LITERAL"
>INTERSECT</TT
>に対する入力に、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>または<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を指定することはできません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-EXCEPT"
></A
><H3
><TT
CLASS="LITERAL"
>EXCEPT</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>EXCEPT</TT
>句の一般的な構文は以下の通りです。
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
> EXCEPT [ ALL | DISTINCT ] <TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
></PRE
><P><TT
CLASS="REPLACEABLE"
><I
>select_statement</I
></TT
>には、<TT
CLASS="LITERAL"
>ORDER BY</TT
>、<TT
CLASS="LITERAL"
>LIMIT</TT
>、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>句を持たない、任意の<TT
CLASS="COMMAND"
>SELECT</TT
>文が入ります。
   </P
><P
><TT
CLASS="LITERAL"
>EXCEPT</TT
>は、左側の<TT
CLASS="COMMAND"
>SELECT</TT
>文の結果には存在し、右側の<TT
CLASS="COMMAND"
>SELECT</TT
>文の結果には存在しない行の集合を生成します。
   </P
><P
><TT
CLASS="LITERAL"
>ALL</TT
>オプションが指定されていない限り、<TT
CLASS="LITERAL"
>EXCEPT</TT
>の結果には重複行は含まれません。
<TT
CLASS="LITERAL"
>ALL</TT
>がある場合、左側テーブルに<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
>個、右側テーブルに<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>個の重複がある行は、結果集合ではmax(<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
>-<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>,0)個出現します。
重複行を除去するデフォルトの動作を明示的に指定するために<TT
CLASS="LITERAL"
>DISTINCT</TT
>を記述することができます。
   </P
><P
>1つの<TT
CLASS="COMMAND"
>SELECT</TT
>文に複数の<TT
CLASS="LITERAL"
>EXCEPT</TT
>演算子がある場合、括弧がない限り、それらは左から右に評価されます。
<TT
CLASS="LITERAL"
>EXCEPT</TT
>の結び付きの強さは<TT
CLASS="LITERAL"
>UNION</TT
>と同じです。
   </P
><P
>現時点では、<TT
CLASS="LITERAL"
>EXCEPT</TT
>の結果や<TT
CLASS="LITERAL"
>EXCEPT</TT
>に対する入力に、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>または<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>を指定することはできません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-ORDERBY"
></A
><H3
><TT
CLASS="LITERAL"
>ORDER BY</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>ORDER BY</TT
>句の一般的な構文は以下の通りです（この句は省略可能です）。

</P><PRE
CLASS="SYNOPSIS"
>ORDER BY <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> [ ASC | DESC | USING <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ] [ NULLS { FIRST | LAST } ] [, ...]</PRE
><P>
<TT
CLASS="LITERAL"
>ORDER BY</TT
>句を使うと、結果行を指定した式（複数可）に従ってソートすることができます。
最も左側の式を使って比較した結果、2つの行が等しいと判断された場合は、1つ右側の式を使って比較します。その結果も等しければ、さらに次の式に進みます。
指定した全ての式で等しいと判断された場合は、実装に依存した順番で返されます。
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>には、出力列（<TT
CLASS="COMMAND"
>SELECT</TT
>リスト項目）の名前または序数、あるいは入力列値から形成される任意の式を取ることができます。
   </P
><P
>序数は、出力列の位置（左から右に割り当てられます）を示します。
これを使うと、一意な名前を持たない列の順序を定義することができます。
<TT
CLASS="LITERAL"
>AS</TT
>句を使用すれば出力列に名前を割り当てることができるので、これはどうしても必要な機能というわけではありません。
   </P
><P
>また、<TT
CLASS="LITERAL"
>ORDER BY</TT
>句には、<TT
CLASS="COMMAND"
>SELECT</TT
>出力リストに出現しない列を含む、任意の式を使用できます。
したがって、以下の文は有効です。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT name FROM distributors ORDER BY code;</PRE
><P>
ただし、<TT
CLASS="LITERAL"
>UNION</TT
>、<TT
CLASS="LITERAL"
>INTERSECT</TT
>、<TT
CLASS="LITERAL"
>EXCEPT</TT
>の結果に<TT
CLASS="LITERAL"
>ORDER BY</TT
>を適用する場合は、式は使用できず、出力列の名前か序数のみを指定できるという制限があります。
   </P
><P
><TT
CLASS="LITERAL"
>ORDER BY</TT
>の式として出力列名と入力列名の両方に一致する単なる名前が与えられた場合、<TT
CLASS="LITERAL"
>ORDER BY</TT
>はそれを出力列名として扱います。
これは、同じ状況における<TT
CLASS="LITERAL"
>GROUP BY</TT
>の選択とは反対です。
この不整合は、標準SQLとの互換性を保持するために発生しています。
   </P
><P
><TT
CLASS="LITERAL"
>ORDER BY</TT
>中の任意の式の後に、キーワード<TT
CLASS="LITERAL"
>ASC</TT
>（昇順）、<TT
CLASS="LITERAL"
>DESC</TT
>（降順）を付加することができます(省略可能)。
指定がなければ、デフォルトで<TT
CLASS="LITERAL"
>ASC</TT
>があるものとして扱われます。
その他、順序を指定する演算子名を<TT
CLASS="LITERAL"
>USING</TT
>句に指定する方法もあります。
順序指定演算子は何らかのB-Tree演算子族の小なりまたは大なり演算子でなければなりません。
通常、<TT
CLASS="LITERAL"
>ASC</TT
>は<TT
CLASS="LITERAL"
>USING &lt;</TT
>と、<TT
CLASS="LITERAL"
>DESC</TT
>は<TT
CLASS="LITERAL"
>USING &gt;</TT
>と同じです
（ただし、ユーザ定義データ型の作成時には、デフォルトのソート順を定義することができます。また、異なる名前の演算子と対応付けすることもできます）。
   </P
><P
><TT
CLASS="LITERAL"
>NULLS LAST</TT
>が指定されると、NULL値はすべての非NULL値の後にソートされます。
<TT
CLASS="LITERAL"
>NULLS FIRST</TT
>が指定されると、NULL値はすべての非NULL値の前にソートされます。
どちらも指定されない場合のデフォルト動作は、明示的あるいは暗黙的な<TT
CLASS="LITERAL"
>ASC</TT
>の場合は<TT
CLASS="LITERAL"
>NULLS LAST</TT
>、<TT
CLASS="LITERAL"
>DESC</TT
>が指定された場合は<TT
CLASS="LITERAL"
>NULLS FIRST</TT
>です。
（したがって、デフォルトでは、NULLが非NULLよりも大きい値であるかのように動作します。）
<TT
CLASS="LITERAL"
>USING</TT
>が指定されると、デフォルトのNULLの順序は、演算子が小なり演算子か大なり演算子によって変わります。
   </P
><P
>順序付けオプションは直前の演算子にのみ適用されます。
たとえば、<TT
CLASS="LITERAL"
>ORDER BY x, y DESC</TT
>は<TT
CLASS="LITERAL"
>ORDER BY x DESC, y DESC</TT
>と同一の意味ではありません。
   </P
><P
>文字型データでは、格納する列に適用された照合順序に従ってソートされます。
これは必要に応じて<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>内に<TT
CLASS="LITERAL"
>COLLATE</TT
>句を含めることで上書きできます。
例えば<TT
CLASS="LITERAL"
>ORDER BY mycolumn COLLATE "en_US"</TT
>です。
より詳細については<A
HREF="sql-expressions.html#SQL-SYNTAX-COLLATE-EXPRS"
>項4.2.10</A
>および<A
HREF="collation.html"
>項23.2</A
>を参照してください。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-LIMIT"
></A
><H3
><TT
CLASS="LITERAL"
>LIMIT</TT
>句</H3
><P
><TT
CLASS="LITERAL"
>LIMIT</TT
>句は2つの独立した副句から構成されます。
</P><PRE
CLASS="SYNOPSIS"
>LIMIT { <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> | ALL }
OFFSET <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
></PRE
><P>
<TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>には返される行の最大数を、一方、<TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
>には行を返し始める前に飛ばす行数を指定します。
両方とも指定された場合、<TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
>行分が飛ばされ、そこから数えて<TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>行が返されます。
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>式がNULLと評価された場合、<TT
CLASS="LITERAL"
>LIMIT ALL</TT
>として、つまり制限無しとして扱われます。
<TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
>がNULLと評価された場合、<TT
CLASS="LITERAL"
>OFFSET 0</TT
>と同様に扱われます。
   </P
><P
>SQL:2008では同じ結果を実現する異なる構文が導入されました。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>でもサポートしています。
以下の構文です。
</P><PRE
CLASS="SYNOPSIS"
>OFFSET <TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
> { ROW | ROWS }
FETCH { FIRST | NEXT } [ <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
> ] { ROW | ROWS } ONLY</PRE
><P>
この構文において、<TT
CLASS="REPLACEABLE"
><I
>start</I
></TT
>または<TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>に単一整数定数以外を記述するためには、括弧でくくって記述しなければなりません。
<TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>を<TT
CLASS="LITERAL"
>FETCH</TT
>句で省略した場合、そのデフォルトは１です。
<TT
CLASS="LITERAL"
>ROW</TT
>および<TT
CLASS="LITERAL"
>ROWS</TT
>、そして<TT
CLASS="LITERAL"
>FIRST</TT
>および<TT
CLASS="LITERAL"
>NEXT</TT
>は意味がない単語で、この句に影響を与えることはありません。
標準に従うと<TT
CLASS="LITERAL"
>OFFSET</TT
>句は、<TT
CLASS="LITERAL"
>FETCH</TT
>句と同時に使用する場合、これより前に存在しなければなりません。
しかし<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は厳密ではなく、どちらが先でも許されます。
   </P
><P
><TT
CLASS="LITERAL"
>LIMIT</TT
>を使う時は、結果行を一意な順番に強制する<TT
CLASS="LITERAL"
>ORDER BY</TT
>句を使うとよいでしょう。
そうしないと、問い合わせ結果のどの部分が返されるのかがわかりません。
10〜20行目までを出力するとしても、どの順番で並べた時の10〜20行目なのでしょうか。
<TT
CLASS="LITERAL"
>ORDER BY</TT
>を指定しない限り、行が返される順番は不明です。
   </P
><P
>問い合わせプランナは問い合わせ計画を作成する時に<TT
CLASS="LITERAL"
>LIMIT</TT
>を考慮するので、<TT
CLASS="LITERAL"
>LIMIT</TT
>と<TT
CLASS="LITERAL"
>OFFSET</TT
>の指定によって異なった計画を得ることになるでしょう。計画が異なれば、異なる順番で行が返ります。
したがって、<TT
CLASS="LITERAL"
>LIMIT</TT
>/<TT
CLASS="LITERAL"
>OFFSET</TT
>値の変更によって異なる結果行を選択しようとすると、<TT
CLASS="LITERAL"
>ORDER BY</TT
>で順序を並び替えない限り、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>矛盾した結果を返すことになります</I
></SPAN
>。
これはバグではありません。
「SQLは、<TT
CLASS="LITERAL"
>ORDER BY</TT
>で順序を制御されない限り、問い合わせ結果が返す順序を約束しない」という事実の当然の帰結なのです。
   </P
><P
>厳密的に部分集合の選択を強制する<TT
CLASS="LITERAL"
>ORDER BY</TT
>がなければ、同じ<TT
CLASS="LITERAL"
>LIMIT</TT
>問い合わせを繰り返し実行してもテーブル行から異なる部分集合が取り出される可能性すらあります。
繰り返しますが、これは不具合ではありません。
こうした場合に確定した結果は単に保証されていないのです。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-FOR-UPDATE-SHARE"
></A
><H3
>ロック処理句</H3
><P
><TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>および<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>は<I
CLASS="FIRSTTERM"
>ロック処理句</I
>です。
これらはテーブルから行を入手する時にどのように<TT
CLASS="LITERAL"
>SELECT</TT
>がその行をロックするかに影響します。
   </P
><P
>ロック処理句の一般的な構文は以下の通りです。

</P><PRE
CLASS="SYNOPSIS"
>FOR <TT
CLASS="REPLACEABLE"
><I
>lock_strength</I
></TT
> [ OF <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [, ...] ] [ NOWAIT | SKIP LOCKED ]</PRE
><P>

ここで<TT
CLASS="REPLACEABLE"
><I
>lock_strength</I
></TT
>は以下のいずれかを取ることができます。

</P><PRE
CLASS="SYNOPSIS"
>UPDATE
NO KEY UPDATE
SHARE
KEY SHARE</PRE
><P>
   </P
><P
>それぞれの行レベルロックモードについての詳しい説明は<A
HREF="explicit-locking.html#LOCKING-ROWS"
>項13.3.2</A
>を参照してください。
   </P
><P
>他のトランザクションのコミットを待機することなく操作を進めるには、<TT
CLASS="LITERAL"
>NOWAIT</TT
>あるいは<TT
CLASS="LITERAL"
>SKIP LOCKED</TT
>オプションを使用してください。
<TT
CLASS="LITERAL"
>NOWAIT</TT
>では、選択行のロックを即座に獲得できない時、文は待機せずに、エラーを報告します。
<TT
CLASS="LITERAL"
>SKIP LOCKED</TT
>では、即座にロックできない行はすべてスキップされます。
行のロックをスキップすると、一貫性のないデータが見えることになるので、一般的な目的の作業のためには適しませんが、複数の消費者がキューのようなテーブルにアクセスするときのロック競合の回避などに利用できます。
<TT
CLASS="LITERAL"
>NOWAIT</TT
>および<TT
CLASS="LITERAL"
>SKIP LOCKED</TT
>は行レベルロックにのみに適用される点に注意してください。
つまり、必要な<TT
CLASS="LITERAL"
>ROW SHARE</TT
>テーブルレベルロックは通常通りの方法（ <A
HREF="mvcc.html"
>第13章</A
>を参照）で獲得されます。
もし、テーブルレベルのロックを待機せずに獲得しなければならないのであれば、最初に<A
HREF="sql-lock.html"
>LOCK</A
>の<TT
CLASS="LITERAL"
>NOWAIT</TT
>オプションを使用してください。
   </P
><P
>ロック処理句内に特定のテーブルが指定されている場合は、そのテーブルの行のみがロックされます。
<TT
CLASS="COMMAND"
>SELECT</TT
>内の他のテーブルは通常通りに読み込まれます。
テーブルリストを持たないロック処理句は、その文で使用されるすべてのテーブルに影響を与えます。
ロック処理句がビューまたは副問い合わせで使用された場合、そのビューや副問い合わせで使用されるすべてのテーブルに影響を与えます。
しかしこれらの句は主問い合わせで参照される<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせには適用されません。
<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせ内での行ロックを行いたい場合は、<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせ内でロック処理句を指定してください。
   </P
><P
>異なるロック方式を異なるテーブルに指定する必要があれば、複数のロック処理句を記述することができます。
複数のロック処理句で同一のテーブルを記述した（または暗黙的に影響が与えられた）場合、最も強いものだけが指定されたかのように処理されます。
同様に、あるテーブルに影響を与える句のいずれかで<TT
CLASS="LITERAL"
>NOWAIT</TT
>が指定された場合、そのテーブルは<TT
CLASS="LITERAL"
>NOWAIT</TT
>として処理されます。
それ以外の場合、あるテーブルに影響を与える句のいずれかで<TT
CLASS="LITERAL"
>SKIP LOCKED</TT
>が指定されていれば、そのテーブルは<TT
CLASS="LITERAL"
>SKIP LOCKED</TT
>として処理されます。
   </P
><P
>ロック処理句は、返される行がテーブルのどの行に対応するのかが明確に識別できない場合には使用することができません。
例えば、集約には使用できません。
   </P
><P
>ロック処理句が<TT
CLASS="COMMAND"
>SELECT</TT
>問い合わせの最上位レベルに存在する場合、ロック対象行は問い合わせが返す行に正確に一致します。
結合問い合わせ内の場合、ロック対象行は返される結合行に関連する行となります。
さらに、スナップショットを更新した後に問い合わせ条件を満たさなくなった場合は返されなくなりますが、問い合わせのスナップショット時点で問い合わせ条件を満たす行もロックされます。
<TT
CLASS="LITERAL"
>LIMIT</TT
>が使用された場合、制限を満たす行が返されるとロック処理は止まります。
（しかし、<TT
CLASS="LITERAL"
>OFFSET</TT
>により飛ばされた行はロックされることに注意してください。）
同様に、ロック処理句がカーソル問い合わせで使用された場合、カーソルにより実際に取り込んだ行または通り過ぎた行のみがロックされます。
   </P
><P
>ロック処理句が副<TT
CLASS="COMMAND"
>SELECT</TT
>に存在する場合、ロック対象行は副問い合わせの外側の問い合わせに返される行となります。
外側の問い合わせからの条件が副問い合わせ実行の最適化に使用される可能性がありますので、これには副問い合わせ自体の検査が提示する行より少なくなるかもしれません。
例えば、
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss WHERE col1 = 5;</PRE
><P>
は、副問い合わせ内では文字として条件が記載されていなくても、<TT
CLASS="LITERAL"
>col1 = 5</TT
>を持つ行のみがロックされます。
   </P
><P
>以前のリリースでは、セーブポイント以降に更新されるロックの保持は失敗しました。
例えば以下のコードです。
</P><PRE
CLASS="PROGRAMLISTING"
>BEGIN;
SELECT * FROM mytable WHERE key = 1 FOR UPDATE;
SAVEPOINT s;
UPDATE mytable SET ... WHERE key = 1;
ROLLBACK TO s;</PRE
><P>
<TT
CLASS="COMMAND"
>ROLLBACK TO</TT
>後の<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>ロックの保持に失敗します。
これはリリース9.3で修正されました。
  </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>注意</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
><TT
CLASS="LITERAL"
>ORDER BY</TT
>句とロック処理句を使用した、<TT
CLASS="LITERAL"
>READ COMMITTED</TT
>トランザクション隔離レベルで実行する<TT
CLASS="COMMAND"
>SELECT</TT
>コマンドでは、順序通りにならない行を返す可能性があります。
<TT
CLASS="LITERAL"
>ORDER BY</TT
>が最初に適用されるためです。
このコマンドは結果をソートしますが、その後、1行または複数の行のロック獲得がブロックされる可能性があります。
この<TT
CLASS="LITERAL"
>SELECT</TT
>のブロックが解除された時点で、順序付け対象の列値の一部が変更されているかもしれません。
これによりこうした行が（元の列値という観点では順序通りではありますが、）順序通りに現れません。
必要に応じて、これは以下のように副問い合わせ内に<TT
CLASS="LITERAL"
>FOR UPDATE/SHARE</TT
>句を記述することで、回避することができます。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM (SELECT * FROM mytable FOR UPDATE) ss ORDER BY column1;</PRE
><P>
最上位レベルにおける<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>は実際に返される行のみをロックするのに対して、これは結果として<TT
CLASS="STRUCTNAME"
>mytable</TT
>のすべての行をロックすることに注意してください。
これは、特に<TT
CLASS="LITERAL"
>ORDER BY</TT
>が<TT
CLASS="LITERAL"
>LIMIT</TT
>やその他の制限と組み合わせている場合、性能上大きな違いを生み出す可能性があります。
このため、この技法は、順序付け対象の列に対する同時実行の更新が想定され、かつ、厳密にソートされた結果が要求される場合にのみ推奨されます。
   </P
><P
><TT
CLASS="LITERAL"
>REPEATABLE READ</TT
>または<TT
CLASS="LITERAL"
>SERIALIZABLE</TT
>トランザクション隔離レベルでは、（<TT
CLASS="LITERAL"
>'40001'</TT
>という<TT
CLASS="LITERAL"
>SQLSTATE</TT
>を持つ）シリアライゼーション失敗が発生します。
このためこれらの隔離レベルでは順序通りでない行を受け取る可能性はありません。
   </P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-TABLE"
></A
><H3
><TT
CLASS="LITERAL"
>TABLE</TT
>コマンド</H3
><P
></P><PRE
CLASS="PROGRAMLISTING"
>TABLE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></PRE
><P>
というコマンドは以下と同じです。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></PRE
><P>
これは、最上位のコマンドとして、あるいは複雑な問い合わせの一部として、入力を省略する構文の一種としても使用することができます。
<TT
CLASS="LITERAL"
>WITH</TT
>、<TT
CLASS="LITERAL"
>UNION</TT
>、<TT
CLASS="LITERAL"
>INTERSECT</TT
>、<TT
CLASS="LITERAL"
>EXCEPT</TT
>、<TT
CLASS="LITERAL"
>ORDER BY</TT
>、<TT
CLASS="LITERAL"
>LIMIT</TT
>、<TT
CLASS="LITERAL"
>OFFSET</TT
>、<TT
CLASS="LITERAL"
>FETCH</TT
>、<TT
CLASS="LITERAL"
>FOR</TT
>のロック句だけを<TT
CLASS="COMMAND"
>TABLE</TT
>と一緒に使うことができます。
<TT
CLASS="LITERAL"
>WHERE</TT
>句およびいかなる形式の集約も使うことはできません。
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN90960"
></A
><H2
>例</H2
><P
><TT
CLASS="LITERAL"
>films</TT
>テーブルを<TT
CLASS="LITERAL"
>distributors</TT
>テーブルと結合します。

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT f.title, f.did, d.name, f.date_prod, f.kind
    FROM distributors d, films f
    WHERE f.did = d.did

       title       | did |     name     | date_prod  |   kind
-------------------+-----+--------------+------------+----------
 The Third Man     | 101 | British Lion | 1949-12-23 | Drama
 The African Queen | 101 | British Lion | 1951-08-11 | Romantic
 ...</PRE
><P>
  </P
><P
>全ての映画の<TT
CLASS="LITERAL"
>len</TT
>列を合計し<TT
CLASS="LITERAL"
>kind</TT
>列によって結果をグループ化します。

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT kind, sum(len) AS total FROM films GROUP BY kind;

   kind   | total
----------+-------
 Action   | 07:34
 Comedy   | 02:58
 Drama    | 14:28
 Musical  | 06:42
 Romantic | 04:38</PRE
><P>
  </P
><P
>全ての映画の<TT
CLASS="LITERAL"
>len</TT
>列を合計し<TT
CLASS="LITERAL"
>kind</TT
>列によって結果をグループ化し、合計が5時間より少ないグループの合計を表示します。

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT kind, sum(len) AS total
    FROM films
    GROUP BY kind
    HAVING sum(len) &lt; interval '5 hours';

   kind   | total
----------+-------
 Comedy   | 02:58
 Romantic | 04:38</PRE
><P>
  </P
><P
>次に、結果を2番目の列（<TT
CLASS="LITERAL"
>name</TT
>）の内容に基づいてソートする方法を2つ例示します。

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM distributors ORDER BY name;
SELECT * FROM distributors ORDER BY 2;

 did |       name
-----+------------------
 109 | 20th Century Fox
 110 | Bavaria Atelier
 101 | British Lion
 107 | Columbia
 102 | Jean Luc Godard
 113 | Luso films
 104 | Mosfilm
 103 | Paramount
 106 | Toho
 105 | United Artists
 111 | Walt Disney
 112 | Warner Bros.
 108 | Westward</PRE
><P>
  </P
><P
>次の例は、<TT
CLASS="LITERAL"
>distributors</TT
>テーブルと<TT
CLASS="LITERAL"
>actors</TT
>テーブルの和集合を取得する方法を示しています。さらに、両方のテーブルで結果をWという文字で始まる行のみに限定しています。
重複しない行のみが必要なので、<TT
CLASS="LITERAL"
>ALL</TT
>キーワードは省略されています。

</P><PRE
CLASS="PROGRAMLISTING"
>distributors:               actors:
 did |     name              id |     name
-----+--------------        ----+----------------
 108 | Westward               1 | Woody Allen
 111 | Walt Disney            2 | Warren Beatty
 112 | Warner Bros.           3 | Walter Matthau
 ...                         ...

SELECT distributors.name
    FROM distributors
    WHERE distributors.name LIKE 'W%'
UNION
SELECT actors.name
    FROM actors
    WHERE actors.name LIKE 'W%';

      name
----------------
 Walt Disney
 Walter Matthau
 Warner Bros.
 Warren Beatty
 Westward
 Woody Allen</PRE
><P>
  </P
><P
>次に、<TT
CLASS="LITERAL"
>FROM</TT
>句内での関数の使用方法について、列定義リストがある場合とない場合の両方の例を示します。

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION distributors(int) RETURNS SETOF distributors AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors(111);
 did |    name
-----+-------------
 111 | Walt Disney

CREATE FUNCTION distributors_2(int) RETURNS SETOF record AS $$
    SELECT * FROM distributors WHERE did = $1;
$$ LANGUAGE SQL;

SELECT * FROM distributors_2(111) AS (f1 int, f2 text);
 f1  |     f2
-----+-------------
 111 | Walt Disney</PRE
><P>
  </P
><P
>以下は序数列が追加された関数の例です。

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM unnest(ARRAY['a','b','c','d','e','f']) WITH ORDINALITY;
 unnest | ordinality
--------+----------
 a      |        1
 b      |        2
 c      |        3
 d      |        4
 e      |        5
 f      |        6
(6 rows)</PRE
><P>
  </P
><P
>以下の例では簡単な<TT
CLASS="LITERAL"
>WITH</TT
>句の使用方法を示します。

</P><PRE
CLASS="PROGRAMLISTING"
>WITH t AS (
    SELECT random() as x FROM generate_series(1, 3)
  )
SELECT * FROM t
UNION ALL
SELECT * FROM t

         x          
--------------------
  0.534150459803641
  0.520092216785997
 0.0735620250925422
  0.534150459803641
  0.520092216785997
 0.0735620250925422</PRE
><P>

<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせが一度だけ評価されることに注意してください。
このため3つのランダムな値の同じ集合2組を得ることになります。
  </P
><P
>以下の例では<TT
CLASS="LITERAL"
>WITH RECURSIVE</TT
>を使用して、直接の部下しか表示しないテーブルから、従業員Maryの（直接または間接的な）部下とその間接度を見つけ出します。

</P><PRE
CLASS="PROGRAMLISTING"
>WITH RECURSIVE employee_recursive(distance, employee_name, manager_name) AS (
    SELECT 1, employee_name, manager_name
    FROM employee
    WHERE manager_name = 'Mary'
  UNION ALL
    SELECT er.distance + 1, e.employee_name, e.manager_name
    FROM employee_recursive er, employee e
    WHERE er.employee_name = e.manager_name
  )
SELECT distance, employee_name FROM employee_recursive;</PRE
><P>

初期条件、続いて<TT
CLASS="LITERAL"
>UNION</TT
>、さらに問い合わせの再帰部分という再帰問い合わせの典型的な構文に注意してください。
問い合わせの再帰部分は最終的にはタプルを返さないことを確実にしてください。
さもないと問い合わせは無限にループします。
（より多くの例については<A
HREF="queries-with.html"
>項7.8</A
>を参照してください。）
  </P
><P
>以下の例では、<TT
CLASS="STRUCTNAME"
>manufacturers</TT
>テーブルの各行に対して集合を返す<CODE
CLASS="FUNCTION"
>get_product_names()</CODE
>関数を適用するために<TT
CLASS="LITERAL"
>LATERAL</TT
>を使用します。

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT m.name AS mname, pname
FROM manufacturers m, LATERAL get_product_names(m.id) pname;</PRE
><P>

これは内部結合ですので、現時点で製品をまったく持たないメーカは結果に現れません。
こうしたメーカの名前も結果に含めたければ以下のようにします。

</P><PRE
CLASS="PROGRAMLISTING"
>SELECT m.name AS mname, pname
FROM manufacturers m LEFT JOIN LATERAL get_product_names(m.id) pname ON true;</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN91002"
></A
><H2
>互換性</H2
><P
>当然ながら、<TT
CLASS="COMMAND"
>SELECT</TT
>文は標準SQLと互換性があります。
しかし、拡張機能や実現されていない機能もいくつかあります。
  </P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91006"
></A
><H3
><TT
CLASS="LITERAL"
>FROM</TT
>句の省略</H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、<TT
CLASS="LITERAL"
>FROM</TT
>句を省略することができます。
これによって、以下のように単純な式を計算させることができます。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 2+2;

 ?column?
----------
        4</PRE
><P>
他の<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>データベースでは、このような<TT
CLASS="COMMAND"
>SELECT</TT
>を行うためにはダミーの1行テーブルを使わなければならないものもあります。
   </P
><P
><TT
CLASS="LITERAL"
>FROM</TT
>句の指定がない場合、問い合わせではデータベーステーブルを参照することができません。
例えば、以下の問い合わせは無効です。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT distributors.* WHERE distributors.name = 'Westward';</PRE
><P>
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>リリース8.1より前まででは、こうした形の問い合わせを受け付け、問い合わせで参照する各テーブルに対する暗黙的な項目を問い合わせの<TT
CLASS="LITERAL"
>FROM</TT
>句に追加していました。
これは許されなくなりました。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91020"
></A
><H3
>空の<TT
CLASS="LITERAL"
>SELECT</TT
>リスト</H3
><P
><TT
CLASS="LITERAL"
>SELECT</TT
>の後の出力式のリストは空でも良く、このとき列数がゼロの結果テーブルが生成されます。
これは標準SQLでは有効な構文ではありませんが、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は列数がゼロのテーブルを許すので、それと整合性を保つために許しています。
しかし、<TT
CLASS="LITERAL"
>DISTINCT</TT
>を使う時は、空のリストを使うことはできません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91027"
></A
><H3
><TT
CLASS="LITERAL"
>AS</TT
>キーワードの省略</H3
><P
>標準SQLでは、キーワード<TT
CLASS="LITERAL"
>AS</TT
>(省略可能)は、新しい列名が有効な列名（つまり予約済みのどのキーワードとも異なるもの）である場合は常に、出力列名の前から省くことができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>には多少より強い制限があります。
新しい列名が予約済みか否かに関わらず何らかのキーワードに一致する場合は<TT
CLASS="LITERAL"
>AS</TT
>が必要です。
推奨する実践方法は、今後のキーワードの追加と競合する可能性に備え、<TT
CLASS="LITERAL"
>AS</TT
>を使用する、または出力列名を二重引用符で括ることです。
   </P
><P
><TT
CLASS="LITERAL"
>FROM</TT
>項目において標準および<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、未予約のキーワードである別名の前の<TT
CLASS="LITERAL"
>AS</TT
>を省略することができます。
しかし、構文があいまいになるため、出力名では実践的ではありません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91039"
></A
><H3
><TT
CLASS="LITERAL"
>ONLY</TT
>と継承関係</H3
><P
>標準SQLでは、<TT
CLASS="LITERAL"
>SELECT * FROM ONLY (tab1), ONLY (tab2) WHERE ...</TT
>のように、<TT
CLASS="LITERAL"
>ONLY</TT
>を記述する時にテーブル名の前後を括弧でくくることを要求します。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ではこの括弧を省略可能であるとみなしています。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では最後に<TT
CLASS="LITERAL"
>*</TT
>を付けることで
明示的に子テーブルを含めるという<TT
CLASS="LITERAL"
>ONLY</TT
>ではない動作を指定することができます。
標準ではこれを許していません。
   </P
><P
>（これらの点は<TT
CLASS="LITERAL"
>ONLY</TT
>オプションをサポートするすべてのSQLコマンドで同様に適用されます。）
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91052"
></A
><H3
><TT
CLASS="LITERAL"
>TABLESAMPLE</TT
>句の制限</H3
><P
>現在のところ、<TT
CLASS="LITERAL"
>TABLESAMPLE</TT
>句は通常のテーブルとマテリアライズドビューでのみ受け付けられます。
SQL標準では、<TT
CLASS="LITERAL"
>FROM</TT
>句の任意の要素について適用可能であるべきとされています。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91058"
></A
><H3
><TT
CLASS="LITERAL"
>TABLESAMPLE</TT
> Clause Restrictions★訳して</H3
><P
>★この節、追加
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91062"
></A
><H3
><TT
CLASS="LITERAL"
>FROM</TT
>内の関数呼び出し</H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、<TT
CLASS="LITERAL"
>FROM</TT
>リストのメンバとして直接関数呼び出しを記述することができます。
標準SQLではこうした関数呼び出しを副<TT
CLASS="COMMAND"
>SELECT</TT
>内に囲む必要があります。
つまり<TT
CLASS="LITERAL"
>FROM <TT
CLASS="REPLACEABLE"
><I
>func</I
></TT
>(...) <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
></TT
>はおおよそ<TT
CLASS="LITERAL"
>FROM LATERAL (SELECT <TT
CLASS="REPLACEABLE"
><I
>func</I
></TT
>(...)) <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
></TT
>と同じです。
暗黙的に<TT
CLASS="LITERAL"
>LATERAL</TT
>であるとみなされることに注意してください。
標準では<TT
CLASS="LITERAL"
>FROM</TT
>内の<TT
CLASS="LITERAL"
>UNNEST()</TT
>項目には<TT
CLASS="LITERAL"
>LATERAL</TT
>構文を必要とするためです。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では<TT
CLASS="LITERAL"
>UNNEST()</TT
>を他の集合を返す関数と同じものとして扱います。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91081"
></A
><H3
><TT
CLASS="LITERAL"
>GROUP BY</TT
>と<TT
CLASS="LITERAL"
>ORDER BY</TT
>における利用可能な名前空間</H3
><P
>標準SQL-92では、<TT
CLASS="LITERAL"
>ORDER BY</TT
>句で使用できるのは、出力列名か序数のみであり、<TT
CLASS="LITERAL"
>GROUP BY</TT
>句で使用できるのは、入力列名からなる式のみです。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、これらの句で両方が指定できるように拡張されています
（ただし、不明瞭さがある場合は標準の解釈が使用されます）。
さらに、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ではどちらの句にも任意の式を指定できます。
式で使われる名前は、常に出力列名ではなく入力列の名前とみなされることに注意してください。
   </P
><P
>SQL:1999以降では、SQL-92と完全には上位互換でない、多少異なる定義が採用されています。
しかし、ほとんどの場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はSQL:1999と同じ方法で<TT
CLASS="LITERAL"
>ORDER BY</TT
>や<TT
CLASS="LITERAL"
>GROUP BY</TT
>を解釈します。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91094"
></A
><H3
>関数依存性</H3
><P
>テーブルの主キーが<TT
CLASS="LITERAL"
>GROUP BY</TT
>リストに含まれる場合に限り、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は（<TT
CLASS="LITERAL"
>GROUP BY</TT
>で列を省くことができる）関数依存性を認識します。
標準SQLでは、認識しなければならない追加の条件を規定しています。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91100"
></A
><H3
><TT
CLASS="LITERAL"
>WINDOW</TT
>句の制限</H3
><P
>標準SQLではウィンドウ用の<TT
CLASS="REPLACEABLE"
><I
>frame_clause</I
></TT
>に追加のオプションを提供します。
現在の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では上述のオプションのみをサポートします。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91106"
></A
><H3
><TT
CLASS="LITERAL"
>LIMIT</TT
>および<TT
CLASS="LITERAL"
>OFFSET</TT
></H3
><P
><TT
CLASS="LITERAL"
>LIMIT</TT
>および<TT
CLASS="LITERAL"
>OFFSET</TT
>句は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>独自の構文ですが、<SPAN
CLASS="PRODUCTNAME"
>MySQL</SPAN
>でも使用されています。
<A
HREF="sql-select.html#SQL-LIMIT"
><I
><I
>LIMIT</I
>句</I
></A
>で説明したように、標準SQL:2008にて同じ機能の<TT
CLASS="LITERAL"
>OFFSET ... FETCH {FIRST|NEXT} ...</TT
>が導入されました。
この構文は<SPAN
CLASS="PRODUCTNAME"
>IBM DB2</SPAN
>でも使用されています。
（<SPAN
CLASS="PRODUCTNAME"
>Oracle</SPAN
>用に開発されたアプリケーションでは、これらの句の機能を実装するために自動生成される<TT
CLASS="LITERAL"
>rownum</TT
>列を含めるという回避策を使用することが多いですが、PostgreSQLでは利用できません。）
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91120"
></A
><H3
><TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
></H3
><P
><TT
CLASS="LITERAL"
>FOR UPDATE</TT
>は標準SQLに存在しますが、標準では、<TT
CLASS="COMMAND"
>DECLARE CURSOR</TT
>のオプションとしてしか許されていません。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、副<TT
CLASS="COMMAND"
>SELECT</TT
>など任意の<TT
CLASS="COMMAND"
>SELECT</TT
>で許されます。
これは拡張です。
<TT
CLASS="LITERAL"
>FOR NO KEY UPDATE</TT
>、<TT
CLASS="LITERAL"
>FOR SHARE</TT
>、<TT
CLASS="LITERAL"
>FOR KEY SHARE</TT
>の亜種、および<TT
CLASS="LITERAL"
>NOWAIT</TT
>と<TT
CLASS="LITERAL"
>SKIP LOCKED</TT
>オプションは標準にはありません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91137"
></A
><H3
><TT
CLASS="LITERAL"
>WITH</TT
>内のデータ変更文</H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では<TT
CLASS="LITERAL"
>WITH</TT
>問い合わせとして<TT
CLASS="COMMAND"
>INSERT</TT
>、<TT
CLASS="COMMAND"
>UPDATE</TT
>および<TT
CLASS="COMMAND"
>DELETE</TT
>を使用することができます。
これは標準SQLにはありません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN91146"
></A
><H3
>非標準句</H3
><P
><TT
CLASS="LITERAL"
>DISTINCT ON ( ... )</TT
>は標準SQLの拡張です。
   </P
><P
><TT
CLASS="LITERAL"
>ROWS FROM( ... )</TT
>は標準SQLの拡張です。
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-security-label.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-selectinto.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>SECURITY LABEL</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>SELECT INTO</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
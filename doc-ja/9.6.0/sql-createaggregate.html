<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE AGGREGATE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE ACCESS METHOD"
HREF="sql-create-access-method.html"><LINK
REL="NEXT"
TITLE="CREATE CAST"
HREF="sql-createcast.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE ACCESS METHOD"
HREF="sql-create-access-method.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE CAST"
HREF="sql-createcast.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATEAGGREGATE"
></A
>CREATE AGGREGATE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN77791"
></A
><H2
>名前</H2
>CREATE AGGREGATE&nbsp;--&nbsp;新しい集約関数を定義する</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN77794"
></A
><H2
>概要</H2
><PRE
CLASS="SYNOPSIS"
>CREATE AGGREGATE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ( [ <TT
CLASS="REPLACEABLE"
><I
>argmode</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>argname</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>arg_data_type</I
></TT
> [ , ... ] ) (
    SFUNC = <TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
>,
    STYPE = <TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>
    [ , SSPACE = <TT
CLASS="REPLACEABLE"
><I
>state_data_size</I
></TT
> ]
    [ , FINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
> ]
    [ , FINALFUNC_EXTRA ]
    [ , COMBINEFUNC = <TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
> ]
    [ , SERIALFUNC = <TT
CLASS="REPLACEABLE"
><I
>serialfunc</I
></TT
> ]
    [ , DESERIALFUNC = <TT
CLASS="REPLACEABLE"
><I
>deserialfunc</I
></TT
> ]
    [ , INITCOND = <TT
CLASS="REPLACEABLE"
><I
>initial_condition</I
></TT
> ]
    [ , MSFUNC = <TT
CLASS="REPLACEABLE"
><I
>msfunc</I
></TT
> ]
    [ , MINVFUNC = <TT
CLASS="REPLACEABLE"
><I
>minvfunc</I
></TT
> ]
    [ , MSTYPE = <TT
CLASS="REPLACEABLE"
><I
>mstate_data_type</I
></TT
> ]
    [ , MSSPACE = <TT
CLASS="REPLACEABLE"
><I
>mstate_data_size</I
></TT
> ]
    [ , MFINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>mffunc</I
></TT
> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <TT
CLASS="REPLACEABLE"
><I
>minitial_condition</I
></TT
> ]
    [ , SORTOP = <TT
CLASS="REPLACEABLE"
><I
>sort_operator</I
></TT
> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
)

CREATE AGGREGATE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ( [ [ <TT
CLASS="REPLACEABLE"
><I
>argmode</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>argname</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>arg_data_type</I
></TT
> [ , ... ] ]
                        ORDER BY [ <TT
CLASS="REPLACEABLE"
><I
>argmode</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>argname</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>arg_data_type</I
></TT
> [ , ... ] ) (
    SFUNC = <TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
>,
    STYPE = <TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>
    [ , SSPACE = <TT
CLASS="REPLACEABLE"
><I
>state_data_size</I
></TT
> ]
    [ , FINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
> ]
    [ , FINALFUNC_EXTRA ]
    [ , INITCOND = <TT
CLASS="REPLACEABLE"
><I
>initial_condition</I
></TT
> ]
    [ , PARALLEL = { SAFE | RESTRICTED | UNSAFE } ]
    [ , HYPOTHETICAL ]
)

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>または以下の旧構文</SPAN
></SPAN
>

CREATE AGGREGATE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> (
    BASETYPE = <TT
CLASS="REPLACEABLE"
><I
>base_type</I
></TT
>,
    SFUNC = <TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
>,
    STYPE = <TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>
    [ , SSPACE = <TT
CLASS="REPLACEABLE"
><I
>state_data_size</I
></TT
> ]
    [ , FINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
> ]
    [ , FINALFUNC_EXTRA ]
    [ , COMBINEFUNC = <TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
> ]
    [ , SERIALFUNC = <TT
CLASS="REPLACEABLE"
><I
>serialfunc</I
></TT
> ]
    [ , DESERIALFUNC = <TT
CLASS="REPLACEABLE"
><I
>deserialfunc</I
></TT
> ]
    [ , INITCOND = <TT
CLASS="REPLACEABLE"
><I
>initial_condition</I
></TT
> ]
    [ , MSFUNC = <TT
CLASS="REPLACEABLE"
><I
>msfunc</I
></TT
> ]
    [ , MINVFUNC = <TT
CLASS="REPLACEABLE"
><I
>minvfunc</I
></TT
> ]
    [ , MSTYPE = <TT
CLASS="REPLACEABLE"
><I
>mstate_data_type</I
></TT
> ]
    [ , MSSPACE = <TT
CLASS="REPLACEABLE"
><I
>mstate_data_size</I
></TT
> ]
    [ , MFINALFUNC = <TT
CLASS="REPLACEABLE"
><I
>mffunc</I
></TT
> ]
    [ , MFINALFUNC_EXTRA ]
    [ , MINITCOND = <TT
CLASS="REPLACEABLE"
><I
>minitial_condition</I
></TT
> ]
    [ , SORTOP = <TT
CLASS="REPLACEABLE"
><I
>sort_operator</I
></TT
> ]
)</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN77845"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
>は、新しい集約関数を定義します。
配布物には基本的、かつ、よく使用される集約関数がいくつか含まれています。これらの集約関数については、<A
HREF="functions-aggregate.html"
>項9.20</A
>に文書化されています。
新しい型を定義する場合、またはまだ提供されていない集約関数が必要な場合、必要な機能を実現するために<TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
>を使うことができます。
  </P
><P
>スキーマ名が付けられている場合（例えば、<TT
CLASS="LITERAL"
>CREATE AGGREGATE myschema.myagg ...</TT
>）、集約関数は指定されたスキーマに作成されます。
スキーマ名がなければ、集約関数は現在のスキーマに作成されます。
  </P
><P
>集約関数は名前と入力データ型(複数可)の組み合わせによって識別されます。
演算の対象となる入力データ型が異なっていれば、同じスキーマ内に同じ名前の集約関数があっても構いません。
1つのスキーマ内では、集約関数の名前と入力データ型の組み合わせは、通常の関数の名前と入力データ型の組み合わせと異なる必要があります。
この動作は通常の関数名についてオーバーロードする時と同じです(<A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>を参照してください)。
  </P
><P
>単純な集約関数は1つか2つの通常の関数から作られます。
状態遷移関数<TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
>と最終計算関数<TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
>(省略可能)です。
これらは以下のように使われます。
</P><PRE
CLASS="PROGRAMLISTING"
><TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
>( 内部状態, 次のデータ値 ) ---&#62; 次の内部状態
<TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
>( 内部状態 ) ---&#62; 集約の結果</PRE
><P>
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、集約の現在の内部状態を保持する<TT
CLASS="REPLACEABLE"
><I
>stype</I
></TT
>データ型の一時変数を作成します。
それぞれの入力行に対して、集約引数の値が計算され、現在の状態値と新しい引数値で状態遷移関数が呼び出され、新しい内部状態変数が計算されます。
全ての行が処理されると、最終関数が1回呼び出され、集約の出力値が計算されます。
最終関数がない場合は、終了時の状態値がそのまま返されます。
  </P
><P
>集約関数は、初期条件、つまり内部状態値の初期値を提供することができます。
これは<TT
CLASS="TYPE"
>text</TT
>型の値としてデータベースに格納されますが、状態値データ型の定数として有効な外部表現でなければいけません。
初期状態が与えられていない場合、状態値はNULLから始まります。
  </P
><P
>状態遷移関数が<SPAN
CLASS="QUOTE"
>"strict"</SPAN
>と宣言されている場合、NULLを入力値にして呼び出すことはできません。
そのような遷移関数では、集約は次のように実行されます。
NULL入力値を持つ行は無視されます。
（関数は呼び出されず、前回の状態値が保持されます。）
初期状態値がNULLである場合、初めて入力行がすべて非NULL入力値であった時にその最初の引数の値で状態値を置き換え、以後、すべて非NULL入力値のそれぞれの行について、遷移関数が呼び出されます。
このような動作は、<CODE
CLASS="FUNCTION"
>max</CODE
>のような集約を実装するには便利です。
ただし、<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>が最初の<TT
CLASS="REPLACEABLE"
><I
>arg_data_type</I
></TT
>と同じ時にのみ有効であることに注意してください。
これらの型が異なる時は、非NULL初期値を供給するか、strictでない遷移関数を使わなければいけません。
  </P
><P
>状態遷移関数がstrictでない場合は、それぞれの入力行に対してその関数が無条件に呼び出されるので、NULL入力とNULL状態値を自分で処理しなければいけません。
これは、関数の作成者が、集約関数におけるNULL値の扱いを完全に制御できることを意味します。
  </P
><P
>最終関数が<SPAN
CLASS="QUOTE"
>"strict"</SPAN
>と宣言されていると、終了状態値がNULLの時は、最終関数が呼び出されません。
その場合、NULLという結果が自動的に出力されます
（もちろんこれは、strictな関数の一般的な動作に過ぎません）。
いずれにせよ、最終関数はNULLを返すことができます。
例えば、<CODE
CLASS="FUNCTION"
>avg</CODE
>の最終関数は、入力が0行だとわかるとNULLを返します。
  </P
><P
>最終関数を、状態値だけでなく、集約の入力値に対応する追加パラメータも取るように宣言すると便利なことがあります。
こうすることの主な理由に、最終関数が多様型で、状態値のデータ型だけでは結果の型を決定するのに不十分である、ということがあります。
これらの追加パラメータは必ずNULLとして渡されます(従って<TT
CLASS="LITERAL"
>FINALFUNC_EXTRA</TT
>オプションが使われている場合、最終関数はstrictであってはいけません)が、それでも有効なパラメータです。
最終関数は、現在の呼び出しでの実際の引数の型を特定するために、例えば<CODE
CLASS="FUNCTION"
>get_fn_expr_argtype</CODE
>を使うことができます。
  </P
><P
>集約は、<A
HREF="xaggr.html#XAGGR-MOVING-AGGREGATES"
>項36.10.1</A
>に記述されているように<I
CLASS="FIRSTTERM"
>移動集約モード</I
>をサポートすることができます。
このためには、<TT
CLASS="LITERAL"
>MSFUNC</TT
>、<TT
CLASS="LITERAL"
>MINVFUNC</TT
>、<TT
CLASS="LITERAL"
>MSTYPE</TT
>のパラメータを指定する必要があり、またオプションで<TT
CLASS="LITERAL"
>MSPACE</TT
>、<TT
CLASS="LITERAL"
>MFINALFUNC</TT
>、<TT
CLASS="LITERAL"
>MFINALFUNC_EXTRA</TT
>、<TT
CLASS="LITERAL"
>MINITCOND</TT
>のパラメータを指定できます。
<TT
CLASS="LITERAL"
>MINVFUNC</TT
>を除き、これらのパラメータは、<TT
CLASS="LITERAL"
>M</TT
>のない単純集約の対応するパラメータのように動作しますが、集約について逆変換関数を含む別の実装を定義します。
  </P
><P
>パラメータのリストに<TT
CLASS="LITERAL"
>ORDER BY</TT
>を含む構文は、<I
CLASS="FIRSTTERM"
>順序集合集約</I
>と呼ばれる特別な種類の集約を作ります。
また<TT
CLASS="LITERAL"
>HYPOTHETICAL</TT
>が指定されている場合は、<I
CLASS="FIRSTTERM"
>仮想集合集約</I
>が作られます。
これらの集約は、ソートされた値のグループに対して、順序に依存した方法で作用するため、入力についてのソート順の指定は、呼び出しにおける本質的な部分になります。
また、これらの集約は<I
CLASS="FIRSTTERM"
>直接</I
>引数をとることができます。
直接引数は、行毎に一度ではなく、集約に対して一度だけ評価されます。
仮想集合集約は、順序集合集約のサブクラスで、直接引数のいくつかが、集約される引数の列と、数とデータ型についてマッチする必要があります。
これにより、直接引数の値を、<SPAN
CLASS="QUOTE"
>"仮想的な"</SPAN
>行として、集約の入力行の集合に加えることができます。
  </P
><P
><A
HREF="xaggr.html#XAGGR-PARTIAL-AGGREGATES"
>項36.10.4</A
>で説明されている通り、集約では<I
CLASS="FIRSTTERM"
>部分集約</I
>をサポートすることができます。
このためには<TT
CLASS="LITERAL"
>COMBINEFUNC</TT
>パラメータを指定する必要があります。
<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>が<TT
CLASS="TYPE"
>internal</TT
>の場合、通常は<TT
CLASS="LITERAL"
>SERIALFUNC</TT
>および<TT
CLASS="LITERAL"
>DESERIALFUNC</TT
>パラメータも提供して、並列集約を可能にするのが適切でしょう。
並列集約を可能にするには、集約に<TT
CLASS="LITERAL"
>PARALLEL SAFE</TT
>の印をつける必要もあることに注意してください。
  </P
><P
><CODE
CLASS="FUNCTION"
>MIN</CODE
>や<CODE
CLASS="FUNCTION"
>MAX</CODE
>のような振舞いをする集約では、すべての入力行を走査せずにインデックスを検索することで最適化できることがあります。
このように最適化される集約の場合、<I
CLASS="FIRSTTERM"
>ソート演算子</I
>を指定することで明示してください。
その演算子で生成されるソート順で集約の最初の要素が生成されなければならないということが基本的な必要条件です。
言い換えると、
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT agg(col) FROM tab;</PRE
><P>
が
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT col FROM tab ORDER BY col USING sortop LIMIT 1;</PRE
><P>
と同じでなければならないということです。
更に、集約がNULL入力を無視すること、および、NULL以外の入力がまったくなかった時にのみNULLという結果を返すことも前提となります。
通常、データ型の<TT
CLASS="LITERAL"
>&lt;</TT
>演算子は<CODE
CLASS="FUNCTION"
>MIN</CODE
>のソート演算子として、また、<TT
CLASS="LITERAL"
>&gt;</TT
>演算子は<CODE
CLASS="FUNCTION"
>MAX</CODE
>のソート演算子として適切です。
指定した演算子がB-treeインデックス演算子クラスの<SPAN
CLASS="QUOTE"
>"より小さい"</SPAN
>ストラテジか<SPAN
CLASS="QUOTE"
>"より大きい"</SPAN
>ストラテジのメンバでない限り、最適化が実際には効果がないことに注意してください。
  </P
><P
>集約関数を作成するためには、引数の型、状態の型、戻り値の型に対する<TT
CLASS="LITERAL"
>USAGE</TT
>権限およびサポート関数に対する<TT
CLASS="LITERAL"
>EXECUTE</TT
>権限を持たなければなりません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN77921"
></A
><H2
>パラメータ</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>      作成する集約関数の名前です（スキーマ修飾名も可）。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>argmode</I
></TT
></DT
><DD
><P
>引数のモードで、<TT
CLASS="LITERAL"
>IN</TT
>または<TT
CLASS="LITERAL"
>VARIADIC</TT
>です。
(集約関数は<TT
CLASS="LITERAL"
>OUT</TT
>の引数をサポートしません。)
省略した場合のデフォルトは<TT
CLASS="LITERAL"
>IN</TT
>です。
<TT
CLASS="LITERAL"
>VARIADIC</TT
>を指定できるのは、最後の引数だけです。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>argname</I
></TT
></DT
><DD
><P
>引数の名前です。
現在は、文書化を目的とする場合にのみ有効です。
省略した場合、引数には名前がありません。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>arg_data_type</I
></TT
></DT
><DD
><P
>集約関数が演算する入力データ型です。
引数が存在しない集約関数を作成するには、引数指定のリストに<TT
CLASS="LITERAL"
>*</TT
>と記載してください
（例えば <CODE
CLASS="FUNCTION"
>count(*)</CODE
>などの集約です）。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>base_type</I
></TT
></DT
><DD
><P
><TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
>の旧構文では、入力データ型は集約の名前の次に記載されたものではなく<TT
CLASS="LITERAL"
>basetype</TT
>パラメータにより指定されます。
この構文では入力パラメータを1つしかとれないことに注意してください。
この構文で引数を持たない集約を定義するためには、<TT
CLASS="LITERAL"
>basetype</TT
>を<TT
CLASS="LITERAL"
>"ANY"</TT
> （<TT
CLASS="LITERAL"
>*</TT
>ではありません）と指定してください。
順序集合集約関数は旧構文では定義できません。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
></DT
><DD
><P
>それぞれの入力行に対して呼び出される状態遷移関数の名前です。
通常の<TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
>引数を持つ集約関数では、<TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
>は<TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
>+1個の引数を取らなければなりません。
最初の引数は<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>型で、残りはその集約の入力データ型として宣言したものと一致していなければなりません。
この関数は<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>型の値を返さなければなりません。
この関数は、現在の状態値と現在の入力データ値を受け取り、次の状態値を返します。
     </P
><P
>順序集合(仮想集合を含む)集約では、状態遷移関数は現在値と集約引数のみを受け取り、直接引数は受け取りません。
それ以外の点は全く同じです。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
></DT
><DD
><P
>集約の状態値のデータ型です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>state_data_size</I
></TT
></DT
><DD
><P
>集約の状態値のおおよその平均サイズ(単位はバイト)です。
このパラメータを省略した場合、あるいはゼロを指定した場合、<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>に基づいたデフォルトの推定が使われます。
プランナは、グループ化された集約のクエリに必要なメモリを推定するのに、この値を使います。
プランナは、ハッシュテーブルが<A
HREF="runtime-config-resource.html#GUC-WORK-MEM"
>work_mem</A
>に収まると見積もられる場合にのみ、ハッシュ集約の使用を検討します。
従って、このパラメータに大きな値を設定すると、ハッシュ集約が使われないようになります。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
></DT
><DD
><P
>最終関数の名前です。最終関数は、全ての入力行に対する処理が終わった後、集約の結果を計算するために呼び出されます。
通常の集約では、この関数は<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>型の引数を1つ取らなければなりません。
集約の出力データ型はこの関数の返り値として定義されます。
<TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
>が指定されない場合には、集約の結果として終了時の状態値が使われます。出力型は<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>になります。
     </P
><P
>順序集合(仮想集合を含む)集約では、最終関数は終了時の状態値だけでなく、すべての直接引数の値も受け取ります。
     </P
><P
><TT
CLASS="LITERAL"
>FINALFUNC_EXTRA</TT
>が指定された場合、最終関数は、終了時の状態値と直接引数に加えて、集約の通常の(集約された）引数に対応する追加のNULL値を受け取ります。
これは主に、多様型の集約が定義されているときに、集約の結果の型を正しく解決するのに役立ちます。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
></DT
><DD
><P
>集約関数が部分集約をサポートできるようにするために、<TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
>を指定することができます。
これが指定されると、<TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
>は、入力値の何らかの部分集合に対する集約の結果を含む2つの<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>値を結合し、両方の入力に対する集約結果を表す新しい<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>を生成しなければなりません。
この関数は、個々の入力行に対して作用してそれを集約中の状態に追加するのではなく、実行中の状態に別の集約状態を追加する<TT
CLASS="REPLACEABLE"
><I
>sfunc</I
></TT
>として考えることができます。
     </P
><P
><TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
>は、<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>の引数を2つ取り、<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>の値を返すものとして宣言されなければなりません。
この関数は<SPAN
CLASS="QUOTE"
>"strict"</SPAN
>とすることもできます。
その場合、入力状態の一方がNULLのときは関数が呼び出されず、他方の状態が正しい結果であると見なされます。
     </P
><P
><TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>が<TT
CLASS="TYPE"
>internal</TT
>の集約関数では、<TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
>をSTRICTにすることはできません。
この場合、<TT
CLASS="REPLACEABLE"
><I
>combinefunc</I
></TT
>はNULL状態を正しく処理し、返される状態が集約のメモリコンテキスト内に適切に保存されることを確実にする必要があります。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>serialfunc</I
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>が<TT
CLASS="TYPE"
>internal</TT
>の集約関数は、<TT
CLASS="REPLACEABLE"
><I
>serialfunc</I
></TT
>関数がある場合に限り、並列集約に参加することができます。
<TT
CLASS="REPLACEABLE"
><I
>serialfunc</I
></TT
>は、集約の状態を他のプロセスに転送するために<TT
CLASS="TYPE"
>bytea</TT
>の値にシリアライズしなければなりません。
この関数は<TT
CLASS="TYPE"
>internal</TT
>型の引数を1つ取り、<TT
CLASS="TYPE"
>bytea</TT
>型を返さなければなりません。
これに対応する<TT
CLASS="REPLACEABLE"
><I
>deserialfunc</I
></TT
>も必要です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>deserialfunc</I
></TT
></DT
><DD
><P
>以前にシリアライズされた集約状態をデシリアライズして<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>に戻します。
この関数は<TT
CLASS="TYPE"
>bytea</TT
>型および<TT
CLASS="TYPE"
>internal</TT
>型の2つの引数を取り、<TT
CLASS="TYPE"
>internal</TT
>型の結果を生成しなければなりません。
（注意：2番目の<TT
CLASS="TYPE"
>internal</TT
>の引数は使用されませんが、型の安全性の理由から必要となっています。）
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>initial_condition</I
></TT
></DT
><DD
><P
>状態値の初期設定です。
データ型<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>として受け取り可能な文字列定数でなければいけません。
このパラメータが指定されない場合、状態値はNULLから始まります。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>msfunc</I
></TT
></DT
><DD
><P
>移動集約モードにおいて、それぞれの入力行に対して呼び出される前方状態遷移関数の名前です。
これは最初の引数と結果が<TT
CLASS="REPLACEABLE"
><I
>mstate_data_type</I
></TT
>型で、<TT
CLASS="REPLACEABLE"
><I
>state_data_type</I
></TT
>とは異なるかもしれないことを除けば、通常の遷移関数と全く同じです。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>minvfunc</I
></TT
></DT
><DD
><P
>移動集約モードで使われる逆状態遷移関数の名前です。
この関数は<TT
CLASS="REPLACEABLE"
><I
>msfunc</I
></TT
>と同じ引数および結果型を持ちますが、現在の集約状態に対して、値を追加するのではなく、取り除くために使われます。
逆遷移関数は前方状態遷移関数と同じstrictさの属性を持っていなければなりません。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>mstate_data_type</I
></TT
></DT
><DD
><P
>移動集約モードを使うときの、集約状態値のデータ型です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>mstate_data_size</I
></TT
></DT
><DD
><P
>移動集約モードを使うときの、集約状態値のおおよその平均サイズ(バイト単位)です。
<TT
CLASS="REPLACEABLE"
><I
>state_data_size</I
></TT
>と同じように作用します。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>mffunc</I
></TT
></DT
><DD
><P
>移動集約モードを使うときに、すべての入力行が走査された後で、集約結果を計算するために呼び出される最終関数の名前です。
これは、最初の引数の型が<TT
CLASS="REPLACEABLE"
><I
>mstate_data_type</I
></TT
>であり、<TT
CLASS="LITERAL"
>MFINALFUNC_EXTRA</TT
>により追加のダミー引数を指定できることを除けば、<TT
CLASS="REPLACEABLE"
><I
>ffunc</I
></TT
>と同じように作用します。
<TT
CLASS="REPLACEABLE"
><I
>mffunc</I
></TT
>または<TT
CLASS="REPLACEABLE"
><I
>mstate_data_type</I
></TT
>によって決定される集約結果の型は、集約の通常の実装によって決定される型と適合しなければなりません。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>minitial_condition</I
></TT
></DT
><DD
><P
>移動集約モードを使うときの、状態値の初期設定です。
これは、<TT
CLASS="REPLACEABLE"
><I
>initial_condition</I
></TT
>と同じように作用します。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>sort_operator</I
></TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>MIN</CODE
>または<CODE
CLASS="FUNCTION"
>MAX</CODE
>のような集約に対して関連付けされるソート演算子です。
これは単なる演算子の名前です（スキーマ修飾可能）。
この演算子は集約（これは単一引数の通常の集約でなければなりません）と同じ入力データ型を持つと前提されています。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>PARALLEL</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>PARALLEL SAFE</TT
>、<TT
CLASS="LITERAL"
>PARALLEL RESTRICTED</TT
>、<TT
CLASS="LITERAL"
>PARALLEL UNSAFE</TT
>の意味は<A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>におけるものと同じです。
集約は、その印が<TT
CLASS="LITERAL"
>PARALLEL UNSAFE</TT
>（これがデフォルトです！）あるいは<TT
CLASS="LITERAL"
>PARALLEL RESTRICTED</TT
>となっている場合、並列処理での使用を考慮されません。
プランナは集約のサポート関数の並列処理安全性の印を考慮せず、集約自体の印のみを参照することに注意してください。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>HYPOTHETICAL</TT
></DT
><DD
><P
>順序集合集約についてのみ、このフラグは、仮想集合集約の要求に従って集約の引数が処理されることを指定します。
つまり、最後のいくつかの引数が、集約される(<TT
CLASS="LITERAL"
>WITHIN GROUP</TT
>の)引数と適合しなければなりません。
<TT
CLASS="LITERAL"
>HYPOTHETICAL</TT
>フラグは実行時の動作には何の影響もなく、集約の引数のデータ型と照合についての解析時の解決にのみ影響します。
     </P
></DD
></DL
></DIV
><P
><TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
>のパラメータは、任意の順番で記述することができます。上記の順番で記述する必要はありません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN78111"
></A
><H2
>注釈</H2
><P
>サポート関数名を指定するパラメータでは、必要なら、<TT
CLASS="LITERAL"
>SFUNC = public.sum</TT
>のようにスキーマ名を書くことができます。
しかし、引数の型をそこに書くことはできません。
サポート関数の引数の型は、他のパラメータにより決定されるからです。
   </P
><P
>集約が移動集約モードをサポートしていると、移動フレームの開始のあるウィンドウ（つまり、<TT
CLASS="LITERAL"
>UNBOUNDED PRECEDING</TT
>以外のフレーム開始モード)として集約が使われる場合に計算の効率が向上します。
概念的には、前方遷移関数はウィンドウフレームに下から入るときに集約の状態に入力値を追加し、逆遷移関数はフレームを上から抜けるときにそれを取り除きます。
従って、値が取り除かれるときは、必ず追加された時と同じ順番で取り除かれます。
従って、逆遷移関数が実行される時は、いつでも最も早く追加されたけれども、まだ取り除かれていない引き数値を受け取ります。
逆遷移関数は、最も古い行を取り除いた後、現在の状態に少なくとも1行が残ることを前提とできます。
(そうならない場合は、ウィンドウ関数の仕組みは、逆遷移関数を使うのでなく、単純に新しい集約を開始します。)
   </P
><P
>移動集約モードの前方遷移関数は、新しい集約値としてNULLを返すことは許されません。
逆遷移関数がNULLを返した場合、それは、逆関数がその入力値について状態計算を元に戻すことができなかったと見なされるため、集約の計算は現在のフレームの開始位置からやり直しとなります。
こうすることで、実行中の状態値を元に戻すのが現実的でないということが稀に起こるような場合でも、移動集約モードを使うことができます。
   </P
><P
>移動集約が実装されていない場合でも、集約は移動フレームを使うことができますが、フレームの開始が移動した場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は必ず集約全体を再計算します。
集約が移動集約モードをサポートするかどうかに関わらず、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は移動フレームの終了を再計算なしに処理することができます。
これは、集約の状態に新しい値を追加し続けることで処理できます。
最終関数は集約の状態値を破壊しないものとされるので、フレームの境界の集合に対して集約結果の値が得られた後でも、集約を続行することが可能です。
   </P
><P
>順序集合集約の構文では、<TT
CLASS="LITERAL"
>VARIADIC</TT
>を最後の直接パラメータと、最後の集約(<TT
CLASS="LITERAL"
>WITHIN GROUP</TT
>)パラメータの両方について指定することができます。
しかし、現在の実装では<TT
CLASS="LITERAL"
>VARIADIC</TT
>の使用を2つの方法に制限しています。
1つ目は、順序集合集約では、<TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>のみが利用でき、他のvariadicの配列型は利用できないことです。
2つ目は、最後の直接パラメータが<TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>の場合、集約パラメータは1つだけしか使えず、かつそれも<TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>でなければならない、ということです。
(システムカタログで使われる表現において、これらの2つのパラメータは、1つの<TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>要素に統合されています。
なぜなら、<TT
CLASS="STRUCTNAME"
>pg_proc</TT
>は2つ以上の<TT
CLASS="LITERAL"
>VARIADIC</TT
>パラメータがある関数を表現できないからです。)
仮想集合集約の場合、<TT
CLASS="LITERAL"
>VARIADIC "any"</TT
>パラメータに対応する直接引数は仮想的なパラメータで、それより前のパラメータは、集約引数に対応する制約のない、追加の直接引数となります。
   </P
><P
>現在は、順序集合集約は、ウィンドウ関数として使うことはできないので、移動集約モードをサポートする必要はありません。
   </P
><P
>部分集約（並列集約を含む）は現在のところ、順序集約ではサポートされません。
また、部分集約は<TT
CLASS="LITERAL"
>DISTINCT</TT
>あるいは<TT
CLASS="LITERAL"
>ORDER BY</TT
>句を含む集約の呼び出しでは決して使われることはありません。
なぜなら、部分集約ではそれらを意味論的にサポートできないからです。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN78136"
></A
><H2
>例</H2
><P
><A
HREF="xaggr.html"
>項36.10</A
>を参照してください。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN78140"
></A
><H2
>互換性</H2
><P
><TT
CLASS="COMMAND"
>CREATE AGGREGATE</TT
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の言語拡張です。
標準SQLには、ユーザ定義の集約関数を使用する機能はありません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN78145"
></A
><H2
>関連項目</H2
><A
HREF="sql-alteraggregate.html"
>ALTER AGGREGATE</A
>, <A
HREF="sql-dropaggregate.html"
>DROP AGGREGATE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-create-access-method.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createcast.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE ACCESS METHOD</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE CAST</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
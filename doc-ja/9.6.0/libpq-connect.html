<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>データベース接続制御関数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C ライブラリ"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="libpq - C ライブラリ"
HREF="libpq.html"><LINK
REL="NEXT"
TITLE="接続状態関数"
HREF="libpq-status.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="libpq - C ライブラリ"
HREF="libpq.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 32章<SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C ライブラリ</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="接続状態関数"
HREF="libpq-status.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-CONNECT"
>32.1. データベース接続制御関数</A
></H1
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のバックエンドサーバとの接続を作成するには、以下の関数を使用します。
アプリケーションプログラムはバックエンドとの接続を一度に複数個開くことができます。
（1つの理由として、複数のデータベースへのアクセスが挙げられます。）
個々の接続は、<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>、<CODE
CLASS="FUNCTION"
>PQconnectdbParams</CODE
>または<CODE
CLASS="FUNCTION"
>PQsetdbLogin</CODE
>関数を呼び出すことで得られる<TT
CLASS="STRUCTNAME"
>PGconn</TT
>オブジェクトによって表されます。
なお、これらの関数は、<TT
CLASS="STRUCTNAME"
>PGconn</TT
>オブジェクトに割り当てるほんのわずかなメモリの余裕さえもない場合を除き、NULLではなく常にオブジェクトのポインタを返します。
また、この接続オブジェクトを通じて問い合わせを送る前に、<CODE
CLASS="FUNCTION"
>PQstatus</CODE
>関数を呼び出して、データベースとの接続に成功したか戻り値を検査しなければなりません。

   <DIV
CLASS="WARNING"
><P
></P
><TABLE
CLASS="WARNING"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>警告</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>Unix上で、libpq接続を開いたプロセスのフォークは、親と子のプロセスが同じソケットとオペレーティングシステムの資源を共有するため、予期せぬ結果を招くことがあります。
この理由により、新規実行形式を子プロセスが読み込むため<CODE
CLASS="FUNCTION"
>exec</CODE
>を行うことが安全と言っても、このような使用方法は推奨されません。
    </P
></TD
></TR
></TABLE
></DIV
>

   </P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>Windowsでは、単一のデータベース接続が反復して開始と終了を繰り返す場合、性能を向上させる方法があります。
内部的には、接続開始と終了に対して、libpqはそれぞれ<CODE
CLASS="FUNCTION"
>WSAStartup()</CODE
>と<CODE
CLASS="FUNCTION"
>WSACleanup()</CODE
>を呼び出します。
<CODE
CLASS="FUNCTION"
>WSAStartup()</CODE
>は<CODE
CLASS="FUNCTION"
>WSACleanup()</CODE
>で値が減少させられた内部Windowsライブラリ参照カウントを増加させます。
参照カウントがたった１の場合、<CODE
CLASS="FUNCTION"
>WSACleanup()</CODE
>呼び出しはすべてのリソースを解放し、すべてのDLLはアンロードされます。
これは高価な操作です。
これを回避するには、最後のデータベース接続が閉じられる時、リソースが解放されないようにアプリケーションが手動で<CODE
CLASS="FUNCTION"
>WSAStartup()</CODE
>を呼び出すことができます。
    </P
></BLOCKQUOTE
></DIV
><P>

   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQCONNECTDBPARAMS"
></A
><CODE
CLASS="FUNCTION"
>PQconnectdbParams</CODE
></DT
><DD
><P
>新たにデータベースサーバへの接続を作成します。

</P><PRE
CLASS="SYNOPSIS"
>PGconn *PQconnectdbParams(const char * const *keywords,
                          const char * const *values,
                          int expand_dbname);</PRE
><P>
      </P
><P
>この関数は、2つの<TT
CLASS="SYMBOL"
>NULL</TT
>終端の配列から取得したパラメータを使用して、データベースとの接続を新たに1つ確立します。
1つ目は文字列配列として定義される<TT
CLASS="LITERAL"
>keywords</TT
>で、それぞれがキーワードとなります。
2つ目は<TT
CLASS="LITERAL"
>values</TT
>で、各キーワードの値を提供します。
後述の<CODE
CLASS="FUNCTION"
>PQsetdbLogin</CODE
>とは異なり、関数のシグネチャを変更せずにパラメータ集合を拡張できますので、アプリケーションプログラムを新たに作成する際には、この関数(もしくは非ブロックモードでよく似た処理をする<CODE
CLASS="FUNCTION"
>PQconnectStartParams</CODE
>と<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>)を使用することをお勧めします。
      </P
><P
>現在有効なパラメータキーワードを<A
HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS"
>項32.1.2</A
>に示します。
      </P
><P
><TT
CLASS="LITERAL"
>expand_dbname</TT
>が非ゼロの場合、<TT
CLASS="PARAMETER"
>dbname</TT
>キーワードの値を接続文字列として認識させることができます。
最初に出現した<TT
CLASS="PARAMETER"
>dbname</TT
>だけがこのように展開され、後続の<TT
CLASS="PARAMETER"
>dbname</TT
>値は通常のデータベース名として処理されます。
接続文字列の取り得る書式に関する詳細については<A
HREF="libpq-connect.html#LIBPQ-CONNSTRING"
>項32.1.1</A
>を参照してください。
      </P
><P
>空の配列を渡してすべてデフォルトパラメータを使用することができます。
また渡される配列に1つ以上のパラメータ設定を持たせることもできます。
これらの長さは一致しなければなりません。
<TT
CLASS="LITERAL"
>keywords</TT
>配列の最初の<TT
CLASS="SYMBOL"
>NULL</TT
>要素で処理は停止します。
      </P
><P
>パラメータが<TT
CLASS="SYMBOL"
>NULL</TT
>や空文字列の場合には、対応する環境変数（<A
HREF="libpq-envars.html"
>項32.14</A
>参照）が検査されます。
環境変数も設定されていない場合は、組み込みのデフォルト値が使用されます。
      </P
><P
>一般的にキーワードはこれらの配列の先頭からインデックス順で処理されます。
この影響はキーワードが繰り返された場合で、最後に処理された値が残ることになります。
このため、<TT
CLASS="PARAMETER"
>dbname</TT
>キーワードの記述場所に注意することで、<TT
CLASS="PARAMETER"
>conninfo</TT
>文字列により何が上書きされるか、何が上書きされないかを決定することができます。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQCONNECTDB"
></A
><CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
></DT
><DD
><P
>新たにデータベースサーバへの接続を作成します。

</P><PRE
CLASS="SYNOPSIS"
>PGconn *PQconnectdb(const char *conninfo);</PRE
><P>
      </P
><P
>この関数は<TT
CLASS="LITERAL"
>conninfo</TT
>文字列から取得されるパラメータを使用して、新しいデータベース接続を開きます。
      </P
><P
>空の文字列を渡してすべてデフォルトパラメータを使用することができます。
また空白文字で区切ることで1つ以上のパラメータ設定を持たせることもできます。
さらに<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>を含めることができます。
詳細については<A
HREF="libpq-connect.html#LIBPQ-CONNSTRING"
>項32.1.1</A
>を参照してください。
     </P
></DD
><DT
><A
NAME="LIBPQ-PQSETDBLOGIN"
></A
><CODE
CLASS="FUNCTION"
>PQsetdbLogin</CODE
></DT
><DD
><P
>新たにデータベースサーバへの接続を作成します。
</P><PRE
CLASS="SYNOPSIS"
>PGconn *PQsetdbLogin(const char *pghost,
                     const char *pgport,
                     const char *pgoptions,
                     const char *pgtty,
                     const char *dbName,
                     const char *login,
                     const char *pwd);</PRE
><P>
       </P
><P
>これはパラメータ群を固定した<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>の前身です。
設定できないパラメータが常にデフォルト値になる点を除き、同一の機能を持ちます。
固定のパラメータに対して<TT
CLASS="SYMBOL"
>NULL</TT
>もしくは空文字列とすると、それはデフォルトを使用することになります。
      </P
><P
><TT
CLASS="PARAMETER"
>dbName</TT
>内に<TT
CLASS="SYMBOL"
>=</TT
>記号が含まれる場合、または有効な接続<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>接頭辞を持つ場合、<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>に渡された場合とまったく同じ扱いで<TT
CLASS="PARAMETER"
>conninfo</TT
>文字列として扱われます。
その後残りのパラメータが<CODE
CLASS="FUNCTION"
>PQconnectdbParams</CODE
>の指定のように適用されます。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQSETDB"
></A
><CODE
CLASS="FUNCTION"
>PQsetdb</CODE
></DT
><DD
><P
>新たにデータベースサーバへの接続を作成します。
</P><PRE
CLASS="SYNOPSIS"
>PGconn *PQsetdb(char *pghost,
                char *pgport,
                char *pgoptions,
                char *pgtty,
                char *dbName);</PRE
><P>
     </P
><P
>これは、<TT
CLASS="PARAMETER"
>login</TT
>と<TT
CLASS="PARAMETER"
>pwd</TT
>にNULLポインタを設定する<CODE
CLASS="FUNCTION"
>PQsetdbLogin</CODE
>を呼び出すマクロです。
非常に古いプログラムへの後方互換性のために提供されています。
     </P
></DD
><DT
><A
NAME="LIBPQ-PQCONNECTSTARTPARAMS"
></A
><CODE
CLASS="FUNCTION"
>PQconnectStartParams</CODE
><BR><CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
><BR><CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
></DT
><DD
><P
>       
ブロックしない方法で、データベースサーバへの接続を作成します。

</P><PRE
CLASS="SYNOPSIS"
>PGconn *PQconnectStartParams(const char * const *keywords,
                             const char * const *values,
                             int expand_dbname);

PGconn *PQconnectStart(const char *conninfo);

PostgresPollingStatusType PQconnectPoll(PGconn *conn);</PRE
><P>
      </P
><P
>これら3つの関数は、リモートI/Oの実行時にアプリケーションスレッドの実行がブロックされないようなデータベースサーバへの接続を作成するために使われます。
この手法の利点は、I/Oの終了待ちが<CODE
CLASS="FUNCTION"
>PQconnectdbParams</CODE
>または<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>内部ではなく、アプリケーションプログラムのメインループでできることにあります。
これによって、アプリケーションは他の処理と並行してこの処理を管理することができます。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQconnectStartParams</CODE
>では、上で<CODE
CLASS="FUNCTION"
>PQconnectdbParams</CODE
>で説明したように、データベース接続は<TT
CLASS="LITERAL"
>keywords</TT
>および<TT
CLASS="LITERAL"
>values</TT
>配列から取得され、<TT
CLASS="LITERAL"
>expand_dbname</TT
>によって制御されたパラメータを使用して確立します。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>では、上で<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>で説明したように、<TT
CLASS="LITERAL"
>conninfo</TT
>文字列から取得されたパラメータを使用してデータベース接続を確立します。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQconnectStartParams</CODE
>、<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>と<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>のどちらも以下の制限に適合する場合ブロックしません。
       <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>hostaddr</TT
>と<TT
CLASS="LITERAL"
>host</TT
>パラメータは、ホスト名からのIPアドレス検索やホスト名の逆引きが起こらないように適切に使用されなければいけません。
詳細に付いては<A
HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS"
>項32.1.2</A
>内のパラメータ説明を参照してください。
         </P
></LI
><LI
><P
><CODE
CLASS="FUNCTION"
>PQtrace</CODE
>を呼び出す場合は、トレースに使用するストリームオブジェクトがブロックされないことが保証されていなくてはなりません。
         </P
></LI
><LI
><P
>プログラマ自身が、後に示すように、<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>を呼び出す前にソケットが適切な状態にあることを保証しなくてはいけません。
         </P
></LI
></UL
><P>
      </P
><P
>注意：<CODE
CLASS="FUNCTION"
>PQconnectStartParams</CODE
>の使用は後述の<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>と類似しています。
      </P
><P
>非ブロック接続要求を始めるにはまず、<TT
CLASS="LITERAL"
>conn=PQconnectStart("<TT
CLASS="REPLACEABLE"
><I
>connection_info_string</I
></TT
>")</TT
>を呼び出します。
<TT
CLASS="VARNAME"
>conn</TT
>がNULLの場合、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>が新たに<TT
CLASS="STRUCTNAME"
>PGconn</TT
>構造体を割り当てられなかったことを表します。
そうでない場合は、適切な<TT
CLASS="STRUCTNAME"
>PGconn</TT
>へのポインタが返されます
（ただし、データベースに正しく接続されていることを表しているわけではありません）。
<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>から値が返ってきた段階で、<TT
CLASS="LITERAL"
>status=PQstatus(conn)</TT
>を呼び出します。
もし、<TT
CLASS="VARNAME"
>status</TT
>が<TT
CLASS="SYMBOL"
>CONNECTION_BAD</TT
>と等しい場合には、<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>が失敗しています。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>が成功したら、次は接続シーケンスを進めるために、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>をポーリングします。
データベース接続の背後にあるソケットの記述子を取り出すには、<CODE
CLASS="FUNCTION"
>PQsocket(conn)</CODE
>を使用します。
以下の繰り返しです。
直前の<CODE
CLASS="FUNCTION"
>PQconnectPoll(conn)</CODE
>が<TT
CLASS="SYMBOL"
>PGRES_POLLING_READING</TT
>の場合、ソケットの読み込み準備が整うまで待機します。
（<CODE
CLASS="FUNCTION"
>select()</CODE
>や<CODE
CLASS="FUNCTION"
>poll()</CODE
>などのシステム関数で示されます。）
そして、再度<CODE
CLASS="FUNCTION"
>PQconnectPoll(conn)</CODE
>を呼び出します。
反対に直前の<CODE
CLASS="FUNCTION"
>PQconnectPoll(conn)</CODE
>が<TT
CLASS="SYMBOL"
>PGRES_POLLING_WRITING</TT
>の場合、ソケットの書き込み準備が整うまで待機し、その後、<CODE
CLASS="FUNCTION"
>PQconnectPoll(conn)</CODE
>を再度呼び出します。
まだ<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>を呼び出していない場合、つまり、<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>の呼び出し直後では、直前が<TT
CLASS="SYMBOL"
>PGRES_POLLING_WRITING</TT
>であった場合と同様の処理を行ないます。
この繰り返しを<CODE
CLASS="FUNCTION"
>PQconnectPoll(conn)</CODE
>が、接続手続きの失敗を示す<TT
CLASS="SYMBOL"
>PGRES_POLLING_FAILED</TT
>、もしくは、接続確立に成功したことを示す<TT
CLASS="SYMBOL"
>PGRES_POLLING_OK</TT
>を返すまで継続します。
      </P
><P
>接続している間は、いつでも<CODE
CLASS="FUNCTION"
>PQstatus</CODE
>を呼び出すことで、接続の状態を検査することができます。
この関数呼び出しが<TT
CLASS="SYMBOL"
>CONNECTION_BAD</TT
>を返す場合、接続手続きは失敗しており、<TT
CLASS="SYMBOL"
>CONNECTION_OK</TT
>を返す場合、接続が確立しています。
上述のように、このいずれの状態も、<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>の戻り値から同様に検出できます。
これ以外の状態は、非同期の接続手続きの間（のみに）現れることがあります。
これらは、接続手続きの現在の段階を示すものであり、例えばユーザへのフィードバックを提供することに使用できます。
以下の状態があります。

       <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-CONNECTION-STARTED"
></A
><TT
CLASS="SYMBOL"
>CONNECTION_STARTED</TT
></DT
><DD
><P
>接続の確立待ち状態です。
          </P
></DD
><DT
><A
NAME="LIBPQ-CONNECTION-MADE"
></A
><TT
CLASS="SYMBOL"
>CONNECTION_MADE</TT
></DT
><DD
><P
>接続はOKです。送信待ち状態です。
          </P
></DD
><DT
><A
NAME="LIBPQ-CONNECTION-AWAITING-RESPONSE"
></A
><TT
CLASS="SYMBOL"
>CONNECTION_AWAITING_RESPONSE</TT
></DT
><DD
><P
>サーバからの応答待ち状態です。
          </P
></DD
><DT
><A
NAME="LIBPQ-CONNECTION-AUTH-OK"
></A
><TT
CLASS="SYMBOL"
>CONNECTION_AUTH_OK</TT
></DT
><DD
><P
>        認証済みです。バックエンドの起動待ち状態です。
          </P
></DD
><DT
><A
NAME="LIBPQ-CONNECTION-SSL-STARTUP"
></A
><TT
CLASS="SYMBOL"
>CONNECTION_SSL_STARTUP</TT
></DT
><DD
><P
>SSL暗号化の調停状態です。
          </P
></DD
><DT
><A
NAME="LIBPQ-CONNECTION-SETENV"
></A
><TT
CLASS="SYMBOL"
>CONNECTION_SETENV</TT
></DT
><DD
><P
>環境が提供するパラメータ設定の調停状態です。
          </P
></DD
></DL
></DIV
><P>

これらの定数は（互換性を保つため）なくなることはありませんが、アプリケーションは、これらが特定の順で出現したり、本書に書いてある値のどれかに必ずステータス値が該当するということを決して当てにしてはいけません。
アプリケーションは、以下に示すようにするべきです。

</P><PRE
CLASS="PROGRAMLISTING"
>switch(PQstatus(conn))
{
        case CONNECTION_STARTED:
            feedback = "Connecting...";
            break;

        case CONNECTION_MADE:
            feedback = "Connected to server...";
            break;
.
.
.
        default:
            feedback = "Connecting...";
}</PRE
><P>
      </P
><P
><CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>を使用する場合、<TT
CLASS="LITERAL"
>connect_timeout</TT
>接続パラメータは無視されます。
経過時間が長過ぎるかどうかの判定はアプリケーションの責任で行ないます。
さもないと、<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>の後の<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>の繰り返しが<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>と同じになります。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>が非NULLポインタを返した場合、処理を終了する際には、構造体や関連するメモリブロックを始末するために、<CODE
CLASS="FUNCTION"
>PQfinish</CODE
>を呼び出さなくてはならないことに注意してください。
この処理は、接続試行が失敗した場合やその試行を中断する場合にも、必ず実行されなければいけません。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQCONNDEFAULTS"
></A
><CODE
CLASS="FUNCTION"
>PQconndefaults</CODE
></DT
><DD
><P
>デフォルトの接続オプションを返します。
</P><PRE
CLASS="SYNOPSIS"
>PQconninfoOption *PQconndefaults(void);

typedef struct
{
    char   *keyword;   /* このオプションのキーワード */
    char   *envvar;    /* 代替となる環境変数の名前 */
    char   *compiled;  /* 代替となるコンパイル時に組み込まれたデフォルト値 */
    char   *val;       /* オプションの現在値、もしくは、NULL */
    char   *label;     /* 接続ダイアログ内の当該フィールドのラベル */
    char   *dispchar;  /* 接続ダイアログ内の当該フィールドをどのように表示するかの指示
                          値:
                          ""        入力された値をそのまま表示
                          "*"       値を隠すパスワードフィールド用
                          "D"       デバッグオプション。デフォルトで何も表示しません */
    int     dispsize;  /* ダイアログ用のフィールドの大きさ(文字数単位) */
} PQconninfoOption;</PRE
><P>
      </P
><P
>接続オプションの配列を返します。
これは、使用可能な<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>用オプションのすべてや、その時点でのデフォルト値を決定するために使用することができます。
戻り値は、<TT
CLASS="STRUCTNAME"
>PQconninfoOption</TT
>構造体の配列へのポインタで、<TT
CLASS="STRUCTFIELD"
>keyword</TT
>ポインタがヌルとなる項目が配列の末尾にきます。
メモリが確保できなかった場合にはヌルポインタを返します。
現在のデフォルト値(<TT
CLASS="STRUCTFIELD"
>val</TT
> フィールド）は、環境変数や他のコンテキストに依存します。
呼び出し側では、接続オプションの情報は、読み込み専用として取り扱わなければいけません。
      </P
><P
>オプションの配列を処理した後は、それを<CODE
CLASS="FUNCTION"
>PQconninfoFree</CODE
>に渡して解放します。
この処理をしないと、<CODE
CLASS="FUNCTION"
>PQconndefaults</CODE
>が呼び出されるたびに少しずつメモリリークが発生します。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQCONNINFO"
></A
><CODE
CLASS="FUNCTION"
>PQconninfo</CODE
></DT
><DD
><P
>所在する接続で使用される接続オプションを返します。
</P><PRE
CLASS="SYNOPSIS"
>PQconninfoOption *PQconninfo(PGconn *conn);</PRE
><P>
      </P
><P
>接続オプション配列を返します。これは全ての可能性のある<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>オプションとサーバに接続するのに使用される値を確定するために使用することができます。
返り値は<TT
CLASS="STRUCTNAME"
>PQconninfoOption</TT
>構造体の配列を指し示します。それはnull <TT
CLASS="STRUCTFIELD"
>keyword</TT
> ポインタを持つ項目で終結します。<CODE
CLASS="FUNCTION"
>PQconndefaults</CODE
>に対する上記の全ての注釈はまた<CODE
CLASS="FUNCTION"
>PQconninfo</CODE
>の結果に適用されます。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQCONNINFOPARSE"
></A
><CODE
CLASS="FUNCTION"
>PQconninfoParse</CODE
></DT
><DD
><P
>提供された接続文字列から構文解析された接続オプションを返します。

</P><PRE
CLASS="SYNOPSIS"
>PQconninfoOption *PQconninfoParse(const char *conninfo, char **errmsg);</PRE
><P>
      </P
><P
>接続文字列の構文解析を行い、配列として結果オプションを返すか、または接続文字列に問題があった場合に<TT
CLASS="SYMBOL"
>NULL</TT
>を返します。
この関数を提供された接続文字列の中の<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>オプションを取り出すために使用することができます。
戻り値は<TT
CLASS="STRUCTNAME"
>PQconninfoOption</TT
>構造体の配列を指し示し、それはヌルの<TT
CLASS="STRUCTFIELD"
>keyword</TT
>ポインタを持つ項目で終結します。
      </P
><P
>正規なオプションはすべて、結果配列内に現れます。
しかし接続文字列内に現れない、何らかのオプション用の<TT
CLASS="LITERAL"
>PQconninfoOption</TT
>は<TT
CLASS="LITERAL"
>NULL</TT
>に設定された<TT
CLASS="LITERAL"
>val</TT
>を持ちます。
デフォルトは挿入されません。
      </P
><P
><TT
CLASS="LITERAL"
>errmsg</TT
>が非<TT
CLASS="SYMBOL"
>NULL</TT
>であれば、成功した場合<TT
CLASS="LITERAL"
>*errmsg</TT
>は<TT
CLASS="SYMBOL"
>NULL</TT
>に設定され、そうでなければ、問題を説明した<CODE
CLASS="FUNCTION"
>malloc</CODE
>されたエラー文字列になります。
（<TT
CLASS="LITERAL"
>*errmsg</TT
>が<TT
CLASS="SYMBOL"
>NULL</TT
>に設定され、かつ、この関数が<TT
CLASS="SYMBOL"
>NULL</TT
>を返すこともあり得ます。
これはメモリ不足状態を意味します。）
      </P
><P
>オプション配列を処理した後、それを<CODE
CLASS="FUNCTION"
>PQconninfoFree</CODE
>に渡して解放してください。
これが行われない場合、<CODE
CLASS="FUNCTION"
>PQconninfoParse</CODE
>へのそれぞれの呼び出しに対してメモリーリークが起こります。
反対に、エラーが起こり、そして<TT
CLASS="LITERAL"
>errmsg</TT
>が非<TT
CLASS="SYMBOL"
>NULL</TT
>であれば、<CODE
CLASS="FUNCTION"
>PQfreemem</CODE
>を使用してエラー文字列を必ず解放してください。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQFINISH"
></A
><CODE
CLASS="FUNCTION"
>PQfinish</CODE
></DT
><DD
><P
>サーバとの接続を閉ざします。
また、<TT
CLASS="STRUCTNAME"
>PGconn</TT
>オブジェクトが占めるメモリも解放します。
</P><PRE
CLASS="SYNOPSIS"
>void PQfinish(PGconn *conn);</PRE
><P>
      </P
><P
>たとえサーバへの接続試行が失敗しても（<CODE
CLASS="FUNCTION"
>PQstatus</CODE
>で調べます）、アプリケーションは<CODE
CLASS="FUNCTION"
>PQfinish</CODE
>を呼び出し<TT
CLASS="STRUCTNAME"
>PGconn</TT
>オブジェクトが占めるメモリを解放するべきです。
そして<CODE
CLASS="FUNCTION"
>PQfinish</CODE
>を呼び出したら、もう<TT
CLASS="STRUCTNAME"
>PGconn</TT
>へのポインタを使ってはいけません。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQRESET"
></A
><CODE
CLASS="FUNCTION"
>PQreset</CODE
></DT
><DD
><P
>サーバへの通信チャンネルをリセットします。
</P><PRE
CLASS="SYNOPSIS"
>void PQreset(PGconn *conn);</PRE
><P>
      </P
><P
>この関数はサーバへの接続を閉じ、以前使用したパラメータをすべて使用して、同一のサーバへ新しく接続を確立します。
これは、作業中の接続が失われた場合のエラーの修復に役立つでしょう。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQRESETSTART"
></A
><CODE
CLASS="FUNCTION"
>PQresetStart</CODE
><BR><CODE
CLASS="FUNCTION"
>PQresetPoll</CODE
></DT
><DD
><P
>非ブロッキング方式で、サーバへの接続チャンネルをリセットします。

</P><PRE
CLASS="SYNOPSIS"
>int PQresetStart(PGconn *conn);

PostgresPollingStatusType PQresetPoll(PGconn *conn);</PRE
><P>
      </P
><P
>これらの関数はサーバへの接続を閉じ、それから再度、以前使用したパラメータをすべて使用して、同じサーバと新たな接続を確立しようとします。
これらは作業中の接続が失われた場合のエラー修復に役立つでしょう。
<CODE
CLASS="FUNCTION"
>PQreset</CODE
>（前述）との違いは、この2つの関数が非ブロック方式で動作することです。
また、これらの関数は<CODE
CLASS="FUNCTION"
>PQconnectStartParams</CODE
>、<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>および<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>と同じ制限を受けます。
      </P
><P
>接続のリセットを始めるためには<CODE
CLASS="FUNCTION"
>PQresetStart</CODE
>を呼び出します。
この関数がゼロを返す場合、リセットに失敗しています。
戻り値が1ならば、<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>を使って接続を確立した時とまったく同じに、<CODE
CLASS="FUNCTION"
>PQresetPoll</CODE
>を使用してリセットのポーリングを行います。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQPINGPARAMS"
></A
><CODE
CLASS="FUNCTION"
>PQpingParams</CODE
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PQpingParams</CODE
>はサーバの状態を報告します。
この関数は上述の<CODE
CLASS="FUNCTION"
>PQconnectdbParams</CODE
>と同じ接続パラメータを受け付けます。
サーバの状態を得るために正しいユーザ名、パスワード、データベース名を提供する必要はありません。
しかし、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。

</P><PRE
CLASS="SYNOPSIS"
>PGPing PQpingParams(const char * const *keywords,
                    const char * const *values,
                    int expand_dbname);</PRE
><P>

このサーバは以下の値のいずれかを返します。

       <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQPINGPARAMS-PQPING-OK"
></A
><TT
CLASS="LITERAL"
>PQPING_OK</TT
></DT
><DD
><P
>サーバは稼動中で、接続を受け付けているようです。
          </P
></DD
><DT
><A
NAME="LIBPQ-PQPINGPARAMS-PQPING-REJECT"
></A
><TT
CLASS="LITERAL"
>PQPING_REJECT</TT
></DT
><DD
><P
>サーバは稼動中ですが、接続を許可しない状態（起動処理中、停止処理中、クラッシュリカバリ中）です。
          </P
></DD
><DT
><A
NAME="LIBPQ-PQPINGPARAMS-PQPING-NO-RESPONSE"
></A
><TT
CLASS="LITERAL"
>PQPING_NO_RESPONSE</TT
></DT
><DD
><P
>サーバと通信できません。
これは、サーバが稼動中ではない、指定した接続パラメータの何か（例えばポート番号の間違い）が間違っている、ネットワーク接続性の問題（例えば接続要求をブロックするファイアウォール）があることを示しているかもしれません。
          </P
></DD
><DT
><A
NAME="LIBPQ-PQPINGPARAMS-PQPING-NO-ATTEMPT"
></A
><TT
CLASS="LITERAL"
>PQPING_NO_ATTEMPT</TT
></DT
><DD
><P
>指定されたパラメータが明らかに間違っている、または、（メモリ不足など）クライアント側の問題があったため、サーバとの通信を試行しませんでした。
          </P
></DD
></DL
></DIV
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQPING"
></A
><CODE
CLASS="FUNCTION"
>PQping</CODE
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PQping</CODE
>はサーバの状態を報告します。
この関数は上述の<CODE
CLASS="FUNCTION"
>PQconnectdb</CODE
>と同じ接続パラメータを受け付けます。
サーバの状態を得るために正しいユーザ名、パスワード、データベース名を提供する必要はありません。
しかし、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。
サーバの状態を入手するためには現在のユーザ名、パスワード、またはデータベース名などの値を供給する必要はありませんが、不適切な値が供給されると、サーバは不成功に終わった接続の試みをログに残します。

</P><PRE
CLASS="SYNOPSIS"
>PGPing PQping(const char *conninfo);</PRE
><P>
      </P
><P
>戻り値は<CODE
CLASS="FUNCTION"
>PQpingParams</CODE
>と同じです。
      </P
></DD
></DL
></DIV
><P>
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-CONNSTRING"
>32.1.1. 接続文字列</A
></H2
><P
>複数の<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>関数は、接続パラメータを得るためにユーザが指定した文字列の解析を行います。
この文字列として、普通の<TT
CLASS="LITERAL"
>keyword = value</TT
>文字列と<A
HREF="http://www.ietf.org/rfc/rfc3986.txt"
TARGET="_top"
>RFC 3986</A
>のURIという２種類の書式が受け付けられます。
   </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN45261"
>32.1.1.1. キーワード/値形式の接続文字列</A
></H3
><P
>最初の書式では、各パラメータ設定は<TT
CLASS="LITERAL"
>keyword = value</TT
>という形式です。
等号記号の前後の空白文字は省略可能です。
空の値を書く、または空白文字を含む値を書くためには、<TT
CLASS="LITERAL"
>keyword = 'a value'</TT
>のように単一引用符で値を括ります。
値内部の単一引用符とバックスラッシュはバックスラッシュでエスケープしなければなりません。
つまり<TT
CLASS="LITERAL"
>\'</TT
>と<TT
CLASS="LITERAL"
>\\</TT
>です。
   </P
><P
>以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>host=localhost port=5432 dbname=mydb connect_timeout=10</PRE
><P>
   </P
><P
>有効なパラメータキーワードを<A
HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS"
>項32.1.2</A
>に示します。
   </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="AEN45272"
>32.1.1.2. 接続URI</A
></H3
><P
>接続<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>の一般的な形式を以下に示します。
</P><PRE
CLASS="SYNOPSIS"
>postgresql://[user[:password]@][netloc][:port][/dbname][?param1=value1&amp;...]</PRE
><P>
   </P
><P
><ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>スキーマ指示子は<TT
CLASS="LITERAL"
>postgresql://</TT
>または<TT
CLASS="LITERAL"
>postgres://</TT
>のいずれかを取ることができます。
個々の<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>部品は省略可能です。
以下の例で有効な<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>構文の使用例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>postgresql://
postgresql://localhost
postgresql://localhost:5433
postgresql://localhost/mydb
postgresql://user@localhost
postgresql://user:secret@localhost
postgresql://other@localhost/otherdb?connect_timeout=10&amp;application_name=myapp</PRE
><P>
<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>の階層部品の要素をパラメータとして与えることができます。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>postgresql:///mydb?host=localhost&amp;port=5433</PRE
><P>
   </P
><P
>パーセント符号化を使用して、<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>部品のいずれかに特殊な意味を持つ記号を含めることができます。
   </P
><P
><A
HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS"
>項32.1.2</A
>に示されたキーワードに対応しない接続パラメータは無視され、これに関する警告メッセージが<TT
CLASS="FILENAME"
>stderr</TT
>に書き出されます。
   </P
><P
>JDBCの接続<ACRONYM
CLASS="ACRONYM"
>URI</ACRONYM
>構文との互換性を高めるために、<TT
CLASS="LITERAL"
>ssl=true</TT
>パラメータインスタンスは<TT
CLASS="LITERAL"
>sslmode=require</TT
>に変換されます。
   </P
><P
>ホスト部分にはホスト名またはIPアドレスを書くことができます。
IPv6ホストアドレスを指定するためには角括弧で括ります。
</P><PRE
CLASS="SYNOPSIS"
>postgresql://[2001:db8::1234]/database</PRE
><P>
   </P
><P
>ホスト要素は<A
HREF="libpq-connect.html#LIBPQ-CONNECT-HOST"
>host</A
>で説明したように解釈されます。
具体的には、ホスト部品が空またはスラッシュで始まる場合Unixドメインソケット接続が選択され、さもなければTCP/IP接続で初期化されます。
しかしURIの階層部ではスラッシュが予約された文字であることに注意してください。
このため、標準以外のUnixドメインソケットディレクトリを指定するためには、URIからホスト指定を省き、パラメータとしてホストを指定するか、URIのホスト要素内のパスをパーセントエスケープするかどちらかを行ってください。
</P><PRE
CLASS="PROGRAMLISTING"
>postgresql:///dbname?host=/var/lib/postgresql
postgresql://%2Fvar%2Flib%2Fpostgresql/dbname</PRE
><P>
   </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-PARAMKEYWORDS"
>32.1.2. パラメータキーワード</A
></H2
><P
>現時点で有効なパラメータのキーワードは以下に示す通りです。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-CONNECT-HOST"
></A
><TT
CLASS="LITERAL"
>host</TT
></DT
><DD
><P
>接続するホスト名を指定します。
 この引数をスラッシュで始めた場合、TCP/IPによる通信ではなく、Unixドメインの通信を明示することになります。
その場合、この値はソケットファイルを格納するディレクトリの名前になります。
<TT
CLASS="LITERAL"
>host</TT
>が指定されなかった場合のデフォルトは、<TT
CLASS="FILENAME"
>/tmp</TT
>にあるUnixドメインのソケットに接続することです。
 （または、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の構築時に指定した別のディレクトリにあるソケットです。）
Unixドメインソケットを持たないマシンにおけるデフォルトは、<TT
CLASS="LITERAL"
>localhost</TT
>に接続することです。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-HOSTADDR"
></A
><TT
CLASS="LITERAL"
>hostaddr</TT
></DT
><DD
><P
>接続するホストのIPアドレスを指定します。
これは、<TT
CLASS="LITERAL"
>172.28.40.9</TT
>といった標準的なIPv4アドレス書式でなければなりません。
使用するマシンでIPv6をサポートする場合は、そのアドレスを使用することもできます。
このパラメータに空以外の文字列が指定されると、TCP/IP通信が常に使用されます。
       </P
><P
><TT
CLASS="LITERAL"
>host</TT
>の代わりに<TT
CLASS="LITERAL"
>hostaddr</TT
>を使用することで、アプリケーションがホスト名の検索を行なわずに済みます。
特に時間的制約があるアプリケーションでは重要になるでしょう。
しかし、GSSAP、SSPI認証方式では、ホスト名が必要になります。
<TT
CLASS="LITERAL"
>verify-full</TT
>SSL証明書検証を行う場合も同様です。
以下の規則が使用されます。
        <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>hostaddr</TT
>を使わずに<TT
CLASS="LITERAL"
>host</TT
>を指定した場合は、ホスト名の検索が発生します。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>host</TT
>を使わずに<TT
CLASS="LITERAL"
>hostaddr</TT
>を指定した場合、<TT
CLASS="LITERAL"
>hostaddr</TT
>の値はサーバのネットワークアドレスとなります。
認証方式がホスト名を必要する場合は接続試行が失敗します。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>host</TT
>と<TT
CLASS="LITERAL"
>hostaddr</TT
>の両方を指定した場合、<TT
CLASS="LITERAL"
>hostaddr</TT
>がサーバのネットワークアドレスとなります。
<TT
CLASS="LITERAL"
>host</TT
>の値は認証方式で必要とされない限り無視され、必要とされる場合にはホスト名として使用されます。
          </P
></LI
></UL
><P>
<TT
CLASS="LITERAL"
>host</TT
>が<TT
CLASS="LITERAL"
>hostaddr</TT
>ネットワークアドレスに対応するマシンの名前と一致しない場合は、認証に失敗する可能性があるので注意してください。
また、<TT
CLASS="LITERAL"
>hostaddr</TT
>ではなく<TT
CLASS="LITERAL"
>host</TT
>が<TT
CLASS="FILENAME"
>~/.pgpass</TT
>(<A
HREF="libpq-pgpass.html"
>項32.15</A
>を参照)での接続の識別に使用されます。
       </P
><P
>ホスト名もホストのアドレスも用いない場合、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>はローカルのUnixドメインソケットを使用して接続します。
ただし、Unixドメインソケットを持たないマシンでは、<TT
CLASS="LITERAL"
>localhost</TT
>への接続を試みます。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-PORT"
></A
><TT
CLASS="LITERAL"
>port</TT
></DT
><DD
><P
>サーバホストでの接続用のポート番号、または、Unixドメイン接続の場合は、ソケットファイルの拡張子を指定します。

       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-DBNAME"
></A
><TT
CLASS="LITERAL"
>dbname</TT
></DT
><DD
><P
>データベース名を指定します。
デフォルトはユーザ名と同じです。
特定の文脈では、この値は拡張書式で検査されます。
詳細については<A
HREF="libpq-connect.html#LIBPQ-CONNSTRING"
>項32.1.1</A
>を参照してください。
      </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-USER"
></A
><TT
CLASS="LITERAL"
>user</TT
></DT
><DD
><P
>データベースへ接続する<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ユーザ名を指定します。
デフォルトは、そのアプリケーションを実行しているユーザのオペレーティングシステム上の名前と同じです。
      </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-PASSWORD"
></A
><TT
CLASS="LITERAL"
>password</TT
></DT
><DD
><P
>サーバがパスワードによる認証を必要とした場合に使用されるパスワードを指定します。
      </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-CONNECT-TIMEOUT"
></A
><TT
CLASS="LITERAL"
>connect_timeout</TT
></DT
><DD
><P
>接続用の最大待機時間を秒単位(10進数整数で表した文字列として記述してください)で指定します。
ゼロもしくは未設定は、無限時間の待機を意味します。
2秒未満の待機時間を使用することは勧めません。
      </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-CLIENT-ENCODING"
></A
><TT
CLASS="LITERAL"
>client_encoding</TT
></DT
><DD
><P
>接続用の<TT
CLASS="VARNAME"
>client_encoding</TT
>設定パラメータを設定します。
対応するサーバオプションで受け付けられる値の他に、クライアントにおける現在のロケール（Unixシステムの場合は<TT
CLASS="ENVAR"
>LC_CTYPE</TT
>環境変数）から正しい符号化方式を決定する<TT
CLASS="LITERAL"
>auto</TT
>を使用することができます。
      </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-OPTIONS"
></A
><TT
CLASS="LITERAL"
>options</TT
></DT
><DD
><P
>接続開始時にサーバに送信するコマンドラインオプションを指定します。
例えば、これを<TT
CLASS="LITERAL"
>-c geqo=off</TT
>に設定すると、<TT
CLASS="VARNAME"
>geqo</TT
>パラメータのセッション値は<TT
CLASS="LITERAL"
>off</TT
>になります。
この文字列中の空白はバックスラッシュ(<TT
CLASS="LITERAL"
>\</TT
>)でエスケープされていなければコマンド行引数の区切りであるとみなされます。
リテラルのバックスラッシュを表すには<TT
CLASS="LITERAL"
>\\</TT
>と書いて下さい。
利用可能なオプションに関する詳細については<A
HREF="runtime-config.html"
>第19章</A
>を参照してください。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-APPLICATION-NAME"
></A
><TT
CLASS="LITERAL"
>application_name</TT
></DT
><DD
><P
><A
HREF="runtime-config-logging.html#GUC-APPLICATION-NAME"
>application_name</A
>設定パラメータの値を指定します。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-FALLBACK-APPLICATION-NAME"
></A
><TT
CLASS="LITERAL"
>fallback_application_name</TT
></DT
><DD
><P
><A
HREF="runtime-config-logging.html#GUC-APPLICATION-NAME"
>application_name</A
>設定パラメータの予備値を指定します。
接続パラメータまたは<TT
CLASS="ENVAR"
>PGAPPNAME</TT
>環境変数により<TT
CLASS="LITERAL"
>application_name</TT
>の値が指定されない場合に、この値が使用されます。
予備の名前を指定することは、デフォルトのアプリケーション名を設定したいが、ユーザにもそれを上書きできるようにしておきたい、一般的なユーティリティプログラムで有用です。
       </P
></DD
><DT
><A
NAME="LIBPQ-KEEPALIVES"
></A
><TT
CLASS="LITERAL"
>keepalives</TT
></DT
><DD
><P
>クライアント側におけるTCPキープアライブの使用を制御します。
デフォルト値は1であり、有効であることを意味します。
しかしキープアライブを望まない場合は、無効であることを意味するゼロに設定することができます。
このパラメータはUnixドメインソケット経由の接続では無視されます。
       </P
></DD
><DT
><A
NAME="LIBPQ-KEEPALIVES-IDLE"
></A
><TT
CLASS="LITERAL"
>keepalives_idle</TT
></DT
><DD
><P
>TCPがサーバにキープアライブメッセージを送信した後に活動を行わない期間を秒単位で制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合もしくはキープアライブが無効な場合、このパラメータは無視されます。
これは<TT
CLASS="SYMBOL"
>TCP_KEEPIDLE</TT
>ソケットオプションまたは<TT
CLASS="SYMBOL"
>TCP_KEEPALIVE</TT
>ソケットオプションが利用できるシステムおよびWindowsでのみサポートされます。
他のシステムでは効果がありません。
       </P
></DD
><DT
><A
NAME="LIBPQ-KEEPALIVES-INTERVAL"
></A
><TT
CLASS="LITERAL"
>keepalives_interval</TT
></DT
><DD
><P
>TCPキープアライブメッセージに対する応答がサーバからない場合に、何秒後に再送を行うかを制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合、またはキープアライブを無効にしている場合、このパラメータは無視されます。
これは<TT
CLASS="SYMBOL"
>TCP_KEEPINTVL</TT
>ソケットオプションが利用できるシステムおよびWindowsでのみサポートされます。
他のシステムでは効果がありません。
       </P
></DD
><DT
><A
NAME="LIBPQ-KEEPALIVES-COUNT"
></A
><TT
CLASS="LITERAL"
>keepalives_count</TT
></DT
><DD
><P
>サーバへのクライアント接続が不要になったとみなすまで、何回キープアライブの欠落を認めるかを制御します。
ゼロという値ではシステムのデフォルトを使用します。
Unixドメインソケット経由でなされた接続の場合、またはキープアライブを無効にしている場合、このパラメータは無視されます。
これは<TT
CLASS="SYMBOL"
>TCP_KEEPCNT</TT
>ソケットオプションが利用できるシステムでのみサポートされます。
他のシステムでは効果がありません。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-TTY"
></A
><TT
CLASS="LITERAL"
>tty</TT
></DT
><DD
><P
>無視されます(以前は、これはサーバデバッグ出力を送信する場所を指定するものでした)。
      </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-SSLMODE"
></A
><TT
CLASS="LITERAL"
>sslmode</TT
></DT
><DD
><P
>このオプションは、どの<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>による安全なTCP/IP接続の優先度でサーバと調停するかを決定します。
6つのモードがあります。

        <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>disable</TT
></DT
><DD
><P
>非<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続のみ試行
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>allow</TT
></DT
><DD
><P
>最初に非<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続を試行し、失敗したら、<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続を試行
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>prefer</TT
> （デフォルト）</DT
><DD
><P
>最初に<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続を試行し、失敗したら、非<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続を試行
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>require</TT
></DT
><DD
><P
><ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続のみ試行。
ルートCAファイルが存在する場合、<TT
CLASS="LITERAL"
>verify-ca</TT
>が指定された場合と同じ方法で証明書が検証されます。
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>verify-ca</TT
></DT
><DD
><P
><ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続のみ試行し、サーバ証明書が信用された認証局（<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>）から発行されたかを検証
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>verify-full</TT
></DT
><DD
><P
><ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続のみ試行し、サーバ証明書が信用された<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>から発行されたか、およびそのサーバホスト名が証明書内のものと一致するかを検証
           </P
></DD
></DL
></DIV
><P>

これらのオプションがどのように動くのかについては<A
HREF="libpq-ssl.html"
>項32.18</A
>を参照してください。
       </P
><P
><TT
CLASS="LITERAL"
>sslmode</TT
>はUnixドメインソケット通信では無視されます。
SSLサポートなしで<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>がコンパイルされた場合に、<TT
CLASS="LITERAL"
>require</TT
>、<TT
CLASS="LITERAL"
>verify-ca</TT
>、<TT
CLASS="LITERAL"
>verify-full</TT
>を使用するとエラーになります。
一方、<TT
CLASS="LITERAL"
>allow</TT
>と<TT
CLASS="LITERAL"
>prefer</TT
>は使用できますが、実際に<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>は<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続を受け付けません。

       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-REQUIRESSL"
></A
><TT
CLASS="LITERAL"
>requiressl</TT
></DT
><DD
><P
>このオプションは<TT
CLASS="LITERAL"
>sslmode</TT
>設定を支持する観点から廃止予定になっています。
       </P
><P
>1に設定することで、サーバへの<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続が必要になります
(これは<TT
CLASS="LITERAL"
>sslmode</TT
>の<TT
CLASS="LITERAL"
>require</TT
>と同じです)。
サーバが<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>接続を受け付けない場合、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>は接続を拒絶します。
0(デフォルト)に設定することで、サーバと接続形式の調停を行います。
(<TT
CLASS="LITERAL"
>sslmode</TT
>の<TT
CLASS="LITERAL"
>prefer</TT
>と同じです。)
SSLサポート付きで<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>をコンパイルした場合にのみ、このオプションが利用できます。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-SSLCOMPRESSION"
></A
><TT
CLASS="LITERAL"
>sslcompression</TT
></DT
><DD
><P
>１（デフォルト）に設定することで、SSL接続越えで送信されるデータは圧縮されます（これには<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>バージョン0.9.8以降が必要です）。
０に設定すると、圧縮が無効になります（これには<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>1.0.0以降が必要です）。
このパラメータはSSLが確立していない接続や使用される<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>がサポートしていない場合は無視されます。
       </P
><P
>圧縮はCPU処理時間を使用しますが、ネットワークが問題である場合はスループットを改良することができます。
CPU性能が制約要因であれば、圧縮を無効にすることで、応答時間やスループットを改良することができます。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-SSLCERT"
></A
><TT
CLASS="LITERAL"
>sslcert</TT
></DT
><DD
><P
>このパラメータは、<TT
CLASS="FILENAME"
>~/.postgresql/postgresql.crt</TT
>というデフォルトを置き換えるクライアントSSL証明書のファイル名を指定します。
このパラメータはSSL接続が確立していない場合は無視されます。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-SSLKEY"
></A
><TT
CLASS="LITERAL"
>sslkey</TT
></DT
><DD
><P
>このパラメータはクライアント証明書に対して使用される秘密鍵の場所を指定します。
デフォルトの<TT
CLASS="FILENAME"
>~/.postgresql/postgresql.key</TT
>の代わりに使用されるファイル名、または外部<SPAN
CLASS="QUOTE"
>"エンジン"</SPAN
>（エンジンとは<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>ロード可能なモジュール）から得られるキーを指定することも可能です。
外部エンジンの指定にはコロンで区切ったエンジン名とエンジン特有の鍵識別子を含んでいなければなりません。
SSL接続が確立していない場合このパラメータは無視されます。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-SSLROOTCERT"
></A
><TT
CLASS="LITERAL"
>sslrootcert</TT
></DT
><DD
><P
>このパラメータはSSL認証局(<ACRONYM
CLASS="ACRONYM"
>CA</ACRONYM
>)の証明書のファイル名を指定します。
このファイルが存在する場合、サーバ証明書はこれらの認証局の1つで署名されているかどうか検証されます。
デフォルトは<TT
CLASS="FILENAME"
>~/.postgresql/root.crt</TT
>です。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-SSLCRL"
></A
><TT
CLASS="LITERAL"
>sslcrl</TT
></DT
><DD
><P
>このパラメータはSSL証明書失効リスト（CRL）のファイル名を指定します。
このファイルに列挙された証明書が存在した場合、それはサーバ証明書を承認しようとする時に拒絶されます。
デフォルトは<TT
CLASS="FILENAME"
>~/.postgresql/root.crl</TT
>です。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-REQUIREPEER"
></A
><TT
CLASS="LITERAL"
>requirepeer</TT
></DT
><DD
><P
>このパラメータは、例えば<TT
CLASS="LITERAL"
>requirepeer=postgres</TT
>のようにサーバのオペレーティングシステムのユーザ名を指定します。
Unixドメインソケット接続を確立する時に、このパラメータが設定された場合、クライアントは接続開始時にサーバプロセスが指定されたユーザ名で稼動しているか検査し、稼動していない場合は接続をエラーとして中断します。
このパラメータは、TCP/IP接続においてSSL証明書で実現するようなサーバ認証を実現するために使用することができます。
（Unixドメインソケットが<TT
CLASS="FILENAME"
>/tmp</TT
>などの誰にでも書き込むことができる場所にある場合、誰でもそこで接続を監視するサーバを起動できることに注意してください。
信頼できるユーザが起動したサーバに接続することを確実に行うために、このパラメータを使用してください。）
このオプションは<TT
CLASS="LITERAL"
>peer</TT
>認証方式が実装されたプラットフォームでのみでサポートされます。
<A
HREF="auth-methods.html#AUTH-PEER"
>項20.3.6</A
>を参照してください。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-KRBSRVNAME"
></A
><TT
CLASS="LITERAL"
>krbsrvname</TT
></DT
><DD
><P
>GSSAPIの認証時に使われるKerberosサービス名です。
成功するためには、これはサーバのKerberos認証設定のサービス名と一致していなければなりません。
(<A
HREF="auth-methods.html#GSSAPI-AUTH"
>項20.3.3</A
>も参照してください。)
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-GSSLIB"
></A
><TT
CLASS="LITERAL"
>gsslib</TT
></DT
><DD
><P
>GSSAPI認証で使用されるGSSライブラリです。
Windows上のみで使用されます。
libpqの認証がデフォルトのSSPIではなく、強制的にGSSAPIライブラリを使用させるには<TT
CLASS="LITERAL"
>gssapi</TT
>を設定してください。
       </P
></DD
><DT
><A
NAME="LIBPQ-CONNECT-SERVICE"
></A
><TT
CLASS="LITERAL"
>service</TT
></DT
><DD
><P
>追加のパラメータ用に使用されるサービス名です。
<TT
CLASS="FILENAME"
>pg_service.conf</TT
>内の追加的な接続パラメータを保持するサービス名を指定します。
これによりアプリケーションはサービス名だけを指定でき、接続パラメータを集中的に保守できるようになります。
<A
HREF="libpq-pgservice.html"
>項32.16</A
>を参照してください。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-status.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C ライブラリ</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>接続状態関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
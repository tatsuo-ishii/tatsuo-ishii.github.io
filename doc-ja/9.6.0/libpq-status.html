<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>接続状態関数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C ライブラリ"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="データベース接続制御関数"
HREF="libpq-connect.html"><LINK
REL="NEXT"
TITLE="コマンド実行関数"
HREF="libpq-exec.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="データベース接続制御関数"
HREF="libpq-connect.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 32章<SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C ライブラリ</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="コマンド実行関数"
HREF="libpq-exec.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-STATUS"
>32.2. 接続状態関数</A
></H1
><P
>これらの関数を使用して、既存のデータベース接続オブジェクトの状態を調べることができます。
  </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>ティップ: </B
>    
    
<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>アプリケーションのプログラマは注意して<TT
CLASS="STRUCTNAME"
>PGconn</TT
>という抽象化を維持してください。
<TT
CLASS="STRUCTNAME"
>PGconn</TT
>の内容は以下に挙げるアクセス用関数を使って取り出してください。
<TT
CLASS="STRUCTNAME"
>PGconn</TT
>構造体中のフィールドは将来予告なく変更されることがありますので、<TT
CLASS="FILENAME"
>libpq-int.h</TT
>を使用したフィールドの参照は避けてください。
   </P
></BLOCKQUOTE
></DIV
><P
>以下の関数は、接続で確立したパラメータの値を返します。
これらの値は<TT
CLASS="STRUCTNAME"
>PGconn</TT
>の存続期間中で固定されます。

   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQDB"
></A
><CODE
CLASS="FUNCTION"
>PQdb</CODE
>
      </DT
><DD
><P
>接続したデータベース名を返します。
</P><PRE
CLASS="SYNOPSIS"
>char *PQdb(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQUSER"
></A
><CODE
CLASS="FUNCTION"
>PQuser</CODE
>
      </DT
><DD
><P
>接続したユーザ名を返します。
</P><PRE
CLASS="SYNOPSIS"
>char *PQuser(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQPASS"
></A
><CODE
CLASS="FUNCTION"
>PQpass</CODE
>
      </DT
><DD
><P
>接続したパスワードを返します。
</P><PRE
CLASS="SYNOPSIS"
>char *PQpass(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQHOST"
></A
><CODE
CLASS="FUNCTION"
>PQhost</CODE
>
      </DT
><DD
><P
>接続したサーバホスト名を返します。 ★変更あり
</P><PRE
CLASS="SYNOPSIS"
>char *PQhost(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQPORT"
></A
><CODE
CLASS="FUNCTION"
>PQport</CODE
>
      </DT
><DD
><P
>接続したポートを返します。

</P><PRE
CLASS="SYNOPSIS"
>char *PQport(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQTTY"
></A
><CODE
CLASS="FUNCTION"
>PQtty</CODE
>
      </DT
><DD
><P
>接続のデバッグ用<ACRONYM
CLASS="ACRONYM"
>TTY</ACRONYM
>を返します。
(これは廃れたものです。サーバはもはや<ACRONYM
CLASS="ACRONYM"
>TTY</ACRONYM
>設定を参照しません。
後方互換性のためにこの関数が残っています。)

</P><PRE
CLASS="SYNOPSIS"
>char *PQtty(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQOPTIONS"
></A
><CODE
CLASS="FUNCTION"
>PQoptions</CODE
>
      </DT
><DD
><P
>接続要求時に渡されたコマンドラインオプションを返します。
</P><PRE
CLASS="SYNOPSIS"
>char *PQoptions(const PGconn *conn);</PRE
><P>
      </P
></DD
></DL
></DIV
><P>
  </P
><P
>以下の関数は、<TT
CLASS="STRUCTNAME"
>PGconn</TT
>オブジェクトに対して操作を行うことで変更可能な状態データを返します。

   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQSTATUS"
></A
><CODE
CLASS="FUNCTION"
>PQstatus</CODE
>
      </DT
><DD
><P
>接続の状態を返します。
</P><PRE
CLASS="SYNOPSIS"
>ConnStatusType PQstatus(const PGconn *conn);</PRE
><P>
      </P
><P
>この状態は多くの値の中の１つとなるはずです。
しかし非同期接続手順の外部からは、その中でたった２つ、<TT
CLASS="LITERAL"
>CONNECTION_OK</TT
>と<TT
CLASS="LITERAL"
>CONNECTION_BAD</TT
>だけが現れます。
データベースへの接続に問題がなければ、<TT
CLASS="LITERAL"
>CONNECTION_OK</TT
>状態になります。
接続に失敗している場合は<TT
CLASS="LITERAL"
>CONNECTION_BAD</TT
>状態となります。
通常、OK状態は<CODE
CLASS="FUNCTION"
>PQfinish</CODE
>まで維持されますが、通信失敗のために早まって<TT
CLASS="LITERAL"
>CONNECTION_BAD</TT
>になることもあります。
その場合、アプリケーションは<CODE
CLASS="FUNCTION"
>PQreset</CODE
>を呼び出して修復を試みることができます。
      </P
><P
>返される可能性があるその他の状態コードについては<CODE
CLASS="FUNCTION"
>PQconnectStartParams</CODE
>、<CODE
CLASS="FUNCTION"
>PQconnectStart</CODE
>および<CODE
CLASS="FUNCTION"
>PQconnectPoll</CODE
>の項目を参照してください。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQTRANSACTIONSTATUS"
></A
><CODE
CLASS="FUNCTION"
>PQtransactionStatus</CODE
>
      </DT
><DD
><P
>サーバの現在のトランザクション内部状態を返します。

</P><PRE
CLASS="SYNOPSIS"
>PGTransactionStatusType PQtransactionStatus(const PGconn *conn);</PRE
><P>

この状態は、<TT
CLASS="LITERAL"
>PQTRANS_IDLE</TT
> (現在待機中)、<TT
CLASS="LITERAL"
>PQTRANS_ACTIVE</TT
> (コマンド実行中)、<TT
CLASS="LITERAL"
>PQTRANS_INTRANS</TT
> (有効なトランザクションブロック内で待機中)、<TT
CLASS="LITERAL"
>PQTRANS_INERROR</TT
> (無効なトランザクションブロック内で待機中)となり得ます。
接続に問題がある場合のみ<TT
CLASS="LITERAL"
>PQTRANS_UNKNOWN</TT
>が報告されます。
サーバへ問い合わせが送信されたが、まだ完了していない場合のみ<TT
CLASS="LITERAL"
>PQTRANS_ACTIVE</TT
>が報告されます。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQPARAMETERSTATUS"
></A
><CODE
CLASS="FUNCTION"
>PQparameterStatus</CODE
>
      </DT
><DD
><P
>サーバの現在のパラメータ設定を検索します。

</P><PRE
CLASS="SYNOPSIS"
>const char *PQparameterStatus(const PGconn *conn, const char *paramName);</PRE
><P>

あるパラメータ値は、接続開始時に、もしくは、その値が変更された時は常にサーバによって自動的に報告されます。
<CODE
CLASS="FUNCTION"
>PQparameterStatus</CODE
>はそれらの設定の調査に役立ちます。
パラメータの現在値がわかればその値を、わからない場合は<TT
CLASS="SYMBOL"
>NULL</TT
>を返します。
      </P
><P
>現在のリリースで報告されるパラメータには、<TT
CLASS="VARNAME"
>server_version</TT
>、<TT
CLASS="VARNAME"
>server_encoding</TT
>、<TT
CLASS="VARNAME"
>client_encoding</TT
>、<TT
CLASS="VARNAME"
>application_name</TT
>、<TT
CLASS="VARNAME"
>is_superuser</TT
>、<TT
CLASS="VARNAME"
>session_authorization</TT
>、<TT
CLASS="VARNAME"
>DateStyle</TT
>、<TT
CLASS="VARNAME"
>IntervalStyle</TT
>、<TT
CLASS="VARNAME"
>TimeZone</TT
>、<TT
CLASS="VARNAME"
>integer_datetimes</TT
>および<TT
CLASS="VARNAME"
>standard_conforming_strings</TT
>があります。
（8.0より前では<TT
CLASS="VARNAME"
>server_encoding</TT
>、<TT
CLASS="VARNAME"
>TimeZone</TT
>および<TT
CLASS="VARNAME"
>integer_datetimes</TT
>が、8.1より前では<TT
CLASS="LITERAL"
>standard_conforming_strings</TT
>が、そして8.4より前では<TT
CLASS="VARNAME"
>IntervalStyle</TT
>が、9.0より前では<TT
CLASS="VARNAME"
>application_name</TT
>が報告されませんでした。 ）
<TT
CLASS="VARNAME"
>server_version</TT
>、<TT
CLASS="VARNAME"
>server_encoding</TT
>および<TT
CLASS="VARNAME"
>integer_datetimes</TT
>は起動後変更できないことに注意してください。
      </P
><P
>プロトコル3.0より前のサーバはパラメータ設定を報告しません。
しかし、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>には<TT
CLASS="VARNAME"
>server_version</TT
>と<TT
CLASS="VARNAME"
>client_encoding</TT
>の値を取り出す仕組みがとりあえずあります。
アプリケーションは、<I
CLASS="FOREIGNPHRASE"
>付け焼き刃な</I
>コードでこれらの値を決定するのではなく、<CODE
CLASS="FUNCTION"
>PQparameterStatus</CODE
>を使用することが求められています。
(しかし、3.0より前の接続では、接続開始後に<TT
CLASS="COMMAND"
>SET</TT
>による<TT
CLASS="VARNAME"
>client_encoding</TT
>の変更は<CODE
CLASS="FUNCTION"
>PQparameterStatus</CODE
>に反映されないことに注意してください。)
<TT
CLASS="VARNAME"
>server_version</TT
>については、この情報をより比較し易い数値形式で返す<CODE
CLASS="FUNCTION"
>PQserverVersion</CODE
>も参照してください。
      </P
><P
><TT
CLASS="VARNAME"
>standard_conforming_strings</TT
>の値がないと報告された場合、アプリケーションは<TT
CLASS="LITERAL"
>off</TT
>と推測することができます。
つまり、バックスラッシュは文字リテラル中のエスケープ文字として扱います。
また、このパラメータが存在すると、エスケープ文字構文(<TT
CLASS="LITERAL"
>E'...'</TT
>)が受付けられることを意味するものと取られます。
      </P
><P
>返されるポインタは<TT
CLASS="LITERAL"
>const</TT
>と宣言されていますが、実際には<TT
CLASS="LITERAL"
>PGconn</TT
>構造体に関連付けされた変化する領域を指し示します。
このポインタが諸問い合わせに渡って有効なままであるとみなすのは賢明ではありません。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQPROTOCOLVERSION"
></A
><CODE
CLASS="FUNCTION"
>PQprotocolVersion</CODE
>
      </DT
><DD
><P
>使用されるフロントエンド/バックエンドプロトコルを調査します。
</P><PRE
CLASS="SYNOPSIS"
>int PQprotocolVersion(const PGconn *conn);</PRE
><P>
ある機能がサポートされているかどうかを決定するために、アプリケーションはこの関数を使用することができます。
現在、取り得る値は2(2.0プロトコル)、3(3.0プロトコル)、あるいは0(接続不良)です。
このプロトコルバージョンは接続の開始が完了した後で変更することはできません。
しかし、理論的には接続のリセット時に変更可能です。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.4以降での通信時、通常3.0プロトコルが使用されます。
7.4より前のサーバでは2.0プロトコルのみをサポートします。
(1.0プロトコルは廃止され、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>ではサポートされていません。)
      </P
></DD
><DT
><A
NAME="LIBPQ-PQSERVERVERSION"
></A
><CODE
CLASS="FUNCTION"
>PQserverVersion</CODE
>
      </DT
><DD
><P
>バックエンドのバージョンの整数表現を返します。
</P><PRE
CLASS="SYNOPSIS"
>int PQserverVersion(const PGconn *conn);</PRE
><P>
この関数を使用してアプリケーションは接続したデータベースサーバのバージョンを決定することができます。
この数値の形式は、メジャー、マイナー、リビジョン番号を2桁の10進数に変換し、連結させたものです。
例えば、バージョン8.1.5では80105を返し、バージョン8.2では80200を返します。
（先頭の0は現れません。）
接続不良の場合は0が返されます。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQERRORMESSAGE"
></A
><CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>
      </DT
><DD
><P
>&#13;       
接続における操作において、最も最近に生成されたエラーメッセージを返します。
</P><PRE
CLASS="SYNOPSIS"
>char *PQerrorMessage(const PGconn *conn);</PRE
><P>

      </P
><P
>ほとんどすべての<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>関数は、失敗時に<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>用のメッセージを設定します。
<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>での決まりとして、空でない<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>の結果は複数行に渡ることも可能で、最後に改行が含まれることがある点に注意してください。
呼び出し元はこの結果を直接解放してはいけません。
関連する<TT
CLASS="STRUCTNAME"
>PGconn</TT
>ハンドルが<CODE
CLASS="FUNCTION"
>PQfinish</CODE
>に渡された時にこれは解放されます。
<TT
CLASS="LITERAL"
>PGconn</TT
>構造体への操作を跨って、この結果文字列が同一であると想定してはいけません。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQSOCKET"
></A
><CODE
CLASS="FUNCTION"
>PQsocket</CODE
></DT
><DD
><P
>サーバとの接続ソケットに対するファイル記述子番号を得ます。
有効な記述子なら値は0以上です。
-1の場合は、サーバとの接続がまだ開いていないことを示します。
(これは通常の操作では変更することはできません。
接続設定中やリセット中に変更されます。)

</P><PRE
CLASS="SYNOPSIS"
>int PQsocket(const PGconn *conn);</PRE
><P>

      </P
></DD
><DT
><A
NAME="LIBPQ-PQBACKENDPID"
></A
><CODE
CLASS="FUNCTION"
>PQbackendPID</CODE
></DT
><DD
><P
>接続を処理するバックエンドのプロセス<ACRONYM
CLASS="ACRONYM"
>ID</ACRONYM
>(PID)を返します。


</P><PRE
CLASS="SYNOPSIS"
>int PQbackendPID(const PGconn *conn);</PRE
><P>
      </P
><P
>バックエンドの<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>は、デバッグする場合や<TT
CLASS="COMMAND"
>NOTIFY</TT
>メッセージ（これは通知を発行したバックエンドプロセスの<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>を含んでいます）の比較に便利です。
この<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>はデータベースサーバホスト上で実行されているプロセスのものであり、ローカルホスト側のものではありません！ 
注意してください。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQCONNECTIONNEEDSPASSWORD"
></A
><CODE
CLASS="FUNCTION"
>PQconnectionNeedsPassword</CODE
></DT
><DD
><P
>接続認証方式がパスワードを要求し、利用可能なパスワードがない場合真（1）を返します。
さもなくば偽（0）を返します。

</P><PRE
CLASS="SYNOPSIS"
>int PQconnectionNeedsPassword(const PGconn *conn);</PRE
><P>

      </P
><P
>この関数を、接続試行に失敗した後でユーザにパスワード入力を促すかどうかを決定するために適用することができます。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQCONNECTIONUSEDPASSWORD"
></A
><CODE
CLASS="FUNCTION"
>PQconnectionUsedPassword</CODE
></DT
><DD
><P
>接続認証方式でパスワードを使用する場合は真（1）、さもなくば偽（0）を返します。

</P><PRE
CLASS="SYNOPSIS"
>int PQconnectionUsedPassword(const PGconn *conn);</PRE
><P>

      </P
><P
>この関数は、接続の試みが失敗したか成功したかの後に、サーバがパスワードを要求したかどうかを検出するために適用できます。
      </P
></DD
></DL
></DIV
><P>
  </P
><P
>以下の関数はSSLに関連した情報を返します。
この情報は通常、接続の確立後には変更されません。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQSSLINUSE"
></A
><CODE
CLASS="FUNCTION"
>PQsslInUse</CODE
></DT
><DD
><P
>接続がSSLを使っていれば真(1)、使っていなければ偽(0)を返します。

</P><PRE
CLASS="SYNOPSIS"
>int PQsslInUse(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQSSLATTRIBUTE"
></A
><CODE
CLASS="FUNCTION"
>PQsslAttribute</CODE
></DT
><DD
><P
>接続におけるSSL関連の情報を返します。

</P><PRE
CLASS="SYNOPSIS"
>const char *PQsslAttribute(const PGconn *conn, const char *attribute_name);</PRE
><P>
      </P
><P
>利用可能な属性のリストは使用されているSSLライブラリおよび接続の種類に依存して変わります。
属性が利用可能でないときはNULLが返されます。
      </P
><P
>一般的には、以下の属性が利用可能です。
       <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>library</TT
></DT
><DD
><P
>使用されているSSLの実装の名前です。
（現在は<TT
CLASS="LITERAL"
>"OpenSSL"</TT
>だけが実装されています。）
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>protocol</TT
></DT
><DD
><P
>使用されているSSL/TLSのバージョンです。
一般的な値は、<TT
CLASS="LITERAL"
>"SSLv2"</TT
>、<TT
CLASS="LITERAL"
>"SSLv3"</TT
>、<TT
CLASS="LITERAL"
>"TLSv1"</TT
>、<TT
CLASS="LITERAL"
>"TLSv1.1"</TT
>、<TT
CLASS="LITERAL"
>"TLSv1.2"</TT
>ですが、他のプロトコルが使用されれば、異なる文字列が返されるかもしれません。
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>key_bits</TT
></DT
><DD
><P
>暗号アルゴリズムで使用されている鍵のビット数です。
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>cipher</TT
></DT
><DD
><P
>使用されている暗号スイートの短縮名、例えば<TT
CLASS="LITERAL"
>"DHE-RSA-DES-CBC3-SHA"</TT
>です。
この名前は各SSLの実装に固有のものです。
           </P
></DD
><DT
><TT
CLASS="LITERAL"
>compression</TT
></DT
><DD
><P
>SSL圧縮が使用されている場合、圧縮アルゴリズムの名前を返します。
圧縮は使われているがアルゴリズムが不明という場合を"on"を返します。
圧縮が使われていない場合は"off"を返します。
           </P
></DD
></DL
></DIV
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQSSLATTRIBUTENAMES"
></A
><CODE
CLASS="FUNCTION"
>PQsslAttributeNames</CODE
></DT
><DD
><P
>利用可能なSSL属性名の配列を返します。
配列の最後のメンバにはNULLポインタが入ります。
</P><PRE
CLASS="SYNOPSIS"
>const char * const * PQsslAttributeNames(const PGconn *conn);</PRE
><P>
      </P
></DD
><DT
><A
NAME="LIBPQ-PQSSLSTRUCT"
></A
><CODE
CLASS="FUNCTION"
>PQsslStruct</CODE
></DT
><DD
><P
>接続を説明するSSLの実装に固有のオブジェクトへのポインタを返します。
</P><PRE
CLASS="SYNOPSIS"
>void *PQsslStruct(const PGconn *conn, const char *struct_name);</PRE
><P>
      </P
><P
>利用可能な構造体は、使用されるSSLの実装に依存します。
OpenSSLでは、"OpenSSL"の名前の下に利用可能な構造体が1つあり、OpenSSLの<TT
CLASS="LITERAL"
>SSL</TT
>構造体へのポインタを返します。
この関数を使用するには、以下のようなプログラムが利用できます。
</P><PRE
CLASS="PROGRAMLISTING"
>#include &#60;libpq-fe.h&#62;
#include &#60;openssl/ssl.h&#62;

...

    SSL *ssl;

    dbconn = PQconnectdb(...);
    ...

    ssl = PQsslStruct(dbconn, "OpenSSL");
    if (ssl)
    {
        /* sslにアクセスするためOpenSSLの関数を使う */
    }</PRE
><P>
      </P
><P
>この構造体は、暗号化レベルの確認、サーバ証明書の検証、その他に使用できます。
この構造体に関する情報については<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>のドキュメントを参照して下さい。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQGETSSL"
></A
><CODE
CLASS="FUNCTION"
>PQgetssl</CODE
></DT
><DD
><P
>       
接続で使用されているSSLの構造体を返します。
SSLが使われていなければNULLを返します。

</P><PRE
CLASS="SYNOPSIS"
>void *PQgetssl(const PGconn *conn);</PRE
><P>
      </P
><P
>この関数は<TT
CLASS="LITERAL"
>PQsslStruct(conn, "OpenSSL")</TT
>と同等です。
返される構造体はOpenSSLに固有のもので他のSSL実装が利用されていると使用できないので、新しく作成するアプリケーションでは使うべきではありません。
接続がSSLを使用しているかどうかを調べるには、代わりに<CODE
CLASS="FUNCTION"
>PQsslInUse</CODE
>を呼び出して下さい。
また、接続に関するより詳細については<CODE
CLASS="FUNCTION"
>PQsslAttribute</CODE
>を使って下さい。
      </P
></DD
></DL
></DIV
><P>
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-connect.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-exec.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>データベース接続制御関数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>コマンド実行関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
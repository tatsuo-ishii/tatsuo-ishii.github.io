<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>行と配列の比較</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="関数と演算子"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="副問い合わせ式"
HREF="functions-subquery.html"><LINK
REL="NEXT"
TITLE="集合を返す関数"
HREF="functions-srf.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="副問い合わせ式"
HREF="functions-subquery.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 9章関数と演算子</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="集合を返す関数"
HREF="functions-srf.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-COMPARISONS"
>9.23. 行と配列の比較</A
></H1
><P
>本節では、値のグループ間で複数の比較を行う、さまざまな特殊化したコンストラクトについて説明します。
この形式は構文的には、前節の副問い合わせ形式と関係しています。しかし、副問い合わせを含みません。
配列副式を含む形式は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張ですが、それ以外は<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>準拠です。
本節で記載した全ての式形式は結果として論理値（真/偽）を返します。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-COMPARISONS-IN-SCALAR"
>9.23.1. <TT
CLASS="LITERAL"
>IN</TT
></A
></H2
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> IN (<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>])</PRE
><P
>右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式のいずれかと等しい場合、結果は<SPAN
CLASS="QUOTE"
>"true（真）"</SPAN
>になります。
これは以下の省略形です。

</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value1</I
></TT
>
OR
<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value2</I
></TT
>
OR
...</PRE
><P>
  </P
><P
>左辺の式がNULLを生じる場合、または右側の値に等しいものがなくて少なくとも1つの右辺の行がNULLを持つ場合、<TT
CLASS="TOKEN"
>IN</TT
>構文の結果は偽ではなくNULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN20872"
>9.23.2. <TT
CLASS="LITERAL"
>NOT IN</TT
></A
></H2
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> NOT IN (<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [<SPAN
CLASS="OPTIONAL"
>, ...</SPAN
>])</PRE
><P
>右辺は括弧で括られたスカラ式のリストです。
左辺の式の結果が右辺の式の全てと等しくない場合、結果は<SPAN
CLASS="QUOTE"
>"真"</SPAN
>です。
これは以下の省略形です。

</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> &lt;&gt; <TT
CLASS="REPLACEABLE"
><I
>value1</I
></TT
>
AND
<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> &lt;&gt; <TT
CLASS="REPLACEABLE"
><I
>value2</I
></TT
>
AND
...</PRE
><P>
  </P
><P
>左辺の式でNULLが生じる場合、または右辺の値に左辺の式と等しいものがなく、かつ少なくとも1つの右辺の式がNULLを生じる場合、<TT
CLASS="TOKEN"
>NOT IN</TT
>構文の結果は、一部の人が予想する真ではなく、NULLとなることに注意してください。
これは、NULL値の論理的な組み合わせに対するSQLの標準規則に従うものです。
  </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>ティップ: </B
>全ての場合において、<TT
CLASS="LITERAL"
>x NOT IN y</TT
>は<TT
CLASS="LITERAL"
>NOT (x IN y)</TT
>と等価です。
しかし、<TT
CLASS="TOKEN"
>IN</TT
>を使用するよりも<TT
CLASS="TOKEN"
>NOT IN</TT
>を使用する方が初心者がNULL値による間違いをしやすくなります。
可能な限り条件を肯定的に表現することが最善です。
  </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN20894"
>9.23.3. <TT
CLASS="LITERAL"
>ANY</TT
>/<TT
CLASS="LITERAL"
>SOME</TT
> (配列)</A
></H2
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ANY (<TT
CLASS="REPLACEABLE"
><I
>array expression</I
></TT
>)
<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> SOME (<TT
CLASS="REPLACEABLE"
><I
>array expression</I
></TT
>)</PRE
><P
>右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列要素それぞれに対して、指定された<TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
>を使用して評価、比較されます。なお、<TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
>は結果として論理値を生成する必要があります。
真の結果が１つでもあると、<TT
CLASS="TOKEN"
>ANY</TT
>の結果は<SPAN
CLASS="QUOTE"
>"true（真）"</SPAN
>です。
真の結果がない（配列の要素数がゼロである場合を含む）と、結果は<SPAN
CLASS="QUOTE"
>"false（偽）"</SPAN
>です。
  </P
><P
>配列式がNULL配列を生成する場合、<TT
CLASS="TOKEN"
>ANY</TT
>の結果はNULLになります。
左辺式がNULLとなる場合、<TT
CLASS="TOKEN"
>ANY</TT
>の結果は通常NULLになります（STRICTでない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較の結果、真が得られなかった場合、<TT
CLASS="TOKEN"
>ANY</TT
>の結果は偽ではなくNULLになります（ここでも、STRICTな演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </P
><P
><TT
CLASS="TOKEN"
>SOME</TT
>は<TT
CLASS="TOKEN"
>ANY</TT
>の同義語です。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN20918"
>9.23.4. <TT
CLASS="LITERAL"
>ALL</TT
> (配列)</A
></H2
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> ALL (<TT
CLASS="REPLACEABLE"
><I
>array expression</I
></TT
>)</PRE
><P
>右辺は括弧で括られた式で、配列値を返さなければなりません。
左辺の式は配列の要素それぞれに対して、指定された<TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
>を使用して評価、比較されます。なお、<TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
>は結果として論理値を生成する必要があります。
全ての比較が真になる場合（配列の要素数がゼロである場合を含む）、<TT
CLASS="TOKEN"
>ALL</TT
>の結果は<SPAN
CLASS="QUOTE"
>"true（真）"</SPAN
>です。
1つでも偽の結果があると、結果は<SPAN
CLASS="QUOTE"
>"false（偽）"</SPAN
>です。
  </P
><P
>配列式がNULL配列を生成する場合、<TT
CLASS="TOKEN"
>ALL</TT
>の結果はNULLになります。
左辺式がNULLとなる場合、<TT
CLASS="TOKEN"
>ALL</TT
>の結果は通常NULLになります（厳格でない比較演算子では異なる結果になるかもしれません）。
また、右辺の配列にNULL要素が含まれ、かつ、比較の結果、偽が得られなかった場合、<TT
CLASS="TOKEN"
>ALL</TT
>の結果は真ではなくNULLになります（ここでも、厳格な演算子の場合です）。
これは、NULLに対する、SQLの論理値組み合わせに関する標準規則に従うものです。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ROW-WISE-COMPARISON"
>9.23.5. 行コンストラクタの比較</A
></H2
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
></PRE
><P
>両辺とも<A
HREF="sql-expressions.html#SQL-SYNTAX-ROW-CONSTRUCTORS"
>項4.2.13</A
>で説明する行コンストラクタです。
この２つの行値は同じフィールド数でなければなりません。
両辺はそれぞれ評価され、行として比較されます。
行コンストラクタの比較は、<TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
>が<TT
CLASS="LITERAL"
>=</TT
>、<TT
CLASS="LITERAL"
>&lt;&gt;</TT
>、<TT
CLASS="LITERAL"
>&lt;</TT
>、<TT
CLASS="LITERAL"
>&lt;=</TT
>、<TT
CLASS="LITERAL"
>&gt;</TT
>、<TT
CLASS="LITERAL"
>&gt;=</TT
>の場合に認められます。
各行の要素はデフォルトのB-tree演算子クラスを持つ型でなければなりません。そうでなければ、比較を試みるとエラーが発生します。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>比較が先行する列で解決された場合、要素の数や型に関係するエラーは起きないこともあります。
   </P
></BLOCKQUOTE
></DIV
><P
><TT
CLASS="LITERAL"
>=</TT
>と<TT
CLASS="LITERAL"
>&lt;&gt;</TT
>の場合、他と動作が多少異なります。
2つの行は対応する全ての構成要素が非NULLかつ等しい場合に等しいとみなされます。
１つでも構成要素が非NULLかつ等しくない場合、2つの行は等しくないとみなされます。
それ以外の場合、その行の比較結果は不明（NULL）です。
  </P
><P
><TT
CLASS="LITERAL"
>&lt;</TT
>、<TT
CLASS="LITERAL"
>&lt;=</TT
>、<TT
CLASS="LITERAL"
>&gt;</TT
>、<TT
CLASS="LITERAL"
>&gt;=</TT
>の場合、行の要素は左から右に比較されます。そして、不等またはNULLの組み合わせが見つかったところで停止します。
要素の組み合わせのどちらかがNULLであった場合、行比較の結果は不明（NULL）です。さもなくば、要素の組み合わせの比較により結果が決まります。
例えば、<TT
CLASS="LITERAL"
>ROW(1,2,NULL) &lt; ROW(1,3,0)</TT
>は、３番目の要素の組み合わせまで進まないため、NULLではなく真を返します。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の8.2より前では、<TT
CLASS="LITERAL"
>&lt;</TT
>、<TT
CLASS="LITERAL"
>&lt;=</TT
>、<TT
CLASS="LITERAL"
>&gt;</TT
> 、<TT
CLASS="LITERAL"
>&gt;=</TT
>の場合SQL仕様に従っていませんでした。
<TT
CLASS="LITERAL"
>ROW(a,b) &lt; ROW(c,d)</TT
>などの比較は正しくは<TT
CLASS="LITERAL"
>a &lt; c OR (a = c AND b &lt; d)</TT
>ですが、<TT
CLASS="LITERAL"
>a &lt; c AND b &lt; d</TT
>として実装されていました。
   </P
></BLOCKQUOTE
></DIV
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
> IS DISTINCT FROM <TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
></PRE
><P
>このコンストラクトは<TT
CLASS="LITERAL"
>&lt;&gt;</TT
>行比較と類似していますが、NULL入力に対してNULLを生成しない点が異なります。
その代わりに、全てのNULL値は非NULL値と等しくない（DISTINCT FROM）ものとみなされ、また、２つのNULLは等しい（NOT DISTINCT）ものとみなされます。
したがって、結果は真か偽のいずれかで、NULLにはなりません。
  </P
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
> IS NOT DISTINCT FROM <TT
CLASS="REPLACEABLE"
><I
>row_constructor</I
></TT
></PRE
><P
>このコンストラクトは<TT
CLASS="LITERAL"
>=</TT
>行比較と類似していますが、NULL入力に対してNULLを生成しません。
代わりに、NULL値を、すべての非NULLの値に対して不等（DISTINCT FROM）とみなし、２つのNULLを等しいもの（NOT DISTINCT）とみなします。
したがって、結果は常に真か偽となり、NULLになることはありません
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="COMPOSITE-TYPE-COMPARISON"
>9.23.6. 複合型の比較</A
></H2
><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>record</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>record</I
></TT
></PRE
><P
>SQL仕様では、結果が2つのNULL値、またはNULLと非NULLの比較に依存するのであれば、行の観点からの比較はNULLを返すことを要求されています。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、(<A
HREF="functions-comparisons.html#ROW-WISE-COMPARISON"
>項9.23.5</A
>にあるように)２つの行コンストラクタの出力の比較を行う時、または副問い合わせの出力に対し(<A
HREF="functions-subquery.html"
>項9.22</A
>にあるように)行コンストラクタの比較を行う時のみこれを実施します。
２つの複合型の値が比較されるほかの状況では、２つのNULLフィールドの値は等しいと考えられ、NULLは非NULLより大きいとみなされます。
複合型に対して、これは一貫した並び替えとインデックス付け動作担保のため必要です。
  </P
><P
>各辺が評価され、行単位で比較が行なわれます。
複合型の比較は<TT
CLASS="REPLACEABLE"
><I
>operator</I
></TT
>が<TT
CLASS="LITERAL"
>=</TT
>、<TT
CLASS="LITERAL"
>&lt;&gt;</TT
>、<TT
CLASS="LITERAL"
>&lt;</TT
>、<TT
CLASS="LITERAL"
>&lt;=</TT
>、<TT
CLASS="LITERAL"
>&gt;</TT
>、<TT
CLASS="LITERAL"
>&gt;=</TT
>またはそのいずれかと類似の意味を持つ場合に許されます。
(正確には、演算子はB-tree演算子クラスのメンバである場合、またはB-tree演算子クラスの<TT
CLASS="LITERAL"
>=</TT
>メンバの否定子である場合に行比較演算子となり得ます。)
上記の演算子のデフォルトの動作は、行コンストラクタに対する<TT
CLASS="LITERAL"
>IS [ NOT ] DISTINCT FROM</TT
>と同じです（<A
HREF="functions-comparisons.html#ROW-WISE-COMPARISON"
>項9.23.5</A
>参照）。
  </P
><P
>デフォルトのB-tree演算子クラスを持たない要素を含む行の一致をサポートするために、いくつかの演算子が複合型の比較のために定義されています。
それは<TT
CLASS="LITERAL"
>*=</TT
>、<TT
CLASS="LITERAL"
>*&lt;&gt;</TT
>、<TT
CLASS="LITERAL"
>*&lt;</TT
>、<TT
CLASS="LITERAL"
>*&lt;=</TT
>、<TT
CLASS="LITERAL"
>*&gt;</TT
>、<TT
CLASS="LITERAL"
>*&gt;=</TT
>です。
上記の演算子は2つの行の内部バイナリ表現を比較します。
2つの行の等価演算子での比較が真であっても、2つの行はバイナリ表現が異なるかもしれません。
上記の比較演算子での行の順序は決定論的ですが、それ以外は意味がありません。
上記の演算子はマテリアライズドビューで内部的に使われ、レプリケーションのような他の特定の目的のためには有用かもしれませんが、問い合わせを書くのに一般的に有用であるようにとは意図していません。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-subquery.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-srf.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>副問い合わせ式</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>集合を返す関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
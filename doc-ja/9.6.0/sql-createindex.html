<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE INDEX</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE GROUP"
HREF="sql-creategroup.html"><LINK
REL="NEXT"
TITLE="CREATE LANGUAGE"
HREF="sql-createlanguage.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE GROUP"
HREF="sql-creategroup.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE LANGUAGE"
HREF="sql-createlanguage.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATEINDEX"
></A
>CREATE INDEX</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN79707"
></A
><H2
>名前</H2
>CREATE INDEX&nbsp;--&nbsp;新しいインデックスを定義する
  </DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN79710"
></A
><H2
>概要</H2
><PRE
CLASS="SYNOPSIS"
>CREATE [ UNIQUE ] INDEX [ CONCURRENTLY ] [ [ IF NOT EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> ] ON <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ USING <TT
CLASS="REPLACEABLE"
><I
>method</I
></TT
> ]
    ( { <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ) } [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
> ] [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [, ...] )
    [ WITH ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] ) ]
    [ TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>tablespace_name</I
></TT
> ]
    [ WHERE <TT
CLASS="REPLACEABLE"
><I
>predicate</I
></TT
> ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN79723"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は、指定したリレーションの指定した列(複数可)に対するインデックスを作ります。
リレーションとしてテーブルまたはマテリアライズドビューを取ることができます。
インデックスは主にデータベースの性能を向上するために使われます
（しかし、インデックスの不適切な使用は性能の低下につながる可能性があります）。
  </P
><P
>インデックスのキーフィールドは、列名、または括弧に囲まれた式として指定されます。
インデックスメソッドが複数列に対するインデックスをサポートする場合は、複数のフィールドを指定できます。
  </P
><P
>インデックスのフィールドとして、テーブル行の1つ以上の列の値から計算する式を指定できます。
この機能は、元のデータに何らかの変換を加えた値を基とするデータへの高速なアクセスを行う手段として使用することができます。
例えば、<TT
CLASS="LITERAL"
>upper(col)</TT
>という計算に基づくインデックスがあれば、<TT
CLASS="LITERAL"
>WHERE upper(col) = 'JIM'</TT
>という句ではインデックスを使用することができます。
  </P
><P
><SPAN
CLASS="APPLICATION"
>PostgreSQL</SPAN
>はB-tree、ハッシュ、GiST、SP-GiST、GIN、BRINのインデックスメソッドを用意しています。
ユーザが独自にインデックスメソッドを定義することもできますが、これはかなり複雑です。
  </P
><P
><TT
CLASS="LITERAL"
>WHERE</TT
>句が存在する場合、<I
CLASS="FIRSTTERM"
>部分インデックス</I
>が作成されます。
部分インデックスは、テーブルの一部、通常は、テーブルの中でよりインデックスが有用な部分のみのエントリを持つインデックスです。
例えば、請求済みの注文と未請求の注文を情報として持つテーブルがあり、テーブル全体における未請求の注文の割合が小さく、かつ、頻繁に使用される場合、未請求の注文のみにインデックスを作成することで性能を向上できます。
部分インデックスのその他の利用方法として、<TT
CLASS="COMMAND"
>UNIQUE</TT
>付きの<TT
CLASS="COMMAND"
>WHERE</TT
>を使用して、テーブルの部分集合に一意性を強制する例が考えられます。
詳細は<A
HREF="indexes-partial.html"
>項11.8</A
>を参照してください。
  </P
><P
><TT
CLASS="LITERAL"
>WHERE</TT
>句内の式では、元となるテーブルの列のみを参照できます。
しかし、インデックスを付加する列だけではなく、全ての列を使用することができます。
また、現在、副問い合わせと集約式については、<TT
CLASS="COMMAND"
>WHERE</TT
>で使用することができません。
同一の制限は、式で表されたインデックスのフィールドにも適用されます。
  </P
><P
>インデックスの定義で使用される全ての関数と演算子は、<SPAN
CLASS="QUOTE"
>"不変"</SPAN
>（immutable）でなければなりません。
つまり、結果は入力引数にのみに依存し、（他のテーブルの内容や現時刻などの）外部からの影響を受けてはなりません。
この制限によって、インデックスの動作が十分定義されていることが保証されます。
インデックス式や<TT
CLASS="LITERAL"
>WHERE</TT
>句にユーザ定義の関数を使用する場合、関数を作成する際、IMMUTABLE（不変）オプションを付けることを忘れないでください。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN79745"
></A
><H2
>パラメータ</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>UNIQUE</TT
></DT
><DD
><P
>インデックスを（既にデータがある状態で）作成する時、およびテーブルにデータを追加する時に、テーブル内の値が重複していないかを検査します。
重複エントリを生じるデータの挿入または更新はエラーとなります。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>CONCURRENTLY</TT
></DT
><DD
><P
>このオプションを使用すると、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、対象テーブルに対する同時挿入、更新、削除を防止するようなロックを獲得せずにインデックスを作成します。
通常のインデックス作成処理では、完了するまで対象テーブルへの書き込みはできません（読み取りは可能です）。
このオプションを使用する際に注意しなければならない点が複数あります。
<A
HREF="sql-createindex.html#SQL-CREATEINDEX-CONCURRENTLY"
><I
>インデックスの同時作成</I
></A
>を参照してください。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>IF NOT EXISTS</TT
></DT
><DD
><P
>同じ名前のリレーションが既に存在している場合にエラーとしません。
この場合、注意が発行されます。
既存のインデックスが、作成されようとしていたものと類似のものである保証は全くないことに注意してください。
<TT
CLASS="LITERAL"
>IF NOT EXISTS</TT
>を指定する場合はインデックス名が必須です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>作成するインデックスの名前です。
この名前には、スキーマ名を含めることはできません。
インデックスは、常にその親テーブルと同じスキーマに作成されます。
この名前を省略すると、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はその親テーブルの名前とインデックス付けされる列名に基づいた適切な名前を選びます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></DT
><DD
><P
>インデックスを作成するテーブルの名前です（スキーマ修飾名の場合もあります）。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>method</I
></TT
></DT
><DD
><P
>使用するインデックスメソッドの名前です。
<TT
CLASS="LITERAL"
>btree</TT
>、<TT
CLASS="LITERAL"
>hash</TT
>、<TT
CLASS="LITERAL"
>gist</TT
>、<TT
CLASS="LITERAL"
>spgist</TT
>、<TT
CLASS="LITERAL"
>gin</TT
>、<TT
CLASS="LITERAL"
>brin</TT
>から選択します。
デフォルトのメソッドは<TT
CLASS="LITERAL"
>btree</TT
>です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
></DT
><DD
><P
>テーブルの列の名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
></DT
><DD
><P
>テーブル上の1つ以上の列を使用した式です。
通常この式は、構文で示した通り括弧で囲む必要があります。
しかし、式が関数呼び出し形式になっている場合は括弧を省略することができます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
></DT
><DD
><P
>インデックスで使用する照合順序の名前です。
デフォルトではインデックスはインデックス付け対象の列で宣言された照合順序またはインデックス付け対象の式の結果の照合順序を使用します。
デフォルト以外の照合順序を使用する式を含む問い合わせで、デフォルト以外の照合順序を持つインデックスが有用になるかもしれません。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
></DT
><DD
><P
>演算子クラスの名前です。詳細は下記を参照してください。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ASC</TT
></DT
><DD
><P
>正方向のソート順を指定します(これがデフォルトです)。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>DESC</TT
></DT
><DD
><P
>逆方向のソート順を指定します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>NULLS FIRST</TT
></DT
><DD
><P
>NULLを非NULLより前にソートすることを指定します。
これは<TT
CLASS="LITERAL"
>DESC</TT
>が指定された場合のデフォルトです。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>NULLS LAST</TT
></DT
><DD
><P
>NULLを非NULLより後にソートすることを指定します。
これは<TT
CLASS="LITERAL"
>DESC</TT
>が指定されない場合のデフォルトです。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
></DT
><DD
><P
>インデックスメソッド固有の格納パラメータの名前です。
<A
HREF="sql-createindex.html#SQL-CREATEINDEX-STORAGE-PARAMETERS"
><I
>インデックス格納パラメータ</I
></A
>を参照してください。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>tablespace_name</I
></TT
></DT
><DD
><P
>インデックスを生成するテーブル空間です。
指定されなかった場合、<A
HREF="runtime-config-client.html#GUC-DEFAULT-TABLESPACE"
>default_tablespace</A
>、もし一時テーブル上のインデックスであれば、<A
HREF="runtime-config-client.html#GUC-TEMP-TABLESPACES"
>temp_tablespaces</A
>が考慮されます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>predicate</I
></TT
></DT
><DD
><P
>部分インデックス用の制約式です。
       </P
></DD
></DL
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATEINDEX-STORAGE-PARAMETERS"
></A
><H3
>インデックス格納パラメータ</H3
><P
><TT
CLASS="LITERAL"
>WITH</TT
>句を使うと、インデックスの<I
CLASS="FIRSTTERM"
>格納パラメータ</I
>を指定できます。
インデックスメソッドはそれぞれ固有の設定可能な格納パラメータを持ちます。
B-tree、ハッシュ、GiSTおよびSP-GiSTといったインデックスはすべて次のパラメータを受け付けます。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>fillfactor</TT
></DT
><DD
><P
>インデックス用のフィルファクタは割合（パーセント）で、インデックスメソッドがインデックスページをまとめ上げる時にどの程度ページを使用するかを決定するものです。
B-treeでは、リーフページは初期インデックス構築時と右側（新しい最大キー値を追加する方向）にインデックスを拡張する時にこの割合分までページを使用します。
その後ページすべてが完全に使用されると分割され、インデックスの効果が徐々に劣化します。
B-treeのデフォルトのフィルファクタは90ですが、10から100までの任意の整数値を設定することができます。
テーブルが静的な場合、100が最善でインデックスの物理サイズを最小化できます。
更新が非常に多い場合は、ページ分割の頻度を少なくするために、より小さなフィルファクタを設定する方が良いです。
この他のインデックスメソッドでは、フィルファクタを異なる意味で使用しますが、おおよそは同じです。
メソッドによってフィルファクタのデフォルト値は異なります。
     </P
></DD
></DL
></DIV
><P
>GiSTインデックスではさらに以下のパラメータを受け付けます。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>buffering</TT
></DT
><DD
><P
><A
HREF="gist-implementation.html#GIST-BUFFERING-BUILD"
>項61.4.1</A
>で説明するバッファリング構築技術をインデックスを構築する時に使用するかどうかを決定します。
<TT
CLASS="LITERAL"
>OFF</TT
>で無効に、<TT
CLASS="LITERAL"
>ON</TT
>で有効になります。
また<TT
CLASS="LITERAL"
>AUTO</TT
>と指定すると、最初は無効ですが、
インデックスサイズが<A
HREF="runtime-config-query.html#GUC-EFFECTIVE-CACHE-SIZE"
>effective_cache_size</A
>に達した後はその場で有効になります。
デフォルトは<TT
CLASS="LITERAL"
>AUTO</TT
>です。
    </P
></DD
></DL
></DIV
><P
>GINインデックスでは以下の異なるパラメータを受け付けます。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>fastupdate</TT
></DT
><DD
><P
>この設定は<A
HREF="gin-implementation.html#GIN-FAST-UPDATE"
>項63.4.1</A
>で説明する高速更新技法を使用するかどうかを制御します。
これは論理値パラメータであり、<TT
CLASS="LITERAL"
>ON</TT
>は高速更新を有効に、<TT
CLASS="LITERAL"
>OFF</TT
>は無効にします。
（<A
HREF="config-setting.html"
>項19.1</A
>の説明のように、<TT
CLASS="LITERAL"
>ON</TT
>や<TT
CLASS="LITERAL"
>OFF</TT
>と異なる記載も可能です。）
デフォルトは<TT
CLASS="LITERAL"
>ON</TT
>です。
    </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><TT
CLASS="COMMAND"
>ALTER INDEX</TT
>を使用して<TT
CLASS="LITERAL"
>fastupdate</TT
>を無効にすることにより、以後の挿入は待機中のインデックス項目リストに入らないようになります。
しかし、このコマンド自体はこれまでの項目を吐き出しません。
確実に待機中のリストを空にするためには、続いてテーブルを<TT
CLASS="COMMAND"
>VACUUM</TT
>するか、<CODE
CLASS="FUNCTION"
>gin_clean_pending_list</CODE
>関数を呼び出すのが良いでしょう。
     </P
></BLOCKQUOTE
></DIV
></DD
></DL
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>gin_pending_list_limit</TT
></DT
><DD
><P
><A
HREF="runtime-config-client.html#GUC-GIN-PENDING-LIST-LIMIT"
>gin_pending_list_limit</A
>のカスタムパラメータです。
値はキロバイト単位で指定します。
    </P
></DD
></DL
></DIV
><P
><ACRONYM
CLASS="ACRONYM"
>BRIN</ACRONYM
>インデックスは別のパラメータを受け入れます。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>pages_per_range</TT
></DT
><DD
><P
><ACRONYM
CLASS="ACRONYM"
>BRIN</ACRONYM
>インデックスの各エントリについて1つのブロックレンジを構成するテーブルブロックの数を定義します（詳しくは<A
HREF="brin-intro.html"
>項64.1</A
>参照）。
デフォルトは<TT
CLASS="LITERAL"
>128</TT
>です。
    </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATEINDEX-CONCURRENTLY"
></A
><H3
>インデックスの同時作成</H3
><P
>インデックスの作成が、通常のデータベース操作に影響を与えることがあります。
通常<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、対象テーブルに対する書き込みをロックしてから、対象テーブル全体のインデックス作成を一度のスキャンで行います。
他のトランザクションはテーブルを読み取ることはできますが、対象テーブル内の行を挿入、更新、削除しようとすると、インデックス作成が完了するまでブロックされます。
実行中の運用状態のデータベースシステムの場合、これは重大な影響を与える可能性があります。
非常に大規模なテーブルに対するインデックス作成は何時間もかかることがあり得ます。
また小規模なテーブルであっても、インデックス作成により、運用状態のシステムとしては受け入れられないほど長い時間、書き込みロックがかかる可能性があります。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は書き込みをロックしないインデックス作成もサポートしています。
<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>に<TT
CLASS="LITERAL"
>CONCURRENTLY</TT
>オプションをつけることでこの方式が行われます。
このオプションを使うと、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はテーブルを2回スキャンしなければなりません。
さらに、潜在的にそのインデックスを更新または使用する可能性がある、実行中のすべてのトランザクションが終わるまで待機しなければなりません。
したがって、この方式は通常の方式よりも総作業時間がかかり、また、完了するまでの時間が非常に長くなります。
しかし、インデックス作成中に通常の操作を行い続けることができますので、この方式は運用環境での新規インデックス作成に有用です。
もちろん、インデックス作成によりCPUや入出力に余分に負荷がかかりますので、他の操作が低速になる可能性があります。
   </P
><P
>同時実行インデックス構築では実際には、1つのトランザクションでシステムカタログに登録され、さらに2つのトランザクションで２つのテーブルスキャンが起こります。
各テーブルスキャンの前に、インデックス構築はテーブルを修正した実行中のトランザクションが終了するのを待たなければなりません。
2回目のスキャンの後、インデックス構築は2回目のスキャンより前のスナップショット（<A
HREF="mvcc.html"
>第13章</A
>参照）を持つすべてのトランザクションが終了するのを待たなければなりません。
その後でようやく、インデックスは利用可能であると印が付けられ、<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>コマンドが終了します。
しかし、それでもインデックスは問い合わせに対して即座に利用可能であるとは限りません。
最悪の場合、インデックス構築開始前のトランザクションが存在する間は利用できません。
   </P
><P
>たとえばデッドロックや一意性インデックスにおける一意性違反など、テーブルスキャン中に問題が発生すると、<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は失敗しますが、<SPAN
CLASS="QUOTE"
>"無効な"</SPAN
>インデックスが残ってしまいます。
こうしたインデックスは完全ではない可能性がありますので、問い合わせの際には無視されます。
しかし、更新時にオーバーヘッドがかかります。
<SPAN
CLASS="APPLICATION"
>psql</SPAN
>の<TT
CLASS="COMMAND"
>\d</TT
>コマンドでは、こうしたインデックスを<TT
CLASS="LITERAL"
>INVALID</TT
>として報告します。

</P><PRE
CLASS="PROGRAMLISTING"
>postgres=# \d tab
       Table "public.tab"
 Column |  Type   | Modifiers 
--------+---------+-----------
 col    | integer | 
Indexes:
    "idx" btree (col) INVALID</PRE
><P>

こうした場合の推奨復旧方法は、インデックスを削除し、再度<TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>を実行することです。
（他にも<TT
CLASS="COMMAND"
>REINDEX</TT
>を使用したインデックスの再作成という方法もあります。
しかし、<TT
CLASS="COMMAND"
>REINDEX</TT
>は同時作成をサポートしていませんので、この方法は魅力がありません。）
   </P
><P
>この他に一意性インデックスを同時作成する場合の注意事項があります。
2回目のテーブルスキャンが始まる時点で、他のトランザクションに対する一意性制約が既に有効になっているという点です。
これは、インデックスが使用できるようになる前やインデックス作成が最終的に失敗したとしても、制約違反が他のトランザクションで報告されてしまうことを意味します。
また、2回目のスキャン中に失敗した後も、<SPAN
CLASS="QUOTE"
>"無効な"</SPAN
>インデックスによる一意性制約は強制され続けます。
   </P
><P
>式インデックスや部分インデックスの同時作成もサポートされています。
式の評価中にエラーが発生した場合も、上で説明した一意性制約違反と同様な状況が発生します。
   </P
><P
>同一テーブルに対する通常のインデックス作成処理は複数並行して行うことができます。
しかし、あるテーブルに対するインデックスの同時作成は一度に1つしか行うことができません。
また、どの場合でもインデックス作成中はテーブルスキーマの変更はできません。
この他に、通常の<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>コマンドはトランザクションブロック内で実行させることができますが、<TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>は実行させることができないという相違点があります。
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN79942"
></A
><H2
>注釈</H2
><P
>インデックスが、どのような時に使用され、どのような時に使用されないか、また、どのような場合に有用かといった情報については<A
HREF="indexes.html"
>第11章</A
>を参照してください。
  </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>注意</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>ハッシュインデックス操作は現在WALに記録されません。
このためハッシュインデックスは、データベースがクラッシュした後、書き込みが済んでいない変更があれば、<TT
CLASS="COMMAND"
>REINDEX</TT
>を用いて再構築しなければならない可能性があります。
また、ハッシュインデックスの変更は最初のベースバックアップ以降のストリーミングまたはファイルベースのレプリケーションでは複製されません。
ですので、その後にそのインデックスを使用する問い合わせに対して間違った答えが返ります。
またハッシュインデックスはポイントインタイムリカバリのときに適切にリストアされません。
このような理由から現在ハッシュインデックスの使用を勧めません。
   </P
></TD
></TR
></TABLE
></DIV
><P
>    
現在は、B-tree、GiST、GIN、BRINインデックスメソッドのみが、複数列に対するインデックスをサポートしています。
指定できる列は、デフォルトでは32個までです（この制限は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のコンパイル時に変更できます）。
現在、B-treeのみが一意性インデックスをサポートしています。
  </P
><P
><I
CLASS="FIRSTTERM"
>演算子クラス</I
>は、インデックスのそれぞれの列に指定することができます。
演算子クラスは、その列のインデックスが使う演算子を識別します。
例えば、4バイト整数に対するB-treeインデックスには、<TT
CLASS="LITERAL"
>int4_ops</TT
>クラスを使います。
この演算子クラスには、4バイト整数の比較関数が含まれています。
実際の使用では、通常、列のデータ型のデフォルト演算子クラスで十分です。
演算子クラスを保持する主な理由は、データ型の中には有意な順序を2つ以上持つものがあるかもしれないからです。
例えば、複素数のソートで絶対値または実数部のどちらかを使いたい場合がありえます。
これを実現するには、データ型として2つの演算子クラスを定義し、インデックスを作る時に適切なクラスを選択します。
演算子クラスについての詳細は、<A
HREF="indexes-opclass.html"
>項11.9</A
>と<A
HREF="xindex.html"
>項36.14</A
>を参照してください。
  </P
><P
>順序付きスキャンをサポートするインデックスメソッド（現時点ではB-Treeのみ）では、<TT
CLASS="LITERAL"
>ASC</TT
>、<TT
CLASS="LITERAL"
>DESC</TT
>、<TT
CLASS="LITERAL"
>NULLS FIRST</TT
>、<TT
CLASS="LITERAL"
>NULLS LAST</TT
>句(省略可能)をオプションで指定し、インデックスのソート順を変更することができます。
順序付きインデックスは正方向にも逆方向にもスキャンすることができますので、単一列に対する<TT
CLASS="LITERAL"
>DESC</TT
>インデックスは通常は有用ではありません。
このソート順序はすでに通常のインデックスを使用して実現できます。
これらのオプションの価値は、<TT
CLASS="LITERAL"
>SELECT ... ORDER BY x ASC, y DESC</TT
>などの順序指定が混在する問い合わせによって要求されるソート順に一致する、複数列に対するインデックスを作成できる点です。
<TT
CLASS="LITERAL"
>NULLS</TT
>オプションは、インデックスに基づいた問い合わせにおいてソート処理を省略するために<SPAN
CLASS="QUOTE"
>"NULLのソート順を低くする"</SPAN
>動作をサポートする必要がある場合に有用です。
デフォルトの動作は<SPAN
CLASS="QUOTE"
>"NULLのソート順を高くする"</SPAN
>です。
  </P
><P
>ほとんどのインデックスメソッドにおいて、インデックス作成速度は<A
HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"
>maintenance_work_mem</A
>の設定に依存します。
より大きな値を設定すると、インデックス作成に必要となる時間が短縮されます。
ただし、実際に使用できるメモリ量を超えるほど大きくすると、マシンがスワップ状態になり、遅くなります。
  </P
><P
>インデックスを削除するには、<A
HREF="sql-dropindex.html"
>DROP INDEX</A
>を使用してください。
  </P
><P
>以前の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>にはR-treeインデックスメソッドがありました。
GiSTメソッドに比べて大きな利点がありませんでしたので、このメソッドは削除されました。
古いデータベースからGiSTへの変換を簡単にするため、<TT
CLASS="LITERAL"
>USING rtree</TT
>が指定された場合、<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は<TT
CLASS="LITERAL"
>USING gist</TT
>と解釈します。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN79975"
></A
><H2
>例</H2
><P
>テーブル<TT
CLASS="LITERAL"
>films</TT
>の列<TT
CLASS="LITERAL"
>title</TT
>にB-treeインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX title_idx ON films (title);</PRE
><P>
  </P
><P
>大文字小文字を区別しない検索が効率的になるように、式<TT
CLASS="LITERAL"
>lower(title)</TT
>に対してインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX ON films ((lower(title)));</PRE
><P>
(この例では、インデックス名を省略することを選びました。
このためシステムが<TT
CLASS="LITERAL"
>films_lower_idx</TT
>などという名前を選ぶことになります。)
  </P
><P
>デフォルト以外の照合順序でインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX title_idx_german ON films (title COLLATE "de_DE");</PRE
><P>
  </P
><P
>デフォルトと異なるNULLのソート順を指定したインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX title_idx_nulls_low ON films (title NULLS FIRST);</PRE
><P>
  </P
><P
>デフォルトと異なるフィルファクタを持つインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX title_idx ON films (title) WITH (fillfactor = 70);</PRE
><P>
  </P
><P
>高速更新を無効にして<ACRONYM
CLASS="ACRONYM"
>GIN</ACRONYM
>インデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX gin_idx ON documents_table USING GIN (locations) WITH (fastupdate = off);</PRE
><P>
  </P
><P
>テーブル<TT
CLASS="LITERAL"
>films</TT
>上の列<TT
CLASS="LITERAL"
>code</TT
>に対するインデックスを作成します。
また、このインデックスをテーブル空間<TT
CLASS="LITERAL"
>indexspace</TT
>内に生成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX code_idx ON films (code) TABLESPACE indexspace;</PRE
><P>
  </P
><P
>変換関数の結果に対するbox操作を効率的に使用できるようにpoint属性にGiSTインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX pointloc
    ON points USING gist (box(location,location));
SELECT * FROM points
    WHERE box(location,location) &amp;&amp; '(0,0),(1,1)'::box;</PRE
><P>
  </P
><P
>対象テーブルへの書き込みをロックせずにインデックスを作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE INDEX CONCURRENTLY sales_quantity_index ON sales_table (quantity);</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN80003"
></A
><H2
>互換性</H2
><P
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。
標準SQLにはインデックスについての規定はありません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN80008"
></A
><H2
>関連項目</H2
><A
HREF="sql-alterindex.html"
>ALTER INDEX</A
>, <A
HREF="sql-dropindex.html"
>DROP INDEX</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-creategroup.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createlanguage.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE GROUP</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE LANGUAGE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
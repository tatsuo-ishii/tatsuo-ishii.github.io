<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>データベースページのレイアウト</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="データベースの物理的な格納"
HREF="storage.html"><LINK
REL="PREVIOUS"
TITLE="初期化フォーク"
HREF="storage-init.html"><LINK
REL="NEXT"
TITLE="BKIバックエンドインタフェース"
HREF="bki.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="初期化フォーク"
HREF="storage-init.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="storage.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 65章データベースの物理的な格納</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="BKIバックエンドインタフェース"
HREF="bki.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="STORAGE-PAGE-LAYOUT"
>65.6. データベースページのレイアウト</A
></H1
><P
>本節では<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のテーブルおよびインデックスで使われるページ書式の概略について説明します。
<A
NAME="AEN119281"
HREF="#FTN.AEN119281"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>
<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>のテーブルとシーケンスは、通常のテーブルと同様に整形されています。</P
><P
>以下の説明では1<I
CLASS="FIRSTTERM"
>バイト</I
>は8ビットからなることを前提としています。
さらに、<I
CLASS="FIRSTTERM"
>アイテム</I
>という単語は、ページに格納される個別のデータ値のことを指しています。
テーブル内ではアイテムは行であり、インデックス内ではアイテムはインデックスのエントリです。</P
><P
>テーブルとインデックスはすべて、固定サイズ（通常8キロバイト。サーバのコンパイル時に異なるサイズを設定可能）の<I
CLASS="FIRSTTERM"
>ページ</I
>の集まりとして格納されます。
テーブルでは、すべてのページは論理上等価です。
したがって、あるアイテム（行）はどのページにでも格納することができます。
インデックスでは、初めのページは通常、制御用の情報を保持する<I
CLASS="FIRSTTERM"
>メタページ</I
>として予約されます。
また、インデックスではインデックスアクセスメソッドに依存した様々なページ種類があります。</P
><P
><A
HREF="storage-page-layout.html#PAGE-TABLE"
>表65-2</A
>はページの全体的なレイアウトを示しています。
各ページには5つの部分があります。</P
><DIV
CLASS="TABLE"
><A
NAME="PAGE-TABLE"
></A
><P
><B
>表 65-2. ページレイアウト全体</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>アイテム</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>PageHeaderData</TD
><TD
>長さは24バイト。空き領域ポインタを含む、ページについての一般情報です。</TD
></TR
><TR
><TD
>ItemIdData</TD
><TD
>実際のアイテムを指す（オフセットと長さの）ペアの配列です。
1アイテムにつき4バイトです。</TD
></TR
><TR
><TD
>空き領域</TD
><TD
>割り当てられていない空間です。
新規のアイテムポインタはこの領域の先頭から、新規のアイテムは最後から割り当てられます。</TD
></TR
><TR
><TD
>アイテム</TD
><TD
>実際のアイテムそのものです。</TD
></TR
><TR
><TD
>特別な空間</TD
><TD
>インデックスアクセスメソッド特有のデータです。異なるメソッドは異なるデータを格納します。通常のテーブルでは空です。</TD
></TR
></TBODY
></TABLE
></DIV
><P
>&#13;それぞれのページの最初の24バイトはページヘッダ(<TT
CLASS="STRUCTNAME"
>PageHeaderData</TT
>)から構成されています。
その書式を<A
HREF="storage-page-layout.html#PAGEHEADERDATA-TABLE"
>表65-3</A
>にて説明します。
最初のフィールドは、このページに関連する最も最近のWAL項目を表しています。
2番目のフィールドには<A
HREF="app-initdb.html#APP-INITDB-DATA-CHECKSUMS"
>data checksums</A
>が有効な場合にページチェックサムが格納されています。
次にフラグビットを含む2バイトのフィールドがあります。
その後に2バイトの整数フィールドが3つ続きます（<TT
CLASS="STRUCTFIELD"
>pd_lower</TT
>、<TT
CLASS="STRUCTFIELD"
>pd_upper</TT
>、<TT
CLASS="STRUCTFIELD"
>pd_special</TT
>）。
これらには、割り当てられていない空間の始まり、割り当てられていない空間の終わり、そして特別な空間の始まりのバイトオフセットが格納されています。
ページヘッダの次の2バイトである<TT
CLASS="STRUCTFIELD"
>pd_pagesize_version</TT
>は、ページサイズとバージョン指示子の両方を格納します。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.3以降のバージョン番号は4、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.1と8.2のバージョン番号は3、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.0のバージョン番号は2、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.3と7.4のバージョン番号は1です。
それより前のリリースのバージョン番号は0です
（ほとんどのバージョン間で基本的なページレイアウトやヘッダの書式は変更されていませんが、ヒープ行ヘッダのレイアウトが変更されました）。
ページサイズは基本的に照合用としてのみ存在しています。
同一インストレーションでの複数のページサイズはサポートされていません。
最後のフィールドはそのページの切り詰めが有益かどうかを示すヒントです。
これはページ上で切り詰められていないもっとも古いXMAXが追跡するものです。

 </P
><DIV
CLASS="TABLE"
><A
NAME="PAGEHEADERDATA-TABLE"
></A
><P
><B
>表 65-3. PageHeaderDataのレイアウト</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>フィールド</TH
><TH
>型</TH
><TH
>長さ</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>pd_lsn</TD
><TD
>PageXLogRecPtr</TD
><TD
>8バイト</TD
><TD
>LSN: このページへの最終変更に対応するxlogレコードの最後のバイトの次のバイト</TD
></TR
><TR
><TD
>pd_checksum</TD
><TD
>uint16</TD
><TD
>2バイト</TD
><TD
>ページチェックサム</TD
></TR
><TR
><TD
>pd_flags</TD
><TD
>uint16</TD
><TD
>2バイト</TD
><TD
>フラグビット</TD
></TR
><TR
><TD
>pd_lower</TD
><TD
>LocationIndex</TD
><TD
>2 バイト</TD
><TD
>空き領域の始まりに対するオフセット</TD
></TR
><TR
><TD
>pd_upper</TD
><TD
>LocationIndex</TD
><TD
>2バイト</TD
><TD
>空き領域の終わりに対するオフセット</TD
></TR
><TR
><TD
>pd_special</TD
><TD
>LocationIndex</TD
><TD
>2バイト</TD
><TD
>特別な空間の始まりに対するオフセット</TD
></TR
><TR
><TD
>pd_pagesize_version</TD
><TD
>uint16</TD
><TD
>2バイト</TD
><TD
>ページサイズおよびレイアウトのバージョン番号の情報</TD
></TR
><TR
><TD
>pd_prune_xid</TD
><TD
>TransactionId</TD
><TD
>4バイト</TD
><TD
>ページ上でもっとも古い切り詰められていないXMAX。存在しなければゼロ。</TD
></TR
></TBODY
></TABLE
></DIV
><P
>詳細情報については<TT
CLASS="FILENAME"
>src/include/storage/bufpage.h</TT
>を参照してください。
 </P
><P
>&#13;ページヘッダに続くのはアイテム識別子（<TT
CLASS="TYPE"
>ItemIdData</TT
>）です。
識別子ごとに4バイトを必要とします。
アイテム識別子は、アイテムが開始されるバイトオフセット、バイト単位の長さ、そしてその解釈に影響する属性ビット群を持っています。
新しいアイテム識別子は必要に応じて、未割当て空間の最初から割り当てられます。
アイテム識別子の数は、新しい識別子を割り当てるために増加される<TT
CLASS="STRUCTFIELD"
>pd_lower</TT
>を見ることで決定できます。
アイテム識別子は解放されるまで動かされることがないので、アイテム自体が空き領域をまとめるためにページ上で移動される場合でも、そのインデックスはアイテムを参照するために長期にわたって使うことができます。
実際、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が作る、アイテムへのポインタ（<TT
CLASS="TYPE"
>ItemPointer</TT
>、<TT
CLASS="TYPE"
>CTID</TT
>とも言います）はページ番号とアイテム識別子のインデックスによって構成されています。

 </P
><P
>&#13;アイテム自体は、未割り当て空間の最後から順番に割り当てられた空間に格納されます。
正確な構造は、テーブルに何を含めるかによって異なります。
テーブルとシーケンスの両方が、以下で説明する<TT
CLASS="TYPE"
>HeapTupleHeaderData</TT
>という構造を使用します。

 </P
><P
>&#13;最後のセクションは、アクセスメソッドが格納しようとするものを何でも含めることのできる<SPAN
CLASS="QUOTE"
>"特別なセクション"</SPAN
>です。
例えば、B-treeインデックスは、そのページの両隣のページへのリンク、ならびに、インデックス構造体に関連したその他の何らかのデータを持ちます。
通常のテーブルではこれはまったく使用されません（ページサイズを同じにするために<TT
CLASS="STRUCTFIELD"
>pd_special</TT
>を設定することで示されます）。

 </P
><P
>&#13;テーブル行はすべて同じ方法で構成されています。
固定サイズのヘッダ（ほとんどのマシンで23バイトを占有します）があり、その後にオプションのNULLビットマップ、オプションのオブジェクトIDフィールド、およびユーザデータが続きます。
ヘッダについては<A
HREF="storage-page-layout.html#HEAPTUPLEHEADERDATA-TABLE"
>表65-4</A
>で説明します。
実際のユーザデータ（行内の列）は、常にプラットフォームのMAXALIGN距離の倍数である<TT
CLASS="STRUCTFIELD"
>t_hoff</TT
>で示されるオフセットから始まります。
NULLビットマップは<I
CLASS="FIRSTTERM"
>HEAP_HASNULL</I
>ビットが<TT
CLASS="STRUCTFIELD"
>t_infomask</TT
>で設定されている場合にのみ存在します。
存在する場合は、固定ヘッダのすぐ後ろから始まり、データ列ごとに1ビットとするのに十分なバイト数を占有します（合計すると、<TT
CLASS="STRUCTFIELD"
>t_natts</TT
>のビット数となります）。
このビットのリスト内では、1ビットは非NULLを、0ビットはNULLを示します。
このビットマップが存在しない場合、すべての列が非NULLとみなされます。
オブジェクトIDは<I
CLASS="FIRSTTERM"
>HEAP_HASOID</I
>ビットが<TT
CLASS="STRUCTFIELD"
>t_infomask</TT
>で設定されている場合にのみ存在します。
存在する場合、これは<TT
CLASS="STRUCTFIELD"
>t_hoff</TT
>境界の直前に現れます。
<TT
CLASS="STRUCTFIELD"
>t_hoff</TT
>をMAXALIGNの倍数とするために必要なパッドは全て、NULLビットマップとオブジェクトIDの間に現れます
（このことにより、オブジェクトIDの位置揃えが確実に適切になります）。

 </P
><DIV
CLASS="TABLE"
><A
NAME="HEAPTUPLEHEADERDATA-TABLE"
></A
><P
><B
>表 65-4. HeapTupleHeaderDataのレイアウト</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>フィールド</TH
><TH
>型</TH
><TH
>長さ</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>t_xmin</TD
><TD
>TransactionId</TD
><TD
>4バイト</TD
><TD
>挿入XIDスタンプ</TD
></TR
><TR
><TD
>t_xmax</TD
><TD
>TransactionId</TD
><TD
>4バイト</TD
><TD
>削除XIDスタンプ</TD
></TR
><TR
><TD
>t_cid</TD
><TD
>CommandId</TD
><TD
>4バイト</TD
><TD
>挿入、削除の両方または片方のCIDスタンプ（t_xvacと共有）</TD
></TR
><TR
><TD
>t_xvac</TD
><TD
>TransactionId</TD
><TD
>4バイト</TD
><TD
>行バージョンを移すVACUUM操作用XID</TD
></TR
><TR
><TD
>t_ctid</TD
><TD
>ItemPointerData</TD
><TD
>6バイト</TD
><TD
>この行または最新バージョンの行の現在のTID</TD
></TR
><TR
><TD
>t_infomask2</TD
><TD
>uint16</TD
><TD
>2バイト</TD
><TD
>属性の数と各種フラグビット</TD
></TR
><TR
><TD
>t_infomask</TD
><TD
>uint16</TD
><TD
>2バイト</TD
><TD
>様々なフラグビット</TD
></TR
><TR
><TD
>t_hoff</TD
><TD
>uint8</TD
><TD
>1バイト</TD
><TD
>ユーザデータに対するオフセット</TD
></TR
></TBODY
></TABLE
></DIV
><P
>詳細情報については<TT
CLASS="FILENAME"
>src/include/access/htup.h</TT
>を参照してください。
 </P
><P
>&#13;実際のデータの解釈は、他のテーブル、ほとんどの場合、<TT
CLASS="STRUCTNAME"
>pg_attribute</TT
>から取得された情報でのみ行うことができます。
フィールド位置を識別するために必要なキー値は、<TT
CLASS="STRUCTFIELD"
>attlen</TT
>および<TT
CLASS="STRUCTFIELD"
>attalign</TT
>です。
フィールドの幅が固定されていてNULL値が存在しない場合を除き、特定の属性を直接取得する方法はありません。
この仕組みはすべて、<I
CLASS="FIRSTTERM"
>heap_getattr</I
>、<I
CLASS="FIRSTTERM"
>fastgetattr</I
>および<I
CLASS="FIRSTTERM"
>heap_getsysattr</I
>関数にラップされています。

 </P
><P
>&#13;データを読むためには、それぞれの属性を順番に検査する必要があります。
まず、NULLビットマップに従ってフィールドがNULLかどうかを検査します。
もしNULLであれば、次に進みます。
次に、位置揃えが正しいことを確認してください。
フィールドの幅が固定されていれば、すべてのバイトが単純に配置されます。
可変長のフィールド（attlen == -1）の場合はもう少し複雑です。
可変長のデータ型はすべて、格納する値の長さといくつかのフラグビットを持つ<TT
CLASS="TYPE"
>struct varlena</TT
>という共通ヘッダ構造体を共有します。
フラグによって、データは行内、または別のテーブル（TOAST）のいずれかとなったり、圧縮済みとなったりします
（<A
HREF="storage-toast.html"
>項65.2</A
>を参照してください）。

 </P
></DIV
><H3
CLASS="FOOTNOTES"
>注意</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN119281"
HREF="storage-page-layout.html#AEN119281"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>実際にはインデックスアクセスメソッドはこのページ書式を使用する必要はありません。
既存のすべてのインデックスメソッドがこの基本書式を使用しています。
しかし、インデックスメタページに保持されるデータは通常、アイテムレイアウト規則に正確には従っていません。
  </P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="storage-init.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="bki.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>初期化フォーク</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="storage.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><ACRONYM
CLASS="ACRONYM"
>BKI</ACRONYM
>バックエンドインタフェース</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
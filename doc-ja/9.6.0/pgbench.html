<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>pgbench</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="PostgreSQLクライアントアプリケーション"
HREF="reference-client.html"><LINK
REL="PREVIOUS"
TITLE="pg_basebackup"
HREF="app-pgbasebackup.html"><LINK
REL="NEXT"
TITLE="pg_config"
HREF="app-pgconfig.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="pg_basebackup"
HREF="app-pgbasebackup.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="reference-client.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="pg_config"
HREF="app-pgconfig.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="PGBENCH"
></A
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
></H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN94681"
></A
><H2
>名前</H2
>pgbench&nbsp;--&nbsp;<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に対してベンチマーク試験を行う</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN94685"
></A
><H2
>概要</H2
><P
><TT
CLASS="COMMAND"
>pgbench</TT
>  <TT
CLASS="OPTION"
>-i</TT
>  [<TT
CLASS="REPLACEABLE"
><I
>option</I
></TT
>...] [<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
>]</P
><P
><TT
CLASS="COMMAND"
>pgbench</TT
> [<TT
CLASS="REPLACEABLE"
><I
>option</I
></TT
>...] [<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
>]</P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN94700"
></A
><H2
>説明</H2
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>上でベンチマーク試験を行う単純なプログラムです。
これは同一のSQLコマンドの並びを何度も実行します。複数の同時実行データベースセッションで実行することもできます。
そして、トランザクションの速度（1秒当たりのトランザクション数）の平均を計算します。
デフォルトで<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は、1トランザクション当たり5つの<TT
CLASS="COMMAND"
>SELECT</TT
>、<TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>INSERT</TT
>コマンドを含むおおよそTPC-Bに基いたシナリオを試験します。
しかし、独自のトランザクションスクリプトファイルを作成することで他の試験ケースを簡単に実行することができます。
 </P
><P
>pgbenchの典型的な出力を以下に示します。

</P><PRE
CLASS="SCREEN"
>transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)</PRE
><P>

最初の6行はいくつかの最重要パラメータの設定を表示しています。
次行が完了トランザクション数と予定トランザクション数です（後者は単なるクライアント数とクライアント毎のトランザクション数の積算結果です。）
実行が完了する前に失敗しない限りこれは等しくなります。
(<TT
CLASS="OPTION"
>-T</TT
>モードでは、トランザクションの実際の数が表示されます)
最後の2行は、データベースセッションを開始するための時間を含める場合と含めない場合の1秒当たりのトランザクション数を示します。
 </P
><P
>デフォルトのTPC-Bと似たトランザクション試験では、あらかじめ設定する特定のテーブルが必要です。
これらのテーブルを作成し、データを投入するためには、<TT
CLASS="OPTION"
>-i</TT
>(初期化)オプションを付けて<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>を呼び出さなければなりません。
(独自スクリプトを試験する場合、この手順は必要ありません。
しかし代わりに試験に必要な何らかの設定を行わなければならないでしょう。)
初期化は以下のようになります。

</P><PRE
CLASS="PROGRAMLISTING"
>pgbench -i [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>other-options</I
></TT
> </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>

ここで<TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
>は試験用に前もって作成されたデータベースの名前です。
（またデータベースサーバの接続方法を指定するために、<TT
CLASS="OPTION"
>-h</TT
>、<TT
CLASS="OPTION"
>-p</TT
>、<TT
CLASS="OPTION"
>-U</TT
>が必要になるかもしれません。）
  </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>注意</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
><TT
CLASS="LITERAL"
>pgbench -i</TT
>は4つのテーブル<TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_history</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>を作成します。
もしあればこうした名前のテーブルは破壊されます。
もし同じ名前のテーブルが存在する場合にはよく注意してください。
   </P
></TD
></TR
></TABLE
></DIV
><P
>デフォルトの<SPAN
CLASS="QUOTE"
>"倍数"</SPAN
>の1では、テーブルは初期状態で以下の行数を含みます。
</P><PRE
CLASS="SCREEN"
>table                   # of rows
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0</PRE
><P>
<TT
CLASS="OPTION"
>-s</TT
>（倍数）オプションを使用して行数を増加させることができます（また、ほとんどの目的ではおそらく増加させるべきです）。
また、<TT
CLASS="OPTION"
>-F</TT
> （フィルファクタ）オプションをここで使用しても構いません。
  </P
><P
>一度この必要な設定を行った後、以下のように<TT
CLASS="OPTION"
>-i</TT
>を持たないコマンドでベンチマークを行うことができます。

</P><PRE
CLASS="PROGRAMLISTING"
>pgbench [<SPAN
CLASS="OPTIONAL"
> <TT
CLASS="REPLACEABLE"
><I
>options</I
></TT
> </SPAN
>] <TT
CLASS="REPLACEABLE"
><I
>dbname</I
></TT
></PRE
><P>

ほとんどすべての場合、有用な試験とするためにいくつかのオプションが必要になります。
最重要オプションは<TT
CLASS="OPTION"
>-c</TT
>（クライアント数）、<TT
CLASS="OPTION"
>-t</TT
>（トランザクション数）、<TT
CLASS="OPTION"
>-T</TT
> (制限時間)、<TT
CLASS="OPTION"
>-f</TT
>（独自スクリプトファイルの指定）です。
以下の全一覧を参照してください。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN94745"
></A
><H2
>オプション</H2
><P
>以下では、データベース初期化時に使用されるオプション、ベンチマーク実行時に使用されるオプション、どちらの場合でも使われるオプションの３つに分けて説明します。
  </P
><DIV
CLASS="REFSECT2"
><A
NAME="PGBENCH-INIT-OPTIONS"
></A
><H3
>初期化用のオプション</H3
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は以下の初期化用のコマンドライン引数を受け付けます。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-i</TT
><BR><TT
CLASS="OPTION"
>--initialize</TT
></DT
><DD
><P
>初期化モードを呼び出すために必要です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-F</TT
> <TT
CLASS="REPLACEABLE"
><I
>fillfactor</I
></TT
><BR><TT
CLASS="OPTION"
>--fillfactor=</TT
><TT
CLASS="REPLACEABLE"
><I
>fillfactor</I
></TT
></DT
><DD
><P
>指定したフィルファクタで<TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルを作成します。
デフォルトは100です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-n</TT
><BR><TT
CLASS="OPTION"
>--no-vacuum</TT
></DT
><DD
><P
>初期化の後にバキューム処理を行いません。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-q</TT
><BR><TT
CLASS="OPTION"
>--quiet</TT
></DT
><DD
><P
>ログ処理を、5秒に１つの進行メッセージのみを生成する静寂モードに切り替えます。
デフォルトのログ処理では、10000行毎にメッセージを１つ出力し、（特に優れたハードウェアでは）1秒当たりに多くのメッセージを出力します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
> <TT
CLASS="REPLACEABLE"
><I
>scale_factor</I
></TT
><BR><TT
CLASS="OPTION"
>--scale=</TT
><TT
CLASS="REPLACEABLE"
><I
>scale_factor</I
></TT
></DT
><DD
><P
>この倍率で生成される行数を積算します。
例えば、<TT
CLASS="LITERAL"
>-s 100</TT
>は <TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>テーブルに10,000,000行を生成することを意味します。
デフォルトは1です。
この倍率が20000以上になると、アカウント識別子の範囲を保持できる程度に大きくなるように、アカウント識別子を保持するために使用される列（<TT
CLASS="STRUCTFIELD"
>aid</TT
>列）はより大きな整数（<TT
CLASS="TYPE"
>bigint</TT
>）を使用するように切り替わります。

       </P
></DD
><DT
><TT
CLASS="OPTION"
>--foreign-keys</TT
></DT
><DD
><P
>標準テーブル間で外部キー制約を作成します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>--index-tablespace=<TT
CLASS="REPLACEABLE"
><I
>index_tablespace</I
></TT
></TT
></DT
><DD
><P
>デフォルトのテーブル空間ではなく、指定したテーブル空間の中にインデックスを作成します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>--tablespace=<TT
CLASS="REPLACEABLE"
><I
>tablespace</I
></TT
></TT
></DT
><DD
><P
>デフォルトのテーブル空間ではなく、指定したテーブル空間の中にテーブルを作成します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>--unlogged-tables</TT
></DT
><DD
><P
>永続テーブルではなくログを取らないテーブルとしてテーブルを作成します。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="PGBENCH-RUN-OPTIONS"
></A
><H3
>ベンチマーク用オプション</H3
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は以下のベンチマーク用コマンドライン引数を受け付けます。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-b</TT
> <TT
CLASS="REPLACEABLE"
><I
>scriptname[@weight]</I
></TT
><BR><TT
CLASS="OPTION"
>--builtin</TT
>=<TT
CLASS="REPLACEABLE"
><I
>scriptname[@weight]</I
></TT
></DT
><DD
><P
>        Add the specified built-in script to the list of executed scripts.
        An optional integer weight after <TT
CLASS="LITERAL"
>@</TT
> allows to adjust the
        probability of drawing the script.  If not specified, it is set to 1.
        Available built-in scripts are: <TT
CLASS="LITERAL"
>tpcb-like</TT
>,
        <TT
CLASS="LITERAL"
>simple-update</TT
> and <TT
CLASS="LITERAL"
>select-only</TT
>.
        Unambiguous prefixes of built-in names are accepted.
        With special name <TT
CLASS="LITERAL"
>list</TT
>, show the list of built-in scripts
        and exit immediately.
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-c</TT
> <TT
CLASS="REPLACEABLE"
><I
>clients</I
></TT
><BR><TT
CLASS="OPTION"
>--client=</TT
><TT
CLASS="REPLACEABLE"
><I
>clients</I
></TT
></DT
><DD
><P
>模擬するクライアント数、つまり、同時に実行されるデータベースセッション数です。
デフォルトは1です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-C</TT
><BR><TT
CLASS="OPTION"
>--connect</TT
></DT
><DD
><P
>各クライアントセッションが一度だけ接続を確立するのではなく、各トランザクションが新しい接続を確立します。
これは接続オーバーヘッドを測定する場合に有用です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-d</TT
><BR><TT
CLASS="OPTION"
>--debug</TT
></DT
><DD
><P
>デバッグ用出力を表示します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-D</TT
> <TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
><TT
CLASS="LITERAL"
>=</TT
><TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
><BR><TT
CLASS="OPTION"
>--define=</TT
><TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
><TT
CLASS="LITERAL"
>=</TT
><TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
></DT
><DD
><P
>独自スクリプト（後述）で使用される変数を定義します。
複数の<TT
CLASS="OPTION"
>-D</TT
>オプションを使用することができます。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-f</TT
> <TT
CLASS="REPLACEABLE"
><I
>filename[@weight]</I
></TT
><BR><TT
CLASS="OPTION"
>--file=</TT
><TT
CLASS="REPLACEABLE"
><I
>filename[@weight]</I
></TT
></DT
><DD
><P
>★原文変更あり
トランザクションスクリプトを<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>から読み取ります。
詳細は後で説明します。
<TT
CLASS="OPTION"
>-N</TT
>、<TT
CLASS="OPTION"
>-S</TT
>、<TT
CLASS="OPTION"
>-f</TT
>は互いに排他的です。

       </P
></DD
><DT
><TT
CLASS="OPTION"
>-j</TT
> <TT
CLASS="REPLACEABLE"
><I
>threads</I
></TT
><BR><TT
CLASS="OPTION"
>--jobs=</TT
><TT
CLASS="REPLACEABLE"
><I
>threads</I
></TT
></DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>内のワーカスレッド数です。
複数のスレッドを使用することはマルチCPUマシンで有用になります。
各スレッドには管理するクライアントセッションを同じ数与えられますので、クライアント数はスレッド数の倍数でなければなりません。
デフォルトは1です。

       </P
></DD
><DT
><TT
CLASS="OPTION"
>-l</TT
><BR><TT
CLASS="OPTION"
>--log</TT
></DT
><DD
><P
>各トランザクションで費やした時間をログファイルに書き出します。
後で詳細を説明します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-L</TT
> <TT
CLASS="REPLACEABLE"
><I
>limit</I
></TT
><BR><TT
CLASS="OPTION"
>--latency-limit=</TT
><TT
CLASS="REPLACEABLE"
><I
>limit</I
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>limit</I
></TT
>ミリ秒以上続くトランザクションが計数され、別途<I
CLASS="FIRSTTERM"
>遅いトランザクション</I
>として報告されます。
       </P
><P
>制限が使用されると(<TT
CLASS="OPTION"
>--rate=...</TT
>)、<TT
CLASS="REPLACEABLE"
><I
>limit</I
></TT
>ミリ秒以上遅延がスケジュールされたトランザクションは遅延制限を満たす可能性がないため、サーバに送信されることは決してありません。
これらのトラザクションは計数され、別途<I
CLASS="FIRSTTERM"
>スキップされた</I
>として報告されます。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-M</TT
> <TT
CLASS="REPLACEABLE"
><I
>querymode</I
></TT
><BR><TT
CLASS="OPTION"
>--protocol=</TT
><TT
CLASS="REPLACEABLE"
><I
>querymode</I
></TT
></DT
><DD
><P
>サーバへ問い合わせを送信するために使用するプロトコルです。
          <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>simple</TT
>: 簡易問い合わせプロトコルを使用します。</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>extended</TT
>: 拡張問い合わせプロトコルを使用します。</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>prepared</TT
>: プリペアドステートメントを伴う拡張問い合わせプロトコルを使用します。</P
></LI
></UL
><P>
デフォルトは簡易問い合わせプロトコルです。
（詳しい情報は<A
HREF="protocol.html"
>第51章</A
>を参照してください）
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-n</TT
><BR><TT
CLASS="OPTION"
>--no-vacuum</TT
></DT
><DD
><P
>試験を実行する前にバキュームを行いません。
<TT
CLASS="STRUCTNAME"
>pgbench_accounts</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>、<TT
CLASS="STRUCTNAME"
>pgbench_history</TT
>、
<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>標準テーブルを含まない独自試験シナリオを実行する場合、このオプションは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>必要</I
></SPAN
>です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-N</TT
><BR><TT
CLASS="OPTION"
>--skip-some-updates</TT
></DT
><DD
><P
>★原文変更あり
<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>と<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>を更新しません。
これは両テーブル上の重度の更新の競合を防ぎますが、TPC-Bのような試験ケースを行わなくなります。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-P</TT
> <TT
CLASS="REPLACEABLE"
><I
>sec</I
></TT
><BR><TT
CLASS="OPTION"
>--progress=</TT
><TT
CLASS="REPLACEABLE"
><I
>sec</I
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>sec</I
></TT
>秒毎の進捗レポートを表示します。
レポートには起動からの経過時間、前回レポート時からのtps、前回レポート時からのトランザクションの平均待ち時間、標準偏差を含んでいます。
(<TT
CLASS="OPTION"
>-R</TT
>)オプションによる制限下では、待ち時間はトランザクションの実開始時間ではなく、予定開始時間で算出されていますので、平均予定遅延時間が含まれています。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-r</TT
><BR><TT
CLASS="OPTION"
>--report-latencies</TT
></DT
><DD
><P
>ベンチマーク完了後の各コマンドにおけるステートメント毎の平均レイテンシ(クライアントから見た実行時間)を報告します。詳しくは下を参照してください。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-R</TT
> <TT
CLASS="REPLACEABLE"
><I
>rate</I
></TT
><BR><TT
CLASS="OPTION"
>--rate=</TT
><TT
CLASS="REPLACEABLE"
><I
>rate</I
></TT
></DT
><DD
><P
>トランザクションを可能な限り高速（デフォルト）で実行するのではなく、指定された目標レートで実行します。
レートは1秒あたりのトランザクション数で与えられます。目標レートが実施可能な最大レートを越えている場合、レート制限は結果に影響を与えません。
       </P
><P
>レートはトランザクションの開始予定タイムラインがポアソン分布に沿う事を目標としています。
期待される開始時刻の予定は、前トランザクションの終了時ではなくクライアントの初期起動時に基づいて動かします。
このアプローチはトランザクションがオリジナルの終了予定時刻を過ぎた場合でも、後でまた追い付けることを意味します。
       </P
><P
>制限がアクティブになると、実行終了時に報告されるトランザクション待ち時間は、予定開始時刻から計算されるので、
各トランザクションが前トランザクションの終了を待たねばならなかった時間を含んでいます。
この待ち時間はスケジュールラグタイムと呼ばれ、平均と最大値も別々に報告されます。
実トランザクション開始時刻についてのトランザクション待ち時間、つまりデータベース内でトランザクションの実行に要した時間は、報告された待ち時間からスケジュールラグタイムを減算することで算出することができます。
       </P
><P
><TT
CLASS="OPTION"
>--latency-limit</TT
>が<TT
CLASS="OPTION"
>--rate</TT
>と一緒に指定された場合、トランザクションは、先行するトランザクションが終了した際にすでに遅延制限を超えていて、非常に遅れてしまうことがあり得ます。
そのようなトランザクションはサーバに送信さることなくスキップされ、別途カウントされます。
       </P
><P
>スケジュールラグタイムの高い値は、システムが選択されたクライアント数とスレッド数で、指定されたレートでトランザクションを処理できなかったことを示しています。
トランザクションの平均実行時間が各トランザクション間で予定されていた間隔より長い場合、各逐次トランザクションは更に遅くなり、
スケジュールラグタイムはテスト実行がより長く増加し続けます。
これが起こる場合、指定トランザクションレートを減らす必要があります。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
> <TT
CLASS="REPLACEABLE"
><I
>scale_factor</I
></TT
><BR><TT
CLASS="OPTION"
>--scale=</TT
><TT
CLASS="REPLACEABLE"
><I
>scale_factor</I
></TT
></DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>の出力で指定した倍率を報告します。
これは組み込みの試験では必要ありません。
★原文変更あり
正確な倍率が<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルの行数を数えることで検出されます。
しかし、独自ベンチマーク（<TT
CLASS="OPTION"
>-f</TT
>オプション）を試験している場合、このオプションを使用しない限り、倍率は1として報告されます。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-S</TT
><BR><TT
CLASS="OPTION"
>--select-only</TT
></DT
><DD
><P
>★原文変更あり
TPC-Bのような試験ではなく読み取りのみのトランザクションを実行します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
> <TT
CLASS="REPLACEABLE"
><I
>transactions</I
></TT
><BR><TT
CLASS="OPTION"
>--transactions=</TT
><TT
CLASS="REPLACEABLE"
><I
>transactions</I
></TT
></DT
><DD
><P
>各クライアントが実行するトランザクション数です。
デフォルトは10です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-T</TT
> <TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
><BR><TT
CLASS="OPTION"
>--time=</TT
><TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
></DT
><DD
><P
>クライアントあたりのトランザクション数を固定で指定するよりも長くテストを実行したい場合、ここに指定した秒数でテストを実行します。
<TT
CLASS="OPTION"
>-t</TT
>と<TT
CLASS="OPTION"
>-T</TT
>は互いに排他的です。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-v</TT
><BR><TT
CLASS="OPTION"
>--vacuum-all</TT
></DT
><DD
><P
>試験前に4つの標準テーブルすべてをバキュームを行います。
<TT
CLASS="OPTION"
>-n</TT
>も<TT
CLASS="OPTION"
>-v</TT
>もなければ、pgbenchは<TT
CLASS="STRUCTNAME"
>pgbench_tellers</TT
>と<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルをバキュームし、<TT
CLASS="STRUCTNAME"
>pgbench_history</TT
>内のデータをすべて消去します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>--aggregate-interval=<TT
CLASS="REPLACEABLE"
><I
>seconds</I
></TT
></TT
></DT
><DD
><P
>集約間隔の長さ（秒単位）です。
これは<SPAN
CLASS="APPLICATION"
>-l</SPAN
>と一緒でのみ使用される可能性があります。
このオプションを付けると、ログには指定間隔単位の要約（トランザクション数、最大レイテンシ、最小レイテンシ、分散の推定に役に立つ2つの追加フィールド）が含まれます。

       </P
><P
>現在このオプションはWindowsではサポートされていません。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>--progress-timestamp</TT
></DT
><DD
><P
>        When showing progress (option <TT
CLASS="OPTION"
>-P</TT
>), use a timestamp
        (Unix epoch) instead of the number of seconds since the
        beginning of the run.  The unit is in seconds, with millisecond
        precision after the dot.
        This helps compare logs generated by various tools.
       </P
></DD
><DT
><TT
CLASS="OPTION"
>--sampling-rate=<TT
CLASS="REPLACEABLE"
><I
>rate</I
></TT
></TT
></DT
><DD
><P
>データをログに書き出す際に使用される、生成されるログの量を減少するためのサンプリング割合です。
このオプションが指定された場合、指定された割合のトランザクションがログに残ります。
1.0はすべてのトランザクションが、0.05はトランザクションの5%のみがログに残ることを意味します。
       </P
><P
>ログファイルを処理する際にはこのサンプリング割合を考慮することを忘れないでください。
例えば、tps値を計算する際には、比例した数を掛け合わせなければなりません（例：サンプリング割合が0.01の場合実際のtpsの1/100を得るだけです。）
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="PGBENCH-COMMON-OPTIONS"
></A
><H3
>共通オプション</H3
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は以下の共通コマンドライン引数を受け付けます。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-h</TT
> <TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
><BR><TT
CLASS="OPTION"
>--host=</TT
><TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
></DT
><DD
><P
>      データベースサーバのホスト名
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-p</TT
> <TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
><BR><TT
CLASS="OPTION"
>--port=</TT
><TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
></DT
><DD
><P
>データベースサーバのポート番号
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-U</TT
> <TT
CLASS="REPLACEABLE"
><I
>login</I
></TT
><BR><TT
CLASS="OPTION"
>--username=</TT
><TT
CLASS="REPLACEABLE"
><I
>login</I
></TT
></DT
><DD
><P
>      接続ユーザ名
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-V</TT
><BR><TT
CLASS="OPTION"
>--version</TT
></DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>のバージョンを表示し、終了します。
       </P
></DD
><DT
><TT
CLASS="OPTION"
>-?</TT
><BR><TT
CLASS="OPTION"
>--help</TT
></DT
><DD
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>のコマンドライン引数の説明を表示し、終了します。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN95116"
></A
><H2
>注釈</H2
><DIV
CLASS="REFSECT2"
><A
NAME="AEN95118"
></A
><H3
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>で実際に実行される<SPAN
CLASS="QUOTE"
>"トランザクション"</SPAN
>は何か?</H3
><P
>★この節追加
 </P
><P
>★原文変更、追加あり
デフォルトのトランザクションスクリプトは、1トランザクションで以下の7コマンドを発行します。
  </P
><P
></P
><OL
TYPE="1"
><LI
><P
><TT
CLASS="LITERAL"
>BEGIN;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>SELECT abalance FROM pgbench_accounts WHERE aid = :aid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);</TT
></P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>END;</TT
></P
></LI
></OL
><P
>★？
  </P
><P
>★？
<TT
CLASS="OPTION"
>-N</TT
>を指定した場合、第4コマンドと第5コマンドはトランザクションに含まれません。
<TT
CLASS="OPTION"
>-S</TT
>を指定した場合、<TT
CLASS="COMMAND"
>SELECT</TT
>のみが発行されます。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN95151"
></A
><H3
>独自スクリプト</H3
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は、ファイルから読み込んだトランザクションスクリプト（<TT
CLASS="OPTION"
>-f</TT
>オプション）でデフォルトのトランザクションスクリプト（上述）を置き換えて独自のベンチマークシナリオを実行する機能をサポートします。
この場合、<SPAN
CLASS="QUOTE"
>"トランザクション"</SPAN
>はスクリプトファイルの1回の実行として数えられます。
  </P
><P
>★原文変更あり
スクリプトファイルの書式は、1行1 SQLコマンドという形で、複数行に跨るSQLコマンドはサポートされません。
空行および<TT
CLASS="LITERAL"
>--</TT
>から始まる行は無視されます。
スクリプトファイルの行には、<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>自身が解釈する<SPAN
CLASS="QUOTE"
>"メタコマンド"</SPAN
>（後述）も記述することができます。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>★この節追加
   </P
></BLOCKQUOTE
></DIV
><P
>スクリプトファイル向けの簡単な変数置換機能があります。
上で説明したように変数を<TT
CLASS="OPTION"
>-D</TT
>コマンドラインオプションで設定することができます。
また、後で説明するようにメタコマンドで設定することもできます。
<TT
CLASS="OPTION"
>-D</TT
>コマンドラインオプションで設定された変数の他に、<A
HREF="pgbench.html#PGBENCH-AUTOMATIC-VARIABLES"
>表1</A
>に記載されているように、自動的に設定される変数がいくつかあります。
<TT
CLASS="OPTION"
>-D</TT
> を使ってこれらの変数に設定された値は、自動設定の値より優先されます。
一度設定すると、変数の値は、<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>と書かれてSQLコマンドに挿入されます。
1つ以上のクライアントセッションが実行される場合、セッション毎に独自の変数群を持ちます。
  </P
><DIV
CLASS="TABLE"
><A
NAME="PGBENCH-AUTOMATIC-VARIABLES"
></A
><P
><B
>表 1. 自動変数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>変数</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
> <TT
CLASS="LITERAL"
>scale</TT
> </TD
><TD
>現在のスケールファクタ</TD
></TR
><TR
><TD
> <TT
CLASS="LITERAL"
>client_id</TT
> </TD
><TD
>クライアントセッションを識別する一意の数値（ゼロから始まる）</TD
></TR
></TBODY
></TABLE
></DIV
><P
>スクリプトファイルメタコマンドはバックスラッシュ（<TT
CLASS="LITERAL"
>\</TT
>）から始まります。★原文変更あり
メタコマンドへの引数は空白文字で区切られます。
以下のメタコマンドがサポートされています。
  </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="PGBENCH-METACOMMAND-SET"
></A
><TT
CLASS="LITERAL"
>\set <TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
></TT
></DT
><DD
><P
>★原文変更あり
<TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
>変数を<TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>から計算された整数値に設定します。
expression(式)は、 <TT
CLASS="LITERAL"
>5432</TT
>のような定数、変数への参照 <TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>、通常の結合法則と括弧を伴う単項演算子(<TT
CLASS="LITERAL"
>-</TT
>)または2項演算子(<TT
CLASS="LITERAL"
>+</TT
>、<TT
CLASS="LITERAL"
>-</TT
>、<TT
CLASS="LITERAL"
>*</TT
>、<TT
CLASS="LITERAL"
>/</TT
>、<TT
CLASS="LITERAL"
>%</TT
>)から構成された式を含むことができます。
     </P
><P
>例
</P><PRE
CLASS="PROGRAMLISTING"
>\set ntellers 10 * :scale
\set aid (1021 * random(1, 100000 * :scale)) % (100000 * :scale) + 1</PRE
><P></P
></DD
><DT
><TT
CLASS="LITERAL"
>\sleep <TT
CLASS="REPLACEABLE"
><I
>number</I
></TT
> [ us | ms | s ]</TT
></DT
><DD
><P
>スクリプトの実行をマイクロ秒（<TT
CLASS="LITERAL"
>us</TT
>）、ミリ秒（<TT
CLASS="LITERAL"
>ms</TT
>）、秒（<TT
CLASS="LITERAL"
>s</TT
>）単位で指定した間待機させます。
単位を省略した場合、デフォルトは秒です。
<TT
CLASS="REPLACEABLE"
><I
>number</I
></TT
>は整数定数か整数値を持つ変数への<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>参照のいずれかです。
     </P
><P
>例
</P><PRE
CLASS="PROGRAMLISTING"
>\sleep 10 ms</PRE
><P></P
></DD
><DT
><TT
CLASS="LITERAL"
>\setshell <TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> ... ]</TT
></DT
><DD
><P
>★原文変更あり
<TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
>シェルコマンドの結果を<TT
CLASS="REPLACEABLE"
><I
>varname</I
></TT
>変数に設定します。
このコマンドは標準出力を通して整数値を返さなければなりません。
     </P
><P
><TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>は、テキスト定数または任意の型の変数を参照する<TT
CLASS="LITERAL"
>:</TT
><TT
CLASS="REPLACEABLE"
><I
>variablename</I
></TT
>とすることができます。
コロンから始まる<TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>を使用したい場合、<TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>の先頭にさらにコロンを付けなければなりません。
     </P
><P
>例:
</P><PRE
CLASS="PROGRAMLISTING"
>\setshell variable_to_be_assigned command literal_argument :variable ::literal_starting_with_colon</PRE
><P></P
></DD
><DT
><TT
CLASS="LITERAL"
>\shell <TT
CLASS="REPLACEABLE"
><I
>command</I
></TT
> [ <TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
> ... ]</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>\setshell</TT
>と同じですが、結果は無視されます。★原文変更あり
     </P
><P
>例:
</P><PRE
CLASS="PROGRAMLISTING"
>\shell command literal_argument :variable ::literal_starting_with_colon</PRE
><P></P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="PGBENCH-BUILTIN-FUNCTIONS"
></A
><H3
>Built-In Functions</H3
><P
>   The functions listed in <A
HREF="pgbench.html#PGBENCH-FUNCTIONS"
>表2</A
> are built
   into <SPAN
CLASS="APPLICATION"
>pgbench</SPAN
> and may be used in expressions appearing in
   <A
HREF="pgbench.html#PGBENCH-METACOMMAND-SET"
><TT
CLASS="LITERAL"
>\set</TT
></A
>.
  </P
><DIV
CLASS="TABLE"
><A
NAME="PGBENCH-FUNCTIONS"
></A
><P
><B
>表 2. pgbench Functions</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>Function</TH
><TH
>Return Type</TH
><TH
>Description</TH
><TH
>Example</TH
><TH
>Result</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>abs(<TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
>)</CODE
></TT
></TD
><TD
>same as <TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
></TD
><TD
>absolute value</TD
><TD
><TT
CLASS="LITERAL"
>abs(-17)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>17</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>debug(<TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
>)</CODE
></TT
></TD
><TD
>same as <TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
> </TD
><TD
>print <TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
> to <SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>,
        and return <TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
></TD
><TD
><TT
CLASS="LITERAL"
>debug(5432.1)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>5432.1</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>double(<TT
CLASS="REPLACEABLE"
><I
>i</I
></TT
>)</CODE
></TT
></TD
><TD
>double</TD
><TD
>cast to double</TD
><TD
><TT
CLASS="LITERAL"
>double(5432)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>5432.0</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>greatest(<TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
> [, <TT
CLASS="REPLACEABLE"
><I
>...</I
></TT
> ] )</CODE
></TT
></TD
><TD
>double if any <TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
> is double, else integer</TD
><TD
>largest value among arguments</TD
><TD
><TT
CLASS="LITERAL"
>greatest(5, 4, 3, 2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>5</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>int(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</CODE
></TT
></TD
><TD
>integer</TD
><TD
>cast to int</TD
><TD
><TT
CLASS="LITERAL"
>int(5.4 + 3.8)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>9</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>least(<TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
> [, <TT
CLASS="REPLACEABLE"
><I
>...</I
></TT
> ] )</CODE
></TT
></TD
><TD
>double if any <TT
CLASS="REPLACEABLE"
><I
>a</I
></TT
> is double, else integer</TD
><TD
>smallest value among arguments</TD
><TD
><TT
CLASS="LITERAL"
>least(5, 4, 3, 2.1)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2.1</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pi()</CODE
></TT
></TD
><TD
>double</TD
><TD
>value of the constant PI</TD
><TD
><TT
CLASS="LITERAL"
>pi()</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3.14159265358979323846</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>random(<TT
CLASS="REPLACEABLE"
><I
>lb</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>ub</I
></TT
>)</CODE
></TT
></TD
><TD
>integer</TD
><TD
>uniformly-distributed random integer in <TT
CLASS="LITERAL"
>[lb, ub]</TT
></TD
><TD
><TT
CLASS="LITERAL"
>random(1, 10)</TT
></TD
><TD
>an integer between <TT
CLASS="LITERAL"
>1</TT
> and <TT
CLASS="LITERAL"
>10</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>random_exponential(<TT
CLASS="REPLACEABLE"
><I
>lb</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>ub</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>)</CODE
></TT
></TD
><TD
>integer</TD
><TD
>exponentially-distributed random integer in <TT
CLASS="LITERAL"
>[lb, ub]</TT
>,
              see below</TD
><TD
><TT
CLASS="LITERAL"
>random_exponential(1, 10, 3.0)</TT
></TD
><TD
>an integer between <TT
CLASS="LITERAL"
>1</TT
> and <TT
CLASS="LITERAL"
>10</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>random_gaussian(<TT
CLASS="REPLACEABLE"
><I
>lb</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>ub</I
></TT
>, <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>)</CODE
></TT
></TD
><TD
>integer</TD
><TD
>Gaussian-distributed random integer in <TT
CLASS="LITERAL"
>[lb, ub]</TT
>,
              see below</TD
><TD
><TT
CLASS="LITERAL"
>random_gaussian(1, 10, 2.5)</TT
></TD
><TD
>an integer between <TT
CLASS="LITERAL"
>1</TT
> and <TT
CLASS="LITERAL"
>10</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>sqrt(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</CODE
></TT
></TD
><TD
>double</TD
><TD
>square root</TD
><TD
><TT
CLASS="LITERAL"
>sqrt(2.0)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1.414213562</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><P
>    The <TT
CLASS="LITERAL"
>random</TT
> function generates values using a uniform
    distribution, that is all the values are drawn within the specified
    range with equal probability. The <TT
CLASS="LITERAL"
>random_exponential</TT
> and
    <TT
CLASS="LITERAL"
>random_gaussian</TT
> functions require an additional double
    parameter which determines the precise shape of the distribution.
   </P
><P
></P
><UL
><LI
><P
>      For an exponential distribution, <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>
      controls the distribution by truncating a quickly-decreasing
      exponential distribution at <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>, and then
      projecting onto integers between the bounds.
      To be precise, with
<P
CLASS="LITERALLAYOUT"
>f(x)&nbsp;=&nbsp;exp(-parameter&nbsp;*&nbsp;(x&nbsp;-&nbsp;min)&nbsp;/&nbsp;(max&nbsp;-&nbsp;min&nbsp;+&nbsp;1))&nbsp;/&nbsp;(1&nbsp;-&nbsp;exp(-parameter))</P
>
      Then value <TT
CLASS="REPLACEABLE"
><I
>i</I
></TT
> between <TT
CLASS="REPLACEABLE"
><I
>min</I
></TT
> and
      <TT
CLASS="REPLACEABLE"
><I
>max</I
></TT
> inclusive is drawn with probability:
      <TT
CLASS="LITERAL"
>f(x) - f(x + 1)</TT
>.
     </P
><P
>      Intuitively, the larger the <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>, the more
      frequently values close to <TT
CLASS="REPLACEABLE"
><I
>min</I
></TT
> are accessed, and the
      less frequently values close to <TT
CLASS="REPLACEABLE"
><I
>max</I
></TT
> are accessed.
      The closer to 0 <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
> is, the flatter (more
      uniform) the access distribution.
      A crude approximation of the distribution is that the most frequent 1%
      values in the range, close to <TT
CLASS="REPLACEABLE"
><I
>min</I
></TT
>, are drawn
      <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>% of the time.
      The <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
> value must be strictly positive.
     </P
></LI
><LI
><P
>      For a Gaussian distribution, the interval is mapped onto a standard
      normal distribution (the classical bell-shaped Gaussian curve) truncated
      at <TT
CLASS="LITERAL"
>-parameter</TT
> on the left and <TT
CLASS="LITERAL"
>+parameter</TT
>
      on the right.
      Values in the middle of the interval are more likely to be drawn.
      To be precise, if <TT
CLASS="LITERAL"
>PHI(x)</TT
> is the cumulative distribution
      function of the standard normal distribution, with mean <TT
CLASS="LITERAL"
>mu</TT
>
      defined as <TT
CLASS="LITERAL"
>(max + min) / 2.0</TT
>, with
<P
CLASS="LITERALLAYOUT"
>f(x)&nbsp;=&nbsp;PHI(2.0&nbsp;*&nbsp;parameter&nbsp;*&nbsp;(x&nbsp;-&nbsp;mu)&nbsp;/&nbsp;(max&nbsp;-&nbsp;min&nbsp;+&nbsp;1))&nbsp;/<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2.0&nbsp;*&nbsp;PHI(parameter)&nbsp;-&nbsp;1)</P
>
      then value <TT
CLASS="REPLACEABLE"
><I
>i</I
></TT
> between <TT
CLASS="REPLACEABLE"
><I
>min</I
></TT
> and
      <TT
CLASS="REPLACEABLE"
><I
>max</I
></TT
> inclusive is drawn with probability:
      <TT
CLASS="LITERAL"
>f(i + 0.5) - f(i - 0.5)</TT
>.
      Intuitively, the larger the <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>, the more
      frequently values close to the middle of the interval are drawn, and the
      less frequently values close to the <TT
CLASS="REPLACEABLE"
><I
>min</I
></TT
> and
      <TT
CLASS="REPLACEABLE"
><I
>max</I
></TT
> bounds. About 67% of values are drawn from the
      middle <TT
CLASS="LITERAL"
>1.0 / parameter</TT
>, that is a relative
      <TT
CLASS="LITERAL"
>0.5 / parameter</TT
> around the mean, and 95% in the middle
      <TT
CLASS="LITERAL"
>2.0 / parameter</TT
>, that is a relative
      <TT
CLASS="LITERAL"
>1.0 / parameter</TT
> around the mean; for instance, if
      <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
> is 4.0, 67% of values are drawn from the
      middle quarter (1.0 / 4.0) of the interval (i.e. from
      <TT
CLASS="LITERAL"
>3.0 / 8.0</TT
> to <TT
CLASS="LITERAL"
>5.0 / 8.0</TT
>) and 95% from
      the middle half (<TT
CLASS="LITERAL"
>2.0 / 4.0</TT
>) of the interval (second and third
      quartiles). The minimum <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
> is 2.0 for performance
      of the Box-Muller transform.
     </P
></LI
></UL
><P
>例えば、組込みのTPC-Bのようなトランザクションの完全な定義を示します。

</P><PRE
CLASS="PROGRAMLISTING"
>\set aid random(1, 100000 * :scale)
\set bid random(1, 1 * :scale)
\set tid random(1, 10 * :scale)
\set delta random(-5000, 5000)
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;</PRE
><P>

 このスクリプトにより、トランザクションを繰り返す度に異なる、ランダムに選ばれた行を参照することができます。
 （この例はまた、各クライアントセッションがなぜ独自の変数を持つことが重要なのかも表しています。
 これがないと、異なる行を独立して参照することができないのです。）
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN95457"
></A
><H3
>トランザクション毎のログ処理</H3
><P
><TT
CLASS="OPTION"
>--aggregate-interval</TT
>を付けずに<TT
CLASS="OPTION"
>-l</TT
>オプションを使用すると、
<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は各トランザクションで要した時間をログファイルに書き出します。
ログファイルの名前は<TT
CLASS="FILENAME"
>pgbench_log.<TT
CLASS="REPLACEABLE"
><I
>nnn</I
></TT
></TT
>です。
ここで<TT
CLASS="REPLACEABLE"
><I
>nnn</I
></TT
>はpgbenchプロセスのPIDです。
<TT
CLASS="OPTION"
>-j</TT
>オプションが2以上の場合、それぞれ独自のログファイルを持つ複数のワーカスレッドが生成されます。
最初のワーカは標準的な単一ワーカの場合と同じ名前を持つログファイルを使用します。
他のワーカ用の追加のログファイルは<TT
CLASS="FILENAME"
>pgbench_log.<TT
CLASS="REPLACEABLE"
><I
>nnn</I
></TT
>.<TT
CLASS="REPLACEABLE"
><I
>mmm</I
></TT
></TT
>のように命名されます。
ここで<TT
CLASS="REPLACEABLE"
><I
>mmm</I
></TT
>は1から始まる各ワーカの連番です。
  </P
><P
>ログの書式は以下の通りです。

</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>client_id</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>transaction_no</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>script_no</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time_epoch</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>time_us</I
></TT
> [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>schedule_lag</I
></TT
></SPAN
>]</PRE
><P>

ここで<TT
CLASS="REPLACEABLE"
><I
>time</I
></TT
>はマイクロ秒単位の総トランザクション処理時間、
<TT
CLASS="REPLACEABLE"
><I
>file_no</I
></TT
>は使用されたスクリプトファイルを識別するもの（<TT
CLASS="OPTION"
>-f</TT
>により複数のスクリプトが指定された場合に有用）、
<TT
CLASS="REPLACEABLE"
><I
>time_epoch</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>time_us</I
></TT
>はマイクロ秒のオフセットを持つUNIXエポック書式のタイムスタンプ（小数秒付きのISO 8601タイムスタンプの作成に適します）
でトランザクションの完了時刻を示します。
フィールド<TT
CLASS="REPLACEABLE"
><I
>schedule_lag</I
></TT
>は、マイクロ秒単位のトランザクションの予定開始時刻と実開始時刻の差です。
これは<TT
CLASS="OPTION"
>--rate</TT
>オプションを使用した時だけ表示されます。
<TT
CLASS="OPTION"
>--rate</TT
>と<TT
CLASS="OPTION"
>--latency-limit</TT
>の両方のオプションを使用した時は、スキップされたトランザクションの<TT
CLASS="REPLACEABLE"
><I
>time</I
></TT
>が<TT
CLASS="LITERAL"
>skipped</TT
>として表示されます。
  </P
><P
>生成されたログファイルの一部を示します。
</P><PRE
CLASS="SCREEN"
>0 199 2241 0 1175850568 995598
0 200 2465 0 1175850568 998079
0 201 2513 0 1175850569 608
0 202 2038 0 1175850569 2663</PRE
><P>

--rate=100 と --latency-limit=5 を指定した例を示します。(<TT
CLASS="REPLACEABLE"
><I
>schedule_lag</I
></TT
>列が追加されていることに注意)
</P><PRE
CLASS="SCREEN"
>0 81 4621 0 1412881037 912698 3005
0 82 6173 0 1412881037 914578 4304
0 83 skipped 0 1412881037 914578 5217
0 83 skipped 0 1412881037 914578 5099
0 83 4722 0 1412881037 916203 3108
0 84 4142 0 1412881037 918023 2333
0 85 2465 0 1412881037 919759 740</PRE
><P>
この例では、トランザクション82は遅延(6.173ミリ秒)が5ミリ秒を越えており、遅れています。
次の2つのトランザクションは、開始する前にすでに遅れてしまっているため、スキップされています。
  </P
><P
>大量のトランザクションを処理することができるハードウェアで長時間試験を実行する場合、ログファイルは非常に大きくなる可能性があります。
<TT
CLASS="OPTION"
>--sampling-rate</TT
>オプションを使用して、トランザクションのランダムなサンプルだけをログに記録することができます。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN95498"
></A
><H3
>ログ処理の集約</H3
><P
><TT
CLASS="OPTION"
>--aggregate-interval</TT
>オプションを付ける場合、以下のようにログの書式が多少異なります。

</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>interval_start</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>num_of_transactions</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>latency_sum</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>latency_2_sum</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>min_latency</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>max_latency</I
></TT
> [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>lag_sum</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>lag_2_sum</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>min_lag</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>max_lag</I
></TT
> [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>skipped_transactions</I
></TT
></SPAN
>]</SPAN
>]</PRE
><P>

ここで、<TT
CLASS="REPLACEABLE"
><I
>interval_start</I
></TT
>はインターバルの開始時刻（Unixエポック書式のタイムスタンプ）、
<TT
CLASS="REPLACEABLE"
><I
>num_of_transactions</I
></TT
>はインターバル内のトランザクション数、
<TT
CLASS="REPLACEABLE"
><I
>latency_sum</I
></TT
>はレイテンシの総和です（これらを使って簡単に平均レイテンシを計算できます）。
以下２つのフィールドは分散推定の際に有用です。
<TT
CLASS="REPLACEABLE"
><I
>latency_sum</I
></TT
>はレイテンシの総和であり、<TT
CLASS="REPLACEABLE"
><I
>latency_2_sum</I
></TT
>はレイテンシの二乗の総和です。
次の２つのフィールドは、インターバル内の最小レイテンシである<TT
CLASS="REPLACEABLE"
><I
>min_latency</I
></TT
>と、インターバル内の最大レイテンシである<TT
CLASS="REPLACEABLE"
><I
>max_latency</I
></TT
>です。
インターバル内でコミットされた時点でトランザクションとしてカウントされます。
最後の方のフィールド<TT
CLASS="REPLACEABLE"
><I
>lag_sum</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>lag_2_sum</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>min_lag</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>max_lag</I
></TT
>は<TT
CLASS="OPTION"
>--rate</TT
>オプションが使われた時だけ表示されます。
最後の<TT
CLASS="REPLACEABLE"
><I
>skipped_transactions</I
></TT
>もやはり<TT
CLASS="OPTION"
>--latency-limit</TT
>が指定された時だけ表示されます。
これらは、各トランザクションが前のトランザクション終了を待つ時間、つまり各トランザクションの予定開始時刻と実開始時刻の差から算出されます。
  </P
><P
>以下に出力例を示します。
</P><PRE
CLASS="SCREEN"
>1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411</PRE
><P></P
><P
>通常の（集約されていない）ログファイルには、カスタムスクリプトファイルへの参照が含まれますが、集約されたログには含まれません。
このためスクリプト単位のデータが必要な場合は、自身でデータを集約しなければなりません。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN95533"
></A
><H3
>ステートメント毎のレイテンシ</H3
><P
><TT
CLASS="OPTION"
>-r</TT
>オプションを付けると、<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>は各クライアントにより実行されたトランザクションのステートメント毎の経過時間を収集します。
ベンチマークが終了した後、各値の平均値(各ステートメントのレイテンシと呼びます)が報告されます。
  </P
><P
>標準スクリプトでは、次のような出力になります。
</P><PRE
CLASS="SCREEN"
>starting vacuum...end.
transaction type: &lt;builtin: TPC-B (sort of)&gt;
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
latency average = 15.844 ms
latency stddev = 2.715 ms
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
script statistics:
 - statement latencies in milliseconds:
        0.002  \set aid random(1, 100000 * :scale)
        0.005  \set bid random(1, 1 * :scale)
        0.002  \set tid random(1, 10 * :scale)
        0.001  \set delta random(-5000, 5000)
        0.326  BEGIN;
        0.603  UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454  SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528  UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335  UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371  INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212  END;</PRE
><P>
  </P
><P
>複数のスクリプトファイルが定義された場合、平均値はそれぞれのスクリプトファイル毎に分けて報告されます。
  </P
><P
>ステートメント毎のレイテンシを計算するために必要となる、追加のタイミング情報を収集することは、オーバーヘッドが加わることに注意してください。
これは平均実行速度を遅くし、計測TPSを小さくするでしょう。
低下量はプラットフォームとハードウェアに依存して著しく変わります。
レイテンシの報告を有効にする、有効にしないで平均TPS値を比較することは、タイミング・オーバーヘッドが顕著かどうかを測定するには良い方法です。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN95542"
></A
><H3
>優れた実践</H3
><P
>まったく無意味な数値を生み出すように<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>を使用することは非常に簡単です。
以下に有意な結果を生み出す手助けとなるガイドラインをいくつか示します。
  </P
><P
>まず第一に、数秒で終わる試験を<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>決して</I
></SPAN
>信用しないでください。
<TT
CLASS="OPTION"
>-t</TT
>または<TT
CLASS="OPTION"
>-T</TT
>オプションを使って、雑音を取り除くために、少なくとも数分試験にかかるようにしてください。
再現可能な数値を得るために数時間必要になる場合もあります。
数回試験を繰り返し、数値が再現できるかどうか確認することを勧めます。
  </P
><P
>デフォルトのTPC-Bのような試験シナリオでは、初期倍率（<TT
CLASS="OPTION"
>-s</TT
>）を試験予定のクライアント数（<TT
CLASS="OPTION"
>-c</TT
>）の最大値と同程度にしなければなりません。
<TT
CLASS="STRUCTNAME"
>pgbench_branches</TT
>テーブルには<TT
CLASS="OPTION"
>-s</TT
>行しかありません。
また、前トランザクションはその内の1つを更新しようとします。
ですので、<TT
CLASS="OPTION"
>-c</TT
>値を<TT
CLASS="OPTION"
>-s</TT
>より大きくすると、他のトランザクションを待機するためにブロックされるトランザクションが多くなることは間違いありません。
  </P
><P
>デフォルトの試験シナリオはまた、テーブルを初期化してからの経過時間に非常に敏感です。
テーブル内の不要行や不要空間の累積により結果が変わります。
結果を理解するためには、更新された行数とバキューム時期を把握する必要があります。
自動バキュームが有効な場合、性能を測定する上で結果は予測できないほど変わる可能性があります。
  </P
><P
><SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>の制限は、多くのクライアントセッションを試験しようとする際に<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>自身がボトルネックになる可能性があることです。
これは、データベースサーバとは別のマシンで<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>を実行することで緩和させることが可能です。
しかし、多少のネットワーク遅延が重要です。
同一データベースサーバに対し複数のクライアントマシンから複数の<SPAN
CLASS="APPLICATION"
>pgbench</SPAN
>インスタンスを同時に実行することが有用かもしれません。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="app-pgbasebackup.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="app-pgconfig.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>pg_basebackup</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="reference-client.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>pg_config</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
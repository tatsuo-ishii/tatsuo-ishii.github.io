<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>クライアントインタフェース</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="ラージオブジェクト"
HREF="largeobjects.html"><LINK
REL="PREVIOUS"
TITLE="実装機能"
HREF="lo-implementation.html"><LINK
REL="NEXT"
TITLE="サーバ側の関数"
HREF="lo-funcs.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="実装機能"
HREF="lo-implementation.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="largeobjects.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 33章ラージオブジェクト</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="サーバ側の関数"
HREF="lo-funcs.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LO-INTERFACES"
>33.3. クライアントインタフェース</A
></H1
><P
>本節では、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>クライアントインタフェースライブラリで提供されるラージオブジェクトへのアクセス手段について説明します。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ラージオブジェクトインタフェースは、<ACRONYM
CLASS="ACRONYM"
>Unix</ACRONYM
>ファイルシステムインタフェースに因んで設計されており、<CODE
CLASS="FUNCTION"
>open</CODE
>、<CODE
CLASS="FUNCTION"
>read</CODE
>、<CODE
CLASS="FUNCTION"
>write</CODE
>、<CODE
CLASS="FUNCTION"
>lseek</CODE
>など同様のインタフェースを有しています。
   </P
><P
>ラージオブジェクトファイル記述子はトランザクションの間でしか有効でありませんので、これらの関数を使用したラージオブジェクトの操作はすべてSQLトランザクションブロック内で行われ<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>なければなりません</I
></SPAN
>。
   </P
><P
>これらの関数のいずれか１つの実行時にエラーが発生した場合、関数は他ではあり得ない値、通常は0または-1を返します。
エラーを説明するメッセージは接続オブジェクト内に格納され、<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>を用いて取り出すことができます。
   </P
><P
>これらの関数を使用するクライアントアプリケーションは、<TT
CLASS="FILENAME"
>libpq/libpq-fs.h</TT
>ヘッダファイルをインクルードし、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>ライブラリとリンクしなければなりません。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-CREATE"
>33.3.1. ラージオブジェクトの作成</A
></H2
><P
>     
</P><PRE
CLASS="SYNOPSIS"
>Oid lo_creat(PGconn *conn, int mode);</PRE
><P>
この関数はラージオブジェクトを新規に作成します。
戻り値は新規ラージオブジェクトに割り当てられたOIDで、失敗時には<TT
CLASS="SYMBOL"
>InvalidOid</TT
>（0）が返されます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.1では、<TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
>は使用されず、無視されます。
しかし、以前のリリースとの後方互換性を保持するために、これを<TT
CLASS="SYMBOL"
>INV_READ</TT
>、<TT
CLASS="SYMBOL"
>INV_WRITE</TT
>、<TT
CLASS="SYMBOL"
>INV_READ</TT
> <TT
CLASS="LITERAL"
>|</TT
> <TT
CLASS="SYMBOL"
>INV_WRITE</TT
>に設定することが最善です。
（これらの定数シンボルは<TT
CLASS="FILENAME"
>libpq/libpq-fs.h</TT
>ヘッダファイルで定義されています。）
    </P
><P
>以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>inv_oid = lo_creat(conn, INV_READ|INV_WRITE);</PRE
><P>
    </P
><P
>     
</P><PRE
CLASS="SYNOPSIS"
>Oid lo_create(PGconn *conn, Oid lobjId);</PRE
><P>
この関数もラージオブジェクトを新規に作成します。
割り当てられるOIDを<TT
CLASS="REPLACEABLE"
><I
>lobjId</I
></TT
>で指定することができます。
こうした場合、そのOIDが他のラージオブジェクトですでに使用されていた場合、失敗します。
<TT
CLASS="REPLACEABLE"
><I
>lobjId</I
></TT
>が<TT
CLASS="SYMBOL"
>InvalidOid</TT
>（0）の場合、<CODE
CLASS="FUNCTION"
>lo_create</CODE
>は未使用のOIDを割り当てます。
（これは<CODE
CLASS="FUNCTION"
>lo_creat</CODE
>と同じ動作です。）
戻り値は新規ラージオブジェクトに割り当てられたOIDで、失敗時には<TT
CLASS="SYMBOL"
>InvalidOid</TT
>（0）が返されます。
    </P
><P
><CODE
CLASS="FUNCTION"
>lo_create</CODE
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.1から導入されました。
この関数を古いバージョンで実行させると失敗し、<TT
CLASS="SYMBOL"
>InvalidOid</TT
>が返されます。
    </P
><P
>例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>inv_oid = lo_create(conn, desired_oid);</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-IMPORT"
>33.3.2. ラージオブジェクトのインポート</A
></H2
><P
>     
オペレーティングシステム上のファイルをラージオブジェクトとしてインポートするには、以下の関数を呼び出します。
</P><PRE
CLASS="SYNOPSIS"
>Oid lo_import(PGconn *conn, const char *filename);</PRE
><P>
<TT
CLASS="REPLACEABLE"
><I
>filename</I
></TT
>には、ラージオブジェクトとしてインポートするオペレーティングシステム上のファイルのパス名を指定します。
戻り値は、新規ラージオブジェクトに割り当てられたOIDです。
失敗時は<TT
CLASS="SYMBOL"
>InvalidOid</TT
>（0）が返されます。
このファイルがサーバではなく、クライアントインタフェースライブラリから読み取られることに注意してください。
ですから、このファイルはクライアントのファイルシステム上に存在し、クライアントアプリケーションから読み取り可能でなければなりません。
    </P
><P
>     
</P><PRE
CLASS="SYNOPSIS"
>Oid lo_import_with_oid(PGconn *conn, const char *filename, Oid lobjId);</PRE
><P>
この関数も新規のラージオブジェクトをインポートします。
割り当てられるOIDを<TT
CLASS="REPLACEABLE"
><I
>lobjId</I
></TT
>で指定することができます。
こうした場合、そのOIDが他のラージオブジェクトですでに使用されていた場合、失敗します。
<TT
CLASS="REPLACEABLE"
><I
>lobjId</I
></TT
>が<TT
CLASS="SYMBOL"
>InvalidOid</TT
>（0）の場合、<CODE
CLASS="FUNCTION"
>lo_import_with_oid</CODE
>は未使用のOIDを割り当てます（これは<CODE
CLASS="FUNCTION"
>lo_import</CODE
>と同じ動作です）。
戻り値は新規ラージオブジェクトに割り当てられたOIDで、失敗時には<TT
CLASS="SYMBOL"
>InvalidOid</TT
>（0）が返されます。
    </P
><P
><CODE
CLASS="FUNCTION"
>lo_import_with_oid</CODE
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.4から導入され、8.1から導入された<CODE
CLASS="FUNCTION"
>lo_create</CODE
>を内部で使用しています。
この関数を8.0以前のバージョンで実行させると失敗し、<TT
CLASS="SYMBOL"
>InvalidOid</TT
>が返されます。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-EXPORT"
>33.3.3. ラージオブジェクトのエクスポート</A
></H2
><P
>     
ラージオブジェクトをオペレーティングシステム上のファイルにエクスポートするには、以下の関数を呼び出します。
</P><PRE
CLASS="SYNOPSIS"
>int lo_export(PGconn *conn, Oid lobjId, const char *filename);</PRE
><P>
<TT
CLASS="PARAMETER"
>lobjId</TT
>引数には、エクスポートさせるラージオブジェクトのOIDを指定し、<TT
CLASS="PARAMETER"
>filename</TT
>引数には、オペレーティングシステム上のファイルのパス名を指定します。
このファイルはサーバではなく、クライアントインタフェースライブラリによって書き込まれることに注意してください。
成功時には1、失敗時には-1が返されます。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-OPEN"
>33.3.4. 既存のラージオブジェクトのオープン</A
></H2
><P
>     
読み取りまたは書き込みのために既存のラージオブジェクトを開く場合は、以下の関数を呼び出します。
</P><PRE
CLASS="SYNOPSIS"
>int lo_open(PGconn *conn, Oid lobjId, int mode);</PRE
><P>
<TT
CLASS="PARAMETER"
>lobjId</TT
>引数には開きたいラージオブジェクトのOIDを指定します。
<TT
CLASS="PARAMETER"
>mode</TT
>の各ビットは、そのオブジェクトを読み取りのみ（<TT
CLASS="SYMBOL"
>INV_READ</TT
>）、書き込みのみ（<TT
CLASS="SYMBOL"
>INV_WRITE</TT
>）、またはその両方できるように開くのかを制御するものです。
（これらの定数シンボルは<TT
CLASS="FILENAME"
>libpq/libpq-fs.h</TT
>ヘッダファイルで定義されています。）
<CODE
CLASS="FUNCTION"
>lo_open</CODE
>は、<CODE
CLASS="FUNCTION"
>lo_read</CODE
>、<CODE
CLASS="FUNCTION"
>lo_write</CODE
>、<CODE
CLASS="FUNCTION"
>lo_lseek</CODE
>、<CODE
CLASS="FUNCTION"
>lo_lseek64</CODE
>、<CODE
CLASS="FUNCTION"
>lo_tell</CODE
>、<CODE
CLASS="FUNCTION"
>lo_tell64</CODE
>、<CODE
CLASS="FUNCTION"
>lo_truncate</CODE
>、<CODE
CLASS="FUNCTION"
>lo_truncate64</CODE
>、<CODE
CLASS="FUNCTION"
>lo_close</CODE
>で使用する（非負の）ラージオブジェクト記述子を返します。
この記述子は現在のトランザクション期間のみで有効です。
失敗時には-1が返されます。
    </P
><P
>現時点では、サーバは<TT
CLASS="SYMBOL"
>INV_WRITE</TT
>モードと<TT
CLASS="SYMBOL"
>INV_READ</TT
> <TT
CLASS="LITERAL"
>|</TT
> <TT
CLASS="SYMBOL"
>INV_WRITE</TT
>モードとを区別しません。
どちらの場合でも記述子から読み取り可能です。
しかし、これらのモードと<TT
CLASS="SYMBOL"
>INV_READ</TT
>だけのモードとの間には大きな違いがあります。
<TT
CLASS="SYMBOL"
>INV_READ</TT
>モードでは記述子に書き込むことができません。
そして、読み込んだデータは、このトランザクションや他のトランザクションで後で書き込んだかどうかは関係なく、<CODE
CLASS="FUNCTION"
>lo_open</CODE
>を実行した時に有効だったトランザクションスナップショットの時点のラージオブジェクトの内容を反映したものになります。
<TT
CLASS="SYMBOL"
>INV_WRITE</TT
>を付けて開いた記述子から読み取ると、現在のトランザクションによる書き込みや他のトランザクションがコミットした書き込みすべてを反映したデータが返されます。
これは、通常の<TT
CLASS="COMMAND"
>SELECT</TT
> SQLコマンドにおける<TT
CLASS="LITERAL"
>REPEATABLE READ</TT
>トランザクションの動作と<TT
CLASS="LITERAL"
>READ COMMITTED</TT
>トランザクションの動作の違いに似ています。
    </P
><P
>以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>inv_fd = lo_open(conn, inv_oid, INV_READ|INV_WRITE);</PRE
><P>
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-WRITE"
>33.3.5. ラージオブジェクトへのデータの書き込み</A
></H2
><P
>     
</P><PRE
CLASS="SYNOPSIS"
>int lo_write(PGconn *conn, int fd, const char *buf, size_t len);</PRE
><P>
<TT
CLASS="PARAMETER"
>len</TT
>バイトを、<TT
CLASS="PARAMETER"
>buf</TT
>（<TT
CLASS="PARAMETER"
>len</TT
>サイズでなければなりません）から<TT
CLASS="PARAMETER"
>fd</TT
>ラージオブジェクト記述子に書き込みます。
<TT
CLASS="PARAMETER"
>fd</TT
>引数は事前に実行した<CODE
CLASS="FUNCTION"
>lo_open</CODE
>の戻り値でなければいけません。
実際に書き込まれたバイト数が返されます（現在の実装ではエラーが発生しない限り<TT
CLASS="PARAMETER"
>len</TT
>と常に等しくなります）。
エラーイベントが発生した場合は、-1を返します。</P
><P
><TT
CLASS="PARAMETER"
>len</TT
>パラメータは<TT
CLASS="TYPE"
>size_t</TT
>として宣言されていますが、この関数は<TT
CLASS="LITERAL"
>INT_MAX</TT
>より大きな値を拒絶します。
実際には、多くても数メガバイトのチャンクでデータを転送することが最善です。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-READ"
>33.3.6. ラージオブジェクトからのデータの読み込み</A
></H2
><P
>     
</P><PRE
CLASS="SYNOPSIS"
>int lo_read(PGconn *conn, int fd, char *buf, size_t len);</PRE
><P>
<TT
CLASS="PARAMETER"
>len</TT
>長のバイトを、<TT
CLASS="PARAMETER"
>fd</TT
>ラージオブジェクト記述子から<TT
CLASS="PARAMETER"
>buf</TT
>（<TT
CLASS="PARAMETER"
>len</TT
>サイズでなければなりません）に読み込みます。
<TT
CLASS="PARAMETER"
>fd</TT
>引数は事前に実行した<CODE
CLASS="FUNCTION"
>lo_open</CODE
>の戻り値でなければいけません。
実際に読み込まれたバイト数が返されます。
ラージオブジェクトの最後に先に達した場合は<TT
CLASS="PARAMETER"
>len</TT
>より小さな値になります。
エラーイベントが発生した場合は、-1値を返します。</P
><P
><TT
CLASS="PARAMETER"
>len</TT
>パラメータは<TT
CLASS="TYPE"
>size_t</TT
>として宣言されていますが、この関数は<TT
CLASS="LITERAL"
>INT_MAX</TT
>より大きな値を拒絶します。
実際には、多くても数メガバイトをチャンク内にデータを転送することが最善です。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-SEEK"
>33.3.7. ラージオブジェクトのシーク</A
></H2
><P
>     
ラージオブジェクト記述子に関連付けされている、現在の読み取りまたは書き込みを行う位置を変更するには、以下の関数を呼び出します。
</P><PRE
CLASS="SYNOPSIS"
>int lo_lseek(PGconn *conn, int fd, int offset, int whence);</PRE
><P>
この関数は<TT
CLASS="PARAMETER"
>fd</TT
>で識別されるラージオブジェクト識別子の現在の位置を指すポインタを、<TT
CLASS="PARAMETER"
>offset</TT
>で指定した新しい位置に変更します。
<TT
CLASS="PARAMETER"
>whence</TT
>に指定可能な値は、<TT
CLASS="SYMBOL"
>SEEK_SET</TT
>（オブジェクトの先頭位置からシーク）、<TT
CLASS="SYMBOL"
>SEEK_CUR</TT
>（現在位置からシーク）、<TT
CLASS="SYMBOL"
>SEEK_END</TT
>（オブジェクトの末尾位置からシーク）のいずれかです。
戻り値は新しい位置ポインタで、エラー時に-1が返されます。</P
><P
>     
2GBを超えるサイズのラージオブジェクトを取り扱う場合は代わりに以下を使用してください。
</P><PRE
CLASS="SYNOPSIS"
>pg_int64 lo_lseek64(PGconn *conn, int fd, pg_int64 offset, int whence);</PRE
><P>
この関数は<CODE
CLASS="FUNCTION"
>lo_lseek</CODE
>と同じ動作をしますが、<TT
CLASS="PARAMETER"
>offset</TT
>として2GBを超える値を受付け、2GBより大きな結果を出力します。
<CODE
CLASS="FUNCTION"
>lo_lseek</CODE
>は2GBを超える新しい位置ポインタが指定された場合に失敗することに注意してください。</P
><P
><CODE
CLASS="FUNCTION"
>lo_lseek64</CODE
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.3にて追加されました。
この関数をより古いバージョンのサーバに対して実行した場合には失敗し、-1が返ります。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-TELL"
>33.3.8. ラージオブジェクトのシーク位置の入手</A
></H2
><P
>     
ラージオブジェクト記述子の現在の読み取り、書き込み位置を入手するには、以下の関数を呼び出します。
</P><PRE
CLASS="SYNOPSIS"
>int lo_tell(PGconn *conn, int fd);</PRE
><P>
エラーが発生した場合は-1が返されます。</P
><P
>     
サイズが2GBを超える可能性があるラージオブジェクトを取り扱う場合は代わりに以下を使用します。
</P><PRE
CLASS="SYNOPSIS"
>pg_int64 lo_tell64(PGconn *conn, int fd);</PRE
><P>
この関数は<CODE
CLASS="FUNCTION"
>lo_tell</CODE
>と同じ動作をしますが、2GBより大きな結果を出力します。
<CODE
CLASS="FUNCTION"
>lo_tell</CODE
>は2GBを超える新しい位置での読み書きに失敗します。</P
><P
><CODE
CLASS="FUNCTION"
>lo_tell64</CODE
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.3にて追加されました。
この関数をより古いバージョンのサーバに対して実行した場合には失敗し、-1が返ります。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-TRUNCATE"
>33.3.9. ラージオブジェクトを切り詰める</A
></H2
><P
>     
ラージオブジェクトを指定した長さに切り詰めるには、以下を呼び出します。
</P><PRE
CLASS="SYNOPSIS"
>int lo_truncate(PGcon *conn, int fd, size_t len);</PRE
><P>
この関数はラージオブジェクト記述子<TT
CLASS="PARAMETER"
>fd</TT
>を<TT
CLASS="PARAMETER"
>len</TT
>長に切り詰めます。
<TT
CLASS="PARAMETER"
>fd</TT
>引数は前もって<CODE
CLASS="FUNCTION"
>lo_open</CODE
>が返したものでなければなりません。
<TT
CLASS="PARAMETER"
>len</TT
>が現在のラージオブジェクト長より大きければ、ラージオブジェクトは指定された長さまでヌルバイト('\0')で拡張されます。
成功時<CODE
CLASS="FUNCTION"
>lo_truncate</CODE
>はゼロを返します。
失敗時の戻り値は-1です。</P
><P
><TT
CLASS="PARAMETER"
>fd</TT
>ディスクリプタの読み取り/書き出し位置は変わりません。</P
><P
><TT
CLASS="PARAMETER"
>len</TT
>パラメータは<TT
CLASS="TYPE"
>size_t</TT
>として宣言されていますが、<CODE
CLASS="FUNCTION"
>lo_truncate</CODE
>は<TT
CLASS="LITERAL"
>INT_MAX</TT
>より大きな値を拒絶します。</P
><P
>     
2GBを超える可能性があるラージオブジェクトを取り扱う場合は代わりに以下を使用します。
</P><PRE
CLASS="SYNOPSIS"
>int lo_truncate64(PGcon *conn, int fd, pg_int64 len);</PRE
><P>
この関数は<CODE
CLASS="FUNCTION"
>lo_truncate</CODE
>と同じ動作をしますが、2GBを超える<TT
CLASS="PARAMETER"
>len</TT
>を受け付けることができます。</P
><P
><CODE
CLASS="FUNCTION"
>lo_truncate</CODE
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.3で新規に導入されました。
この関数を古いバージョンのサーバに対して実行した場合は失敗し、-1が返されます。</P
><P
><CODE
CLASS="FUNCTION"
>lo_truncate64</CODE
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.3にて追加されました。
この関数をより古いバージョンのサーバに対して実行した場合には失敗し、-1が返ります。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-CLOSE"
>33.3.10. ラージオブジェクト記述子を閉じる</A
></H2
><P
>     
以下を呼び出すことでラージオブジェクト記述子を閉ざすことができます。
</P><PRE
CLASS="SYNOPSIS"
>int lo_close(PGconn *conn, int fd);</PRE
><P>
ここで、<TT
CLASS="PARAMETER"
>fd</TT
>は<CODE
CLASS="FUNCTION"
>lo_open</CODE
>の戻り値であるラージオブジェクト記述子です。
成功すると、<CODE
CLASS="FUNCTION"
>lo_close</CODE
>は0を返します。
失敗すると、-1を返します。</P
><P
>開いたままのラージオブジェクト記述子は全てトランザクションの終了時に自動的に閉ざされます。</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LO-UNLINK"
>33.3.11. ラージオブジェクトの削除</A
></H2
><P
>     
データベースからラージオブジェクトを削除するには、以下の関数を呼び出します。
</P><PRE
CLASS="SYNOPSIS"
>int lo_unlink(PGconn *conn, Oid lobjId);</PRE
><P>
<TT
CLASS="PARAMETER"
>lobjId</TT
>引数は削除するラージオブジェクトのOIDを指定します。
成功時に1を、失敗時に-1を返します。
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="lo-implementation.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="lo-funcs.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>実装機能</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="largeobjects.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>サーバ側の関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>字句の構造</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLの構文"
HREF="sql-syntax.html"><LINK
REL="PREVIOUS"
TITLE="SQLの構文"
HREF="sql-syntax.html"><LINK
REL="NEXT"
TITLE="評価式"
HREF="sql-expressions.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="SQLの構文"
HREF="sql-syntax.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 4章SQLの構文</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="評価式"
HREF="sql-expressions.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SQL-SYNTAX-LEXICAL"
>4.1. 字句の構造</A
></H1
><P
>SQLの入力は、ひと続きの<I
CLASS="FIRSTTERM"
>コマンド</I
>からなります。
コマンドは<I
CLASS="FIRSTTERM"
>トークン</I
>が繋がったもので構成され、最後はセミコロン（<SPAN
CLASS="QUOTE"
>";"</SPAN
>）で終わります。
入力ストリームの終了もやはりコマンドを終わらせます。
どのトークンが有効かは特定のコマンドの構文によります。
  </P
><P
>トークンは<I
CLASS="FIRSTTERM"
>キーワード</I
>、<I
CLASS="FIRSTTERM"
>識別子</I
>、<I
CLASS="FIRSTTERM"
>引用符で囲まれた識別子</I
>、<I
CLASS="FIRSTTERM"
>リテラル</I
>（もしくは定数）、特別な文字シンボルです。
トークンは通常空白（スペース、タブ、改行）で区切られますが、曖昧さがなければ（一般的には特別な文字が他のトークン型と隣接している場合のみ）必要ありません。
  </P
><P
>例えば、以下のものは（構文的に）正しいSQLの入力です。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM MY_TABLE;
UPDATE MY_TABLE SET A = 5;
INSERT INTO MY_TABLE VALUES (3, 'hi there');</PRE
><P>
この例は1行に1つのコマンドを記述した、3つのコマンドが連続しています（必ずしも1つのコマンドを1行で書く必要はありません。 1行に複数のコマンドを入力することも可能ですし、1つのコマンドを複数行に分けて記述することも可能です）。
   </P
><P
>さらに、入力されたSQLに<I
CLASS="FIRSTTERM"
>コメント</I
>が付いていても構いません。
コメントはトークンではなく、その効果は空白と同じです。
  </P
><P
>SQL構文は、どのトークンがコマンドを識別し、どれがオペランドでどれがパラメータかに関してはさほど首尾一貫していません。
最初のいくつかのトークンは一般にコマンド名です。
したがって、上記の例において<SPAN
CLASS="QUOTE"
>"SELECT"</SPAN
>、<SPAN
CLASS="QUOTE"
>"UPDATE"</SPAN
>、<SPAN
CLASS="QUOTE"
>"INSERT"</SPAN
>コマンドについて通常説明することになります。
しかし、例えば<TT
CLASS="COMMAND"
>UPDATE</TT
>コマンドでは、<TT
CLASS="TOKEN"
>SET</TT
>トークンが特定の位置に常に記述されなければなりませんし、この例で使われている<TT
CLASS="COMMAND"
>INSERT</TT
>コマンドを完結するためには<TT
CLASS="TOKEN"
>VALUES</TT
>トークンが必要です。
それぞれのコマンドの正確な構文規則は<A
HREF="reference.html"
>パートVI</A
>で説明されています。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-IDENTIFIERS"
>4.1.1. 識別子とキーワード</A
></H2
><P
>上記の例に出てくる<TT
CLASS="TOKEN"
>SELECT</TT
>、<TT
CLASS="TOKEN"
>UPDATE</TT
>、もしくは<TT
CLASS="TOKEN"
>VALUES</TT
>のようなトークンは、<I
CLASS="FIRSTTERM"
>キーワード</I
>の一例です。
キーワードとは、SQL言語で決まった意味を持っている単語です。
<TT
CLASS="TOKEN"
>MY_TABLE</TT
>トークンや<TT
CLASS="TOKEN"
>A</TT
>トークンは<I
CLASS="FIRSTTERM"
>識別子</I
>の一例です。
これらは、使われるコマンドによって、テーブル、列、他のデータベースオブジェクトの名前を識別します。
したがって、単に<SPAN
CLASS="QUOTE"
>"名前"</SPAN
>と呼ばれることもあります。
キーワードと識別子は同じ字句の構造を持つため、言語を知らなくてはトークンが識別子なのかキーワードなのかわからないということになります。
全てのキーワードのリストは<A
HREF="sql-keywords-appendix.html"
>付録C</A
>にあります。
   </P
><P
>SQL識別子とキーワードは、文字（<TT
CLASS="LITERAL"
>a</TT
>〜<TT
CLASS="LITERAL"
>z</TT
>および発音区別符号付き文字と非Latin文字)、アンダースコア（<TT
CLASS="LITERAL"
>_</TT
>）で始まらなければいけません。
識別子またはキーワードの中で続く文字は、文字、アンダースコア、数字（<TT
CLASS="LITERAL"
>0</TT
>〜<TT
CLASS="LITERAL"
>9</TT
>）あるいはドル記号(<TT
CLASS="LITERAL"
>$</TT
>)を使用することができます。
標準SQLの記述に従うと、ドル記号は識別子内では使用できないことに注意してください。
ですから、これを使用するとアプリケーションの移植性は低くなる可能性があります。
標準SQLでは、数字を含む、あるいはアンダースコアで始まったり終わったりするキーワードは定義されていません。
したがって、この形式の識別子は標準の今後の拡張と競合する可能性がないという意味で安全と言えます。
   </P
><P
>    
システムは<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>-1バイトより長い識別子を使いません。
より長い名前をコマンドで書くことはできますが、短く切られてしまいます。
デフォルトでは<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>は64なので、識別子は最長で63バイトです。
この制限が問題になる場合は、<TT
CLASS="FILENAME"
>src/include/pg_config_manual.h</TT
>内の<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>定数の値を変更して増やすことができます。
   </P
><P
>    
キーワードと引用符付きでない識別子は大文字と小文字を区別しません。
したがって、
</P><PRE
CLASS="PROGRAMLISTING"
>UPDATE MY_TABLE SET A = 5;</PRE
><P>
は、以下の文と同じ意味になります。
</P><PRE
CLASS="PROGRAMLISTING"
>uPDaTE my_TabLE SeT a = 5;</PRE
><P>
慣習的によく使われる方法では、キーワードを大文字で、名前を小文字で書きます。
例えば下記のようになります。
</P><PRE
CLASS="PROGRAMLISTING"
>UPDATE my_table SET a = 5;</PRE
><P>
   </P
><P
>    
識別子には副次的な種類もあります。
<I
CLASS="FIRSTTERM"
>区切り識別子</I
>あるいは<I
CLASS="FIRSTTERM"
>引用符付き識別子</I
>です。
任意の文字の連なりを二重引用符（<TT
CLASS="LITERAL"
>"</TT
>）で囲んだものです。
区切り識別子は常に識別子であって、キーワードではありません。
ですから、<TT
CLASS="LITERAL"
>"select"</TT
>は<SPAN
CLASS="QUOTE"
>"select"</SPAN
>という名前の列あるいはテーブルを問い合わせるために使えますが、引用符の付かない<TT
CLASS="LITERAL"
>select</TT
>はキーワードとして理解されるので、テーブルもしくは列名が期待される部分では解析エラーを起こします。
引用符付き識別子は下記の例のように書くことができます。
</P><PRE
CLASS="PROGRAMLISTING"
>UPDATE "my_table" SET "a" = 5;</PRE
><P>
   </P
><P
>引用符付き識別子は、コード0の文字以外であればどのような文字でも使えます
（二重引用符を含めたい場合は、二重引用符を2つ入力します）。
これにより、空白やアンパサンド（&amp;）を含むテーブル名や列名など、この方法がなければ作れないような名前のものを作ることが可能になります。
この場合においても長さの制限は適用されます。
   </P
><P
>引用符付き識別子には異形があり、コード番号で識別されるエスケープされたUnicode文字を含むことができます。
この異形は、<TT
CLASS="LITERAL"
>U&amp;</TT
>（大文字または小文字のUの後にアンパサンド）で始まり、その直後に空白を間に入れずに二重引用符を続けます。
例えば、<TT
CLASS="LITERAL"
>U&amp;"foo"</TT
>となります。
（これにより演算子<TT
CLASS="LITERAL"
>&amp;</TT
>との不明確性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く４桁１６進数の文字コード番号で、またはもう１つの方法として、バックスラッシュに続いてプラス符号、そして続いた６桁１６進数の文字コード番号によりエスケープ形式で指定されます。
例えば、識別子<TT
CLASS="LITERAL"
>"data"</TT
>は次のように書くことができます。
</P><PRE
CLASS="PROGRAMLISTING"
>U&amp;"d\0061t\+000061"</PRE
><P>
次の少し意味のある例はロシア語の<SPAN
CLASS="QUOTE"
>"slon"</SPAN
>（象）をキリル文字で書いたものです。
</P><PRE
CLASS="PROGRAMLISTING"
>U&amp;"\0441\043B\043E\043D"</PRE
><P>
   </P
><P
>バックスラッシュ以外のエスケープ文字を使用したい場合、文字列の後に<TT
CLASS="LITERAL"
>UESCAPE</TT
>句を使用して指定することが可能です。例をあげます。
</P><PRE
CLASS="PROGRAMLISTING"
>U&amp;"d!0061t!+000061" UESCAPE '!'</PRE
><P>
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用することができます。
エスケープ文字には二重引用符ではなく単一引用符で記述していることに注意してください。
   </P
><P
>識別子内にエスケープ文字をそのまま含めるためには、それを２つ記述してください。
   </P
><P
>Unicodeエスケープ構文はサーバの符号化方式が<TT
CLASS="LITERAL"
>UTF8</TT
>の場合のみ有効です。
他のサーバ符号化方式が用いられている場合、ASCII範囲（<TT
CLASS="LITERAL"
>\007F</TT
>まで）のコードポイントのみ指定できます。
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と6桁の形式の両方を使用することができますが、技術的には6桁形式の機能によりこれは不要になります。
（サロゲートペアは直接格納されるわけではなく、一つのコードポイントに結合されてから、UTF-8に符号化されます。）
   </P
><P
>引用符が付かない名前は常に小文字に解釈されますが、識別子を引用符で囲むことによって大文字と小文字が区別されるようになります。
例えば、識別子<TT
CLASS="LITERAL"
>FOO</TT
>、<TT
CLASS="LITERAL"
>foo</TT
>、<TT
CLASS="LITERAL"
>"foo"</TT
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>によれば同じものとして解釈されますが、<TT
CLASS="LITERAL"
>"Foo"</TT
>と<TT
CLASS="LITERAL"
>"FOO"</TT
>は、これら3つとも、またお互いに違ったものとして解釈されます
（<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が引用符の付かない名前を小文字として解釈することは標準SQLと互換性がありません。標準SQLでは引用符の付かない名前は大文字に解釈されるべきだとされています。
したがって標準SQLによれば、<TT
CLASS="LITERAL"
>foo</TT
>は<TT
CLASS="LITERAL"
>"FOO"</TT
>と同じであるべきで、<TT
CLASS="LITERAL"
>"foo"</TT
>とは異なるはずなのです。
もし移植可能なアプリケーションを書きたいならば、特定の名前は常に引用符で囲むか、あるいはまったく囲まないかのいずれかに統一することをお勧めします）。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-CONSTANTS"
>4.1.2. 定数</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>には、3つの<I
CLASS="FIRSTTERM"
>暗黙に型付けされる定数</I
>があります。
文字列、ビット文字列、そして数字です。
定数は明示的な型で指定することもでき、その場合はシステムによる、より正確な表現と効率の良い操作が可能になります。
こうした他の方法については後ほど説明します。
   </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-STRINGS"
>4.1.2.1. 文字列定数</A
></H3
><P
>     
     
SQLにおける文字列定数は、単一引用符（<TT
CLASS="LITERAL"
>'</TT
>）で括られた任意の文字の並びです。
例えば、<TT
CLASS="LITERAL"
>'This is a string'</TT
>です。
文字列定数内に単一引用符を含めるには、2つ続けて単一引用符を記述します。
例えば、<TT
CLASS="LITERAL"
>'Dianne''s horse'</TT
>です。
二重引用符(<TT
CLASS="LITERAL"
>"</TT
>)とは同一では<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ない</I
></SPAN
>点に注意してください。
    </P
><P
>2つの文字列定数が、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>少なくとも1つの改行</I
></SPAN
>を含んだ空白のみで区切られている場合は、2つの定数は連結され、実質的に1つの定数として書かれたように処理されます。
例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 'foo'
'bar';</PRE
><P>
は、
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 'foobar';</PRE
><P>
と同じです。しかし、
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 'foo'      'bar';</PRE
><P>
は有効な構文ではありません
（このちょっとした奇妙な振舞いは<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>で決められているもので、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ではこの標準に従っています）。
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-STRINGS-ESCAPE"
>4.1.2.2. C形式エスケープでの文字列定数</A
></H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、また、<SPAN
CLASS="QUOTE"
>"エスケープ"</SPAN
>文字列定数を受け付けます。
これは標準SQLの拡張です。
エスケープ文字列定数は、<TT
CLASS="LITERAL"
>E</TT
>(大文字でも小文字でもかまいません)を開始単一引用符の直前に記述することで指定されます。
例えば<TT
CLASS="LITERAL"
>E'foo'</TT
>です。
（複数行に渡るエスケープ文字列定数では、最初の開始引用符の前にのみ<TT
CLASS="LITERAL"
>E</TT
>を記述してください。）
エスケープ文字列の中では、バックスラッシュ文字（<TT
CLASS="LITERAL"
>\</TT
>）によりC言語のような<I
CLASS="FIRSTTERM"
>バックスラッシュ</I
>シーケンスが開始し、その中でバックスラッシュとそれに続く文字の組み合わせが（<A
HREF="sql-syntax-lexical.html#SQL-BACKSLASH-TABLE"
>表4-1</A
>で示したように）特別なバイト値を表現します。
    </P
><DIV
CLASS="TABLE"
><A
NAME="SQL-BACKSLASH-TABLE"
></A
><P
><B
>表 4-1. バックスラッシュエスケープシーケンス</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>バックスラッシュエスケープシーケンス</TH
><TH
>解釈</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>\b</TT
></TD
><TD
>後退</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\f</TT
></TD
><TD
>改ページ</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\n</TT
></TD
><TD
>改行</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\r</TT
></TD
><TD
>復帰</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>\t</TT
></TD
><TD
>タブ</TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
>\<TT
CLASS="REPLACEABLE"
><I
>o</I
></TT
></TT
>,
         <TT
CLASS="LITERAL"
>\<TT
CLASS="REPLACEABLE"
><I
>oo</I
></TT
></TT
>,
         <TT
CLASS="LITERAL"
>\<TT
CLASS="REPLACEABLE"
><I
>ooo</I
></TT
></TT
>
         (<TT
CLASS="REPLACEABLE"
><I
>o</I
></TT
> = 0 - 7)
        </TD
><TD
>８進数バイト値</TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
>\x<TT
CLASS="REPLACEABLE"
><I
>h</I
></TT
></TT
>,
         <TT
CLASS="LITERAL"
>\x<TT
CLASS="REPLACEABLE"
><I
>hh</I
></TT
></TT
>
         (<TT
CLASS="REPLACEABLE"
><I
>h</I
></TT
> = 0 - 9, A - F)
        </TD
><TD
>１６進数バイト値</TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
>\u<TT
CLASS="REPLACEABLE"
><I
>xxxx</I
></TT
></TT
>,
         <TT
CLASS="LITERAL"
>\U<TT
CLASS="REPLACEABLE"
><I
>xxxxxxxx</I
></TT
></TT
>
         (<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
> = 0 - 9, A - F)
        </TD
><TD
>16もしくは32ビットの16進数 Unicode 文字値</TD
></TR
></TBODY
></TABLE
></DIV
><P
>バックスラッシュの後のそのほかの全ての文字はそのまま扱われます。
従って、バックスラッシュ文字を含ませるときは２つのバックスラッシュ（<TT
CLASS="LITERAL"
>\\</TT
>）を記載します。
同時に、エスケープ文字列の中では、単一引用符を、通常の方法の<TT
CLASS="LITERAL"
>''</TT
>に加え、<TT
CLASS="LITERAL"
>\'</TT
>としても含めることができます。
    </P
><P
>特に8進数や16進数エスケープを用いて作成されるバイトシーケンスが、サーバ文字セット符号化方式において有効な文字で構成されていることはコードを書く人の責任です。
サーバ符号化方式がUTF-8の場合、Unicodeエスケープか、<A
HREF="sql-syntax-lexical.html#SQL-SYNTAX-STRINGS-UESCAPE"
>項4.1.2.3</A
>で説明するもう一つのUnicodeエスケープ構文を代わりとして使用すべきです。
（後者は手作業でUTF-8符号化を行い、書き出さなくてはならないのでとても厄介です。）
    </P
><P
>Unicodeエスケープ構文は、サーバの符号化方式が<TT
CLASS="LITERAL"
>UTF8</TT
>である場合のみ、完全に動作します。
他のサーバ符号化方式が使用されている場合、ASCII範囲（<TT
CLASS="LITERAL"
>\u007F</TT
>まで）のコードポイントのみを指定することができます。
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と8桁の両方の形式を使用することができますが、技術的には8桁形式の機能によりこれは不要になります。
（サーバの符号化方式が<TT
CLASS="LITERAL"
>UTF8</TT
>の場合にサロゲートペアが使用される時、まず単一のコードポイントに組み合わされ、その後にUTF-8に符号化されます。）
    </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
BORDER="1"
WIDTH="100%"
><TR
><TD
ALIGN="CENTER"
><B
>注意</B
></TD
></TR
><TR
><TD
ALIGN="LEFT"
><P
>設定パラメータ<A
HREF="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS"
>standard_conforming_strings</A
>が <TT
CLASS="LITERAL"
>off</TT
>の場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はバックスラッシュエスケープを通常の文字列定数とエスケープ文字列定数の両方で認識します。
しかし、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>9.1からデフォルトは<TT
CLASS="LITERAL"
>on</TT
>になりました。これはバックスラッシュエスケープはエスケープ文字列でのみ認識されるということになります。
この振る舞いはSQL標準仕様に即していますが、バックスラッシュエスケープを常に認識するという歴史的な動作に依存しているアプリケーションは動作しなくなるでしょう。
回避策として、このパラメータを<TT
CLASS="LITERAL"
>off</TT
>にすることはできますが、バックスラッシュエスケープの使用を避けるよう移植するのが良いでしょう。
特殊文字を表現するためにバックスラッシュを使用する必要がある場合、<TT
CLASS="LITERAL"
>E</TT
>をつけて文字列定数を記述してください。
    </P
><P
><TT
CLASS="VARNAME"
>standard_conforming_strings</TT
>の他に、設定パラメータ<A
HREF="runtime-config-compatible.html#GUC-ESCAPE-STRING-WARNING"
>escape_string_warning</A
>および<A
HREF="runtime-config-compatible.html#GUC-BACKSLASH-QUOTE"
>backslash_quote</A
>が文字定数内のバックスラッシュの動作を決定します。
    </P
></TD
></TR
></TABLE
></DIV
><P
>コードゼロの文字は文字列定数の中に入れられません。
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-STRINGS-UESCAPE"
>4.1.2.3. Unicodeエスケープがある文字列定数</A
></H3
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は同時に、文字コード番号で任意のUnicode文字を指定可能な文字列に対するもう一つのエスケープ構文を提供します。
Unicodeエスケープ文字列定数は、<TT
CLASS="LITERAL"
>U&amp;</TT
>（大文字・小文字のUの後にアンパサンド）で始まり、その直後に、空白を間にはさまず、開始引用符が続きます。
例えば、<TT
CLASS="LITERAL"
>U&amp;'foo'</TT
>となります。
（これにより演算子<TT
CLASS="LITERAL"
>&amp;</TT
>との曖昧性が生じることに注意してください。
この問題を回避するには空白を演算子の前後に入れます。）
引用符の中で、Unicode文字はバックスラッシュとそれに続く４桁１６進数の文字コード番号で、またはもう１つの方法として、バックスラッシュに続いてプラス符号、そして続いた６桁１６進数の文字コード番号によりエスケープ形式で指定されます。
例えば、文字列<TT
CLASS="LITERAL"
>'data'</TT
>は次のように書かれます。
</P><PRE
CLASS="PROGRAMLISTING"
>U&amp;'d\0061t\+000061'</PRE
><P>
次の少し意味のある例はロシア語の<SPAN
CLASS="QUOTE"
>"slon"</SPAN
>（象）をキリル文字で書いたものです。
</P><PRE
CLASS="PROGRAMLISTING"
>U&amp;'\0441\043B\043E\043D'</PRE
><P>
    </P
><P
>バックスラッシュ以外のエスケープ文字を使用したい場合、文字列の後に<TT
CLASS="LITERAL"
>UESCAPE</TT
>句を使用して指定することが可能です。例をあげます。
</P><PRE
CLASS="PROGRAMLISTING"
>U&amp;'d!0061t!+000061' UESCAPE '!'</PRE
><P>
エスケープ文字には、16進表記用の文字、プラス記号、単一引用符、二重引用符、空白文字以外の任意の単一文字を使用することができます。
    </P
><P
>Unicodeエスケープ構文はサーバの符号化方式が<TT
CLASS="LITERAL"
>UTF8</TT
>の場合のみ有効です。
他のサーバ符号化方式が用いられている場合、ASCII範囲（<TT
CLASS="LITERAL"
>\007F</TT
>まで）のコードポイントのみ指定できます。
U+FFFFより大きなコードポイントを持つ文字を構成するUTF-16サロゲートペアを指定するために、4桁と6桁の両方の形式を使用することができますが、技術的には6桁形式の機能によりこれは不要になります。
（サーバの符号化方式が<TT
CLASS="LITERAL"
>UTF8</TT
>の場合にサロゲートペアが使用される時、まず単一のコードポイントに組み合わされ、その後にUTF-8に符号化されます。）
    </P
><P
>また、文字列定数に対するユニコードエスケープ構文は設定パラメータ<A
HREF="runtime-config-compatible.html#GUC-STANDARD-CONFORMING-STRINGS"
>standard_conforming_strings</A
>が有効なときのみ動作します。
そうでないとこの構文は、SQL文を構文解釈するクライアントを混乱させ、SQLインジェクションや、それに類似したセキュリティ問題に繋がることさえあるからです。
パラメータがoffに設定されていれば、この構文はエラーメッセージを出して拒絶されます。
    </P
><P
>文字列の中に、エスケープ文字をそのまま含めるにはエスケープ文字を２回書きます。
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-DOLLAR-QUOTING"
>4.1.2.4. ドル記号で引用符付けされた文字列定数</A
></H3
><P
>文字列定数の標準の構文はたいていの場合便利ですが、対象とする文字列内に多くの単一引用符やバックスラッシュがあると、それらを全て二重にしなければなりませんので理解しづらくなります。
こうした状況においても問い合わせの可読性をより高めるために<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、<SPAN
CLASS="QUOTE"
>"ドル引用符付け"</SPAN
>という他の文字列定数の指定方法を提供します。
ドル引用符付けされた文字列定数は、ドル記号（<TT
CLASS="LITERAL"
>$</TT
>）、省略可能な0個以上の文字からなる<SPAN
CLASS="QUOTE"
>"タグ"</SPAN
>、ドル記号、文字列定数を構成する任意の文字の並び、ドル記号、この引用符付けの始めに指定したものと同じタグ、ドル記号から構成されます。
例えば、<SPAN
CLASS="QUOTE"
>"Dianne's horse"</SPAN
>という文字列をドル引用符付けを使用して指定する方法を、以下に2つ示します。
</P><PRE
CLASS="PROGRAMLISTING"
>$$Dianne's horse$$
$SomeTag$Dianne's horse$SomeTag$</PRE
><P>
ドル引用符付けされた文字列の内側では、単一引用符をエスケープすることなく使用できることを理解して下さい。
実際には、ドル引用符付けされた文字列の内側の文字はまったくエスケープが必要なく、文字列定数はすべてそのまま記述することができます。
その並びが開始タグに一致しない限り、バックスラッシュもドル記号も特別なものではありません。
    </P
><P
>各入れ子レベルに異なるタグを付けることで、ドル引用符付けされた文字列を入れ子にすることができます。
これは、関数定義を作成する時に非常によく使用されます。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>$function$
BEGIN
    RETURN ($1 ~ $q$[\t\r\n\v\\]$q$);
END;
$function$</PRE
><P>
ここで、<TT
CLASS="LITERAL"
>$q$[\t\r\n\v\\]$q$</TT
>は、ドル引用符付けされた<TT
CLASS="LITERAL"
>[\t\r\n\v\\]</TT
>リテラル文字列を表し、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>がこの関数本体を実行する時に認識されます。
しかし、この並びは、外側のドル引用符用の区切り文字<TT
CLASS="LITERAL"
>$function$</TT
>に一致しませんので、外側の文字列を対象としている場合は単なる文字の並びとなります。
    </P
><P
>もしあれば、ドル引用符付けされた文字列のタグは、引用符付けされていない識別子と同じ規則に従います。
ただし、タグにはドル記号を含めることはできません。
タグは大文字小文字を区別します。
したがって、<TT
CLASS="LITERAL"
>$tag$String content$tag$</TT
>は正しいのですが、<TT
CLASS="LITERAL"
>$TAG$String content$tag$</TT
>は間違いです。
    </P
><P
>キーワードや識別子の後にドル引用符付けされた文字列を続ける場合は、空白でそれを区切らなければなりません。
さもないと、ドル引用符の区切り文字は、直前の識別子の一部として解釈されます。
    </P
><P
>ドル引用符付けは、標準SQLで定義されていません。
しかし、複雑な文字列リテラルを記述する場合は標準準拠の単一引用符構文よりも便利なことがよくあります。
特に、他の定数の内部に文字列定数を記述するような場合は役に立ちます。
こうした状況は手続き関数の定義でよく必要とされます。
単一引用符構文では、上の例のバックスラッシュはそれぞれ、4個のバックスラッシュで記述しなければなりません。
この4つのバックスラッシュは、元の文字列定数を解析する際に2つに減少され、そして、関数を実行する際に内部の文字列定数が再解析され1つに減少します。
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-BIT-STRINGS"
>4.1.2.5. ビット文字列定数</A
></H3
><P
>ビット文字列定数は<TT
CLASS="LITERAL"
>B</TT
>（大文字もしくは小文字）が始まりの引用符の前に付いている（間に空白はありません）通常の文字列定数のように見えます。
例えば<TT
CLASS="LITERAL"
>B'1001'</TT
>のようになります。
ビット文字列定数の中で許可される文字は<TT
CLASS="LITERAL"
>0</TT
>と<TT
CLASS="LITERAL"
>1</TT
>のみです。
    </P
><P
>その他にも、ビット文字列定数は<TT
CLASS="LITERAL"
>X'1FF'</TT
>といった具合に、先頭に<TT
CLASS="LITERAL"
>X</TT
>（大文字または小文字）を使用して16進表記で指定することもできます。
この表記は、各16進数値をそれぞれ4つの2進数値に置き換えたビット文字列定数と同等です。
    </P
><P
>どちらの形式のビット文字列定数でも、通常の文字列定数と同じように複数行にわたって続けて書くことができます。
ドル引用符付けはビット文字列定数では使用できません。
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-CONSTANTS-NUMERIC"
>4.1.2.6. 数値定数</A
></H3
><P
>数値定数は下記の一般的な形で受け付けられます。
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>
<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>.[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>][<SPAN
CLASS="OPTIONAL"
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>]
[<SPAN
CLASS="OPTIONAL"
><TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>].<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>[<SPAN
CLASS="OPTIONAL"
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></SPAN
>]
<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>e[<SPAN
CLASS="OPTIONAL"
>+-</SPAN
>]<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
></PRE
><P>
ここで<TT
CLASS="REPLACEABLE"
><I
>digits</I
></TT
>は1つ以上の10進数字（0〜9）です。
小数点を使用する場合は、少なくとも1つの数字が小数点の前か後になくてはなりません。
指数記号<TT
CLASS="LITERAL"
>e</TT
>の付く形式を使う場合には<TT
CLASS="LITERAL"
>e</TT
>の後に少なくとも1つの数字がなければいけません。
空白や他の文字は、定数の中に埋め込むことはできません。
プラスまたはマイナスの符号を先頭につけても、定数の一部とはみなされないことに注意してください。
これらの符号は定数に適用される演算子とみなされます。
    </P
><P
>下記は有効な数値定数のいくつかの例です。
<P
CLASS="LITERALLAYOUT"
>42<br>
3.5<br>
4.<br>
.001<br>
5e2<br>
1.925e-3</P
>
    </P
><P
>     
     
     
小数点も指数も含まない数値定数の場合、まずその値が<TT
CLASS="TYPE"
>integer</TT
>型（32ビット）に収まれば<TT
CLASS="TYPE"
>integer</TT
>型であるとみなされます。
そうでない場合、<TT
CLASS="TYPE"
>bigint</TT
>型（64ビット）で収まれば<TT
CLASS="TYPE"
>bigint</TT
>型とみなされます。
どちらでもない場合は、<TT
CLASS="TYPE"
>numeric</TT
>型とみなされます。
定数が小数点または指数あるいはその両方を含む場合は、常に最初に<TT
CLASS="TYPE"
>numeric</TT
>型であるとみなされます。
    </P
><P
>数値定数に最初に割り振られるデータ型は、型解決アルゴリズムの開始点に過ぎません。
ほとんどの場合、定数は文脈に基づいて自動的に最も適切な型に変換されます。
必要であれば、特定のデータ型にキャストして、数値がそのデータ型として解釈されるように強制することができます。

例えば、以下のようにして数値を<TT
CLASS="TYPE"
>real</TT
>型（<TT
CLASS="TYPE"
>float4</TT
>）として処理することができます。

</P><PRE
CLASS="PROGRAMLISTING"
>REAL '1.23'  -- 文字列書式
1.23::REAL   -- （歴史的な）PostgreSQL書式</PRE
><P>

実のところ、これらは以下で説明する一般的なキャスト記法の特別な場合です。
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="SQL-SYNTAX-CONSTANTS-GENERIC"
>4.1.2.7. 他の型の定数</A
></H3
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>任意の</I
></SPAN
>型の定数は下記の表記のいずれかを使って入力することができます。
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'
'<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'::<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>
CAST ( '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>' AS <TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> )</PRE
><P>
文字列定数のテキストは<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
>と呼ばれる型の入力変換ルーチンへと渡されます。
結果は指示された型の定数です。
明示的な型キャストは、定数がどの型でなければならないかについて曖昧な点がなければ（例えば定数が直接テーブル列に代入されている場合）省略しても構いません。
その場合自動的に型強制されます。
    </P
><P
>文字列定数は通常のSQL記法でもドル引用符付けでも記述することができます。
    </P
><P
>     関数のような構文を使って型強制を指定することも可能です。
</P><PRE
CLASS="SYNOPSIS"
><TT
CLASS="REPLACEABLE"
><I
>typename</I
></TT
> ( '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>' )</PRE
><P>
しかし、全ての型の名前でこの方法は使用できるというわけではありません。
詳細は<A
HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS"
>項4.2.9</A
>を参照してください。
    </P
><P
><TT
CLASS="LITERAL"
>::</TT
>、<TT
CLASS="LITERAL"
>CAST()</TT
>や関数呼び出し構文は、<A
HREF="sql-expressions.html#SQL-SYNTAX-TYPE-CASTS"
>項4.2.9</A
>で説明する通り、任意の式の実行時の型変換を指定するために使うこともできます。
構文的なあいまいさをなくすために、<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'</TT
>という形式は単なるリテラル定数を指定する場合にのみ使うことができます。
この他<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'</TT
>構文には、配列型では動作しないという制限があります。
配列型の定数の型を指定する場合は<TT
CLASS="LITERAL"
>::</TT
>か<TT
CLASS="LITERAL"
>CAST()</TT
>を使用してください。
    </P
><P
><TT
CLASS="LITERAL"
>CAST()</TT
>構文はSQLに従っています。
<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> '<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>'</TT
>構文は、標準を一般化したものです。
SQLでは、この構文を数個のデータ型でのみ規定しています。
しかし、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ではすべての型で使用することができます。
<TT
CLASS="LITERAL"
>::</TT
>付きの構文は、歴史的に<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>で使用されてきました。
関数呼び出し構文も同じく歴史的に使用されているものです。
    </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-OPERATORS"
>4.1.3. 演算子</A
></H2
><P
>演算子は<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>-1（デフォルトは63）までの長さの、以下に示すリストに含まれる文字の並びです。
<P
CLASS="LITERALLAYOUT"
>+&nbsp;-&nbsp;*&nbsp;/&nbsp;&lt;&nbsp;&gt;&nbsp;=&nbsp;~&nbsp;!&nbsp;@&nbsp;#&nbsp;%&nbsp;^&nbsp;&amp;&nbsp;|&nbsp;`&nbsp;?</P
>

しかし、演算子の名前にはいくつかの制約があります。
    <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>--</TT
>と<TT
CLASS="LITERAL"
>/*</TT
>は演算子名の中に使うことができません。
なぜならこれらはコメントの始まりと解釈されるからです。
      </P
></LI
><LI
><P
>複数文字の演算子名は、その名前が少なくとも下記の文字の1つ以上を含まない限り、<TT
CLASS="LITERAL"
>+</TT
>や<TT
CLASS="LITERAL"
>-</TT
>で終わることができません。
<P
CLASS="LITERALLAYOUT"
>~&nbsp;!&nbsp;@&nbsp;#&nbsp;%&nbsp;^&nbsp;&amp;&nbsp;|&nbsp;`&nbsp;?</P
>
例えば、<TT
CLASS="LITERAL"
>@-</TT
>は演算子名として認められていますが、<TT
CLASS="LITERAL"
>*-</TT
>は認められていません。
この制限により<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、SQLに準拠する問い合わせをトークン同士の間に空白を要求せず、解析することができます。
      </P
></LI
></UL
><P>
   </P
><P
>非SQL標準の演算子名を使う場合、通常は曖昧さを回避するために、隣り合った演算子を空白で区切る必要があります。
例えば<TT
CLASS="LITERAL"
>@</TT
>という左単項演算子を定義した場合、<TT
CLASS="LITERAL"
>X*@Y</TT
>とは書けません。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>がこれを確実に1つではなく2つの演算子名として解釈できるように、<TT
CLASS="LITERAL"
>X* @Y</TT
>と書く必要があります。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-SPECIAL-CHARS"
>4.1.4. 特殊文字</A
></H2
><P
>英数字ではないいくつかの文字は、演算子であることとは異なる特殊な意味を持っています。
使用方法の詳細はそれぞれの構文要素についてのところで説明します。
本節では、単にその存在を知らせ、これらの文字の目的をまとめるに留めます。

   <P
></P
></P><UL
><LI
><P
>直後に数字が続くドル記号（<TT
CLASS="LITERAL"
>$</TT
>）は、関数定義の本体またはプリペアド文中の位置パラメータを表すために使われます。
他の文脈ではドル記号は識別子名の一部であるかもしれませんし、ドル引用符付けされた文字列定数の一部であるかもしれません。
     </P
></LI
><LI
><P
>括弧（<TT
CLASS="LITERAL"
>()</TT
>）は、通常通り式をまとめ優先するという意味を持ちます。
場合によっては括弧は、特定のSQLコマンドの固定構文の一部として要求されることがあります。
     </P
></LI
><LI
><P
>大括弧（<TT
CLASS="LITERAL"
>[]</TT
>）は、配列要素を選択するために使われます。
配列に関する詳しい情報は<A
HREF="arrays.html"
>項8.15</A
>を参照してください。
     </P
></LI
><LI
><P
>カンマ（<TT
CLASS="LITERAL"
>,</TT
>）は、リストの要素を区切るために構文的構成体で使われることがあります。
     </P
></LI
><LI
><P
>セミコロン（<TT
CLASS="LITERAL"
>;</TT
>）は、SQLコマンドの終わりを意味します。
文字列定数または引用符付き識別子以外では、コマンドの途中では使うことができません。
     </P
></LI
><LI
><P
>コロン（<TT
CLASS="LITERAL"
>:</TT
>）は、配列から<SPAN
CLASS="QUOTE"
>"一部分"</SPAN
>を取り出すために使われます
(<A
HREF="arrays.html"
>項8.15</A
>を参照してください）。
いくつかのSQL方言（埋め込みSQLなど）では、コロンは変数名の接頭辞として使われます。
     </P
></LI
><LI
><P
>アスタリスク（<TT
CLASS="LITERAL"
>*</TT
>）は、いくつかの文脈において、テーブル行や複合型の全てのフィールドを表現するために使用されます。
また、集約関数の引数として使われる場合も特殊な、つまり、その集約が明示的なパラメータをまったく必要としないという意味を持ちます。
     </P
></LI
><LI
><P
>ピリオド（<TT
CLASS="LITERAL"
>.</TT
>）は数値定数の中で使われます。
また、スキーマ名、テーブル名、列名を区切るためにも使われます。
     </P
></LI
></UL
><P>

   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-SYNTAX-COMMENTS"
>4.1.5. コメント</A
></H2
><P
>コメントは二重ハイフンで始まる文字の並びで、行の終わりまで続きます。
例えば以下のようになります。
</P><PRE
CLASS="PROGRAMLISTING"
>-- これは標準SQLのコメントです</PRE
><P>
   </P
><P
>他にも、C言語様式のブロックコメントも使用できます。
</P><PRE
CLASS="PROGRAMLISTING"
>/* ネストされた複数行にわたる
 * コメント /* ネストされたブロックコメント */
 */</PRE
><P>
コメントは<TT
CLASS="LITERAL"
>/*</TT
>で始まり、対応する<TT
CLASS="LITERAL"
>*/</TT
>で終わります。
これらのブロックコメントはC言語とは異なり、標準SQLで規定されているように入れ子にすることができます。
したがって、既存のブロックコメントを含む可能性のある大きなコードのブロックをコメントアウトすることができます。
   </P
><P
>コメントは、その後の構文解析が行われる前に入力ストリームから取り去られ、事実上、空白で置き換えられます。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SQL-PRECEDENCE"
>4.1.6. 演算子の優先順位</A
></H2
><P
><A
HREF="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE"
>表4-2</A
>は、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の演算子の優先順位と結合性を示しています。
ほとんどの演算子は同じ優先順位を持ち、左結合します。
演算子の優先順位と結合性はパーサに組み込まれています。
   </P
><P
>二項演算子と単項演算子を組み合わせて使う場合は括弧を加える必要がある場合があります。
例えば下記のような場合です。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 5 ! - 6;</PRE
><P>
は、
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 5 ! (- 6);</PRE
><P>
と解析されます。
なぜならば、パーサは<TT
CLASS="TOKEN"
>!</TT
>が中置ではなく接尾演算子として定義されていることに最後まで気が付かないためです。
この場合、求める結果を得るためには下記のように書く必要があります。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT (5 !) - 6;</PRE
><P>
これが拡張性を求める故の代償です。
   </P
><DIV
CLASS="TABLE"
><A
NAME="SQL-PRECEDENCE-TABLE"
></A
><P
><B
>表 4-2. 演算子の優先順位（高いものから低いものへ）</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>演算子/要素</TH
><TH
>結合性</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="TOKEN"
>.</TT
></TD
><TD
>左</TD
><TD
>テーブル/列名の区切り文字</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>::</TT
></TD
><TD
>左</TD
><TD
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>方式の型キャスト</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>[</TT
> <TT
CLASS="TOKEN"
>]</TT
></TD
><TD
>左</TD
><TD
>配列要素選択</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>+</TT
> <TT
CLASS="TOKEN"
>-</TT
></TD
><TD
>右</TD
><TD
>単項加算、単項減算</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>^</TT
></TD
><TD
>左</TD
><TD
>累乗</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>*</TT
> <TT
CLASS="TOKEN"
>/</TT
> <TT
CLASS="TOKEN"
>%</TT
></TD
><TD
>左</TD
><TD
>掛け算、割り算、剰余</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>+</TT
> <TT
CLASS="TOKEN"
>-</TT
></TD
><TD
>左</TD
><TD
>加算、減算</TD
></TR
><TR
><TD
>(その他の演算子)</TD
><TD
>左</TD
><TD
>その他全ての組み込み、あるいはユーザ定義の演算子</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>BETWEEN</TT
> <TT
CLASS="TOKEN"
>IN</TT
> <TT
CLASS="TOKEN"
>LIKE</TT
> <TT
CLASS="TOKEN"
>ILIKE</TT
> <TT
CLASS="TOKEN"
>SIMILAR</TT
></TD
><TD
>&nbsp;</TD
><TD
>範囲内に包含、集合の要素、文字列の一致</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>&lt;</TT
> <TT
CLASS="TOKEN"
>&gt;</TT
> <TT
CLASS="TOKEN"
>=</TT
> <TT
CLASS="TOKEN"
>&lt;=</TT
> <TT
CLASS="TOKEN"
>&gt;=</TT
> <TT
CLASS="TOKEN"
>&lt;&gt;</TT
></TD
><TD
>&nbsp;</TD
><TD
>比較演算子</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>IS</TT
> <TT
CLASS="TOKEN"
>ISNULL</TT
> <TT
CLASS="TOKEN"
>NOTNULL</TT
></TD
><TD
>&nbsp;</TD
><TD
><TT
CLASS="LITERAL"
>IS TRUE</TT
>、<TT
CLASS="LITERAL"
>IS FALSE</TT
>、<TT
CLASS="LITERAL"
>IS NULL</TT
>、<TT
CLASS="LITERAL"
>IS DISTINCT FROM</TT
>、その他</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>NOT</TT
></TD
><TD
>右</TD
><TD
>論理否定</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>AND</TT
></TD
><TD
>左</TD
><TD
>論理積</TD
></TR
><TR
><TD
><TT
CLASS="TOKEN"
>OR</TT
></TD
><TD
>左</TD
><TD
>論理和</TD
></TR
></TBODY
></TABLE
></DIV
><P
>演算子優先順位の規則は、上記で触れた組み込み演算子と同じ名前を持つユーザ定義演算子にも当てはまります。
例えばもし<SPAN
CLASS="QUOTE"
>"+"</SPAN
>演算子をある独自のデータ型に定義すると、新しい演算子が何をするかにかかわらず、<SPAN
CLASS="QUOTE"
>"+"</SPAN
>組み込み演算子と同じ優先順位を持つようになります。
   </P
><P
>次の例のように、<TT
CLASS="LITERAL"
>OPERATOR</TT
>構文でスキーマで修飾された演算子名を使用する場合、
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT 3 OPERATOR(pg_catalog.+) 4;</PRE
><P>
<TT
CLASS="LITERAL"
>OPERATOR</TT
>構文は、<A
HREF="sql-syntax-lexical.html#SQL-PRECEDENCE-TABLE"
>表4-2</A
>の<SPAN
CLASS="QUOTE"
>"その他の演算子"</SPAN
>で示されているデフォルトの優先順位を持つとみなされます。
これは、<TT
CLASS="LITERAL"
>OPERATOR()</TT
>にどの特定の演算子が入る場合でも変わりません。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>9.5より前の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のバージョンでは少し異なる演算子優先順位規則を使っていました。
特に<TT
CLASS="TOKEN"
>&lt;=</TT
>、<TT
CLASS="TOKEN"
>&gt;=</TT
>、<TT
CLASS="TOKEN"
>&lt;&gt;</TT
>は一般的な演算子として扱われていました。<TT
CLASS="LITERAL"
>IS</TT
>テストは高い優先順位を持つとして使われていました。<TT
CLASS="LITERAL"
>NOT BETWEEN</TT
>とそれに関係する構文は振る舞いが一貫しておらず、<TT
CLASS="LITERAL"
>BETWEEN</TT
>ではなく<TT
CLASS="LITERAL"
>NOT</TT
>の優先順位を持つと見なされる場合がありました。
標準SQLにより準拠し、論理的に等しい構文の一貫しない扱いから来る混乱を減らすように、これらの規則は変更されました。
ほとんどの場合、これらの変更により振る舞いが変わることはないでしょうし、もし変わっても恐らく<SPAN
CLASS="QUOTE"
>"no such operator"</SPAN
>で失敗になるくらいでしょう。後者は括弧を追加することで解決できるでしょう。
しかしながら、稀に問い合わせがパースエラーを返すことなく振る舞いを変える場合があります。
これらの変更が黙って何かを壊してしまったかどうかが心配であれば、設定パラメータ<A
HREF="runtime-config-compatible.html#GUC-OPERATOR-PRECEDENCE-WARNING"
>operator_precedence_warning</A
>をオンにして、何か警告がログに書き込まれるかを見てください。
    </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-expressions.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>SQLの構文</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-syntax.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>評価式</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>JSON関数と演算子</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.0文書"
HREF="index.html"><LINK
REL="UP"
TITLE="関数と演算子"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="XML関数"
HREF="functions-xml.html"><LINK
REL="NEXT"
TITLE="シーケンス操作関数"
HREF="functions-sequence.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-10-20T00:12:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.0文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="XML関数"
HREF="functions-xml.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 9章関数と演算子</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="シーケンス操作関数"
HREF="functions-sequence.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-JSON"
>9.15. JSON関数と演算子</A
></H1
><P
><A
HREF="functions-json.html#FUNCTIONS-JSON-OP-TABLE"
>表9-42</A
>に2つのJSONデータ型(<A
HREF="datatype-json.html"
>項8.14</A
>を参照)で使用可能な演算子を示します。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSON-OP-TABLE"
></A
><P
><B
>表 9-42. <TT
CLASS="TYPE"
>json</TT
>と<TT
CLASS="TYPE"
>jsonb</TT
>演算子</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>演算子</TH
><TH
>右オペランド型</TH
><TH
>説明</TH
><TH
>例</TH
><TH
>例の結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>JSON配列要素を取得（添字はゼロから、負数なら後ろから数える）</TD
><TD
><TT
CLASS="LITERAL"
>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json-&gt;2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"c":"baz"}</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>キーに依るJSONオブジェクトフィールド取得</TD
><TD
><TT
CLASS="LITERAL"
>'{"a": {"b":"foo"}}'::json-&gt;'a'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"b":"foo"}</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>JSON 配列要素を<TT
CLASS="TYPE"
>text</TT
>として取得</TD
><TD
><TT
CLASS="LITERAL"
>'[1,2,3]'::json-&gt;&gt;2</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-&gt;&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>JSON オブジェクトフィールドを<TT
CLASS="TYPE"
>text</TT
>として取得</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1,"b":2}'::json-&gt;&gt;'b'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>#&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>指定されたパスにあるJSONオブジェクトを取得</TD
><TD
><TT
CLASS="LITERAL"
>'{"a": {"b":{"c": "foo"}}}'::json#&gt;'{a,b}'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"c": "foo"}</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>#&gt;&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>指定されたパスにあるJSONオブジェクトを<TT
CLASS="TYPE"
>text</TT
>として取得</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":[1,2,3],"b":[4,5,6]}'::json#&gt;&gt;'{a,2}'</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><TT
CLASS="TYPE"
>json</TT
>と<TT
CLASS="TYPE"
>jsonb</TT
>型の両方に対して、以上の演算子の対応するものがあります。
フィールド/要素/パス抽出演算子は左辺の入力と同じ型（<TT
CLASS="TYPE"
>json</TT
>または<TT
CLASS="TYPE"
>jsonb</TT
>）を返します。
ただし、<TT
CLASS="TYPE"
>text</TT
>を返すと明示してあるものは、値をテキストに変換して返します。
JSON入力が要求と一致する正しい構造をしていなければ、フィールド/要素/パス抽出演算子は失敗するのではなくNULLを返します。例えばそのような要素が存在しない場合です。
JSON配列の添字を整数で受け取り、フィールド、要素、パスを返す演算子はすべて、配列の終わりから数える負の添字をサポートします。
   </P
></BLOCKQUOTE
></DIV
><P
><A
HREF="functions-comparison.html#FUNCTIONS-COMPARISON-OP-TABLE"
>表9-1</A
>に示されている標準の比較演算子が<TT
CLASS="TYPE"
>jsonb</TT
>で利用可能ですが、<TT
CLASS="TYPE"
>json</TT
>ではそうではありません。
それらは<A
HREF="datatype-json.html#JSON-INDEXING"
>項8.14.4</A
>で概略を述べたB-tree演算子の順序規則に従います。
  </P
><P
>ほかに<TT
CLASS="TYPE"
>jsonb</TT
>だけで利用可能な演算子もいくつか存在します。
それらを<A
HREF="functions-json.html#FUNCTIONS-JSONB-OP-TABLE"
>表9-43</A
>に示します。
これらのうち多くの演算子は<TT
CLASS="TYPE"
>jsonb</TT
>演算子クラスでインデックス付けすることが可能です。
<TT
CLASS="TYPE"
>jsonb</TT
>の包含と存在の意味に関する完全な記述は<A
HREF="datatype-json.html#JSON-CONTAINMENT"
>項8.14.3</A
>を参照してください。
<A
HREF="datatype-json.html#JSON-INDEXING"
>項8.14.4</A
>には、<TT
CLASS="TYPE"
>jsonb</TT
>データを効率的にインデックス付けするためにこれらの演算子をどのように利用できるかについて書いてあります。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSONB-OP-TABLE"
></A
><P
><B
>表 9-43. 追加<TT
CLASS="TYPE"
>jsonb</TT
>演算子</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>演算子</TH
><TH
>右オペランド型</TH
><TH
>説明</TH
><TH
>例</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>@&gt;</TT
></TD
><TD
><TT
CLASS="TYPE"
>jsonb</TT
></TD
><TD
>左のJSON値はトップレベルにおいて右のJSONパスまたは値を包含するか</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1, "b":2}'::jsonb @&gt; '{"b":2}'::jsonb</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>&lt;@</TT
></TD
><TD
><TT
CLASS="TYPE"
>jsonb</TT
></TD
><TD
>左のJSONパスまたは値は右のJSON値にトップレベルで包含されるか</TD
><TD
><TT
CLASS="LITERAL"
>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>?</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>文字列</I
></SPAN
>はJSON値のトップレベルのキーとして存在するか</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1, "b":2}'::jsonb ? 'b'</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>?|</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>配列の<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>文字列</I
></SPAN
>のいずれかがトップレベルのキーとして存在するか。</TD
><TD
><TT
CLASS="LITERAL"
>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>?&amp;</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>配列の<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>文字列</I
></SPAN
>のすべてがトップレベルのキーとして存在するか。</TD
><TD
><TT
CLASS="LITERAL"
>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>||</TT
></TD
><TD
><TT
CLASS="TYPE"
>jsonb</TT
></TD
><TD
>2つの<TT
CLASS="TYPE"
>jsonb</TT
>値を結合して、新しい<TT
CLASS="TYPE"
>jsonb</TT
>値を作る</TD
><TD
><TT
CLASS="LITERAL"
>'["a", "b"]'::jsonb || '["c", "d"]'::jsonb</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-</TT
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>左のオペランドからキー／値のペア、あるいは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>文字列</I
></SPAN
>要素を削除する。
キー／値のペアはキーの値に基づいてマッチされる。</TD
><TD
><TT
CLASS="LITERAL"
>'{"a": "b"}'::jsonb - 'a' </TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>-</TT
></TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>指定した添字の配列要素を削除する（負数の場合は後ろから数えます）。
トップレベルのコンテナが配列でないときはエラーが発生する。</TD
><TD
><TT
CLASS="LITERAL"
>'["a", "b"]'::jsonb - 1 </TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>#-</TT
></TD
><TD
><TT
CLASS="TYPE"
>text[]</TT
></TD
><TD
>指定したパスのフィールドまたは要素を削除する（JSON配列では、負数は後ろから数えます）</TD
><TD
><TT
CLASS="LITERAL"
>'["a", {"b":1}]'::jsonb #- '{1,b}'</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><TT
CLASS="LITERAL"
>||</TT
>演算子は、両オペランドのトップレベルで要素を結合します。
再帰的には作用しません。
例えば、両方のオペランドが同じキーフィールド名のオブジェクトの場合、そのフィールドの値は、単に右側のオペランドの値になります。
   </P
></BLOCKQUOTE
></DIV
><P
><A
HREF="functions-json.html#FUNCTIONS-JSON-CREATION-TABLE"
>表9-44</A
>に、JSON値および<TT
CLASS="TYPE"
>jsonb</TT
>値を作成するために利用可能な関数を示します。
（<TT
CLASS="LITERAL"
>row_to_json</TT
>関数および<TT
CLASS="LITERAL"
>array_to_json</TT
>関数と同等な<TT
CLASS="TYPE"
>jsonb</TT
>の関数はありません。
しかし、<TT
CLASS="LITERAL"
>to_jsonb</TT
>を使えば、これらの関数と同じ機能を提供できるでしょう。）
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSON-CREATION-TABLE"
></A
><P
><B
>表 9-44. JSON作成関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><THEAD
><TR
><TH
>関数</TH
><TH
>説明</TH
><TH
>例</TH
><TH
>例の結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><P
><TT
CLASS="LITERAL"
>to_json(anyelement)</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>to_jsonb(anyelement)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>json</TT
>あるいは<TT
CLASS="TYPE"
>jsonb</TT
>として値を返す。
配列と複合型は（再帰的に）配列とオブジェクトに変換される。
あるいは、その型から<TT
CLASS="TYPE"
>json</TT
>にキャストがあれば、キャスト関数が変換のために用いられる。
そうでなければ、スカラ値が生成される。
数値、論理値、またはNULL値以外のスカラ型に対しては、有効な<TT
CLASS="TYPE"
>json</TT
>値あるいは<TT
CLASS="TYPE"
>jsonb</TT
>値となる形式の文字列表現が使用される。
       </TD
><TD
><TT
CLASS="LITERAL"
>to_json('Fred said "Hi."'::text)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>"Fred said \"Hi.\""</TT
></TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
>array_to_json(anyarray [, pretty_bool])</TT
>
       </TD
><TD
>配列をJSON配列として返す。
PostgreSQLの多次元配列はJSON配列の配列となる。
<TT
CLASS="PARAMETER"
>pretty_bool</TT
>が真の場合、次元数-1の要素の間に改行が加えられる。
       </TD
><TD
><TT
CLASS="LITERAL"
>array_to_json('{{1,5},{99,100}}'::int[])</TT
></TD
><TD
><TT
CLASS="LITERAL"
>[[1,5],[99,100]]</TT
></TD
></TR
><TR
><TD
>         <TT
CLASS="LITERAL"
>row_to_json(record [, pretty_bool])</TT
>
       </TD
><TD
>行をJSONオブジェクトとして返す。
<TT
CLASS="PARAMETER"
>pretty_bool</TT
>が真の場合、レベル-1の要素の間に改行が加えられる。
       </TD
><TD
><TT
CLASS="LITERAL"
>row_to_json(row(1,'foo'))</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"f1":1,"f2":"foo"}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_build_array(VARIADIC "any")</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>jsonb_build_array(VARIADIC "any")</TT
>
       </P
></TD
><TD
>異なる型から構成される可能性のあるJSON配列をvariadic引数リストから作成。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_build_array(1,2,'3',4,5)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>[1, 2, "3", 4, 5]</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_build_object(VARIADIC "any")</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>jsonb_build_object(VARIADIC "any")</TT
>
       </P
></TD
><TD
>variadic引数リストからJSONオブジェクトを作成。
慣例により引数リストはキーと値が交互に並んだもの。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_build_object('foo',1,'bar',2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"foo": 1, "bar": 2}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_object(text[])</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>jsonb_object(text[])</TT
>
       </P
></TD
><TD
>テキスト配列からJSONオブジェクトを作成。
配列は、偶数個の要素からなる1次元（キー／値の対が交互に並んでいるものと扱われる)）あるいは内側の配列が2つの要素を持つ2次元（2つの要素がキー／値の対として扱われる）のいずれかでなければならない。
       </TD
><TD
><P
><TT
CLASS="LITERAL"
>json_object('{a, 1, b, "def", c, 3.5}')</TT
></P
>
        <P
><TT
CLASS="LITERAL"
>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</TT
></P
></TD
><TD
><TT
CLASS="LITERAL"
>{"a": "1", "b": "def", "c": "3.5"}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_object(keys text[], values text[])</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>jsonb_object(keys text[], values text[])</TT
>
       </P
></TD
><TD
>この形の<CODE
CLASS="FUNCTION"
>json_object</CODE
>は2つの別々の配列からキーと値の対を取る。
他の点ではすべて、引数1つの形と同じ。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_object('{a, b}', '{1,2}')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"a": "1", "b": "2"}</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><CODE
CLASS="FUNCTION"
>array_to_json</CODE
>と<CODE
CLASS="FUNCTION"
>row_to_json</CODE
>は表示を整えるオプションを提供する以外は<CODE
CLASS="FUNCTION"
>to_json</CODE
>と同様の振舞いをします。
同様に<CODE
CLASS="FUNCTION"
>to_json</CODE
>に書かれた振舞いはJSON作成関数により変換された個々の値に適用されます。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><A
HREF="hstore.html"
>hstore</A
>拡張は<TT
CLASS="TYPE"
>hstore</TT
>から<TT
CLASS="TYPE"
>json</TT
>へのキャストを含みます。従って、JSON作成関数で変換された<TT
CLASS="TYPE"
>hstore</TT
>値は元の文字列値ではなくJSONオブジェクトとして示されます。
    </P
></BLOCKQUOTE
></DIV
><P
><A
HREF="functions-json.html#FUNCTIONS-JSON-PROCESSING-TABLE"
>表9-45</A
>に<TT
CLASS="TYPE"
>json</TT
>と<TT
CLASS="TYPE"
>jsonb</TT
>値を処理するのに使える関数を示します。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-JSON-PROCESSING-TABLE"
></A
><P
><B
>表 9-45. JSON処理関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>関数</TH
><TH
>戻り値型</TH
><TH
>説明</TH
><TH
>例</TH
><TH
>例の結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_array_length(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_array_length(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>         JSON配列の最も外側の要素の数を返す。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>5</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_each(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_each(jsonb)</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="LITERAL"
>setof key text, value json</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>setof key text, value jsonb</TT
>
       </P
></TD
><TD
>         JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_each('{"a":"foo", "b":"bar"}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> key | value
-----+-------
 a   | "foo"
 b   | "bar"</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_each_text(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_each_text(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof key text, value text</TT
></TD
><TD
>        JSONオブジェクトの最も外側をkey/valueの組み合わせに拡張する。返り値は型<TT
CLASS="TYPE"
>text</TT
>。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_each_text('{"a":"foo", "b":"bar"}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> key | value
-----+-------
 a   | foo
 b   | bar</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_extract_path(from_json json, VARIADIC path_elems text[])</TT
>
        </P
><P
><TT
CLASS="LITERAL"
>jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>json</TT
></P
><P
><TT
CLASS="TYPE"
>jsonb</TT
>
       </P
></TD
><TD
>        <TT
CLASS="REPLACEABLE"
><I
>path_elems</I
></TT
>で示されたJSONオブジェクトを返す(<TT
CLASS="LITERAL"
>#&gt;</TT
>と同じ)。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{"f5":99,"f6":"foo"}</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_extract_path_text(from_json json, VARIADIC path_elems text[])</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        <TT
CLASS="REPLACEABLE"
><I
>path_elems</I
></TT
>で示されたJSONオブジェクトを<TT
CLASS="TYPE"
>text</TT
>として返す(<TT
CLASS="LITERAL"
>#&gt;&gt;</TT
>演算子と同じ)。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4', 'f6')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>foo</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_object_keys(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_object_keys(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof text</TT
></TD
><TD
>        最も外側のJSONオブジェクトの中のキーの集合を返す。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> json_object_keys
------------------
 f1
 f2</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_populate_record(base anyelement, from_json json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_populate_record(base anyelement, from_json jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>anyelement</TT
></TD
><TD
><TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>内のオブジェクトを行を<TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
>で定義されたレコード型に一致する列に拡張する(以下の注意書きを参照)。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_populate_record(null::myrowtype, '{"a":1,"b":2}')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a | b
---+---
 1 | 2</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_populate_recordset(base anyelement, from_json json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_populate_recordset(base anyelement, from_json jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof anyelement</TT
></TD
><TD
><TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>におけるオブジェクトの最も外側の配列を<TT
CLASS="REPLACEABLE"
><I
>base</I
></TT
>で定義されたレコード型に一致する列を持つ行の集合に展開する(以下の注意書き参照)。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_populate_recordset(null::myrowtype, '[{"a":1,"b":2},{"a":3,"b":4}]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a | b
---+---
 1 | 2
 3 | 4</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_array_elements(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_array_elements(jsonb)</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>setof json</TT
>
         </P
><P
><TT
CLASS="TYPE"
>setof jsonb</TT
>
       </P
></TD
><TD
>JSON配列をJSON値の集合に展開する。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_array_elements('[1,true, [2,false]]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
>   value
-----------
 1
 true
 [2,false]</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_array_elements_text(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_array_elements_text(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof text</TT
></TD
><TD
>JSON配列を<TT
CLASS="TYPE"
>text</TT
>値の集合に展開する。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_array_elements_text('["foo", "bar"]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
>   value
-----------
 foo
 bar</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_typeof(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_typeof(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>最も外側のJSON値の型をテキスト文字列として返す。
取りうる型は<TT
CLASS="LITERAL"
>object</TT
>、 <TT
CLASS="LITERAL"
>array</TT
>、 <TT
CLASS="LITERAL"
>string</TT
>、 <TT
CLASS="LITERAL"
>number</TT
>、<TT
CLASS="LITERAL"
>boolean</TT
>、<TT
CLASS="LITERAL"
>null</TT
>である。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_typeof('-123.4')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>number</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_to_record(json)</TT
>
          </P
><P
><TT
CLASS="LITERAL"
>jsonb_to_record(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>record</TT
></TD
><TD
>JSONオブジェクトから任意のレコードを作成する（下記の注釈を参照）。
<TT
CLASS="TYPE"
>record</TT
>を返す関数すべてと同様、呼び出し側が<TT
CLASS="LITERAL"
>AS</TT
>句でレコードの構造を明示的に決める必要がある。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a int, b text, d text) </TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a |    b    | d
---+---------+---
 1 | [1,2,3] |</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_to_recordset(json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_to_recordset(jsonb)</TT
>
       </P
></TD
><TD
><TT
CLASS="TYPE"
>setof record</TT
></TD
><TD
>オブジェクトの配列のJSONから任意のレコードの集合を作成する（下記の注釈を参照）。
<TT
CLASS="TYPE"
>record</TT
>を返す関数すべてと同様、呼び出し側が<TT
CLASS="LITERAL"
>AS</TT
>句でレコードの構造を明示的に決める必要がある。
       </TD
><TD
><TT
CLASS="LITERAL"
>select * from json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b text);</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
> a |  b
---+-----
 1 | foo
 2 |</PRE
>
       </TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>json_strip_nulls(from_json json)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_strip_nulls(from_json jsonb)</TT
>
       </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>json</TT
></P
><P
><TT
CLASS="TYPE"
>jsonb</TT
></P
></TD
><TD
>NULL値を持つオブジェクトフィールドを削除した<TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>を返す。
他のNULL値はそのまま残る。
       </TD
><TD
><TT
CLASS="LITERAL"
>json_strip_nulls('[{"f1":1,"f2":null},2,null,3]')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>[{"f1":1},2,null,3]</TT
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>jsonb_set(target jsonb, path text[], new_value jsonb[<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>create_missing</TT
> <TT
CLASS="TYPE"
>boolean</TT
></SPAN
>])</TT
>
         </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>jsonb</TT
></P
></TD
><TD
><TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>で指定した部分を<TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
>で置換、
あるいは<TT
CLASS="REPLACEABLE"
><I
>create_missing</I
></TT
>が真（デフォルトは<TT
CLASS="LITERAL"
>true</TT
>）で<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>で指定した項目が存在しないなら<TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
>を追加して、
<TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
>を返す。
パスの位置についての演算子について、<TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
>の中にある負の整数はJSON配列の終わりから数える。
       </TD
><TD
><P
><TT
CLASS="LITERAL"
>jsonb_set('[{"f1":1,"f2":null},2,null,3]', '{0,f1}','[2,3,4]', false)</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>jsonb_set('[{"f1":1,"f2":null},2]', '{0,f3}','[2,3,4]')</TT
>
         </P
></TD
><TD
><P
><TT
CLASS="LITERAL"
>[{"f1":[2,3,4],"f2":null},2,null,3]</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>[{"f1": 1, "f2": null, "f3": [2, 3, 4]}, 2]</TT
>
        </P
></TD
></TR
><TR
><TD
>           <P
><TT
CLASS="LITERAL"
>           jsonb_insert(target jsonb, path text[], new_value jsonb, [<SPAN
CLASS="OPTIONAL"
><TT
CLASS="PARAMETER"
>insert_after</TT
> <TT
CLASS="TYPE"
>boolean</TT
></SPAN
>])
           </TT
></P
>
       </TD
><TD
><P
><TT
CLASS="TYPE"
>jsonb</TT
></P
></TD
><TD
>         Returns <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> with
         <TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
> inserted. If
         <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> section designated by
         <TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
> is in a JSONB array,
         <TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
> will be inserted before target or
         after if <TT
CLASS="REPLACEABLE"
><I
>insert_after</I
></TT
> is true (default is
         <TT
CLASS="LITERAL"
>false</TT
>). If <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> section
         designated by <TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
> is in JSONB object,
         <TT
CLASS="REPLACEABLE"
><I
>new_value</I
></TT
> will be inserted only if
         <TT
CLASS="REPLACEABLE"
><I
>target</I
></TT
> does not exist. As with the path
         orientated operators, negative integers that appear in
         <TT
CLASS="REPLACEABLE"
><I
>path</I
></TT
> count from the end of JSON arrays.
       </TD
><TD
>           <P
><TT
CLASS="LITERAL"
>               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"')
           </TT
></P
>
           <P
><TT
CLASS="LITERAL"
>               jsonb_insert('{"a": [0,1,2]}', '{a, 1}', '"new_value"', true)
           </TT
></P
>
       </TD
><TD
><P
><TT
CLASS="LITERAL"
>{"a": [0, "new_value", 1, 2]}</TT
>
         </P
><P
><TT
CLASS="LITERAL"
>{"a": [0, 1, "new_value", 2]}</TT
>
        </P
></TD
></TR
><TR
><TD
><P
><TT
CLASS="LITERAL"
>jsonb_pretty(from_json jsonb)</TT
>
         </P
></TD
><TD
><P
><TT
CLASS="TYPE"
>text</TT
></P
></TD
><TD
><TT
CLASS="REPLACEABLE"
><I
>from_json</I
></TT
>をインデントしたJSON文字列にして返す。
       </TD
><TD
><TT
CLASS="LITERAL"
>jsonb_pretty('[{"f1":1,"f2":null},2,null,3]')</TT
></TD
><TD
><PRE
CLASS="PROGRAMLISTING"
>[
    {
        "f1": 1,
        "f2": null
    },
    2,
    null,
    3
]</PRE
>
        </TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>これらの多くの関数や演算子は、JSON文字列のUnicodeのエスケープを適切な一文字に変換します。
これは入力が<TT
CLASS="TYPE"
>jsonb</TT
>型であれば、変換は既に行なわれていますので、重要な問題ではありません。しかし、<TT
CLASS="TYPE"
>json</TT
>の入力に対しては、<A
HREF="datatype-json.html"
>項8.14</A
>で言及したようにこれはエラーを発生させる結果になるかもしれません．
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><CODE
CLASS="FUNCTION"
>json_populate_record</CODE
>、<CODE
CLASS="FUNCTION"
>json_populate_recordset</CODE
>、<CODE
CLASS="FUNCTION"
>json_to_record</CODE
>および<CODE
CLASS="FUNCTION"
>json_to_recordset</CODE
>におけるJSONからの型強制は<SPAN
CLASS="QUOTE"
>"最善努力"</SPAN
>であり、ある型では望んだ結果にならないかもしれません。
JSONキーは対象の行の型の中の同一の列の名前と一致します。
対象の行の型に現れないJSONフィールドは出力から省略され、JSONフィールドに一致しない対象の列は単にNULLになります。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><TT
CLASS="LITERAL"
>create_missing</TT
>が真でないときは、<TT
CLASS="LITERAL"
>jsonb_set</TT
>の<TT
CLASS="LITERAL"
>path</TT
>パラメータのすべての項目が<TT
CLASS="LITERAL"
>target</TT
>内に存在しなければなりません。
<TT
CLASS="LITERAL"
>create_missing</TT
>が真なら、最後の項目を除き、すべての項目が存在しなければなりません。
これらの条件が満たされなければ、<TT
CLASS="LITERAL"
>target</TT
>が変更されずに返されます。 ★変更あり
    </P
><P
>パスの最後の要素がオブジェクトのキーの場合、それが存在しなければ作成されて、新しい値が与えられます。
パスの最後の項目が配列の添字の場合、それが正ならセットすべき項目は左から数えられ、負なら右から数えられます（<TT
CLASS="LITERAL"
>-1</TT
>は最も右側の要素を指す、という具合です）。
項目が[-array_length .. array_length -1]の範囲外にあり、かつcreate_missingが真なら、新しい値が配列の先頭（項目が負数のとき）あるいは配列の終わり（項目が正数のとき）に追加されます。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><TT
CLASS="LITERAL"
>json_typeof</TT
>の<TT
CLASS="LITERAL"
>null</TT
>戻り値をSQLのNULLと混同してはいけません。
<TT
CLASS="LITERAL"
>json_typeof('null'::json)</TT
>を呼び出すと<TT
CLASS="LITERAL"
>null</TT
>が返りますが、<TT
CLASS="LITERAL"
>json_typeof(NULL::json)</TT
>を呼び出すとSQLのNULLが返ります。
    </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><TT
CLASS="LITERAL"
>json_strip_nulls</TT
>の引数で、オブジェクト内にフィールド名が重複しているものがある場合、それが発生している順序によって、結果は意味的にやや異なるものになることがあります。
<TT
CLASS="TYPE"
>jsonb</TT
>値はオブジェクトのフィールド名が重複することがないので、<TT
CLASS="LITERAL"
>jsonb_strip_nulls</TT
>にはこのような問題はありません。
    </P
></BLOCKQUOTE
></DIV
><P
>レコードの値をJSONに集約する<CODE
CLASS="FUNCTION"
>json_agg</CODE
>集約関数、値の対をJSONオブジェクトに集約する<CODE
CLASS="FUNCTION"
>json_object_agg</CODE
>集約関数、およびそれらの<TT
CLASS="TYPE"
>jsonb</TT
>版の<CODE
CLASS="FUNCTION"
>jsonb_agg</CODE
>と<CODE
CLASS="FUNCTION"
>jsonb_object_agg</CODE
>については<A
HREF="functions-aggregate.html"
>項9.20</A
>を参照して下さい。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-xml.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-sequence.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>XML関数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>シーケンス操作関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
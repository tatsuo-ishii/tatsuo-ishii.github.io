<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>12.9. GiSTおよびGINインデックス種類</title><link rel="stylesheet" type="text/css" href="stylesheet.css" /><link rev="made" href="pgsql-docs@postgresql.org" /><meta name="generator" content="DocBook XSL Stylesheets V1.78.1" /><link rel="home" href="index.html" title="PostgreSQL 9.4.5文書" /><link rel="up" href="textsearch.html" title="第12章 全文検索" /><link rel="prev" href="textsearch-debugging.html" title="12.8. テキスト検索のテストとデバッグ" /><link rel="next" href="textsearch-psql.html" title="12.10. psqlサポート" /><link rel="copyright" href="legalnotice.html" title="法的告知" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">12.9. GiSTおよびGINインデックス種類</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="textsearch-debugging.html">戻る</a> </td><th width="60%" align="center">第12章 全文検索</th><td width="20%" align="right"> <a accesskey="n" href="textsearch-psql.html">次へ</a></td></tr></table><hr /></div><div class="sect1" id="textsearch-indexes"><div class="titlepage"><div><div><h2 class="title" style="clear: both">12.9. GiSTおよびGINインデックス種類</h2></div></div></div><!--
  <title>GiST and GIN Index Types</title>
--><a id="idp69572016" class="indexterm"></a><p><!--
   There are two kinds of indexes that can be used to speed up full text
   searches.
   Note that indexes are not mandatory for full text searching, but in
   cases where a column is searched on a regular basis, an index is
   usually desirable.
-->全文検索を高速化するために、2種類のインデックスが使えます。全文検索のためにインデックスが必須だと言うわけではないことを言っておかなければなりませんが、日常的に検索される列には、インデックスを使った方が良いでしょう。

   </p><div class="variablelist"><dl class="variablelist"><dt><span class="term">     <a id="idp69575200" class="indexterm"></a>

      <code class="literal">CREATE INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em> USING gist(<em class="replaceable"><code>column</code></em>);</code>
     </span></dt><dd><p><!--
       Creates a GiST (Generalized Search Tree)-based index.
       The <replaceable>column</replaceable> can be of <type>tsvector</> or
       <type>tsquery</> type.
-->GiST (Generalized Search Tree)インデックスを作ります。<em class="replaceable"><code>column</code></em>は <code class="type">tsvector</code> または<code class="type">tsquery</code> 型です。
      </p></dd><dt><span class="term">     <a id="idp69581584" class="indexterm"></a>

      <code class="literal">CREATE INDEX <em class="replaceable"><code>name</code></em> ON <em class="replaceable"><code>table</code></em> USING gin(<em class="replaceable"><code>column</code></em>);</code>
     </span></dt><dd><p><!--
       Creates a GIN (Generalized Inverted Index)-based index.
       The <replaceable>column</replaceable> must be of <type>tsvector</> type.
-->GIN (Generalized Inverted Index)インデックスを作ります。
<em class="replaceable"><code>column</code></em>は<code class="type">tsvector</code>型でなければなりません。
      </p></dd></dl></div><p>
  </p><p><!--
   There are substantial performance differences between the two index types,
   so it is important to understand their characteristics.
-->この2つのインデックス形式には、性能上の大きな違いがあります。ですので、それらの特長を理解しておくことが重要です.
  </p><p><!--
   A GiST index is <firstterm>lossy</firstterm>, meaning that the index
   may produce false matches, and it is necessary
   to check the actual table row to eliminate such false matches.
   (<productname>PostgreSQL</productname> does this automatically when needed.)
   GiST indexes are lossy because each document is represented in the
   index by a fixed-length signature. The signature is generated by hashing
   each word into a single bit in an n-bit string, with all these bits OR-ed
   together to produce an n-bit document signature.  When two words hash to
   the same bit position there will be a false match.  If all words in
   the query have matches (real or false) then the table row must be
   retrieved to see if the match is correct.
-->GiSTインデックスは、<em class="firstterm">非可逆</em>です。つまり、インデックスは間違った結果を返すかも知れないので、間違った結果を排除するために、テーブルの行をチェックすることが必要です。<span class="productname">PostgreSQL</span>はこの処理が必要とされた時に自動的に行います。
GiSTインデックスが非可逆なのは、インデックス中の各文書が固定長の署名によって表現されているからです。署名は、各々の単語をハッシュして単一なビットにして、これらのビットをnビットの文書署名にORし、nビットの列中のビットにすることで実現されています。2つの単語が同じビット位置を生成すると、間違った一致が起こります。問い合わせ対象のすべての単語が照合すると(それが正しいか間違っているかは別として)、その照合が正しいものかどうかテーブルの行を取得して調べなければなりません。
  </p><p><!--
   Lossiness causes performance degradation due to unnecessary fetches of table
   records that turn out to be false matches.  Since random access to table
   records is slow, this limits the usefulness of GiST indexes.  The
   likelihood of false matches depends on several factors, in particular the
   number of unique words, so using dictionaries to reduce this number is
   recommended.
-->非可逆性は、間違った照合によるテーブルからの不必要なデータ取得のため、性能を劣化させます。テーブルへのランダムアクセスは遅いので、GiSTインデックスの有用性は制限されています。誤った照合がどの位あるかという可能性はいくつか要因によりますが、とりわけユニークな単語の数に依存します。ですから、辞書を使ってユニークな単語の数を減らすことをお勧めします。
  </p><p><!--
   GIN indexes are not lossy for standard queries, but their performance
   depends logarithmically on the number of unique words.
   (However, GIN indexes store only the words (lexemes) of <type>tsvector</>
   values, and not their weight labels.  Thus a table row recheck is needed
   when using a query that involves weights.)
-->GINインデックスは標準の問い合わせに対しては非可逆ではありませんが、その性能はユニークな単語の数の対数に依存します。(しかしながら、GINインデックスはtsvector値の中の単語(語彙素)のみを保持しており、重み付けラベルは持っていません。したがって、重み付けを伴う問合わせではテーブルの行を再チェックしなければなりません。)
  </p><p><!--
   In choosing which index type to use, GiST or GIN, consider these
   performance differences:
-->GiST、GINのどちらのインデックス形式を選ぶにあたっては、以下の性能上の違いを考慮してください。

   </p><div class="itemizedlist"><ul class="itemizedlist compact" style="list-style-type: bullet; "><li class="listitem" style="list-style-type: disc"><p><!--
      GIN index lookups are about three times faster than GiST
-->GINインデックスの検索はGiSTの約3倍高速です
     </p></li><li class="listitem" style="list-style-type: disc"><p><!--
      GIN indexes take about three times longer to build than GiST
-->GINインデックスの構築はGiSTの約3倍時間がかかります
     </p></li><li class="listitem" style="list-style-type: disc"><p><!--
      GIN indexes are moderately slower to update than GiST indexes, but
      about 10 times slower if fast-update support was disabled
      (see <xref linkend="gin-fast-update"> for details)
-->GINインデックスに対する更新はGiSTよりもそこそこ低速ですが、もし高速更新サポートを無効にしている場合は10倍の低速になります(詳細は<a class="xref" href="gin-implementation.html#gin-fast-update" title="58.4.1. GIN高速更新手法">「GIN高速更新手法」</a>を見てください)
     </p></li><li class="listitem" style="list-style-type: disc"><p><!--
      GIN indexes are two-to-three times larger than GiST indexes
-->GINインデックスは、GiSTインデックスより2から3倍大きいです
     </p></li></ul></div><p>
  </p><p><!--
   As a rule of thumb, <acronym>GIN</acronym> indexes are best for static data
   because lookups are faster.  For dynamic data, GiST indexes are
   faster to update.  Specifically, <acronym>GiST</acronym> indexes are very
   good for dynamic data and fast if the number of unique words (lexemes) is
   under 100,000, while <acronym>GIN</acronym> indexes will handle 100,000+
   lexemes better but are slower to update.
-->大雑把に言うと、<acronym class="acronym">GIN</acronym>インデックスは検索が高速なので、静的なデータにもっとも向いています。動的なデータには、GiSTインデックスの更新が高速です。とりわけ、<acronym class="acronym">GiST</acronym>インデックスは、動的なデータに非常に向いており、ユニークな単語(語彙素)が100,000未満ならば高速です。一方<acronym class="acronym">GIN</acronym>インデックスは100,000以上の語彙素をよりうまく扱うことができますが、更新が遅いです。
  </p><p><!--
   Note that <acronym>GIN</acronym> index build time can often be improved
   by increasing <xref linkend="guc-maintenance-work-mem">, while
   <acronym>GiST</acronym> index build time is not sensitive to that
   parameter.
--><acronym class="acronym">GIN</acronym>インデックスの構築時間は<a class="xref" href="runtime-config-resource.html#guc-maintenance-work-mem">maintenance_work_mem</a>を増やすことによってしばしば改善することができることに注意してください。一方<acronym class="acronym">GiST</acronym>インデックスの構築時間にはあまりそのパラメータは効きません。
  </p><p><!--
   Partitioning of big collections and the proper use of GiST and GIN indexes
   allows the implementation of very fast searches with online update.
   Partitioning can be done at the database level using table inheritance,
   or by distributing documents over
   servers and collecting search results using the <xref linkend="dblink">
   module. The latter is possible because ranking functions use
   only local information.
-->大きなデータをパーティショニングし、GiST、GINインデックスを使うことによってオンラインの更新を伴いながら、非常に高速な検索を実現することができます。パーティショニングは、継承を使ってデータベースレベルで実現できます。あるいは、文書を複数のサーバに分散させ、<a class="xref" href="dblink.html" title="F.9. dblink">dblink</a>モジュールを使って検索結果を集約できます。これは、ランキング関数がローカルな情報しか使わないために可能になります。
  </p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="textsearch-debugging.html">戻る</a> </td><td width="20%" align="center"><a accesskey="u" href="textsearch.html">上に戻る</a></td><td width="40%" align="right"> <a accesskey="n" href="textsearch-psql.html">次へ</a></td></tr><tr><td width="40%" align="left" valign="top">12.8. テキスト検索のテストとデバッグ </td><td width="20%" align="center"><a accesskey="h" href="index.html">ホーム</a></td><td width="40%" align="right" valign="top"> 12.10. <span class="application">psql</span>サポート</td></tr></table></div></body></html>
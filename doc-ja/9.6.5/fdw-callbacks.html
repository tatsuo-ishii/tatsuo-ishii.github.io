<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>外部データラッパのコールバックルーチン</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="外部データラッパの作成"
HREF="fdwhandler.html"><LINK
REL="PREVIOUS"
TITLE="外部データラッパ関数"
HREF="fdw-functions.html"><LINK
REL="NEXT"
TITLE="外部データラッパヘルパ関数"
HREF="fdw-helpers.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="外部データラッパ関数"
HREF="fdw-functions.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="fdwhandler.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 55章外部データラッパの作成</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="外部データラッパヘルパ関数"
HREF="fdw-helpers.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FDW-CALLBACKS"
>55.2. 外部データラッパのコールバックルーチン</A
></H1
><P
>FDWハンドラ関数は、以下で説明するコールバック関数へのポインタを含む、pallocされた<TT
CLASS="STRUCTNAME"
>FdwRoutine</TT
>構造体を返します。
スキャンに関連した関数は必須で、それ以外は省略可能です。
    </P
><P
>     <TT
CLASS="STRUCTNAME"
>FdwRoutine</TT
>構造体は<TT
CLASS="FILENAME"
>src/include/foreign/fdwapi.h</TT
>で宣言されていますので、追加情報はそちらを参照してください。
    </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-SCAN"
>55.2.1. 外部テーブルスキャンのためのFDWルーチン</A
></H2
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
GetForeignRelSize (PlannerInfo *root,
                   RelOptInfo *baserel,
                   Oid foreigntableid);</PRE
><P>

外部テーブルのリレーションサイズ見積もりを取得します。この関数は、ある外部テーブルをスキャンするクエリのプラン作成の開始時に呼び出されます。<TT
CLASS="LITERAL"
>root</TT
>はそのクエリに関するプランナのグローバル情報です。<TT
CLASS="LITERAL"
>baserel</TT
>はそのテーブルに関するプランナの情報です。そして、<TT
CLASS="LITERAL"
>foreigntableid</TT
>はその外部テーブルの<TT
CLASS="STRUCTNAME"
>pg_class</TT
> OIDです。(<TT
CLASS="LITERAL"
>foreigntableid</TT
>はプランナデータ構造体からも取得できますが、手間を省くために明示的に渡されます。)
    </P
><P
>この関数は、制約条件によるフィルタリングも考慮に入れた、そのテーブルスキャンが返すと見込まれる件数に<TT
CLASS="LITERAL"
>baserel-&gt;rows</TT
>を更新するべきです。
<TT
CLASS="LITERAL"
>baserel-&gt;rows</TT
>の初期値は固定のデフォルト見積もりなので、可能な限り置き換えられるべきです。この関数は、行の幅のよりよい見積もりを計算できるのであれば、<TT
CLASS="LITERAL"
>baserel-&gt;width</TT
>を更新することも選択出来ます。
    </P
><P
>追加情報については<A
HREF="fdw-planning.html"
>項55.4</A
>を参照してください。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
GetForeignPaths (PlannerInfo *root,
                 RelOptInfo *baserel,
                 Oid foreigntableid);</PRE
><P>

外部テーブル対するスキャンとしてありえるアクセスパスを作成します。
この関数はクエリのプラン作成中に呼び出されます。
引数は、先に呼ばれている<CODE
CLASS="FUNCTION"
>GetForeignRelSize</CODE
>と同じです。
    </P
><P
>この関数は、少なくとも一つのアクセスパス(<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>ノード)を作成して、それぞれのパスを<TT
CLASS="LITERAL"
>baserel-&gt;pathlist</TT
>に追加するために<CODE
CLASS="FUNCTION"
>add_path</CODE
>を呼ばなければなりません。
<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>ノードを構築するには<CODE
CLASS="FUNCTION"
>create_foreignscan_path</CODE
>を使うことが推奨されています。
この関数は、たとえばソート済みの結果を表現する有効な<TT
CLASS="LITERAL"
>pathkeys</TT
>を持つパスのような複数のアクセスパスを作成することが出来ます。
それぞれのアクセスパスはコスト見積もりを含まねばならず、また意図した特定のスキャン方式を識別するのに必要なFDW固有の情報を持つことが出来ます。
    </P
><P
>追加情報については<A
HREF="fdw-planning.html"
>項55.4</A
>を参照してください。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>ForeignScan *
GetForeignPlan (PlannerInfo *root,
                RelOptInfo *baserel,
                Oid foreigntableid,
                ForeignPath *best_path,
                List *tlist,
                List *scan_clauses,
                Plan *outer_plan);</PRE
><P>

選択された外部アクセスパスから<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノードを作成します。
この関数はクエリプラン作成の最後に呼び出されます。
引数は、<CODE
CLASS="FUNCTION"
>GetForeignRelSize</CODE
>と同じものに、選択された<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>(事前に<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>、<CODE
CLASS="FUNCTION"
>GetForeignJoinPaths</CODE
>または<CODE
CLASS="FUNCTION"
>GetForeignUpperPaths</CODE
>によって作成されたもの)、そのプランノードによって出力されるターゲットリスト、そのプランノードで強制される条件句、および<CODE
CLASS="FUNCTION"
>RecheckForeignScan</CODE
>が実行する再検査で使用される<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>の外側のサブプランが追加されます。
（パスがベースリレーションではなく結合のためのものの場合、<TT
CLASS="LITERAL"
>foreigntableid</TT
>は<TT
CLASS="LITERAL"
>InvalidOid</TT
>になります。）
    </P
><P
>この関数は<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノードを作成して返さなければなりません。<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>ノードを構築するには<CODE
CLASS="FUNCTION"
>make_foreignscan</CODE
>を使うことが推奨されています。
    </P
><P
>追加情報については<A
HREF="fdw-planning.html"
>項55.4</A
>を参照してください。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
BeginForeignScan (ForeignScanState *node,
                  int eflags);</PRE
><P>

外部テーブルスキャンの実行を開始します。
この関数はエグゼキュータの起動中に呼び出されます。
スキャンを開始できるようになる前に、あらゆる必要な初期化を実行するべきですが、実際のスキャンの実行を始めるべきではありません(それは最初の<CODE
CLASS="FUNCTION"
>IterateForeignScan</CODE
>呼び出しにおいて行われるべきです)。
<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
>ノードは作成されていますが、その<TT
CLASS="STRUCTFIELD"
>fdw_state</TT
>フィールドはNULLのままです。
スキャンするテーブルの情報は、<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
>ノード(実際にはその先にある、<CODE
CLASS="FUNCTION"
>PlanForeignScan</CODE
>から返された<TT
CLASS="STRUCTNAME"
>FdwPlan</TT
>構造体へのポインタを含む、<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノード)を通じてアクセス可能です。
<TT
CLASS="LITERAL"
>eflags</TT
>は、このプランノードに関するエグゼキュータの操作モードを表すフラグビットを含みます。
    </P
><P
><TT
CLASS="LITERAL"
>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</TT
>が真の場合、この関数は外部に見える処理を実行すべきではないことに注意してください。
<CODE
CLASS="FUNCTION"
>ExplainForeignScan</CODE
>や<CODE
CLASS="FUNCTION"
>EndForeignScan</CODE
>用にノード状態を有効にするのに必要とされる最小限のことだけをすべきです。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>TupleTableSlot *
IterateForeignScan (ForeignScanState *node);</PRE
><P>

外部ソースから一行を取り出して、それをタプルテーブルスロットに入れて返します(この用途にはnodeの<TT
CLASS="STRUCTFIELD"
>ScanTupleSlot</TT
>を使うべきです)。
利用可能な行がない場合は、NULLを返します。
タプルテーブルスロット機構を使うと、物理タプルと仮想タプルのどちらでも返せます。
ほとんどの場合、パフォーマンスの観点から後者を選ぶのが良いでしょう。
この関数は、呼出しごとにリセットされる短命なメモリコンテキスト内で呼び出されることに注意してください。
より長命なストレージが必要な場合は、<CODE
CLASS="FUNCTION"
>BeginForeignScan</CODE
>でメモリコンテキストを作成するか、ノードの<TT
CLASS="STRUCTNAME"
>EState</TT
>に含まれる<TT
CLASS="STRUCTFIELD"
>es_query_cxt</TT
>を使用してください。
    </P
><P
>返される行は、ターゲットリスト<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>が提供されたなら、それとマッチしなければならず、提供されていない場合はスキャンされている外部テーブルの行型とマッチしなければなりません。
不要な列を取り出さないように最適化することを選ぶなら、それらの列の位置にNULLを入れるか、あるいはそれらの列を除いた<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>リストを生成するべきです。
    </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のエグゼキュータは返された行が外部テーブルに定義された制約に違反しているかどうかは気にしません。
しかし、プランナはそれに着目するので、宣言された制約に反する行が外部テーブル上にあった場合に、不正な最適化をするかもしれません。
ユーザが制約が成り立つと宣言したのに制約に違反した場合は(データ型が一致しなかった場合にする必要があるのと同様に)エラーを発生させるのが適切でしょう。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
ReScanForeignScan (ForeignScanState *node);</PRE
><P>

先頭からスキャンを再開します。
スキャンが依存するいずれかのパラメータが値を変更しているかもしれないので、新しいスキャンが必ずしも厳密に同じ行を返すとは限らないことに注意してください。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
EndForeignScan (ForeignScanState *node);</PRE
><P>

スキャンを終了しリソースを解放します。
通常、pallocされたメモリを解放することは重要ではありませんが、開いたファイルやリモートサーバへの接続などはクリーンアップするべきです。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-JOIN-SCAN"
>55.2.2. 外部テーブルの結合をスキャンするためのFDWルーチン</A
></H2
><P
>FDWが外部テーブルの結合を（両方のテーブルのデータをフェッチして、ローカルで結合するのでなく）リモートで実行することをサポートする場合、次のコールバック関数を提供します。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
GetForeignJoinPaths (PlannerInfo *root,
                     RelOptInfo *joinrel,
                     RelOptInfo *outerrel,
                     RelOptInfo *innerrel,
                     JoinType jointype,
                     JoinPathExtraData *extra);</PRE
><P>
同じ外部サーバにある2つ（またはそれ以上）の外部テーブルの結合のための可能なアクセスパスを作成します。
このオプション関数は、問い合わせの計画時に呼び出されます。
<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>と同じく、この関数は提供された<TT
CLASS="LITERAL"
>joinrel</TT
>のための<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>パスを生成し、<CODE
CLASS="FUNCTION"
>add_path</CODE
>を呼んで、それらのパスを結合のために考慮されるパスの集合に追加します。
しかし、<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>とは異なり、この関数が少なくとも1つのパスの作成に成功することは必要ではありません。
なぜなら、ローカルの結合を含んだパスはいつでも可能だからです。
    </P
><P
>この関数は、同じ結合のリレーションに対して、内側と外側のリレーションの異なる組み合わせで繰り返し呼び出されることに注意して下さい。
同じ作業の繰り返しを最小化することはFDWの責任です。
    </P
><P
><TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>パスが結合のために選択されると、それは結合プロセス全体を代表することになり、構成テーブルとその関連の結合のために生成されたパスは使われなくなります。
結合パスの以降の処理は、単一の外部テーブルをスキャンするパスとほぼ同様に進みます。
1つの相違点は、結果として作られる<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>計画ノードの<TT
CLASS="STRUCTFIELD"
>scanrelid</TT
>が0にセットされるべき、ということで、これはそれが表現する単一のリレーションがないためです。
その代わりに、<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>ノードの<TT
CLASS="STRUCTFIELD"
>fs_relids</TT
>フィールドが結合されるリレーションの集合を表します。
（後者のフィールドはコアのプランナのコードによって自動的にセットされるので、FDWによって設定される必要はありません。）
他の相違点は、リモートの結合についての列リストがシステムカタログにはないため、FDWは<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>に適切な<TT
CLASS="STRUCTFIELD"
>TargetEntry</TT
>ノードのリストを入れて、実行時に返されるタプル内の列の集合を表すようにしなければならないということです。
    </P
><P
>追加情報については<A
HREF="fdw-planning.html"
>項55.4</A
>を参照してください。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-UPPER-PLANNING"
>55.2.3. スキャン/結合後の処理をプラン生成するためのFDWルーチン</A
></H2
><P
>FDWがリモート集約など、リモートでのスキャン/結合後の処理をサポートする場合、次のコールバック関数を提供します。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
GetForeignUpperPaths (PlannerInfo *root,
                      UpperRelationKind stage,
                      RelOptInfo *input_rel,
                      RelOptInfo *output_rel);</PRE
><P>
<I
CLASS="FIRSTTERM"
>上位リレーション</I
>処理のための、ありうるアクセスパスを作成します。上位リレーションはプランナ用語で、ウィンドウ関数、ソート、テーブル更新など、全てのスキャン/結合後の問い合わせのことです。
この省略可能な関数は問い合わせのプラン作成時に呼ばれます。
今のところ、これは問い合わせに含まれる全てのベースリレーションが同じFDWに属する場合だけ呼ばれます。
この関数では、FDWがどのようにリモートで実行するか分かっている全てのスキャン/結合後の処理に<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>パスを生成し、それらパスを指定された上位リレーションに加えるために<CODE
CLASS="FUNCTION"
>add_path</CODE
>を呼び出してください。
<CODE
CLASS="FUNCTION"
>GetForeignJoinPaths</CODE
>の時と同様に、この関数が何らかのパス作成に成功する必要はありません。なぜなら、ローカル処理を含んでいるパスはいつでも可能だからです。
    </P
><P
><TT
CLASS="LITERAL"
>stage</TT
>パラメータはどのスキャン/結合後の処理が現在考慮されているかを定めます。
<TT
CLASS="LITERAL"
>output_rel</TT
>は本処理の計算方法をあらわすパスを受け取るであろう上位リレーションで、<TT
CLASS="LITERAL"
>input_rel</TT
>は本処理への入力をあらわすリレーションです。
（注意：これらの処理は外部で実行されると考えられるため、<TT
CLASS="LITERAL"
>output_rel</TT
>に加えられる<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>パスは、一般的に<TT
CLASS="LITERAL"
>input_rel</TT
>のパスへの直接の依存を全く持たないでしょう。
しかしながら、手前の処理段階のために以前に生成されたパスを検査することは、冗長なプラン作成活動を回避するのに役立ちます。）
    </P
><P
>追加情報については<A
HREF="fdw-planning.html"
>項55.4</A
>を参照してください。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-UPDATE"
>55.2.4. 外部テーブル更新のためのFDWルーチン</A
></H2
><P
>もしFDWが更新可能な外部テーブルをサポートする場合、FDWのニーズと能力に応じて、以下のコールバック関数の一部または全てを提供する必要があります。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
AddForeignUpdateTargets (Query *parsetree,
                         RangeTblEntry *target_rte,
                         Relation target_relation);</PRE
><P>

<TT
CLASS="COMMAND"
>UPDATE</TT
>と<TT
CLASS="COMMAND"
>DELETE</TT
>の操作は、テーブルスキャン関数によって事前にフェッチされた行に対して実行されます。
FDWは、更新や削除の対象行を厳密に識別できるように行IDや主キー列の値といった追加情報を必要とするかもしれません。
それをサポートするために、この関数は<TT
CLASS="COMMAND"
>UPDATE</TT
>や<TT
CLASS="COMMAND"
>DELETE</TT
>の間に外部テーブルから取得される列のリストに追加の隠された(または<SPAN
CLASS="QUOTE"
>"ジャンクの"</SPAN
>)ターゲット列を追加することができます。
    </P
><P
>これを実行するには、フェッチする追加の値の式を含む<TT
CLASS="STRUCTNAME"
>TargetEntry</TT
>エントリを<TT
CLASS="LITERAL"
>parsetree-&gt;targetList</TT
>に追加します。
それぞれのエントリは<TT
CLASS="STRUCTFIELD"
>resjunk</TT
> = <TT
CLASS="LITERAL"
>true</TT
>とマークされなければならず、また実行時にエントリを識別できる異なる<TT
CLASS="STRUCTFIELD"
>resname</TT
>を持つ必要があります。
コアシステムがそのような名前のジャンク列を生成できるように、<TT
CLASS="LITERAL"
>ctid<TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
></TT
>や<TT
CLASS="LITERAL"
>wholerow</TT
>、<TT
CLASS="LITERAL"
>wholerow<TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
></TT
>と一致する名前は使用しないでください。
    </P
><P
>この関数はプランナでなくリライタで呼ばれるので、利用可能な情報はプラン生成ルーチンで利用可能なものとは少し異なります。
<TT
CLASS="LITERAL"
>parsetree</TT
>は<TT
CLASS="COMMAND"
>UPDATE</TT
>や<TT
CLASS="COMMAND"
>DELETE</TT
>コマンドのパース木で、<TT
CLASS="LITERAL"
>target_rte</TT
>と<TT
CLASS="LITERAL"
>target_relation</TT
>は対象の外部テーブルを表します。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>AddForeignUpdateTargets</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、追加のターゲット式は追加されません。
(FDWが行を識別するのに不変の主キーに依存するのであれば<TT
CLASS="COMMAND"
>UPDATE</TT
>は依然として実現可能かもしれませんが、<TT
CLASS="COMMAND"
>DELETE</TT
>操作を実装することは不可能になるでしょう。)
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>List *
PlanForeignModify (PlannerInfo *root,
                   ModifyTable *plan,
                   Index resultRelation,
                   int subplan_index);</PRE
><P>

外部テーブルに対する挿入、更新、削除に必要となる、追加のプラン生成アクションを実行します。
この関数は、更新処理を実行する<TT
CLASS="STRUCTNAME"
>ModifyTable</TT
>プランノードに追加されるFDW固有の情報を生成します。この固有情報は<TT
CLASS="LITERAL"
>List</TT
>形式でなければならず、また実行段階の間に<CODE
CLASS="FUNCTION"
>BeginForeignModify</CODE
>に渡されます。
    </P
><P
><TT
CLASS="LITERAL"
>root</TT
>はそのクエリに関するプランナのグローバル情報です。
<TT
CLASS="LITERAL"
>plan</TT
>は<TT
CLASS="STRUCTFIELD"
>fdwPrivLists</TT
>フィールドを除いて完成している<TT
CLASS="STRUCTNAME"
>ModifyTable</TT
>プランノードです。
<TT
CLASS="LITERAL"
>resultRelation</TT
>は対象の外部テーブルをレンジテーブルの添字で識別します。
<TT
CLASS="LITERAL"
>subplan_index</TT
>は<TT
CLASS="STRUCTNAME"
>ModifyTable</TT
>プランノードの対象がどれであるかを0始まりで識別します。この情報は<TT
CLASS="LITERAL"
>plan-&gt;plans</TT
>などの<TT
CLASS="LITERAL"
>plan</TT
>の下位構造を指定したい場合に使用してください。
    </P
><P
>追加情報は<A
HREF="fdw-planning.html"
>項55.4</A
>を参照してください。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>AddForeignUpdateTargets</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、追加のプラン作成時処理は実行されず、<CODE
CLASS="FUNCTION"
>BeginForeignModify</CODE
>に渡される<TT
CLASS="LITERAL"
>fdw_private</TT
>リストはNILになります。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
BeginForeignModify (ModifyTableState *mtstate,
                    ResultRelInfo *rinfo,
                    List *fdw_private,
                    int subplan_index,
                    int eflags);</PRE
><P>

外部テーブルへの変更操作の実行を開始します。
このルーチンはエグゼキュータの起動中に呼び出されます。
実際のテーブル変更に先立って必要なあらゆる初期化処理を実行する必要があります。
その後、各タプルが挿入、更新、削除されるように<CODE
CLASS="FUNCTION"
>ExecForeignInsert</CODE
>、<CODE
CLASS="FUNCTION"
>ExecForeignUpdate</CODE
>、<CODE
CLASS="FUNCTION"
>ExecForeignDelete</CODE
>のいずれかが呼ばれます。
    </P
><P
><TT
CLASS="LITERAL"
>mtstate</TT
>は実行されている<TT
CLASS="STRUCTNAME"
>ModifyTable</TT
>プランノード全体の状態です。プランに関する全般的なデータと実行状態はこの構造体経由で利用可能です。
<TT
CLASS="LITERAL"
>rinfo</TT
>は対象の外部テーブルを表す<TT
CLASS="STRUCTNAME"
>ResultRelInfo</TT
>構造体です。(<TT
CLASS="STRUCTNAME"
>ResultRelInfo</TT
>の<TT
CLASS="STRUCTFIELD"
>ri_FdwState</TT
>フィールドはこの操作で必要となる固有の状態をFDWが格納するのに利用できます。)
<TT
CLASS="LITERAL"
>fdw_private</TT
>はもしあれば<CODE
CLASS="FUNCTION"
>PlanForeignModify</CODE
>で生成された固有データを含みます。
<TT
CLASS="LITERAL"
>eflags</TT
>は、このプランノードに関するエグゼキュータの操作モードを表すフラグビットを含みます。
    </P
><P
><TT
CLASS="LITERAL"
>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</TT
>が真の場合、この関数は外部に見える処理を実行すべきではないことに注意してください。
<CODE
CLASS="FUNCTION"
>ExplainForeignModify</CODE
>や<CODE
CLASS="FUNCTION"
>EndForeignModify</CODE
>用にノード状態を有効にするのに必要な最小限のことだけを実行するべきです。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>BeginForeignModify</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、エグゼキュータ起動時には追加処理は何も実行されません。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>TupleTableSlot *
ExecForeignInsert (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</PRE
><P>

外部テーブルにタプルを一つ挿入します。
<TT
CLASS="LITERAL"
>estate</TT
>はそのクエリのグローバルな実行状態です。
<TT
CLASS="LITERAL"
>rinfo</TT
>は対象の外部テーブルを表す<TT
CLASS="STRUCTNAME"
>ResultRelInfo</TT
>構造体です。
<TT
CLASS="LITERAL"
>slot</TT
>には挿入されるタプルが含まれます。その行型定義は外部テーブルと一致します。
<TT
CLASS="LITERAL"
>planSlot</TT
>には<TT
CLASS="STRUCTNAME"
>ModifyTable</TT
>プランノードのサブプランが生成したタプルが含まれます。追加の<SPAN
CLASS="QUOTE"
>"ジャンク"</SPAN
>列を含みうる点において、<TT
CLASS="LITERAL"
>slot</TT
>とは異なります。(<TT
CLASS="LITERAL"
>planSlot</TT
>は一般的に<TT
CLASS="COMMAND"
>INSERT</TT
>のケースにおいてはそれほど意味を持ちませんが、完全さのために提供されます。)
    </P
><P
>戻り値は実際に挿入されたデータ(例えばトリガー処理の結果などにより、提供されたデータとは異なるかもしれません)を含むスロットか、または(こちらも一般的にトリガーの結果)実際には挿入されなかった場合はNULLです。
渡された<TT
CLASS="LITERAL"
>slot</TT
>はこの用途に再利用可能です。
    </P
><P
>返却されたスロット内のデータは<TT
CLASS="COMMAND"
>INSERT</TT
>クエリが<TT
CLASS="LITERAL"
>RETURNING</TT
>句を持っていた場合もしくは外部テーブルが<TT
CLASS="LITERAL"
>AFTER ROW</TT
>トリガを持っていた場合にのみ使われます。
トリガは全列を必要としますが、FDWは<TT
CLASS="LITERAL"
>RETURNING</TT
>句の内容に応じて返却する列を一部にするかすべてにするかを最適化する余地があります。
それとは関係なく、処理成功を表すためになんらかのスロットは返却しなければなりません。さもないと、報告されるクエリの結果行数が誤った値になってしまいます。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>ExecForeignInsert</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、外部テーブルへの挿入の試みはエラーメッセージとともに失敗します。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>TupleTableSlot *
ExecForeignUpdate (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</PRE
><P>

外部テーブル内のタプルを一つ更新します。
<TT
CLASS="LITERAL"
>estate</TT
>はそのクエリのグローバルな実行状態です。
<TT
CLASS="LITERAL"
>rinfo</TT
>は対象の外部テーブルを表す<TT
CLASS="STRUCTNAME"
>ResultRelInfo</TT
>構造体です。
<TT
CLASS="LITERAL"
>slot</TT
>にはタプルの新しいデータが含まれます。その行型定義は外部テーブルと一致します。
<TT
CLASS="LITERAL"
>planSlot</TT
>には<TT
CLASS="STRUCTNAME"
>ModifyTable</TT
>プランノードのサブプランが生成したタプルが含まれます。追加の<SPAN
CLASS="QUOTE"
>"ジャンク"</SPAN
>列を含みうる点において、<TT
CLASS="LITERAL"
>slot</TT
>とは異なります。実際、<CODE
CLASS="FUNCTION"
>AddForeignUpdateTargets</CODE
>が要求するジャンク列はこのスロットから利用可能です。
    </P
><P
>戻り値は実際に更新されたデータ(例えばトリガー処理の結果などにより、提供されたデータとは異なるかもしれません)を含むスロットか、または(こちらも一般的にトリガーの結果)実際には更新されなかった場合はNULLです。
渡された<TT
CLASS="LITERAL"
>slot</TT
>はこの用途に再利用可能です。
    </P
><P
>返却されたスロット内のデータは<TT
CLASS="COMMAND"
>UPDATE</TT
>クエリが<TT
CLASS="LITERAL"
>RETURNING</TT
>句を持っていた場合もしくは外部テーブルが<TT
CLASS="LITERAL"
>AFTER ROW</TT
>トリガを持っていた場合にのみ使われます。
トリガは全列を必要としますが、FDWは<TT
CLASS="LITERAL"
>RETURNING</TT
>句の内容に応じて返却する列を一部にするか全てにするかを最適化する余地があります。
それとは関係なく、処理成功を表すためになんらかのスロットは返却しなければなりません。さもないと、報告されるクエリの結果行数が誤った値になってしまいます。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>ExecForeignUpdate</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、外部テーブルへの更新の試みはエラーメッセージとともに失敗します。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>TupleTableSlot *
ExecForeignDelete (EState *estate,
                   ResultRelInfo *rinfo,
                   TupleTableSlot *slot,
                   TupleTableSlot *planSlot);</PRE
><P>

外部テーブルからタプルを一つ削除します。
<TT
CLASS="LITERAL"
>estate</TT
>はそのクエリのグローバルな実行状態です。
<TT
CLASS="LITERAL"
>rinfo</TT
>は対象の外部テーブルを表す<TT
CLASS="STRUCTNAME"
>ResultRelInfo</TT
>構造体です。
<TT
CLASS="LITERAL"
>slot</TT
>にはタプルの新しいデータが含まれます。その行型定義は外部テーブルと一致します。
<TT
CLASS="LITERAL"
>planSlot</TT
>には<TT
CLASS="STRUCTNAME"
>ModifyTable</TT
>プランノードのサブプランが生成したタプルが含まれます。実際、<CODE
CLASS="FUNCTION"
>AddForeignUpdateTargets</CODE
>が要求するジャンク列はこのスロットが運びます。ジャンク列は削除されるタプルを識別するために使用しなければなりません。
    </P
><P
>戻り値は実際に削除されたデータを含むスロットか、または(一般的にトリガーの結果)実際には削除されなかった場合はNULLです。
渡された<TT
CLASS="LITERAL"
>slot</TT
>は返却するタプルを保持する用途に利用可能です。
    </P
><P
>返却されたスロット内のデータは<TT
CLASS="COMMAND"
>DELETE</TT
>クエリが<TT
CLASS="LITERAL"
>RETURNING</TT
>句を持っていた場合もしくは外部テーブルが<TT
CLASS="LITERAL"
>AFTER ROW</TT
>トリガを持っていた場合にのみ使われます。
トリガは全列を必要としますが、FDWは<TT
CLASS="LITERAL"
>RETURNING</TT
>句の内容に応じて返却する列を一部にするか全てにするかを最適化する余地があります。
それとは関係なく、処理成功を表すためになんらかのスロットは返却しなければなりません。さもないと、報告されるクエリの結果行数が誤った値になってしまいます。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>ExecForeignDelete</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、外部テーブルからの削除の試みはエラーメッセージとともに失敗します。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
EndForeignModify (EState *estate,
                  ResultRelInfo *rinfo);</PRE
><P>

テーブル更新を終えてリソースを解放します。pallocされたメモリの解放は通常重要ではありませんが、開いたファイルやリモートサーバへの接続はクリーンアップするべきです。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>EndForeignModify</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、エグゼキュータ終了時には追加処理は何も実行されません。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>int
IsForeignRelUpdatable (Relation rel);</PRE
><P>

指定された外部テーブルがどの更新処理をサポートしているかを報告します。
戻り値は、その外部テーブルがサポートする操作を表すルールイベント番号のビットマスクである必要があります。
<TT
CLASS="COMMAND"
>UPDATE</TT
>用の<TT
CLASS="LITERAL"
>(1 &#60;&#60; CMD_UPDATE) = 4</TT
>、<TT
CLASS="COMMAND"
>INSERT</TT
>用の<TT
CLASS="LITERAL"
>(1 &#60;&#60; CMD_INSERT) = 8</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>用の<TT
CLASS="LITERAL"
>(1 &#60;&#60; CMD_DELETE) = 16</TT
>といった<TT
CLASS="LITERAL"
>CmdType</TT
>列挙値を使います。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>IsForeignRelUpdatable</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されていると、外部テーブルは<CODE
CLASS="FUNCTION"
>ExecForeignInsert</CODE
>、<CODE
CLASS="FUNCTION"
>ExecForeignUpdate</CODE
>、<CODE
CLASS="FUNCTION"
>ExecForeignDelete</CODE
>を提供していると、それぞれ挿入、更新、削除をサポートしていると判断します。
この関数は、FDWが一部のテーブルについてのみ更新をサポートする場合にのみ必要です。
(そのような場合でも、この関数でチェックする代わりにクエリ実行関数でエラーにしても構いません。しかしながら、この関数は<TT
CLASS="LITERAL"
>information_schema</TT
>のビューの表示で更新可否を判定するのに使用されます。)
    </P
><P
>外部テーブルへの挿入、更新、削除は、代替インターフェイス一式を実装することで最適化できます。
通常の挿入、更新、削除のインターフェイスは行をリモートサーバから取得し、その後、それらの行を一つずつ変更します。
一部の場合にはこの一行ごとのやり方は必要ですが、非効率とも言えます。
外部サーバについて行が本当はそれらを引き出すことなしに変更されるべきと判断できて、操作に影響を与えるローカルトリガーが無いならば、操作全体がリモートサーバで実行されるように計画することができます。
以下に示すインターフェイスはこれを可能にします。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>bool
PlanDirectModify (PlannerInfo *root,
                  ModifyTable *plan,
                  Index resultRelation,
                  int subplan_index);</PRE
><P>

リモートサーバ上で直接変更を実行することが安全かを判断します。
そうであれば、そのために必要なプラン作成の動作を実行した後に<TT
CLASS="LITERAL"
>true</TT
>を返します。
さもなくば、<TT
CLASS="LITERAL"
>false</TT
>を返します。
この省略可能な関数は問い合わせのプラン作成時に呼ばれます。
この関数が成功すると、<CODE
CLASS="FUNCTION"
>BeginDirectModify</CODE
>、<CODE
CLASS="FUNCTION"
>IterateDirectModify</CODE
>、<CODE
CLASS="FUNCTION"
>EndDirectModify</CODE
>が実行段階で代わりに呼び出されます。
成功しなければ、テーブルの変更は前述のテーブル更新関数を使って実行されます。
パラメータは<CODE
CLASS="FUNCTION"
>PlanForeignModify</CODE
>に対するものと同じです。
    </P
><P
>リモートサーバで直接変更を実行するには、本関数は対象サブプランをリモートサーバ上で直接変更する<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノードで書き換えしなければなりません。
<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>の<TT
CLASS="STRUCTFIELD"
>operation</TT
>フィールドには<TT
CLASS="LITERAL"
>CmdType</TT
>列挙値を適切に、すなわち、<TT
CLASS="COMMAND"
>UPDATE</TT
>には<TT
CLASS="LITERAL"
>CMD_UPDATE</TT
>、<TT
CLASS="COMMAND"
>INSERT</TT
>には<TT
CLASS="LITERAL"
>CMD_INSERT</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>には<TT
CLASS="LITERAL"
>CMD_DELETE</TT
>を設定しなければいけません。
    </P
><P
>追加情報は<A
HREF="fdw-planning.html"
>項55.4</A
>を参照してください。
    </P
><P
><CODE
CLASS="FUNCTION"
>PlanDirectModify</CODE
>ポインタに<TT
CLASS="LITERAL"
>NULL</TT
>が設定されている場合、
リモートサーバでの直接変更の実行は試みられません。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
BeginDirectModify (ForeignScanState *node,
                   int eflags);</PRE
><P>

リモートサーバでの直接変更を実行する準備をします。
この関数はエグゼキュータが開始するときに呼び出されます。
この関数は（最初の<CODE
CLASS="FUNCTION"
>IterateDirectModify</CODE
>呼び出しで実行されるであろう）直接変更より前に必要とされる全ての初期化を実行するべきです。
<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
>ノードはすでに作られていますが、<TT
CLASS="STRUCTFIELD"
>fdw_state</TT
>がフィールドはまだNULLです。
変更するテーブルに関する情報は<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
>ノードを通して（具体的には<CODE
CLASS="FUNCTION"
>PlanDirectModify</CODE
>で提供されるFDWプライベート情報を含む、元となる<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノードから）入手可能です。
<TT
CLASS="LITERAL"
>eflags</TT
>は、このプランノードに関するエグゼキュータの操作モードを表すフラグビットを含みます。
    </P
><P
><TT
CLASS="LITERAL"
>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</TT
>が真の場合、この関数は外部に見える処理を実行すべきではないことに注意してください。
<CODE
CLASS="FUNCTION"
>ExplainDirectModify</CODE
>や<CODE
CLASS="FUNCTION"
>EndDirectModify</CODE
>用にノード状態を有効にするのに必要な最小限のことだけを実行するべきです。
    </P
><P
><CODE
CLASS="FUNCTION"
>BeginDirectModify</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合、リモートサーバでの直接変更の実行は試みられません。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>TupleTableSlot *
IterateDirectModify (ForeignScanState *node);</PRE
><P>

<TT
CLASS="COMMAND"
>INSERT</TT
>、<TT
CLASS="COMMAND"
>UPDATE</TT
>、または、<TT
CLASS="COMMAND"
>DELETE</TT
>の問い合わせが<TT
CLASS="LITERAL"
>RETURNING</TT
>句を持たないときには、リモートサーバでの直接変更の後、単にNULLが返ります。
問い合わせが<TT
CLASS="LITERAL"
>RETURNING</TT
>句を持つときには、<TT
CLASS="LITERAL"
>RETURNING</TT
>計算に必要なデータを含む結果を一つ取り出し、タプルテーブルスロットでそれを返します（この用途にはノードの<TT
CLASS="STRUCTFIELD"
>ScanTupleSlot</TT
>を使うべきです）。
実際に挿入、更新、削除されたデータはノードの<TT
CLASS="STRUCTNAME"
>EState</TT
>の<TT
CLASS="LITERAL"
>es_result_relation_info-&gt;ri_projectReturning-&gt;pi_exprContext-&gt;ecxt_scantuple</TT
>に格納されなければなりません。
有効な行がそれ以上なければNULLを返します。
これは呼び出しの間でリセットされる寿命の短いメモリコンテキストで呼び出されることに注意してください。
より長命な格納場所を必要とするなら、<CODE
CLASS="FUNCTION"
>BeginDirectModify</CODE
>でメモリコンテキストを作るか、ノードの<TT
CLASS="STRUCTNAME"
>EState</TT
>の<TT
CLASS="STRUCTFIELD"
>es_query_cxt</TT
>を使ってください。
    </P
><P
>返される行は、ターゲットリスト<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>が提供されたなら、それとマッチしなければならず、提供されていない場合は変更されている外部テーブルの行型とマッチしなければなりません。
<TT
CLASS="LITERAL"
>RETURNING</TT
>計算に不要な列を取り出さないように最適化することを選ぶなら、それらの列の位置にNULLを入れるか、あるいはそれらの列を除いた<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>リストを生成するべきです。
    </P
><P
>問い合わせが<TT
CLASS="LITERAL"
>RETURNING</TT
>句をもつかどうかによらず、問い合わせが報告する行数はFDW自身によって増加されなければなりません。
問い合わせが<TT
CLASS="LITERAL"
>RETURNING</TT
>句を持たないときも、FDWは<TT
CLASS="COMMAND"
>EXPLAIN ANALYZE</TT
>の場合の<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
> nodeむけに行数を増加させなければなりません。
    </P
><P
><CODE
CLASS="FUNCTION"
>IterateDirectModify</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合、リモートサーバでの直接変更の実行は試みられません。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
EndDirectModify (ForeignScanState *node);</PRE
><P>

リモートサーバでの直接変更の後、クリーンアップします。
pallocされたメモリの解放は通常重要ではありませんが、開いたファイルやリモートサーバへの接続はクリーンアップするべきです。
    </P
><P
><CODE
CLASS="FUNCTION"
>EndDirectModify</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合、リモートサーバでの直接変更の実行は試みられません。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-ROW-LOCKING"
>55.2.5. 行ロックのためのFDWルーチン</A
></H2
><P
>FDWが（<A
HREF="fdw-row-locking.html"
>項55.5</A
>で説明される）<I
CLASS="FIRSTTERM"
>遅延行ロック</I
>をサポートする場合は、以下のコールバック関数を提供する必要があります。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>RowMarkType
GetForeignRowMarkType (RangeTblEntry *rte,
                       LockClauseStrength strength);</PRE
><P>

行の印付けでどのオプションを外部テーブルに使うかを報告します。
<TT
CLASS="LITERAL"
>rte</TT
>はテーブルの<TT
CLASS="STRUCTNAME"
>RangeTblEntry</TT
>ノードで、<TT
CLASS="LITERAL"
>strength</TT
>は関連する<TT
CLASS="LITERAL"
>FOR UPDATE/SHARE</TT
>句があれば、それが要求するロックの強さを表します。
その結果は、<TT
CLASS="LITERAL"
>RowMarkType</TT
>列挙型のメンバーでなければなりません。
    </P
><P
>この関数は<TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>、<TT
CLASS="COMMAND"
>SELECT FOR UPDATE/SHARE</TT
>の問い合わせに現れ、かつ<TT
CLASS="COMMAND"
>UPDATE</TT
>あるいは<TT
CLASS="COMMAND"
>DELETE</TT
>の対象ではない各外部テーブルについて、問い合わせの計画時に呼び出されます。
    </P
><P
><CODE
CLASS="FUNCTION"
>GetForeignRowMarkType</CODE
>のポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されていると、必ず<TT
CLASS="LITERAL"
>ROW_MARK_COPY</TT
>オプションが使われます。
（これは<CODE
CLASS="FUNCTION"
>RefetchForeignRow</CODE
>が決して呼び出されないので、それを提供する必要もない、ということを意味します。）
    </P
><P
>さらなる情報については<A
HREF="fdw-row-locking.html"
>項55.5</A
>を参照してください。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>HeapTuple
RefetchForeignRow (EState *estate,
                   ExecRowMark *erm,
                   Datum rowid,
                   bool *updated);</PRE
><P>

必要ならロックした後で、外部テーブルから1つのタプルを再フェッチします。
<TT
CLASS="LITERAL"
>estate</TT
>は問い合わせのグローバルな実行状態です。
<TT
CLASS="LITERAL"
>erm</TT
>は対象の外部テーブルおよび獲得する行ロックの種別（あれば）を記述する<TT
CLASS="STRUCTNAME"
>ExecRowMark</TT
>構造体です。
<TT
CLASS="LITERAL"
>rowid</TT
>はフェッチするタプルを特定するものです。
<TT
CLASS="LITERAL"
>updated</TT
>は出力パラメータです。
    </P
><P
>この関数は、フェッチしたタプルをpallocして複製したものを返すか、あるいは行ロックが取得できなければ<TT
CLASS="LITERAL"
>NULL</TT
>を返します。
獲得する行ロックの種別は<TT
CLASS="LITERAL"
>erm-&gt;markType</TT
>で指定されますが、この値は事前に<CODE
CLASS="FUNCTION"
>GetForeignRowMarkType</CODE
>から返されたものです。
（<TT
CLASS="LITERAL"
>ROW_MARK_REFERENCE</TT
>は行のロックを獲得せずに、単にタプルを再フェッチすることを意味し、また、<TT
CLASS="LITERAL"
>ROW_MARK_COPY</TT
>はこのルーチンで使われることはありません。）
    </P
><P
>そして、<TT
CLASS="LITERAL"
>*updated</TT
>はフェッチしたタプルが、以前に取得したものと同じではなく、更新されたバージョンであったときに<TT
CLASS="LITERAL"
>true</TT
>にセットされます。
（どちらなのかFDWが判断できない場合は、<TT
CLASS="LITERAL"
>true</TT
>を返すことが推奨されます）。
    </P
><P
>デフォルトでは、行ロックの獲得に失敗したときはエラーを発生させるべきであることに注意してください。
<TT
CLASS="LITERAL"
>NULL</TT
>を返すのが適切なのは、<TT
CLASS="LITERAL"
>erm-&gt;waitPolicy</TT
>で<TT
CLASS="LITERAL"
>SKIP LOCKED</TT
>オプションが指定されている場合だけです。
    </P
><P
><TT
CLASS="LITERAL"
>rowid</TT
>は、再フェッチする行を以前読んだ時の<TT
CLASS="STRUCTFIELD"
>ctid</TT
>値です。
<TT
CLASS="LITERAL"
>rowid</TT
>値は<TT
CLASS="TYPE"
>Datum</TT
>として渡されますが、現在は<TT
CLASS="TYPE"
>tid</TT
>にしかなりません。
将来は行ID以外のデータ型が可能になることを期待して、関数APIとすることが選択されました。
    </P
><P
><CODE
CLASS="FUNCTION"
>RefetchForeignRow</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>の場合、行を再フェッチする試みは失敗し、エラーメッセージを発行します。
    </P
><P
>さらなる情報については<A
HREF="fdw-row-locking.html"
>項55.5</A
>を参照してください。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>bool
RecheckForeignScan (ForeignScanState *node, TupleTableSlot *slot);</PRE
><P>
以前に戻されたタプルが、関連するスキャンおよび結合の制約とまだ一致しているか再検査し、更新されたバージョンのタプルを提供する場合もあります。
結合のプッシュダウンを行わない外部データラッパでは、通常は、これを<TT
CLASS="LITERAL"
>NULL</TT
>にセットし、代わりに<TT
CLASS="STRUCTFIELD"
>fdw_recheck_quals</TT
>を適切にセットする方が便利でしょう。
しかし、外部結合をプッシュダウンする場合、すべてのベーステーブルに関する検査を結果のタプルに適用するだけでは、たとえすべての必要な属性がそこにあったとしても十分ではありません。
なぜなら一部の制約が一致しないことで、タプルが戻されない代わりに、一部の属性がNULLになってしまうかもしれないからです。
<TT
CLASS="LITERAL"
>RecheckForeignScan</TT
>制約を再検査し、それが依然として満たされていれば真を、そうでなければ偽を返すことができます。
それだけでなく、置換されたタプルを提供されたスロットに格納することもできます。
    </P
><P
>結合のプッシュダウンを実装する場合、外部データラッパは通常、再検査のためだけに使用される代替のローカル結合プランを構築します。
これが<TT
CLASS="LITERAL"
>ForeignScan</TT
>の外部サブプランとなります。
再検査が必要な時は、このサブプランを実行して、結果のタプルをスロットに格納することができます。
どのベーステーブルも最大で1行しか返さないので、このプランは効率的である必要はありません。
例えば、すべての結合をネステッドループで実装することもできます。
関数<TT
CLASS="LITERAL"
>GetExistingLocalJoinPath</TT
>は、存在するパスから代替ローカルの結合プランとして使用可能な適当なローカル結合パスを検索するのに使われるかもしれません。
<TT
CLASS="LITERAL"
>GetExistingLocalJoinPath</TT
>は指定された結合リレーションのパスリストのパラメータ化されていないパスを検索します。
（そのようなパスが見つからなかった場合はNULLを返します。この場合、外部データラッパはそれ自身によりローカルパスを構築するかもしれず、あるいは、その結合むけのアクセスパスを作らないことを選択するかもしれません。）
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-EXPLAIN"
>55.2.6. <TT
CLASS="COMMAND"
>EXPLAIN</TT
>のためのFDWルーチン</A
></H2
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
ExplainForeignScan (ForeignScanState *node,
                    ExplainState *es);</PRE
><P>

外部テーブルスキャンの追加の<TT
CLASS="COMMAND"
>EXPLAIN</TT
>出力を表示します。
<TT
CLASS="COMMAND"
>EXPLAIN</TT
>出力にフィールドを追加するために<CODE
CLASS="FUNCTION"
>ExplainPropertyText</CODE
>や関連する関数を呼び出すことができます。
<TT
CLASS="LITERAL"
>es</TT
>の中のフラグフィールドは何を表示するかを決めるのに使用できます。また、<TT
CLASS="COMMAND"
>EXPLAIN ANALYZE</TT
>の場合には、実行時統計情報を提供するために<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
>ノードの状態を調べることができます。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>ExplainForeignScan</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、<TT
CLASS="COMMAND"
>EXPLAIN</TT
>中に追加情報は表示されません。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
ExplainForeignModify (ModifyTableState *mtstate,
                      ResultRelInfo *rinfo,
                      List *fdw_private,
                      int subplan_index,
                      struct ExplainState *es);</PRE
><P>

外部テーブル更新の追加の<TT
CLASS="COMMAND"
>EXPLAIN</TT
>出力を表示します。
<TT
CLASS="COMMAND"
>EXPLAIN</TT
>出力にフィールドを追加するために<CODE
CLASS="FUNCTION"
>ExplainPropertyText</CODE
>や関連する関数を呼び出すことができます。
<TT
CLASS="LITERAL"
>es</TT
>の中のフラグフィールドは何を表示するかを決めるのに使用できます。また、<TT
CLASS="COMMAND"
>EXPLAIN ANALYZE</TT
>の場合には、実行時統計情報を提供するために<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
>ノードの状態を調べることができます。
最初の4つの引数は<CODE
CLASS="FUNCTION"
>BeginForeignModify</CODE
>と同じです。
    </P
><P
>もし<CODE
CLASS="FUNCTION"
>ExplainForeignModify</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、<TT
CLASS="COMMAND"
>EXPLAIN</TT
>中に追加情報は表示されません。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
ExplainDirectModify (ForeignScanState *node,
                     ExplainState *es);</PRE
><P>

リモートサーバでの直接変更について追加<TT
CLASS="COMMAND"
>EXPLAIN</TT
>出力を表示します。
この関数は<TT
CLASS="COMMAND"
>EXPLAIN</TT
>出力にフィールドを加えるために<CODE
CLASS="FUNCTION"
>ExplainPropertyText</CODE
>と関連の関数を呼ぶことができます。
<TT
CLASS="LITERAL"
>es</TT
>の中のフラグフィールドは何を表示するかを決めるのに使用できます。また、<TT
CLASS="COMMAND"
>EXPLAIN ANALYZE</TT
>の場合には、実行時統計情報を提供するために<TT
CLASS="STRUCTNAME"
>ForeignScanState</TT
>ノードの状態を調べることができます。
    </P
><P
><CODE
CLASS="FUNCTION"
>ExplainForeignScan</CODE
>ポインタが<TT
CLASS="LITERAL"
>NULL</TT
>に設定されている場合は、<TT
CLASS="COMMAND"
>EXPLAIN</TT
>中に追加情報は表示されません。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-ANALYZE"
>55.2.7. <TT
CLASS="COMMAND"
>ANALYZE</TT
>のためのFDWルーチン</A
></H2
><P
></P><PRE
CLASS="PROGRAMLISTING"
>bool
AnalyzeForeignTable (Relation relation,
                     AcquireSampleRowsFunc *func,
                     BlockNumber *totalpages);</PRE
><P>

この関数は<A
HREF="sql-analyze.html"
>ANALYZE</A
>が外部テーブルに対して実行されたときに呼び出されます。
もしFDWがこの外部テーブルの統計情報を収集できる場合は、そのテーブルからサンプル行を集める関数のポインタとページ単位でのテーブルサイズの見積もりをそれぞれ<TT
CLASS="PARAMETER"
>func</TT
>と<TT
CLASS="PARAMETER"
>totalpages</TT
>に渡し<TT
CLASS="LITERAL"
>true</TT
>を返す必要があります。
そうでない場合は、<TT
CLASS="LITERAL"
>false</TT
>を返します。
    </P
><P
>もしFDWが統計情報の収集をどのテーブルについてもサポートしない場合は、<CODE
CLASS="FUNCTION"
>AnalyzeForeignTable</CODE
>ポインタをNULLにすることもできます。
    </P
><P
>もし提供される場合は、サンプル収集関数はこのようなシグネチャを持つ必要があります。
</P><PRE
CLASS="PROGRAMLISTING"
>int
AcquireSampleRowsFunc (Relation relation, int elevel,
                       HeapTuple *rows, int targrows,
                       double *totalrows,
                       double *totaldeadrows);</PRE
><P>

最大<TT
CLASS="PARAMETER"
>targrows</TT
>行のランダムサンプルをテーブルから収集し、呼び出し元が提供する<TT
CLASS="PARAMETER"
>rows</TT
>配列に格納する必要があります。
実際に収集された行の数を返す必要があります。
さらに、テーブルに含まれる有効行と不要行の合計数の見積もりを出力パラメータの<TT
CLASS="PARAMETER"
>totalrows</TT
>と<TT
CLASS="PARAMETER"
>totaldeadrows</TT
>に返す必要があります。(もしFDWが不要行という概念を持たない場合は<TT
CLASS="PARAMETER"
>totaldeadrows</TT
>を0に設定してください。)
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-IMPORT"
>55.2.8. <TT
CLASS="COMMAND"
>IMPORT FOREIGN SCHEMA</TT
>のためのFDWルーチン</A
></H2
><P
></P><PRE
CLASS="PROGRAMLISTING"
>List *
ImportForeignSchema (ImportForeignSchemaStmt *stmt, Oid serverOid);</PRE
><P>

外部テーブル作成コマンドのリストを取得します。
この関数は<A
HREF="sql-importforeignschema.html"
>IMPORT FOREIGN SCHEMA</A
>を実行する時に呼び出され、その文の解析木と外部サーバが使用するOIDとを渡されます。
C文字列のリストを返し、その各文字列は<A
HREF="sql-createforeigntable.html"
>CREATE FOREIGN TABLE</A
>コマンドを含んでいる必要があります。
これらの文字列はコアサーバが解析して実行します。
    </P
><P
><TT
CLASS="STRUCTNAME"
>ImportForeignSchemaStmt</TT
>構造体において、<TT
CLASS="STRUCTFIELD"
>remote_schema</TT
>はリモートスキーマの名前で、そこからテーブルがインポートされます。
<TT
CLASS="STRUCTFIELD"
>list_type</TT
>はテーブル名のフィルタ方法を指定します。
ここで、<TT
CLASS="LITERAL"
>FDW_IMPORT_SCHEMA_ALL</TT
>はリモートスキーマのすべてのテーブルをインポートすること（この場合、<TT
CLASS="STRUCTFIELD"
>table_list</TT
>は空にします）、
<TT
CLASS="LITERAL"
>FDW_IMPORT_SCHEMA_LIMIT_TO</TT
>は<TT
CLASS="STRUCTFIELD"
>table_list</TT
>に列挙されたテーブルだけを含めること、
そして<TT
CLASS="LITERAL"
>FDW_IMPORT_SCHEMA_EXCEPT</TT
>は<TT
CLASS="STRUCTFIELD"
>table_list</TT
>に列挙されたテーブルを除外することを意味します。
<TT
CLASS="STRUCTFIELD"
>options</TT
>はインポートのプロセスで使用されるオプションのリストです。
オプションの意味はFDWに依存します。
例えば、FDWは列の<TT
CLASS="LITERAL"
>NOT NULL</TT
>属性をインポートするかどうかを定めるオプションを使うことができます。
これらのオプションはFDWがデータベースオブジェクトのオプションとしてサポートするものと何ら関係ある必要はありません。
    </P
><P
>FDWは<TT
CLASS="STRUCTNAME"
>ImportForeignSchemaStmt</TT
>の<TT
CLASS="STRUCTFIELD"
>local_schema</TT
>フィールドを無視しても良いです。
なぜなら、コアサーバは解析された<TT
CLASS="COMMAND"
>CREATE FOREIGN TABLE</TT
>コマンドにその名前を自動的に挿入するからです。
    </P
><P
>FDWは<TT
CLASS="STRUCTFIELD"
>list_type</TT
>および<TT
CLASS="STRUCTFIELD"
>table_list</TT
>で指定されるフィルタの実装にも注意する必要はありません。
なぜなら、コアサーバはそれらのオプションによって除外されるテーブルに対して戻されたコマンドをすべて自動的にスキップするからです。
しかし、除外されるテーブルについてコマンドを作成する作業を回避するのは、そもそも役立つことが多いです。
関数<CODE
CLASS="FUNCTION"
>IsImportableForeignTable()</CODE
>は指定の外部テーブル名がフィルタを通るかどうかの検査に役立つかもしれません。
    </P
><P
>FDWがテーブル定義のインポートをサポートしない場合は、<CODE
CLASS="FUNCTION"
>ImportForeignSchema</CODE
>ポインタを<TT
CLASS="LITERAL"
>NULL</TT
>にセットすることができます。
    </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FDW-CALLBACKS-PARALLEL"
>55.2.9. パラレル実行のためのFDWルーチン</A
></H2
><P
><TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>ノードは、オプションとして、パラレル実行をサポートします。
並列<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>は複数プロセスで実行され、全ての協調プロセスにわたって各行が一度だけ返るべきです。
これを行うため、プロセスは動的共有メモリの固定サイズチャンクを通して調整をはかることができます。
この共有メモリは全プロセスで同じアドレスに割り当てされることが保証されませんので、ポインタはおそらく使えません。
以下のコールバックは一般に全て省略可能ですが、パラレル実行をサポートするためには必要です。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>bool
IsForeignScanParallelSafe(PlannerInfo *root, RelOptInfo *rel,
                          RangeTblEntry *rte);</PRE
><P>
スキャンがパラレルワーカーで実行できるかテストします。
この関数はプランナが並列プランが可能であろうと考えるときだけ呼ばれます。また、そのスキャンにとってパラレルワーカーで実行するのが安全であるとき真を返すべきです。
リモートデータソースがトランザクションのセマンティクスを持つ場合は、一般にあてはまりません。ただし、ワーカーのデータへの接続を何らかの形でリーダーとして同じトランザクション文脈を共有させることができる場合を除きます。
    </P
><P
>このコールバックが定義されていない場合、スキャンはパラレルリーダー内で実行しなければならないと想定されます。
真を返すことは、スキャンがパラレルワーカーで実行可能であるだけで、パラレルに実行可能であることを意味するのでは無いことに注意してください。
そのため、この関数を定義することはパラレル実行がサポートされていないときでも役立つ可能性があります。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>Size
EstimateDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt);</PRE
><P>
並列操作に必要とされるであろう動的共有メモリ量を推定します。
これは実際に使われる量よりも大きくてよいですが、小さくてはいけません。
戻り値はバイト単位です。
    </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
InitializeDSMForeignScan(ForeignScanState *node, ParallelContext *pcxt,
                         void *coordinate);</PRE
><P>
並列処理で必要とされる動的共有メモリを初期化します。
<TT
CLASS="LITERAL"
>coordinate</TT
>は<CODE
CLASS="FUNCTION"
>EstimateDSMForeignScan</CODE
>の戻り値に等しいサイズだけ割り当てられた領域へのポインタです。
   </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
InitializeWorkerForeignScan(ForeignScanState *node, shm_toc *toc,
                            void *coordinate);</PRE
><P>
<TT
CLASS="LITERAL"
>InitializeDSMForeignScan</TT
>でリーダーがセットアップした共有状態に基づくパラレルワーカーのカスタム状態を初期化します。
このコールバックは省略可能で、このカスタムパスがパラレル実行をサポートする場合だけ用意する必要があります。
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="fdw-functions.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="fdw-helpers.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>外部データラッパ関数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="fdwhandler.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>外部データラッパヘルパ関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
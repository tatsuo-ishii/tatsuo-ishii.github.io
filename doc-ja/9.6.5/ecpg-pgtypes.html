<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>pgtypes ライブラリ</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="ECPG - C言語による埋め込みSQL"
HREF="ecpg.html"><LINK
REL="PREVIOUS"
TITLE="動的SQL"
HREF="ecpg-dynamic.html"><LINK
REL="NEXT"
TITLE="記述子領域の使用"
HREF="ecpg-descriptors.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="動的SQL"
HREF="ecpg-dynamic.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="ecpg.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 34章<SPAN
CLASS="APPLICATION"
>ECPG</SPAN
> - C言語による埋め込み<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="記述子領域の使用"
HREF="ecpg-descriptors.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="ECPG-PGTYPES"
>34.6. pgtypes ライブラリ</A
></H1
><P
>pgtypesライブラリは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>データベースの型をCプログラムで使用できるようにC言語に対応させます。
また、これらの型を使用したCの基本的な計算を行う関数も提供します。
この計算には、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバを使用しません。
以下の例を参照してください。
</P><PRE
CLASS="PROGRAMLISTING"
>EXEC SQL BEGIN DECLARE SECTION;
   date date1;
   timestamp ts1, tsout;
   interval iv1;
   char *out;
EXEC SQL END DECLARE SECTION;

PGTYPESdate_today(&#38;date1);
EXEC SQL SELECT started, duration INTO :ts1, :iv1 FROM datetbl WHERE d=:date1;
PGTYPEStimestamp_add_interval(&#38;ts1, &#38;iv1, &#38;tsout);
out = PGTYPEStimestamp_to_asc(&#38;tsout);
printf("Started + duration: %s\n", out);
free(out);</PRE
><P>
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-PGTYPES-NUMERIC"
>34.6.1. numeric 型</A
></H2
><P
>numeric 型では任意の精度での計算機能を提供します。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバにおける対応する型については<A
HREF="datatype-numeric.html"
>項8.1</A
>を参照してください。
任意の精度を持つために、この変数は動的に拡張、縮小できなければなりません。
これが、<CODE
CLASS="FUNCTION"
>PGTYPESnumeric_new</CODE
>や<CODE
CLASS="FUNCTION"
>PGTYPESnumeric_free</CODE
>関数では、ヒープ領域上にのみしか numeric 変数を作成できない理由です。
decimal 型も似ていますが精度が限定されていますので、ヒープ領域以外にスタック領域上でも作成可能です。
   </P
><P
>以下の関数は numeric 型で使用することができます:
   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_new</CODE
></DT
><DD
><P
>新規割当ての numeric 型へのポインタを要求します。
</P><PRE
CLASS="SYNOPSIS"
>numeric *PGTYPESnumeric_new(void);</PRE
><P>
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_free</CODE
></DT
><DD
><P
>numeric 型を解放し、そのメモリをすべて解放します。
</P><PRE
CLASS="SYNOPSIS"
>void PGTYPESnumeric_free(numeric *var);</PRE
><P>
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_from_asc</CODE
></DT
><DD
><P
>文字列表記から numeric 型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>numeric *PGTYPESnumeric_from_asc(char *str, char **endptr);</PRE
><P>
有効な書式の例を示します。
<TT
CLASS="LITERAL"
>-2</TT
>、<TT
CLASS="LITERAL"
>.794</TT
>、<TT
CLASS="LITERAL"
>+3.44</TT
>、<TT
CLASS="LITERAL"
>592.49E07</TT
>、<TT
CLASS="LITERAL"
>-32.84e-4</TT
>。
値への変換に成功した場合、有効なポインタが返されます。
失敗した場合は NULL ポインタが返されます。
現在ECPGは文字列全体を解析しますので、現時点では<TT
CLASS="LITERAL"
>*endptr</TT
>内に最初の無効な文字のアドレスを格納することをサポートしません。
このため<TT
CLASS="LITERAL"
>endptr</TT
>を安全に NULL にすることができます。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_to_asc</CODE
></DT
><DD
><P
>numeric 型<TT
CLASS="LITERAL"
>num</TT
>の文字列表現を持つ、<CODE
CLASS="FUNCTION"
>malloc</CODE
>で割り当てられた文字列へのポインタを返します。
</P><PRE
CLASS="SYNOPSIS"
>char *PGTYPESnumeric_to_asc(numeric *num, int dscale);</PRE
><P>
numeric の値は、必要に応じて四捨五入され、<TT
CLASS="LITERAL"
>dscale</TT
> 桁の十進数で出力されます。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_add</CODE
></DT
><DD
><P
>2つの numeric 変数を加算し、3番目の numeric 変数に格納します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_add(numeric *var1, numeric *var2, numeric *result);</PRE
><P>
この関数は変数<TT
CLASS="LITERAL"
>var1</TT
>と変数<TT
CLASS="LITERAL"
>var2</TT
>を加算し、その結果を<TT
CLASS="LITERAL"
>result</TT
>に格納します。
成功時0を、エラー時-1を返します。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_sub</CODE
></DT
><DD
><P
>2つの numeric 型変数を減算し、3番目の numeric 型変数に結果を格納します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_sub(numeric *var1, numeric *var2, numeric *result);</PRE
><P>
この関数は変数<TT
CLASS="LITERAL"
>var1</TT
>から変数<TT
CLASS="LITERAL"
>var2</TT
>を差し引きます。
演算結果を変数<TT
CLASS="LITERAL"
>result</TT
>に格納します。
成功時0を、エラー時-1を返します。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_mul</CODE
></DT
><DD
><P
>2つの numeric 型変数を乗算し、3番目の numeric 型変数に結果を格納します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_mul(numeric *var1, numeric *var2, numeric *result);</PRE
><P>
この関数は変数<TT
CLASS="LITERAL"
>var1</TT
>と変数<TT
CLASS="LITERAL"
>var2</TT
>を掛け合わせます。
演算結果を変数<TT
CLASS="LITERAL"
>result</TT
>に格納します。
成功時0を、エラー時-1を返します。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_div</CODE
></DT
><DD
><P
>2つの numeric 型変数で除算し、3番目の numeric 型変数に結果を格納します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_div(numeric *var1, numeric *var2, numeric *result);</PRE
><P>
この関数は変数<TT
CLASS="LITERAL"
>var1</TT
>を変数<TT
CLASS="LITERAL"
>var2</TT
>で割ります。
演算結果を変数<TT
CLASS="LITERAL"
>result</TT
>に格納します。
成功時0を、エラー時-1を返します。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_cmp</CODE
></DT
><DD
><P
>2つのnumeric型変数を比較します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_cmp(numeric *var1, numeric *var2)</PRE
><P>
この関数は2つのnumeric型変数を比較します。
エラーの場合<TT
CLASS="LITERAL"
>INT_MAX</TT
>が返ります。
成功時、この関数は以下のいずれかを返します:
       <P
></P
></P><UL
><LI
><P
>          <TT
CLASS="LITERAL"
>var1</TT
>が<TT
CLASS="LITERAL"
>var2</TT
>より大きければ1。
         </P
></LI
><LI
><P
>          <TT
CLASS="LITERAL"
>var1</TT
>が<TT
CLASS="LITERAL"
>var2</TT
>より小さければ-1。
         </P
></LI
><LI
><P
>          <TT
CLASS="LITERAL"
>var1</TT
>が<TT
CLASS="LITERAL"
>var2</TT
>と等しければ0。
         </P
></LI
></UL
><P>
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_from_int</CODE
></DT
><DD
><P
>int型変数をnumeric型変数に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_from_int(signed int int_val, numeric *var);</PRE
><P>
この関数はsigned int型の変数を受付け、numeric型変数<TT
CLASS="LITERAL"
>var</TT
>内に格納します。
成功時0、失敗時-1が返ります。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_from_long</CODE
></DT
><DD
><P
>long int型変数をnumeric型変数に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_from_long(signed long int long_val, numeric *var);</PRE
><P>
この関数は符号付long int型の変数を受付け、numeric 型変数<TT
CLASS="LITERAL"
>var</TT
>内に格納します。
成功時0、失敗時-1が返ります。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_copy</CODE
></DT
><DD
><P
>numeric 型変数を他の numeric 型変数にコピーします。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_copy(numeric *src, numeric *dst);</PRE
><P>
この関数は、<TT
CLASS="LITERAL"
>src</TT
>が指し示す変数の値を<TT
CLASS="LITERAL"
>dst</TT
>が指し示す変数にコピーします。
成功時0、失敗時-1が返ります。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_from_double</CODE
></DT
><DD
><P
>double型の変数を numeric 型変数に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int  PGTYPESnumeric_from_double(double d, numeric *dst);</PRE
><P>
この関数はdouble型の変数を受付け、変換結果を<TT
CLASS="LITERAL"
>dst</TT
>が指し示す変数内に格納します。
成功時0、失敗時-1が返ります。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_to_double</CODE
></DT
><DD
><P
>numeric 型変数をdouble型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_to_double(numeric *nv, double *dp)</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>nv</TT
>が指し示す numeric 型変数の値を<TT
CLASS="LITERAL"
>dp</TT
>が指し示すdouble型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<TT
CLASS="LITERAL"
>errno</TT
>は<TT
CLASS="LITERAL"
>PGTYPES_NUM_OVERFLOW</TT
>に設定されます。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_to_int</CODE
></DT
><DD
><P
>numeric 型変数をint型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_to_int(numeric *nv, int *ip);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>nv</TT
>が指し示す numeric 型変数の値を<TT
CLASS="LITERAL"
>ip</TT
>が指し示す整数型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<TT
CLASS="LITERAL"
>errno</TT
>は<TT
CLASS="LITERAL"
>PGTYPES_NUM_OVERFLOW</TT
>に設定されます。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_to_long</CODE
></DT
><DD
><P
>numeric 型変数をlong型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_to_long(numeric *nv, long *lp);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>nv</TT
>が指し示す numeric 型変数の値を<TT
CLASS="LITERAL"
>lp</TT
>が指し示すlong変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<TT
CLASS="LITERAL"
>errno</TT
>は<TT
CLASS="LITERAL"
>PGTYPES_NUM_OVERFLOW</TT
>に設定されます。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_to_decimal</CODE
></DT
><DD
><P
>numeric 型変数を decimal 型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_to_decimal(numeric *src, decimal *dst);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>src</TT
>が指し示す numeric 型変数の値を<TT
CLASS="LITERAL"
>dst</TT
>が指し示す decimal 型変数に変換します。
成功時0、オーバーフローを含むエラーが発生した時-1が返ります。
オーバーフローが発生した場合はさらに、グローバル変数<TT
CLASS="LITERAL"
>errno</TT
>は<TT
CLASS="LITERAL"
>PGTYPES_NUM_OVERFLOW</TT
>に設定されます。
      </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESnumeric_from_decimal</CODE
></DT
><DD
><P
>decimal 型変数を numeric 型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESnumeric_from_decimal(decimal *src, numeric *dst);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>src</TT
>が指し示す decimal 型変数の値を<TT
CLASS="LITERAL"
>dst</TT
>が指し示す numeric 型変数に変換します。
成功時0、エラーが発生した時-1が返ります。
decimal 型は制限付の numeric 型として実装されていますので、この変換ではオーバーフローは起きません。
      </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-PGTYPES-DATE"
>34.6.2. 日付型</A
></H2
><P
>Cの日付型を使用して、プログラムからSQLの日付型を取り扱うことができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバにおける対応する型については<A
HREF="datatype-datetime.html"
>項8.5</A
>を参照してください。
   </P
><P
>日付型を操作するために以下の関数を使用することができます:
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="PGTYPESDATEFROMTIMESTAMP"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_from_timestamp</CODE
></DT
><DD
><P
>タイムスタンプから日付部分を取り出します。
</P><PRE
CLASS="SYNOPSIS"
>date PGTYPESdate_from_timestamp(timestamp dt);</PRE
><P>
この関数は唯一の引数としてタイムスタンプを受付け、そこから日付部分を取り出します。
       </P
></DD
><DT
><A
NAME="PGTYPESDATEFROMASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_from_asc</CODE
></DT
><DD
><P
>テキスト表現から日付型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>date PGTYPESdate_from_asc(char *str, char **endptr);</PRE
><P>
この関数はCのchar*型文字列<TT
CLASS="LITERAL"
>str</TT
>とCのchar*型文字列<TT
CLASS="LITERAL"
>endptr</TT
>へのポインタを受付けます。
現在ECPGは文字列全体を解析しますので、現時点では<TT
CLASS="LITERAL"
>*endptr</TT
>に最初の無効な文字のアドレスを格納することをサポートしません。
このため<TT
CLASS="LITERAL"
>endptr</TT
>を安全にNULLにすることができます。
       </P
><P
>この関数が常にMDY書式の日付を前提としている点に注意してください。
現在ECPGにはこれを変更するための変数がありません。
       </P
><P
>        <A
HREF="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FROM-ASC-TABLE"
>表34-2</A
>に許される入力書式を示します。
       </P
><DIV
CLASS="TABLE"
><A
NAME="ECPG-PGTYPESDATE-FROM-ASC-TABLE"
></A
><P
><B
>表 34-2. 有効な<CODE
CLASS="FUNCTION"
>PGTYPESdate_from_asc</CODE
>の入力書式</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>入力</TH
><TH
>結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>1999-01-08</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>1/8/1999</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>1/18/1999</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 18, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>01/02/03</TT
></TD
><TD
><TT
CLASS="LITERAL"
>February 1, 2003</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>1999-Jan-08</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>Jan-08-1999</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>08-Jan-1999</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>99-Jan-08</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>08-Jan-99</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>08-Jan-06</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 2006</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>Jan-08-99</TT
></TD
><TD
><TT
CLASS="LITERAL"
>January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>19990108</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO 8601; January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>990108</TT
></TD
><TD
><TT
CLASS="LITERAL"
>ISO 8601; January 8, 1999</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>1999.008</TT
></TD
><TD
><TT
CLASS="LITERAL"
>年と年内日数</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>J2451187</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Jユリウス日</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>January 8, 99 BC</TT
></TD
><TD
><TT
CLASS="LITERAL"
>紀元前99年</TT
></TD
></TR
></TBODY
></TABLE
></DIV
></DD
><DT
><A
NAME="PGTYPESDATETOASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_to_asc</CODE
></DT
><DD
><P
>        日付型変数のテキスト表現を返します。
</P><PRE
CLASS="SYNOPSIS"
>char *PGTYPESdate_to_asc(date dDate);</PRE
><P>
この関数は唯一の引数として日付型<TT
CLASS="LITERAL"
>dDate</TT
>を受付けます。
この関数は<TT
CLASS="LITERAL"
>1999-01-18</TT
>、つまり<TT
CLASS="LITERAL"
>YYYY-MM-DD</TT
>書式で日付を出力します。
       </P
></DD
><DT
><A
NAME="PGTYPESDATEJULMDY"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_julmdy</CODE
></DT
><DD
><P
>        日付型の変数から、日、月、年の値を取り出します。
</P><PRE
CLASS="SYNOPSIS"
>void PGTYPESdate_julmdy(date d, int *mdy);</PRE
><P>
       
この関数は日付型の<TT
CLASS="LITERAL"
>d</TT
>と、3つの整数値を持つ配列<TT
CLASS="LITERAL"
>mdy</TT
>へのポインタを受付けます。
この変数名はその並びを表し、<TT
CLASS="LITERAL"
>mdy[0]</TT
>には月数、<TT
CLASS="LITERAL"
>mdy[1]</TT
>には日数が、<TT
CLASS="LITERAL"
>mdy[2]</TT
>には年が入ります。
       </P
></DD
><DT
><A
NAME="PGTYPESDATEMDYJUL"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_mdyjul</CODE
></DT
><DD
><P
>日付の日、月、年を指定した3つの整数からなる配列から日付値を作成します。
</P><PRE
CLASS="SYNOPSIS"
>void PGTYPESdate_mdyjul(int *mdy, date *jdate);</PRE
><P>
この関数は、1番目の引数として3つの整数からなる配列(<TT
CLASS="LITERAL"
>mdy</TT
>)、2番目の引数として処理結果を格納する日付型の変数へのポインタを受付けます。
       </P
></DD
><DT
><A
NAME="PGTYPESDATEDAYOFWEEK"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_dayofweek</CODE
></DT
><DD
><P
>日付値から週内日数を表す数を返します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESdate_dayofweek(date d);</PRE
><P>
この関数は唯一の引数としてdate型変数<TT
CLASS="LITERAL"
>d</TT
>を受付け、その日付の週内日数を表す整数を返します。
        <P
></P
></P><UL
><LI
><P
>           0 - 日曜
          </P
></LI
><LI
><P
>           1 - 月曜
          </P
></LI
><LI
><P
>           2 - 火曜
          </P
></LI
><LI
><P
>           3 - 水曜
          </P
></LI
><LI
><P
>           4 - 木曜
          </P
></LI
><LI
><P
>           5 - 金曜
          </P
></LI
><LI
><P
>           6 - 土曜
          </P
></LI
></UL
><P>
       </P
></DD
><DT
><A
NAME="PGTYPESDATETODAY"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_today</CODE
></DT
><DD
><P
>現在の日付を取得します。
</P><PRE
CLASS="SYNOPSIS"
>void PGTYPESdate_today(date *d);</PRE
><P>
この関数は現在の日付に設定されるdate型変数(<TT
CLASS="LITERAL"
>d</TT
>)を指し示すポインタを受付けます。
       </P
></DD
><DT
><A
NAME="PGTYPESDATEFMTASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_fmt_asc</CODE
></DT
><DD
><P
>date型変数を書式マスクを使用したテキスト表現に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESdate_fmt_asc(date dDate, char *fmtstring, char *outbuf);</PRE
><P>
この関数は変換対象のdate型(<TT
CLASS="LITERAL"
>dDate</TT
>)、書式マスク(<TT
CLASS="LITERAL"
>fmtstring</TT
>)、日付のテキスト表現を格納するための文字列(<TT
CLASS="LITERAL"
>outbuf</TT
>)を受付けます。
       </P
><P
>成功時に0、エラーが発生した場合は負の値が返ります。
       </P
><P
>以下のリテラルを使用して、フィールドを指定することができます。
        <P
></P
></P><UL
><LI
><P
>           <TT
CLASS="LITERAL"
>dd</TT
> - 月内の日数。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>mm</TT
> - 年内の月数。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>yy</TT
> - 二桁表記の年数
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>yyyy</TT
> - 四桁表記の年数
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>ddd</TT
> - 曜日の名前（省略形）
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>mmm</TT
> - 月の名前（省略形）
          </P
></LI
></UL
><P>
他の文字はすべて出力文字列にそのままコピーされます。
       </P
><P
><A
HREF="ecpg-pgtypes.html#ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE"
>表34-3</A
>にいくつかの可能性のある書式を示します。
この関数の使用方法に関するアイディアを提供しています。
出力行はすべて同じ日付、1959年11月23日に基づいています。
       </P
><DIV
CLASS="TABLE"
><A
NAME="ECPG-PGTYPESDATE-FMT-ASC-EXAMPLE-TABLE"
></A
><P
><B
>表 34-3. 有効な<CODE
CLASS="FUNCTION"
>PGTYPESdate_fmt_asc</CODE
>の入力書式</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>書式</TH
><TH
>結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>mmddyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>112359</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ddmmyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>231159</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yymmdd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>591123</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yy/mm/dd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>59/11/23</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yy mm dd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>59 11 23</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yy.mm.dd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>59.11.23</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>.mm.yyyy.dd.</TT
></TD
><TD
><TT
CLASS="LITERAL"
>.11.1959.23.</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mmm. dd, yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Nov. 23, 1959</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mmm dd yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Nov 23 1959</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yyyy dd mm</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1959 23 11</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ddd, mmm. dd, yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Mon, Nov. 23, 1959</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>(ddd) mmm. dd, yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>(Mon) Nov. 23, 1959</TT
></TD
></TR
></TBODY
></TABLE
></DIV
></DD
><DT
><A
NAME="PGTYPESDATEDEFMTASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESdate_defmt_asc</CODE
></DT
><DD
><P
>書式マスクを使用してCの<TT
CLASS="TYPE"
>char*</TT
>文字列からdate型の値に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESdate_defmt_asc(date *d, char *fmt, char *str);</PRE
><P>
        
この関数は、処理結果を格納するための日付型へのポインタ(<TT
CLASS="LITERAL"
>d</TT
>)、日付を解析するための書式マスク(<TT
CLASS="LITERAL"
>fmt</TT
>)、日付のテキスト表現を含むCのchar*文字列(<TT
CLASS="LITERAL"
>str</TT
>)を受付けます。
テキスト表現は書式マスクに合った表現であることが仮定されています。
しかし、文字列と書式マスクを1:1に対応付けする必要はありません。
この関数は並んだ順番に解析し、年の位置を表す<TT
CLASS="LITERAL"
>yy</TT
>または<TT
CLASS="LITERAL"
>yyyy</TT
>を、月の位置を表す<TT
CLASS="LITERAL"
>mm</TT
>を、日の位置を表す<TT
CLASS="LITERAL"
>dd</TT
>を検索します。
       </P
><P
><A
HREF="ecpg-pgtypes.html#ECPG-RDEFMTDATE-EXAMPLE-TABLE"
>表34-4</A
>はいくつかの可能性のある書式を示します。
これはこの関数の使用方法に関するアイディアを提供します。
       </P
><DIV
CLASS="TABLE"
><A
NAME="ECPG-RDEFMTDATE-EXAMPLE-TABLE"
></A
><P
><B
>表 34-4. 有効な<CODE
CLASS="FUNCTION"
>rdefmtdate</CODE
>の入力書式</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>書式</TH
><TH
>文字列</TH
><TH
>結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>ddmmyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>21-2-54</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1954-02-21</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ddmmyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2-12-54</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1954-12-02</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ddmmyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>20111954</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1954-11-20</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>ddmmyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>130464</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1964-04-13</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mmm.dd.yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>MAR-12-1967</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1967-03-12</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yy/mm/dd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1954, February 3rd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1954-02-03</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mmm.dd.yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>041269</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1969-04-12</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yy/mm/dd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>In the year 2525, in the month of July, mankind will be alive on the 28th day</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2525-07-28</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>dd-mm-yy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>I said on the 28th of July in the year 2525</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2525-07-28</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mmm.dd.yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>9/14/58</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1958-09-14</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>yy/mm/dd</TT
></TD
><TD
><TT
CLASS="LITERAL"
>47/03/29</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1947-03-29</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mmm.dd.yyyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>oct 28 1975</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1975-10-28</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>mmddyy</TT
></TD
><TD
><TT
CLASS="LITERAL"
>Nov 14th, 1985</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1985-11-14</TT
></TD
></TR
></TBODY
></TABLE
></DIV
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-PGTYPES-TIMESTAMP"
>34.6.3. timestamp型</A
></H2
><P
>Cのタイムスタンプ型を使用してプログラムからSQLのタイムスタンプ型データを扱うことができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>における対応する型については<A
HREF="datatype-datetime.html"
>項8.5</A
>を参照してください。
   </P
><P
>以下の関数を使用してタイムスタンプ型を扱うことができます:
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="PGTYPESTIMESTAMPFROMASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_from_asc</CODE
></DT
><DD
><P
>テキスト表現のタイムスタンプをタイムスタンプ型変数に変換します。
</P><PRE
CLASS="SYNOPSIS"
>timestamp PGTYPEStimestamp_from_asc(char *str, char **endptr);</PRE
><P>
この関数は変換対象の文字列(<TT
CLASS="LITERAL"
>str</TT
>)とC char*へのポインタ(<TT
CLASS="LITERAL"
>endptr</TT
>)を受付けます。
現在ECPGは文字列全体を解析しますので、現時点では<TT
CLASS="LITERAL"
>*endptr</TT
>に最初の無効な文字の場所を格納をすることサポートしません。
このため<TT
CLASS="LITERAL"
>endptr</TT
>を安全に NULL にすることができます。
       </P
><P
>この関数は成功時変換後のタイムスタンプを返します。
エラー時、<TT
CLASS="LITERAL"
>PGTYPESInvalidTimestamp</TT
>が返され、<TT
CLASS="VARNAME"
>errno</TT
>が<TT
CLASS="LITERAL"
>PGTYPES_TS_BAD_TIMESTAMP</TT
>に設定されます。
この値についての重要な注意書きについて<A
HREF="ecpg-pgtypes.html#PGTYPESINVALIDTIMESTAMP"
><I
CLASS="TERM"
><TT
CLASS="LITERAL"
>PGTYPESInvalidTimestamp</TT
></I
></A
>を参照してください。
       </P
><P
>通常、入力文字列には許される日付指定の任意の組み合わせ、空白文字、許される時間指定を含むことができます。
時間帯はECPGでサポートされていない点に注意してください。
変換することはできますが、例えば<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバが行うような計算を行うことはできません。
時間帯指定は警告無しに無視されます。
       </P
><P
><A
HREF="ecpg-pgtypes.html#ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE"
>表34-5</A
>に入力文字列の例をいくつか示します。
       </P
><DIV
CLASS="TABLE"
><A
NAME="ECPG-PGTYPESTIMESTAMP-FROM-ASC-EXAMPLE-TABLE"
></A
><P
><B
>表 34-5. 有効な<CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_from_asc</CODE
>の入力書式</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><THEAD
><TR
><TH
>入力</TH
><TH
>結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>1999-01-08 04:05:06</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1999-01-08 04:05:06</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>January 8 04:05:06 1999 PST</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1999-01-08 04:05:06</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>1999-Jan-08 04:05:06.789-8</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1999-01-08 04:05:06.789 (時間帯指定は無視されます。)</TT
></TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>J2451187 04:05-08:00</TT
></TD
><TD
><TT
CLASS="LITERAL"
>1999-01-08 04:05:00 (時間帯指定は無視されます。)</TT
></TD
></TR
></TBODY
></TABLE
></DIV
></DD
><DT
><A
NAME="PGTYPESTIMESTAMPTOASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_to_asc</CODE
></DT
><DD
><P
>date型をC char*文字列に変換します。
</P><PRE
CLASS="SYNOPSIS"
>char *PGTYPEStimestamp_to_asc(timestamp tstamp);</PRE
><P>
この関数はtimestamp型の<TT
CLASS="LITERAL"
>tstamp</TT
>を唯一の引数として受付け、timestamp型のテキスト表現を含む割り当てられた文字列を返します。
       </P
></DD
><DT
><A
NAME="PGTYPESTIMESTAMPCURRENT"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_current</CODE
></DT
><DD
><P
>現在のタイムスタンプを取り出します。
</P><PRE
CLASS="SYNOPSIS"
>void PGTYPEStimestamp_current(timestamp *ts);</PRE
><P>
この関数は現在のタイムスタンプを取り出し、<TT
CLASS="LITERAL"
>ts</TT
>が指し示すtimestamp型変数に格納します。
       </P
></DD
><DT
><A
NAME="PGTYPESTIMESTAMPFMTASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_fmt_asc</CODE
></DT
><DD
><P
>書式マスクを使用してtimestamp型変数をC char*に変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPEStimestamp_fmt_asc(timestamp *ts, char *output, int str_len, char *fmtstr);</PRE
><P>
この関数は、最初の引数として変換対象のtimestamp型 (<TT
CLASS="LITERAL"
>ts</TT
>)を、出力バッファのポインタ(<TT
CLASS="LITERAL"
>output</TT
>)、出力バッファで割当て可能な最大長 (<TT
CLASS="LITERAL"
>str_len</TT
>)、変換に使用する書式マスク(<TT
CLASS="LITERAL"
>fmtstr</TT
>)を受付けます。
       </P
><P
>成功するとこの関数は0を返します。
エラーが発生した場合は負の値が返ります。
       </P
><P
>書式マスクには以下の書式指定を使用することができます。
書式指定は<SPAN
CLASS="PRODUCTNAME"
>libc</SPAN
>の<CODE
CLASS="FUNCTION"
>strftime</CODE
>関数で使用されるものと同じです。
書式指定以外は出力バッファにコピーされます。
        
        <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>%A</TT
> - 各言語の曜日名称に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%a</TT
> - 各言語の曜日略称に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%B</TT
> - 各言語の月名称に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%b</TT
> - 各言語の月略称に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%C</TT
> - 年を100で割った10進数に置換されます。1桁の場合は先頭に0が付与されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%c</TT
> - 各言語の日付時刻表現に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%D</TT
> - <TT
CLASS="LITERAL"
>%m/%d/%y</TT
>と同じです。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%d</TT
> - 月内の10進日数(01-31)に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%E*</TT
> <TT
CLASS="LITERAL"
>%O*</TT
> - POSIXロケール拡張です。
           <TT
CLASS="LITERAL"
>%Ec</TT
>
           <TT
CLASS="LITERAL"
>%EC</TT
> 
           <TT
CLASS="LITERAL"
>%Ex</TT
> 
           <TT
CLASS="LITERAL"
>%EX</TT
> 
           <TT
CLASS="LITERAL"
>%Ey</TT
> 
           <TT
CLASS="LITERAL"
>%EY</TT
> 
           <TT
CLASS="LITERAL"
>%Od</TT
> 
           <TT
CLASS="LITERAL"
>%Oe</TT
>
           <TT
CLASS="LITERAL"
>%OH</TT
> 
           <TT
CLASS="LITERAL"
>%OI</TT
> 
           <TT
CLASS="LITERAL"
>%Om</TT
> 
           <TT
CLASS="LITERAL"
>%OM</TT
> 
           <TT
CLASS="LITERAL"
>%OS</TT
> 
           <TT
CLASS="LITERAL"
>%Ou</TT
> 
           <TT
CLASS="LITERAL"
>%OU</TT
> 
           <TT
CLASS="LITERAL"
>%OV</TT
> 
           <TT
CLASS="LITERAL"
>%Ow</TT
> 
           <TT
CLASS="LITERAL"
>%OW</TT
> 
           <TT
CLASS="LITERAL"
>%Oy</TT
> 
という並びは別の表現を提供するものと仮定されています。
          </P
><P
>さらに、<TT
CLASS="LITERAL"
>%OB</TT
>は、（日に関する仕様がない単体で使用される）別の月名を表すものとして実装されています。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%e</TT
> - 月内10進日数(1-31)に置換されます。1桁の場合は前に空白が付けられます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%F</TT
> - <TT
CLASS="LITERAL"
>%Y-%m-%d</TT
>と同じです。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%G</TT
> - 世紀付の10進数として年に置換されます。
この年は週の部分がより多く含まれます。（月曜が週の最初の日です。）
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%g</TT
> -<TT
CLASS="LITERAL"
>%G</TT
>同様に年に置換されますが、世紀の部分を除く10進数(00-99)になります。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%H</TT
> - 10進の時間(24時間単位)に置換されます(00-23)。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>%h</TT
> - <TT
CLASS="LITERAL"
>%b</TT
>と同じです。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%I</TT
> - 10進の時間（12時間単位）に置換されます(01-12)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%j</TT
> - 10進の年内日数に置換されます(001-366)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%k</TT
> - 10進の時間(24時間単位)に置換されます(0-23)。1桁の場合は先頭に空白が付けられます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%l</TT
> - 10進の時間（12時間単位）に置換されます(1-12)。1桁の場合は先頭に空白が付けられます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%M</TT
> - 10進の分数に置換されます(00-59)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%m</TT
> -10進の月数に置換されます(01-12)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%n</TT
> - 改行に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%O*</TT
> - <TT
CLASS="LITERAL"
>%E*</TT
>と同じです。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%p</TT
> - 各言語の"午前"または"午後"に適切に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%R</TT
> - <TT
CLASS="LITERAL"
>%H:%M</TT
>と同じです。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>%r</TT
> - <TT
CLASS="LITERAL"
>%I:%M:%S %p</TT
>と同じです。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%S</TT
> - 10進の秒数に置換されます(00-60)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%s</TT
> - エポック、UTCからの秒数に置換されます。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>%T</TT
> - <TT
CLASS="LITERAL"
>%H:%M:%S</TT
>と同じです。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%t</TT
> - タブに置換されます。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>%U</TT
> - 10進の週番号（日曜が週の先頭です）に置換されます。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>%u</TT
> - 10進の週番号（月曜が週の先頭です）に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%V</TT
> - 10進の年内の週番号（月曜が週の先頭です）に置換されます(01-53)。
新しい年で、1月1日を含む週が4日以上存在する場合、その週が1となります。
さもなくば、この週は前年の週となり、次の週が1となります。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>%v</TT
> - <TT
CLASS="LITERAL"
>%e-%b-%Y</TT
>と同じです。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%W</TT
> - 10進の年内の週番号（月曜が週の先頭です）に置換されます(00-53)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%w</TT
> - 10進の週内日数（日曜が週の先頭です）に置換されます(0-6)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%X</TT
> - 各言語の時間表現に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%x</TT
> - 各言語の日付表現に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%Y</TT
> - 10進の世紀付年に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%y</TT
> - 10進の世紀なし年に置換されます(00-99)。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%Z</TT
> - 時間帯名称に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%z</TT
> - UTCからの時間帯オフセットに置換されます。
UTCより東では正符号が先頭に付き、西では負符号が付きます。
それぞれ2桁の時間と分がその後に続きますが、その区切りはありません。（この形式はRFC 822の日付ヘッダでよく使用されます。）
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%+</TT
> - 各言語の日付時刻表現に置換されます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%-*</TT
> - GNU libc拡張です。数値出力を行う際に何も文字を詰めません。
          </P
></LI
><LI
><P
>$_* - GNU libcの拡張です。明示的に空白文字を使用して文字を詰めます。
          </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>%0*</TT
> - GNU libcの拡張です。明示的に0を使用して文字を詰めます。
          </P
></LI
><LI
><P
>           <TT
CLASS="LITERAL"
>%%</TT
> - <TT
CLASS="LITERAL"
>%</TT
>に置換されます。
          </P
></LI
></UL
><P>
       </P
></DD
><DT
><A
NAME="PGTYPESTIMESTAMPSUB"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_sub</CODE
></DT
><DD
><P
>タイムスタンプの減算を行い、その結果をinterval型の変数に格納します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPEStimestamp_sub(timestamp *ts1, timestamp *ts2, interval *iv);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>ts1</TT
>が指し示すタイムスタンプ型変数から<TT
CLASS="LITERAL"
>ts2</TT
>が指し示すタイムスタンプ型変数を差し引き、<TT
CLASS="LITERAL"
>iv</TT
>が指し示すinterval型変数に結果を格納します。
       </P
><P
>成功すると、この関数は0を返し、エラーが発生した場合は負の値を返します。
       </P
></DD
><DT
><A
NAME="PGTYPESTIMESTAMPDEFMTASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_defmt_asc</CODE
></DT
><DD
><P
>書式マスクを使用して、テキスト表現からtimestamp値へ変換します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPEStimestamp_defmt_asc(char *str, char *fmt, timestamp *d);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>str</TT
>変数内に格納されたタイムスタンプのテキスト表現、<TT
CLASS="LITERAL"
>fmt</TT
>変数内に格納された使用される書式マスクを受付けます。
結果は<TT
CLASS="LITERAL"
>d</TT
>が指し示す変数内に格納されます。
       </P
><P
>書式マスク<TT
CLASS="LITERAL"
>fmt</TT
>が NULL ならば、この関数はデフォルトの書式マスク<TT
CLASS="LITERAL"
>%Y-%m-%d %H:%M:%S</TT
>を使用するようになります。
       </P
><P
>これは<A
HREF="ecpg-pgtypes.html#PGTYPESTIMESTAMPFMTASC"
><I
CLASS="TERM"
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_fmt_asc</CODE
></I
></A
>関数の逆です。
使用できる書式マスク項目についてはその文書を参照してください。
       </P
></DD
><DT
><A
NAME="PGTYPESTIMESTAMPADDINTERVAL"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_add_interval</CODE
></DT
><DD
><P
>timestamp型変数にinterval型変数を加算します。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPEStimestamp_add_interval(timestamp *tin, interval *span, timestamp *tout);</PRE
><P>
この関数はtimestamp型変数<TT
CLASS="LITERAL"
>tin</TT
>へのポインタとinterval型変数<TT
CLASS="LITERAL"
>span</TT
>へのポインタを受付けます。
これは、interval値をtimestamp値に加算し、その結果のtimestamp値を<TT
CLASS="LITERAL"
>tout</TT
>が指し示す変数に格納します。
       </P
><P
>成功するとこの関数は0を返します。
エラーが発生した場合は負の値を返します。
       </P
></DD
><DT
><A
NAME="PGTYPESTIMESTAMPSUBINTERVAL"
></A
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_sub_interval</CODE
></DT
><DD
><P
>timestamp型変数からinterval型変数の値を引きます。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPEStimestamp_sub_interval(timestamp *tin, interval *span, timestamp *tout);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>tin</TT
>が指し示すtimestamp型変数から<TT
CLASS="LITERAL"
>span</TT
>が指し示すinterval型変数を引きます。
結果は<TT
CLASS="LITERAL"
>tout</TT
>が指し示す変数に保存されます。
       </P
><P
>成功するとこの関数は0を、エラーが発生した場合は負の値を返します。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-PGTYPES-INTERVAL"
>34.6.4. interval型</A
></H2
><P
>Cにおけるinterval型を用いることにより、プログラムからSQLのinterval型のデータを扱うことができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバにおける対応する型については<A
HREF="datatype-datetime.html"
>項8.5</A
>を参照してください。
   </P
><P
>以下の関数を使用して、interval型を扱うことができます。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="PGTYPESINTERVALNEW"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESinterval_new</CODE
></DT
><DD
><P
>新しく割り当てたinterval型変数へのポインタを返します。
</P><PRE
CLASS="SYNOPSIS"
>interval *PGTYPESinterval_new(void);</PRE
><P>
       </P
></DD
><DT
><A
NAME="PGTYPESINTERVALFREE"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESinterval_free</CODE
></DT
><DD
><P
>以前に割り当てられたinterval型変数のメモリを解放します。
</P><PRE
CLASS="SYNOPSIS"
>void PGTYPESinterval_new(interval *intvl);</PRE
><P>
       </P
></DD
><DT
><A
NAME="PGTYPESINTERVALFROMASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESinterval_from_asc</CODE
></DT
><DD
><P
>テキスト表現からinterval型に変換します。
</P><PRE
CLASS="SYNOPSIS"
>interval *PGTYPESinterval_from_asc(char *str, char **endptr);</PRE
><P>
この関数は入力文字列<TT
CLASS="LITERAL"
>str</TT
>を変換し、割当てられたinterval型へのポインタを返します。
現在ECPGは文字列全体を解析しますので、現時点では<TT
CLASS="LITERAL"
>*endptr</TT
>に最初の無効な文字のアドレスを格納することをサポートしません。
このため<TT
CLASS="LITERAL"
>endptr</TT
>を安全に NULL にすることができます。
       </P
></DD
><DT
><A
NAME="PGTYPESINTERVALTOASC"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESinterval_to_asc</CODE
></DT
><DD
><P
>interval型変数をテキスト表現に変換します。
</P><PRE
CLASS="SYNOPSIS"
>char *PGTYPESinterval_to_asc(interval *span);</PRE
><P>
この関数は<TT
CLASS="LITERAL"
>span</TT
>が指し示すinterval型変数をC char*に変換します。
出力は<TT
CLASS="LITERAL"
>@ 1 day 12 hours 59 mins 10 secs</TT
>のようになります。
       </P
></DD
><DT
><A
NAME="PGTYPESINTERVALCOPY"
></A
><CODE
CLASS="FUNCTION"
>PGTYPESinterval_copy</CODE
></DT
><DD
><P
>interval型変数をコピーします。
</P><PRE
CLASS="SYNOPSIS"
>int PGTYPESinterval_copy(interval *intvlsrc, interval *intvldest);</PRE
><P>
この関数は、<TT
CLASS="LITERAL"
>intvlsrc</TT
>が指し示すinterval型変数を <TT
CLASS="LITERAL"
>intvldest</TT
>が指し示す変数にコピーします。
事前に格納先の変数用のメモリを割り当てる必要があることに注意してください。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-PGTYPES-DECIMAL"
>34.6.5. decimal型</A
></H2
><P
>decimal型はnumeric型に似ています。
しかし、その最大精度は30有効桁に制限されています。
ヒープ上にしか作成できないnumeric型と比べ、decimal型はスタックまたはヒープ上に作成することができます。
（このためには<CODE
CLASS="FUNCTION"
>PGTYPESdecimal_new</CODE
>および<CODE
CLASS="FUNCTION"
>PGTYPESdecimal_free</CODE
>関数を使用します。）
<A
HREF="ecpg-informix-compat.html"
>項34.15</A
>で説明する<SPAN
CLASS="PRODUCTNAME"
>Informix</SPAN
>互換モードではdecimal型を扱う関数がより多く存在します。
   </P
><P
>以下の関数を使用してdecimal型を扱うことができます。
これらは<TT
CLASS="LITERAL"
>libcompat</TT
>ライブラリに含まれるものだけではありません。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESdecimal_new</CODE
></DT
><DD
><P
>新しく割り当てられたdecimal型変数へのポインタを要求します。
</P><PRE
CLASS="SYNOPSIS"
>decimal *PGTYPESdecimal_new(void);</PRE
><P>
       </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>PGTYPESdecimal_free</CODE
></DT
><DD
><P
>decimal型を解放し、そのメモリをすべて解放します。
</P><PRE
CLASS="SYNOPSIS"
>void PGTYPESdecimal_free(decimal *var);</PRE
><P>
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-PGTYPES-ERRNO"
>34.6.6. pgtypeslibのerrno値</A
></H2
><P
>    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>PGTYPES_NUM_BAD_NUMERIC</TT
></DT
><DD
><P
>引数はnumeric型変数（またはnumeric型変数へのポインタ）を含んでいるはずですが、実際のメモリ上の表現は無効でした。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_NUM_OVERFLOW</TT
></DT
><DD
><P
>オーバーフローが発生しました。
numeric型はほぼ任意の精度を扱うことができますので、numeric型変数から他の型への変換ではオーバーフローが発生する可能性があります。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_NUM_UNDERFLOW</TT
></DT
><DD
><P
>アンダーフローが発生しました。
numeric型はほぼ任意の精度を扱うことができますので、numeric型変数から他の型への変換ではアンダーフローが発生する可能性があります。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_NUM_DIVIDE_ZERO</TT
></DT
><DD
><P
>ゼロ除算をしようとしました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_DATE_BAD_DATE</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPESdate_from_asc</CODE
>関数に無効な日付文字列が渡されました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_DATE_ERR_EARGS</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPESdate_defmt_asc</CODE
>関数に無効な引数が渡されました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_DATE_ERR_ENOSHORTDATE</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPESdate_defmt_asc</CODE
>関数により入力文字列内に無効なトークンが見つかりました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_INTVL_BAD_INTERVAL</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPESinterval_from_asc</CODE
>関数に無効な内部文字列が渡されました。
もしくは<CODE
CLASS="FUNCTION"
>PGTYPESinterval_to_asc</CODE
>関数に無効な内部値が渡されました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_DATE_ERR_ENOTDMY</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPESdate_defmt_asc</CODE
>関数内の日/月/年の代入において不整合がありました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_DATE_BAD_DAY</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPESdate_defmt_asc</CODE
>関数により無効な月内日数が見つかりました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_DATE_BAD_MONTH</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPESdate_defmt_asc</CODE
>関数によって無効な月値が見つかりました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_TS_BAD_TIMESTAMP</TT
></DT
><DD
><P
><CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_from_asc</CODE
>関数に無効なタイムスタンプ文字列が渡されました。
もしくは<CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_to_asc</CODE
>関数に無効なtimestamp値が渡されました。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>PGTYPES_TS_ERR_EINFTIME</TT
></DT
><DD
><P
>コンテキスト内で扱うことができない、無限なタイムスタンプ値がありました。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="ECPG-PGTYPES-CONSTANTS"
>34.6.7. pgtypeslibの特殊な定数</A
></H2
><P
>    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="PGTYPESINVALIDTIMESTAMP"
></A
><TT
CLASS="LITERAL"
>PGTYPESInvalidTimestamp</TT
></DT
><DD
><P
>無効なタイムスタンプを表すtimestamp型の値です。
これは解析エラーの場合に<CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_from_asc</CODE
>関数によって返されます。
<TT
CLASS="TYPE"
>timestamp</TT
>データ型の内部表現のため、<TT
CLASS="LITERAL"
>PGTYPESInvalidTimestamp</TT
>はまた同時に有効なタイムスタンプでもあります。
これは<TT
CLASS="LITERAL"
>1899-12-31 23:59:59</TT
>に設定されます。
エラーを検知するためには、<CODE
CLASS="FUNCTION"
>PGTYPEStimestamp_from_asc</CODE
>を呼び出す度にその後、<TT
CLASS="LITERAL"
>PGTYPESInvalidTimestamp</TT
>を試験するだけではなく、<TT
CLASS="LITERAL"
>errno != 0</TT
>も試験してください。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="ecpg-dynamic.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="ecpg-descriptors.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>動的SQL</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ecpg.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>記述子領域の使用</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
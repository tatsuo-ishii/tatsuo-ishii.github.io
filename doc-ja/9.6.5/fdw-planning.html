<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>外部データラッパのクエリプラン作成</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="外部データラッパの作成"
HREF="fdwhandler.html"><LINK
REL="PREVIOUS"
TITLE="外部データラッパヘルパ関数"
HREF="fdw-helpers.html"><LINK
REL="NEXT"
TITLE="外部データラッパでの行ロック"
HREF="fdw-row-locking.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="外部データラッパヘルパ関数"
HREF="fdw-helpers.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="fdwhandler.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 55章外部データラッパの作成</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="外部データラッパでの行ロック"
HREF="fdw-row-locking.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FDW-PLANNING"
>55.4. 外部データラッパのクエリプラン作成</A
></H1
><P
>FDWコールバック関数の<CODE
CLASS="FUNCTION"
>GetForeignRelSize</CODE
>、<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>、<CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>、<CODE
CLASS="FUNCTION"
>PlanForeignModify</CODE
>、<CODE
CLASS="FUNCTION"
>GetForeignJoinPaths</CODE
>、<CODE
CLASS="FUNCTION"
>GetForeignUpperPaths</CODE
>、<CODE
CLASS="FUNCTION"
>PlanDirectModify</CODE
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>プランナの動作と協調しなければなりません。ここでは、これらの関数がすべき事に関するいくつかの注意事項を述べます。
    </P
><P
><TT
CLASS="LITERAL"
>root</TT
>と<TT
CLASS="LITERAL"
>baserel</TT
>に含まれる情報は、外部テーブルから取得する必要のある情報の量(とそれによるコスト)を削減するために使用できます。
<TT
CLASS="LITERAL"
>baserel-&gt;baserestrictinfo</TT
>は、取得される行をフィルタリングする制約条件(<TT
CLASS="LITERAL"
>WHERE</TT
>句)を含んでいるため、特に興味深いものです。(コアのエグゼキュータが代わりにそれらをチェックできるので、FDW自身がこれらの制約を適用しなければならないわけではありません。)
<TT
CLASS="LITERAL"
>baserel-&gt;reltarget-&gt;exprs</TT
>はどの列が取得される必要があるかを決定するのに使用できます。ただし、このリストは<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノードから出力すべき列しか含んでおらず、条件検査には必要だがクエリからは出力されない列は含まないことに注意してください。
    </P
><P
>様々なプライベートフィールドがFDWのプラン作成関数で情報を格納する目的で利用できます。
一般的に、プラン作成の最後に回収できるように、FDW固有フィールドに格納するものは全てpallocで確保すべきです。
    </P
><P
><TT
CLASS="LITERAL"
>baserel-&gt;fdw_private</TT
>は、<TT
CLASS="TYPE"
>void</TT
>ポインタで、FDWのプラン作成関数で特定の外部テーブルに関する情報を格納する目的で利用できます。
コアプランナは、<TT
CLASS="LITERAL"
>RelOptInfo</TT
>ノードが作成されるときにNULLで初期化するときを除いて、このフィールドに一切に触れません。
このフィールドは、<CODE
CLASS="FUNCTION"
>GetForeignRelSize</CODE
>から<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>や<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>から<CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>といったように情報を順次伝えるの便利で、結果として再計算を省くことができます。
    </P
><P
><CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>では、<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>ノードの<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>フィールドに固有情報を格納することで、異なるアクセスパスを区別できます。<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>は<TT
CLASS="TYPE"
>List</TT
>ポインタとして宣言されていますが、コアプランナがこのフィールドを操作することはないため、実際にはなんでも格納できます。
しかし、バックエンドのデバッグサポート機能を利用できるように<CODE
CLASS="FUNCTION"
>nodeToString</CODE
>でダンプ出来る形式を使うのが最良の手法です。
    </P
><P
><CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>では、選択された<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>ノードの<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>フィールドを調べて、<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノード内に格納されプラン実行時に利用可能な<TT
CLASS="STRUCTFIELD"
>fdw_exprs</TT
>と<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>の二つのリストを生成することができます。
これらは両方とも<CODE
CLASS="FUNCTION"
>copyObject</CODE
>がコピーできる形式でなければなりません。
<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>リストにはこれ以外に制約はなく、コアバックエンドによって解釈されることはありません。
<TT
CLASS="STRUCTFIELD"
>fdw_exprs</TT
>リストがNILでない場合は、クエリ実行時に実行されることを意図した式ツリーが含まれていることが期待されます。
これらのツリーは、完全に実行可能な状態にするためにプランナによる後処理を受けます。
    </P
><P
><CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>では、一般的に渡されたターゲットリストはそのままプランノードにコピーできます。
渡された<TT
CLASS="LITERAL"
>scan_clauses</TT
>リストは<TT
CLASS="LITERAL"
>baserel-&gt;baserestrictinfo</TT
>と同じ句を含みますが、実行効率のよい別の順番に並べ替えることもできます。
FDWにできるのが<TT
CLASS="STRUCTNAME"
>RestrictInfo</TT
>ノードを<TT
CLASS="LITERAL"
>scan_clauses</TT
>リストから(<CODE
CLASS="FUNCTION"
>extract_actual_clauses</CODE
>を使って)抜き出して、全ての句をプランノードの条件リストに入れるだけ、といった単純なケースでは、全ての句は実行時にエグゼキュータによってチェックされます。
より複雑なFDWは内部で一部の句をチェックできるかもしれませんが、そのような場合には、エグゼキュータが再チェックのために時間を無駄にしないように、それらの句はプランノードの条件リストから削除できます。
    </P
><P
>たとえば、ローカル側で評価された<TT
CLASS="REPLACEABLE"
><I
>sub_expression</I
></TT
>の値があればリモートサーバ側で実行出来るとFDWが判断するような、<TT
CLASS="REPLACEABLE"
><I
>foreign_variable</I
></TT
> <TT
CLASS="LITERAL"
>=</TT
> <TT
CLASS="REPLACEABLE"
><I
>sub_expression</I
></TT
>といった形式の条件句をFDWが識別するかもしれません。
パスのコスト見積もりに影響するので、そのような句の実際の識別は<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>でなされるべきです。
おそらく、そのパスの<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>フィールドは識別された句の<TT
CLASS="STRUCTNAME"
>RestrictInfo</TT
>ノードをさすポインタを含むでしょう。
そして、<CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>はその句を<TT
CLASS="LITERAL"
>scan_clauses</TT
>から取り除き、実行可能な形式にほぐされることを保障するために<TT
CLASS="REPLACEABLE"
><I
>sub_expression</I
></TT
>を<TT
CLASS="STRUCTFIELD"
>fdw_exprs</TT
>に追加するでしょう。
また、おそらく、実行時に何をすべきかをプラン実行関数に伝えるためにプランノードの<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>フィールドに制御情報を入れるでしょう。
リモートサーバに送られたクエリは、実行時に<TT
CLASS="STRUCTFIELD"
>fdw_exprs</TT
>式ツリーを評価して得られた値をパラメータ値とする<TT
CLASS="LITERAL"
>WHERE <TT
CLASS="REPLACEABLE"
><I
>foreign_variable</I
></TT
> = $1</TT
>のようなものを伴うでしょう。
    </P
><P
><TT
CLASS="LITERAL"
>READ COMMITTED</TT
>分離レベルでの正しい動作を保証するため、プランノードの条件リストから除かれた句はすべて、代わりに<TT
CLASS="LITERAL"
>fdw_recheck_quals</TT
>に追加されるか、<TT
CLASS="LITERAL"
>RecheckForeignScan</TT
>で再検査される必要があります。
問い合わせに含まれる他のテーブルで同時更新があった場合、エグゼキュータはタプルが元の条件を、それも場合によっては異なるパラメータ値の組み合わせに対して満たすことを確認する必要があるかもしれません。
<TT
CLASS="LITERAL"
>fdw_recheck_quals</TT
>を使うのは、<TT
CLASS="LITERAL"
>RecheckForeignScan</TT
>の内部で検査を実装するより、通常は簡単でしょう。
しかしこの方法は、外部結合がプッシュダウンされる場合は不十分です。
なぜなら、この場合の結合タプルはタプル全体を拒絶せずに、一部のフィールドをNULLにしてしまうからです。
    </P
><P
>FDWがセットできる別の<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>フィールドに<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>があります。
これはこのプランノードについてFDWが返すタプルを記述するものです。
単純な外部テーブルスキャンに対しては、これを<TT
CLASS="LITERAL"
>NIL</TT
>にセットすることができ、それは戻されるタプルが外部テーブルで宣言された行型を持つことを意味します。
<TT
CLASS="SYMBOL"
>NIL</TT
>でない値はVar、あるいは返される列を表す式、あるいはその両方を含む対象のリスト（<TT
CLASS="STRUCTNAME"
>TargetEntry</TT
>のリスト）でなければなりません。
これは例えば、FDWが問い合わせのために必要ないと気づいた列を無視したことを示すのに使えるかもしれません。
また、FDWが問い合わせで使われる式をローカルで計算するより安価に計算できるなら、それらの式を<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>に追加することができます。
結合プラン（<CODE
CLASS="FUNCTION"
>GetForeignJoinPaths</CODE
>が作るパスから作成される）は、それが返す列の集合を記述する<TT
CLASS="STRUCTFIELD"
>fdw_scan_tlist</TT
>を必ず提供しなければならないことに注意して下さい。
    </P
><P
>FDWはそのテーブルの条件句のみに依存するパスを常に少なくとも一つは生成すべきです。結合クエリでは、例えば<TT
CLASS="REPLACEABLE"
><I
>foreign_variable</I
></TT
> <TT
CLASS="LITERAL"
>=</TT
> <TT
CLASS="REPLACEABLE"
><I
>local_variable</I
></TT
>といった結合句に依存するパス(群)を生成することもできます。
そのような句は<TT
CLASS="LITERAL"
>baserel-&gt;baserestrictinfo</TT
>には見つからず、リレーションの結合リストにあるはずです。
そのような句を使用するパスは<SPAN
CLASS="QUOTE"
>"パラメータ化されたパス"</SPAN
>と呼ばれます。
このようなパスでは、選択された結合句（群）で使用されているリレーション（群）を<TT
CLASS="LITERAL"
>param_info</TT
>の適合する値から特定しなければなりません;その値を計算するには<CODE
CLASS="FUNCTION"
>get_baserel_parampathinfo</CODE
>を使用します。
<CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>では、結合句の<TT
CLASS="REPLACEABLE"
><I
>local_variable</I
></TT
>部分が<TT
CLASS="STRUCTFIELD"
>fdw_exprs</TT
>に追加され、実行時には通常の条件句と同じように動作します。
    </P
><P
>FDWがリモートでの結合をサポートする場合、<CODE
CLASS="FUNCTION"
>GetForeignPaths</CODE
>がベーステーブルに対して処理するのとほぼ同じように、<CODE
CLASS="FUNCTION"
>GetForeignJoinPaths</CODE
>は潜在的なリモートの結合に対して<TT
CLASS="STRUCTNAME"
>ForeignPath</TT
>を生成することになります。
意図した結合に関する情報は、上記と同じ方法で<CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>に送ることができます。
しかし、<TT
CLASS="STRUCTFIELD"
>baserestrictinfo</TT
>は結合のリレーションには関連がなく、代わりに、特定の結合に関連するJOIN句は<CODE
CLASS="FUNCTION"
>GetForeignJoinPaths</CODE
>に別のパラメータ(<TT
CLASS="LITERAL"
>extra-&gt;restrictlist</TT
>)として渡されます。
    </P
><P
>FDWはグルーピングや集約のような、スキャンや結合のレベルより上位のプラン動作の直接実行を追加的にサポートできるかもしれません。
このような方法を行うには、FDWはパスを生成して、それを適切な<I
CLASS="FIRSTTERM"
>上位リレーション</I
>に挿入する必要があります。
例えば、リモート集約をあらわすパスは<CODE
CLASS="FUNCTION"
>add_path</CODE
>を使って<TT
CLASS="LITERAL"
>UPPERREL_GROUP_AGG</TT
>リレーションに挿入されるべきです。
このパスは外部リレーションに対する単純なスキャンパスを読むことによるローカル集約実行とコストに基づいて比較されます（このようなパスが提供されなければならないことに注意してください、さもないとプラン時にエラーになります）。
リモート集約パスが、通常そうなりますが、勝った場合には、パスは<CODE
CLASS="FUNCTION"
>GetForeignPlan</CODE
>を呼ぶ通常の手段でプランに変換されます。
もし問い合わせの全てのベースリレーションが同じFDWから来るなら、このようなパスを生成するのに推奨される場所は、各上位リレーション（すなわち各スキャン/結合後の処理の段階）に対して呼び出される<CODE
CLASS="FUNCTION"
>GetForeignUpperPaths</CODE
>コールバック関数の中です。
    </P
><P
><CODE
CLASS="FUNCTION"
>PlanForeignModify</CODE
>と<A
HREF="fdw-callbacks.html#FDW-CALLBACKS-UPDATE"
>項55.2.4</A
>で記述された他のコールバックは、外部リレーションは通常の方法でスキャンされ、それから個別の行変更がローカルの<TT
CLASS="LITERAL"
>ModifyTable</TT
>プランノードで駆動されるという想定をもとに設計されています。
この方法は変更が外部テーブルと同様にローカルテーブルを読む必要がある一般的な場合に必要です。
しかしながら、操作が全体的に外部サーバで実行できるなら、FDWはそのようにするパスを生成して<TT
CLASS="LITERAL"
>UPPERREL_FINAL</TT
>上位リレーションに挿入することができます。ここでは<TT
CLASS="LITERAL"
>ModifyTable</TT
>方式に対して競合します。
この方式は、<A
HREF="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING"
>項55.2.5</A
>で記述された行ロックコールバックを使うのでなしに、リモート<TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
>を実装するのにも使われます。
<TT
CLASS="LITERAL"
>UPPERREL_FINAL</TT
>に挿入されたパスは問い合わせの<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>全ての</I
></SPAN
>振る舞いの実装に責任があることに留意してください。
    </P
><P
><TT
CLASS="COMMAND"
>UPDATE</TT
>や<TT
CLASS="COMMAND"
>DELETE</TT
>のプランを生成しているとき、
<CODE
CLASS="FUNCTION"
>PlanForeignModify</CODE
>と<CODE
CLASS="FUNCTION"
>PlanDirectModify</CODE
>は、事前にスキャンプラン生成関数で作られた<TT
CLASS="LITERAL"
>baserel-&gt;fdw_private</TT
>データを使うために、その外部テーブルのための<TT
CLASS="STRUCTNAME"
>RelOptInfo</TT
>構造体を検索することができます。
しかしながら、<TT
CLASS="COMMAND"
>INSERT</TT
>では対象テーブルはスキャンされないので対応する<TT
CLASS="STRUCTNAME"
>RelOptInfo</TT
>は存在しません。
<CODE
CLASS="FUNCTION"
>PlanForeignModify</CODE
>から返される<TT
CLASS="STRUCTNAME"
>List</TT
>には、<TT
CLASS="STRUCTNAME"
>ForeignScan</TT
>プランノードの<TT
CLASS="STRUCTFIELD"
>fdw_private</TT
>リストと同様に、<CODE
CLASS="FUNCTION"
>copyObject</CODE
>がコピーの仕方を知っている構造体しか保持してはいけないという制約があります。
    </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT</TT
>句のある<TT
CLASS="COMMAND"
>INSERT</TT
>は競合の対象の指定をサポートしません。
なぜなら、リモートのテーブルの一意制約や排他制約についての情報がローカルにはないからです。
これは結果的に<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>がサポートされないことを意味します。
なぜなら、競合の対象の指定が必須だからです。
    </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="fdw-helpers.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="fdw-row-locking.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>外部データラッパヘルパ関数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="fdwhandler.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>外部データラッパでの行ロック</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
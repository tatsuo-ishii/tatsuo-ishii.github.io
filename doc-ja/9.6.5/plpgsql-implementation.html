<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>PL/pgSQLの秘訣</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="PL/pgSQL - SQL手続き言語"
HREF="plpgsql.html"><LINK
REL="PREVIOUS"
TITLE="トリガプロシージャ"
HREF="plpgsql-trigger.html"><LINK
REL="NEXT"
TITLE="PL/pgSQLによる開発向けのヒント"
HREF="plpgsql-development-tips.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="トリガプロシージャ"
HREF="plpgsql-trigger.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="plpgsql.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 41章<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
> - <ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>手続き言語</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="PL/pgSQLによる開発向けのヒント"
HREF="plpgsql-development-tips.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PLPGSQL-IMPLEMENTATION"
>41.10. <SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>の秘訣</A
></H1
><P
>本節では、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>利用者の知識として重要な、実装の詳細を述べます。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-VAR-SUBST"
>41.10.1. 変数置換</A
></H2
><P
><SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>関数内のSQL文および式は変数および関数のパラメータを参照することができます。
背後では、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>はこうした参照を問い合わせパラメータに置き換えます。
パラメータまたは列参照が文法的に許されているところでのみパラメータは置換されます。
極端な場合として、以下のよろしくないプログラミングスタイルの例を考えてみましょう。
</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO foo (foo) VALUES (foo);</PRE
><P>
最初に現れる<TT
CLASS="LITERAL"
>foo</TT
>の場所は文法的にはテーブル名でなければなりません。
このため関数が<TT
CLASS="LITERAL"
>foo</TT
>という名前の変数を持っていたとしても、置換されません。
2番目の場所はテーブルの列名でなければなりません。
このためこれも置換されません。
3番目の場所のみが関数の変数参照の候補です。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>9.0より前の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、3つの場合すべてにおいて変数を置換しようとし、構文エラーを引き起こしました。
    </P
></BLOCKQUOTE
></DIV
><P
>変数名は文法的にはテーブル列名と違いがありませんので、テーブルを参照する文の中であいまいさが出る可能性があります。
与えられた名前はテーブル列を意味するのでしょうか、それとも変数なのでしょうか。
前の例を次のように変えてみましょう。
</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO dest (col) SELECT foo + bar FROM src;</PRE
><P>
ここでは、<TT
CLASS="LITERAL"
>dest</TT
>および<TT
CLASS="LITERAL"
>src</TT
>はテーブル名でなければなりません。
また、<TT
CLASS="LITERAL"
>col</TT
>は<TT
CLASS="LITERAL"
>dest</TT
>の列でなければなりませんが、<TT
CLASS="LITERAL"
>foo</TT
>および<TT
CLASS="LITERAL"
>bar</TT
>は理論上関数の変数かもしれませんし、<TT
CLASS="LITERAL"
>src</TT
>の列かもしれません。
   </P
><P
>デフォルトで<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>はSQL文における名前が変数かテーブル列のいずれかを参照可能な場合にエラーを報告します。
変数または列の名前を変更することやあいまいな参照を修飾すること、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>にどちらを優先して解釈するかを通知することで、こうした問題を解消することができます。
   </P
><P
>最も簡単な解法は変数名または列名を変更することです。
一般的なコーディング法として、列の命名と<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>変数の命名とで規約を分ける方法があります。
例えば、一貫して関数の変数は<TT
CLASS="LITERAL"
>v_<TT
CLASS="REPLACEABLE"
><I
>something</I
></TT
></TT
>という名前とし、列名は<TT
CLASS="LITERAL"
>v_</TT
>で始まらないようにすれば、競合は起こりません。
   </P
><P
>その他、あいまいな参照を明確にするために修飾することができます。
上の例では、<TT
CLASS="LITERAL"
>src.foo</TT
>によりテーブル列への参照についてあいまいさが解消します。
あいまい性のない変数参照を行うためには、ラベル付けしたブロック内で変数を宣言し、そのブロックのラベルを使用します(<A
HREF="plpgsql-structure.html"
>項41.2</A
>参照)。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;</PRE
><P>
ここで<TT
CLASS="LITERAL"
>block.foo</TT
>は<TT
CLASS="LITERAL"
>src</TT
>に<TT
CLASS="LITERAL"
>foo</TT
>列があったとしても、変数を意味することになります。
<TT
CLASS="LITERAL"
>FOUND</TT
>などの特別な変数を含め、関数パラメータを関数名で修飾することができます。
これらは暗黙的に関数名をラベル名とした上位ブロック内で宣言されているためです。
   </P
><P
><SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>の大規模な本体コードにおける、すべてのあいまいな参照を修正することが現実的ではない場合があります。
こうした場合、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>にあいまいな参照を変数として解決すべき(この動作は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.0より前の<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>の動作と互換性を持ちます)、または、テーブル列参照として解決すべき(<SPAN
CLASS="PRODUCTNAME"
>Oracle</SPAN
>などの他のシステムと互換性を持ちます)と指定することができます。
   </P
><P
>システム全体に対してこの動作を変更するためには<TT
CLASS="LITERAL"
>plpgsql.variable_conflict</TT
>設定パラメータを<TT
CLASS="LITERAL"
>error</TT
>、<TT
CLASS="LITERAL"
>use_variable</TT
>、<TT
CLASS="LITERAL"
>use_column</TT
>のいずれかに設定します(<TT
CLASS="LITERAL"
>error</TT
>が標準配布におけるデフォルトです)。
このパラメータは以降の<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>関数の文のコンパイルに影響しますが、現在のセッションでコンパイル済みの文には影響を与えません。
この設定を変更することで、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>の動作において予期できない変化が発生することがありますので、これはスーパーユーザのみが変更することができます。
   </P
><P
>また、関数テキストの先頭に以下の特殊なコマンドの1つをいれることで、関数単位で動作を設定することもできます。
</P><PRE
CLASS="PROGRAMLISTING"
>#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column</PRE
><P>
これらのコマンドを記述した関数に対してのみ、コマンドは影響を与え、<TT
CLASS="LITERAL"
>plpgsql.variable_conflict</TT
>の設定を上書きします。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;</PRE
><P>
<TT
CLASS="LITERAL"
>UPDATE</TT
>コマンドにおいて、<TT
CLASS="LITERAL"
>curtime</TT
>、<TT
CLASS="LITERAL"
>comment</TT
>および<TT
CLASS="LITERAL"
>id</TT
>は、<TT
CLASS="LITERAL"
>users</TT
>に同名の列があるか否かに関わらず、関数の変数またはパラメータを参照します。
テーブル列を参照させるために<TT
CLASS="LITERAL"
>WHERE</TT
>句において<TT
CLASS="LITERAL"
>users.id</TT
>と参照を修飾する必要があったことに注意して下さい。
しかし<TT
CLASS="LITERAL"
>UPDATE</TT
>リストの対象としての<TT
CLASS="LITERAL"
>comment</TT
>への参照は修飾させる必要がありませんでした。
これは文法的に<TT
CLASS="LITERAL"
>users</TT
>の列でなければならないためです。
以下のように<TT
CLASS="LITERAL"
>variable_conflict</TT
>の設定に依存せずに同じ関数を作成することもできます。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;</PRE
><P>
   </P
><P
>変数置換は<TT
CLASS="COMMAND"
>EXECUTE</TT
>コマンドまたはその亜種におけるコマンド文字列の中では起こりません。
そのようなコマンドに可変値を挿入する時は、<A
HREF="plpgsql-statements.html#PLPGSQL-STATEMENTS-EXECUTING-DYN"
>項41.5.4</A
>に述べたように、文字列の値を構成するものの一部とするか<TT
CLASS="LITERAL"
>USING</TT
>を使用してください。
   </P
><P
>今のところ変数置換は、<TT
CLASS="COMMAND"
>SELECT</TT
>と<TT
CLASS="COMMAND"
>INSERT</TT
>と<TT
CLASS="COMMAND"
>UPDATE</TT
>と<TT
CLASS="COMMAND"
>DELETE</TT
>コマンドの中だけで作動します。
メインSQLエンジンが問い合わせパラメータをこれらのコマンドでしか許可しないからです。
他の種類の文（通常ユーティリティ文といいます）において可変名または可変値を使用するには、文字列としてユーティリティ文を構成し<TT
CLASS="COMMAND"
>EXECUTE</TT
>してください。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PLPGSQL-PLAN-CACHING"
>41.10.2. 計画のキャッシュ</A
></H2
><P
><SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>インタプリタは、初めてその関数が（各セッションで）呼び出された時に、関数のソーステキストを解析し、バイナリ形式の命令ツリーを内部で作成します。
この命令ツリーは完全に<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>文構造に変換されますが、関数内部の個々の<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>式と<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>コマンドは即座に変換されません。
   </P
><P
>    
各式や<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>コマンドが初めてその関数で実行される時に、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>インタプリタは<ACRONYM
CLASS="ACRONYM"
>SPI</ACRONYM
>マネージャの<CODE
CLASS="FUNCTION"
>SPI_prepare</CODE
>関数を使用して、プリペアドステートメントを作成するためにコマンドを解析します。
その後にその式やコマンドが行われる時には、そのプリペアドステートメントを再利用します。
こうして、めったに分岐されない条件付きコードパスを持つ関数では、現在のセッションで実行されないそれらのコマンドの解析によるオーバーヘッドを背負いこむことはありません。
欠点は特定の式や問い合わせのエラーが、関数の該当部分が実行されるまで検出されないことです。
（典型的な構文エラーは、最初の解釈において検出されますが、それより深いエラーは、実行の時まで検出されません）。
   </P
><P
><SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>は（正確にはSPIマネージャは）さらに特定のプリペアドステートメントに関する実行計画のキャッシュを試行できます。
キャッシュした実行計画が使用されなかった場合、プリペアドステートメントが呼び出される度に新しい実行計画が作成され、選択した実行計画を最適にするために、最新のパラメータ値（すなわち<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>の変数値）が使用されます。
プリペアドステートメントがパラメータを持たないか何回も使用される場合、SPIマネージャは特定のパラメータ値に依存しない<I
CLASS="FIRSTTERM"
>一般的</I
>な実行計画の作成を考え、再使用のためにキャッシュします。
典型的には、これは参照した<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>の変数値が、実行計画にさほど影響しない場合にだけ起こります。
それならば、毎回の実行計画の作成の方が優れています。
プリペアドステートメントに関する詳細は<A
HREF="sql-prepare.html"
>PREPARE</A
>を参照してください。
   </P
><P
>このように<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>はプリペアドステートメントおよび時には実行計画を保存しますので、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>関数内に直接現れるSQLコマンドは実行の度に同じテーブルとフィールドを参照しなければなりません。
つまり、SQLコマンドにて、テーブルやフィールドの名前としてパラメータを使用することができません。
実行の度に新しく実行計画を作成して解析する無駄を覚悟で、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>の<TT
CLASS="COMMAND"
>EXECUTE</TT
>文を使った動的問い合わせを構成することで、この制限を回避できます。
   </P
><P
>レコード変数の変わりやすいという性質はこの接続において別の問題となります。
レコード変数のフィールドが式や文の中で使用される場合、そのフィールドのデータ型を関数を呼び出す度に変更してはいけません。
それぞれの式が最初に実行された時のデータ型を使用して、その式が解析されているからです。
必要な場合<TT
CLASS="COMMAND"
>EXECUTE</TT
>を使用してこの問題を回避することができます。
    </P
><P
>同一の関数が2つ以上のテーブルのトリガとして使用される場合、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>はテーブルごとのプリペアドステートメントをキャッシュします。
すなわち、各々のトリガ関数とテーブルの組ごとにキャッシュするのであり、トリガ関数ごとではありません。
このため、データ型の変更に伴う問題の一部を軽減します。
例えば、別のテーブルにある異なったデータ型であっても、<TT
CLASS="LITERAL"
>key</TT
>と命名した列に対してトリガ関数は有効に作動します。
    </P
><P
>同様に、多様型の引数を持った関数は、実際に呼び出す引数の型の組み合わせごとに別々のプリペアドステートメントをキャッシュします。
そのため、データ型の差異が原因で予期しない失敗が起こることはありません。
    </P
><P
>プリペアドステートメントのキャッシュにより、時間に依存する値の解釈の結果に違いが現れることがあります。
例えば、以下の2つの関数の結果は異なります。

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;</PRE
><P>

および

</P><PRE
CLASS="PROGRAMLISTING"
>CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;</PRE
><P>
    </P
><P
><CODE
CLASS="FUNCTION"
>logfunc1</CODE
>の場合では、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のメインパーサは、<TT
CLASS="COMMAND"
>INSERT</TT
>を解析する時に、<CODE
CLASS="CLASSNAME"
>logtable</CODE
>の対象列の型から<TT
CLASS="LITERAL"
>'now'</TT
>を<TT
CLASS="TYPE"
>timestamp</TT
>と解釈しなければならないことを把握しています。
こうして、パーサは<TT
CLASS="COMMAND"
>INSERT</TT
>が解析された時点で<TT
CLASS="LITERAL"
>'now'</TT
>を<TT
CLASS="TYPE"
>timestamp</TT
>定数に変換し、その定数値をその後のセッションの有効期間における<CODE
CLASS="FUNCTION"
>logfunc1</CODE
>の全ての呼び出しで使用します。
言うまでもありませんが、これはプログラマが意図した動作ではありません。
<TT
CLASS="LITERAL"
>now()</TT
>または<TT
CLASS="LITERAL"
>current_timestamp</TT
>関数の使用が優れています。
    </P
><P
><CODE
CLASS="FUNCTION"
>logfunc2</CODE
>の場合では、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のメインパーサは<TT
CLASS="LITERAL"
>'now'</TT
>の型を決定することができません。
そのため、<TT
CLASS="LITERAL"
>now</TT
>という文字列を持つ<TT
CLASS="TYPE"
>text</TT
>型のデータ値を返します。
<TT
CLASS="VARNAME"
>curtime</TT
>ローカル変数に代入する時に、<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>インタプリタはこの文字列を<CODE
CLASS="FUNCTION"
>text_out</CODE
>と<CODE
CLASS="FUNCTION"
>timestamp_in</CODE
>関数を変換に使用して<TT
CLASS="TYPE"
>timestamp</TT
>型にキャストします。
ですから、演算されたタイムスタンプは、プログラマが意図した通り、実行の度に更新されます。
この方法でたまたま意図した通り動くけれど、それほど効率的ではありません。
ですから、<TT
CLASS="LITERAL"
>now()</TT
>関数の使用の方が優れています。
    </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="plpgsql-trigger.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="plpgsql-development-tips.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>トリガプロシージャ</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="plpgsql.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>による開発向けのヒント</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
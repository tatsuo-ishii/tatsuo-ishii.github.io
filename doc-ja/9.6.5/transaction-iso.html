<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>トランザクションの分離</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="同時実行制御"
HREF="mvcc.html"><LINK
REL="PREVIOUS"
TITLE="序文"
HREF="mvcc-intro.html"><LINK
REL="NEXT"
TITLE="明示的ロック"
HREF="explicit-locking.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="序文"
HREF="mvcc-intro.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 13章同時実行制御</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="明示的ロック"
HREF="explicit-locking.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TRANSACTION-ISO"
>13.2. トランザクションの分離</A
></H1
><P
><ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の標準規格では、トランザクションの分離について4つのレベルを定義しています。
標準規格で定義されているもののうち最も厳密なものはシリアライザブルです。
1セットのシリアライザブルなトランザクションを同時実行した場合には、ある順番でひとつずつそれらを実行した場合と同じ結果となることが保証されるものです。本文で詳しく述べます。
他の3レベルは、同時実行しているトランザクション間の相互作用に起因する、各レベルでは発生してはならない現象面に基づき定義されます。
標準規格のシリアライザブルの定義では、このレベルではこれらの現象が起こりえないと述べています。
(これは驚くことではありません。トランザクションの効果がひとつずつ実行された場合と一貫性を持たなければならないとしたら、相互作用によって発生した現象はどうやっても見つけ出すことはできないでしょう。)
   </P
><P
>各種レベルにおける禁止される現象を以下に示します。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
>ダーティリード
       </DT
><DD
><P
>同時に実行されている他のトランザクションが書き込んで未だコミットしていないデータを読み込んでしまう。
       </P
></DD
><DT
>反復不能読み取り
       </DT
><DD
><P
>トランザクションが、以前読み込んだデータを再度読み込み、そのデータが(最初の読み込みの後にコミットした)別のトランザクションによって更新されたことを見出す。
       </P
></DD
><DT
>ファントムリード
       </DT
><DD
><P
>トランザクションが、複数行のある集合を返す検索条件で問い合わせを再実行した時、別のトランザクションがコミットしてしまったために、同じ検索条件で問い合わせを実行しても異なる結果を得てしまう。
       </P
></DD
><DT
>直列化異常
       </DT
><DD
><P
>複数のトランザクションを正常にコミットした結果が、それらのトランザクションを1つずつあらゆる可能な順序で実行する場合とは一貫性がない。
       </P
></DD
></DL
></DIV
><P>
   </P
><P
>    
標準SQLおよびPostgreSQLで実装されているトランザクション分離レベルを<A
HREF="transaction-iso.html#MVCC-ISOLEVEL-TABLE"
>表13-1</A
>に示します。
   </P
><DIV
CLASS="TABLE"
><A
NAME="MVCC-ISOLEVEL-TABLE"
></A
><P
><B
>表 13-1. トランザクション分離レベル</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>分離レベル
        </TH
><TH
>ダーティリード
        </TH
><TH
>反復不能読み取り
        </TH
><TH
>ファントムリード
        </TH
><TH
>直列化異常
        </TH
></TR
></THEAD
><TBODY
><TR
><TD
>リードアンコミッティド
        </TD
><TD
>許容されるが、PostgreSQLでは発生しない
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
></TR
><TR
><TD
>リードコミッティド
        </TD
><TD
>安全
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
><TD
>可能性あり
        </TD
></TR
><TR
><TD
>リピータブルリード
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
><TD
>許容されるが、PostgreSQLでは発生しない
        </TD
><TD
>可能性あり
        </TD
></TR
><TR
><TD
>シリアライザブル
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
><TD
>安全
        </TD
></TR
></TBODY
></TABLE
></DIV
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、4つの標準トランザクション分離レベルを全て要求することができます。
しかし、内部的には3つの分離レベルしか実装されていません。
つまり、PostgreSQLのリードアンコミッティドモードは、リードコミッティドのように動作します。
これは、PostgreSQLの多版型同時実行制御という仕組みに標準の分離レベルを関連付ける実際的な方法がこれしかないからです。
   </P
><P
>このテーブルはまた、PostgreSQLのリピータブルリードの実装ではファントムリードが起こらないことを示しています。
より厳密な動作をすることは標準SQLでも許されています。
つまり、この4つの分離レベルでは、発生してはならない事象のみが定義され、発生<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>しなければならない</I
></SPAN
>事象は定義されていません。
利用可能な分離レベルでの動作については後で詳細に説明します。
   </P
><P
>トランザクションのトランザクション分離レベルを設定するには<A
HREF="sql-set-transaction.html"
>SET TRANSACTION</A
>コマンドを使用してください。
   </P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>重要項目: </B
>いくつかの<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>データ型と関数はトランザクションの振る舞いに関して特別の規則があります。
特に、シーケンスに対しての変更は（従い、<TT
CLASS="TYPE"
>serial</TT
>を使用して宣言された列のカウンタ）は直後に全ての他のトランザクションで可視となり、変更を行ったトランザクションが中止されるとロールバックはできません。
<A
HREF="functions-sequence.html"
>項9.16</A
>および<A
HREF="datatype-numeric.html#DATATYPE-SERIAL"
>項8.1.4</A
>を参照してください。
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-READ-COMMITTED"
>13.2.1. リードコミッティド分離レベル</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では<I
CLASS="FIRSTTERM"
>リードコミッティド</I
>がデフォルトの分離レベルです。
トランザクションがこの分離レベルを使用すると、<TT
CLASS="COMMAND"
>SELECT</TT
>問い合わせ（<TT
CLASS="LITERAL"
>FOR UPDATE/SHARE</TT
>句を伴わない）はその問い合わせが実行される直前までにコミットされたデータのみを参照し、まだコミットされていないデータや、その問い合わせの実行中に別の同時実行トランザクションがコミットした更新は参照しません。
結果として、<TT
CLASS="COMMAND"
>SELECT</TT
>問い合わせはその問い合わせが実行を開始した時点のデータベースのスナップショットを参照することになります。
しかし<TT
CLASS="COMMAND"
>SELECT</TT
>文は、自分自身のトランザクション内で実行され更新された結果はたとえまだコミットされていなくても参照します。
単一のトランザクション内であっても、<TT
CLASS="COMMAND"
>SELECT</TT
>文を2回連続して発行した場合、最初の<TT
CLASS="COMMAND"
>SELECT</TT
>文が開始した後で2番目の<TT
CLASS="COMMAND"
>SELECT</TT
>文が開始する前に他のトランザクションが更新をコミットすると、最初とその次に発行した<TT
CLASS="COMMAND"
>SELECT</TT
>問い合わせは異なるデータを参照してしまうことにも注意してください。
   </P
><P
><TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>、<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>、および<TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
>コマンドは対象行を検索する際に<TT
CLASS="COMMAND"
>SELECT</TT
>コマンドと同じように振舞います。
これらのコマンドは、問い合わせが開始された時点で既にコミットされた対象行のみを検出します。
しかし、その対象行は、検出されるまでに、同時実行中の他のトランザクションによって、既に更新（もしくは削除あるいはロック）されてしまっているかもしれません。
このような場合更新されるべき処理は、最初の更新トランザクションが（それがまだ進行中の場合）コミットもしくはロールバックするのを待ちます。
最初の更新処理がロールバックされるとその結果は無視されて、2番目の更新処理で元々検出した行の更新を続行することができます。
最初の更新処理がコミットされると、2番目の更新処理では、最初の更新処理により行が削除された場合はその行を無視します。
行が削除されなかった時の更新処理は、最初のコミットで更新された行に適用されます。
コマンドの検索条件（<TT
CLASS="LITERAL"
>WHERE</TT
>句）は、更新された行がまだその検索条件に一致するかどうかの確認のため再評価されます。
検索条件と一致している場合、2番目の更新処理は、更新された行を使用して処理を開始します。
<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>および<TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
>の場合、ロックされクライアントに返されるのは、更新されるバージョンの行であることを意味します。
   </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>句のある<TT
CLASS="COMMAND"
>INSERT</TT
>は同じように動作します。
リードコミッティドモードでは、挿入を提案された各行は挿入または更新されます。
無関係なエラーが発生しなければ、それら2つの結果のうち1つが保証されます。
まだその結果が<TT
CLASS="COMMAND"
>INSERT</TT
>に対して可視になっていない他のトランザクションに起因する競合では、慣習的な意味でそのコマンドに対して可視のバージョンの行が存在<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>しない</I
></SPAN
>にも関わらず、<TT
CLASS="COMMAND"
>UPDATE</TT
>句がその行に対して動作します。
   </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT DO NOTHING</TT
>句のある<TT
CLASS="COMMAND"
>INSERT</TT
>では、<TT
CLASS="COMMAND"
>INSERT</TT
>のスナップショットに対してその結果が可視になっていない他のトランザクションの結果のために、行の挿入が処理されないかもしれません。
ここでも、問題になるのはリードコミッティドモードのときだけです。
   </P
><P
>このような仕組みにより、更新コマンドが、一貫しないスナップショットを参照する可能性があります。
つまり、自分が更新を試みているのと同じ行に対して同時に更新するコマンドの結果は参照できますが、それらのコマンドがデータベース中の他の行に対して更新した結果は参照しません。
このような動作をするために複雑な検索条件を含む問い合わせにリードコミッティドモードを使用することは適切ではありません。
しかし、より単純な検索条件の場合、このモードの使用が適しています。
例えば、銀行の残高を更新する以下のようなトランザクションを考えてみます。

</P><PRE
CLASS="SCREEN"
>BEGIN;
UPDATE accounts SET balance = balance + 100.00 WHERE acctnum = 12345;
UPDATE accounts SET balance = balance - 100.00 WHERE acctnum = 7534;
COMMIT;</PRE
><P>

2つのこのようなトランザクションが同時に口座番号12345の残高を変更しようとした場合、口座の行の更新されたバージョンに対して2番目のトランザクションが開始されることは明らかに望まれるところです。
各コマンドは事前に決定していた行に対してのみ処理を行うため、行の更新されたバージョンを見せることによって、何の問題となる不整合も引き起こしません。
   </P
><P
>より複雑な使用法により、リードコミッティドモードでは好ましくない結果を生成する場合があります。
例えば、別のコマンドによって<TT
CLASS="COMMAND"
>DELETE</TT
>の制約条件からデータが同時に追加・削除される場合を考えます。
例えば、<TT
CLASS="LITERAL"
>website</TT
>は2行のテーブルで、<TT
CLASS="LITERAL"
>website.hits</TT
>の値には<TT
CLASS="LITERAL"
>9</TT
>と<TT
CLASS="LITERAL"
>10</TT
>があるとします。

</P><PRE
CLASS="SCREEN"
>BEGIN;
UPDATE website SET hits = hits + 1;
-- 別のセッションから DELETE FROM website WHERE hits = 10; を実行します
COMMIT;</PRE
><P>

<TT
CLASS="COMMAND"
>UPDATE</TT
>の前後の両方で<TT
CLASS="LITERAL"
>website.hits = 10</TT
>の行があるにも関わらず、<TT
CLASS="COMMAND"
>DELETE</TT
>は何もしません。
なぜこうなるのかと言うと、更新前の行値<TT
CLASS="LITERAL"
>9</TT
>は読み飛ばされ、また<TT
CLASS="COMMAND"
>UPDATE</TT
>が完了して<TT
CLASS="COMMAND"
>DELETE</TT
>がロックを獲得した時点では、新しい行値は<TT
CLASS="LITERAL"
>10</TT
>ではなく<TT
CLASS="LITERAL"
>11</TT
>となり、判定条件にもはやマッチしなくなっているからです。
   </P
><P
>リードコミッティドモードは、それぞれのコマンドをその時点までにコミットされた全てのトランザクションを含む新規スナップショットを伴って開始するので、同一のトランザクション内でそれに続くコマンドは、いかなる場合でもコミットされた同時実行トランザクションの結果を参照します。
上記問題の要点は<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>単一の</I
></SPAN
>コマンドがデータベースの厳密に一貫性のある見え方を見るか否かです。
   </P
><P
>リードコミッティドモードで提供されている部分的なトランザクション分離は、多くのアプリケーションでは適切です。
またこのモードは高速で、使い方も簡単ですが、全ての場合に対して充分ではありません。
複雑な問い合わせや更新を行うアプリケーションは、リードコミッティドモードが提供する以上のより厳正なデータベースの厳密に一貫性のある見え方を必要とします。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-REPEATABLE-READ"
>13.2.2. リピータブルリード分離レベル</A
></H2
><P
><I
CLASS="FIRSTTERM"
>リピータブルリード</I
>分離レベルは、トランザクションが開始される前までにコミットされたデータのみを参照します。
コミットされていないデータや、そのトランザクションの実行中に別のトランザクションでコミットされた変更を参照しません。
（しかし、その問い合わせと同じトランザクション内で行われた過去の更新は、まだコミットされていませんが、参照します。）
これは<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の標準規格で求められるものよりもより強く保証するもので、直列化異常を除いて、<A
HREF="transaction-iso.html#MVCC-ISOLEVEL-TABLE"
>表13-1</A
>で述べている現象をすべて防ぎます。
上で述べたように、これは標準規格によって明示的に許容されているもので、標準ではそれぞれの分離レベルが提供しなくてはならない<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>最小</I
></SPAN
>の保護のみが示されています。
   </P
><P
>リピータブルリードのトランザクション内の問い合わせは、トランザクション内の現在の文の開始時点ではなく、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>トランザクション</I
></SPAN
>の最初のトランザクション制御以外の文の開始時点のスナップショットを見る、という点でこのレベルはリードコミッティドと異なります。
従って、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>単一</I
></SPAN
>トランザクション内の連続する<TT
CLASS="COMMAND"
>SELECT</TT
>文は、同じデータを参照します。つまり、自身のトランザクションが開始した後にコミットされた他のトランザクションによる変更を参照しません。
   </P
><P
>このレベルを使ったアプリケーションでは、直列化の失敗によるトランザクションの再実行に備えておく必要があります。

   </P
><P
><TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>、<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>、および<TT
CLASS="COMMAND"
>SELECT FOR SHARE</TT
>コマンドでは、<TT
CLASS="COMMAND"
>SELECT</TT
>と同じように対象行を検索します。
これらのコマンドでは、トランザクションが開始された時点で既にコミットされている対象行のみを検出します。
しかし、その対象行は、検出されるまでに、同時実行中の他のトランザクションによって、既に更新（もしくは削除あるいはロック）されている可能性があります。
このような場合、リピータブルリードトランザクションは、最初の更新トランザクションが（それらがまだ進行中の場合）コミットもしくはロールバックするのを待ちます。
最初の更新処理がロールバックされると、その結果は無視され、リピータブルリードトランザクションでは元々検出した行の更新を続行することができます。
しかし、最初の更新処理がコミット（かつ、単にロックされるだけでなく、実際に行が更新または削除）されると、リピータブルリードトランザクションでは、以下のようなメッセージを出力してロールバックを行います。

</P><PRE
CLASS="SCREEN"
>ERROR:  could not serialize access due to concurrent update</PRE
><P>

これは、リピータブルリードトランザクションでは、トランザクションが開始された後に別のトランザクションによって更新されたデータは変更またはロックすることができないためです。
   </P
><P
>アプリケーションがこのエラーメッセージを受け取った場合、現在のトランザクションを中止して、トランザクション全体を始めからやり直されなければなりません。
2回目では、トランザクションはコミットされた変更を含めてデータベースの最初の状態とみなすので、新しいバージョンの行を新しいトランザクションにおける更新の始点としても、論理的矛盾は起こりません。
   </P
><P
>再実行する必要があるかもしれないのは、更新トランザクションのみです。
読み込み専用トランザクションでは直列化の衝突は決して起こりません。
   </P
><P
>リピータブルリードモードでは、全てのトランザクションがデータベースの一貫した不変のビューの状態を参照することが保証されます。
しかし、このビューは常にいくつかの同じレベルの同時実行トランザクションの直列（一度に一つずつの）実行と一貫性を持つとは限りません。
例えば、このレベルの読み取りのみのトランザクションは、バッチが完了したことを示すために更新された制御レコードを参照することができますが、
制御レコードのより以前のバージョンを読み取るため、論理的にそのバッチの一部となる詳細なレコードの１つを参照することは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>できません</I
></SPAN
>。
この分離レベルで実行するトランザクションによりビジネスルールを強制しようとすることは、競合するトランザクションをブロックするために注意深く明示的なロックを持たないと、正確に動作しないことが多くあります。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> version 9.1より前まででは、シリアライザブル分離レベルの要求はここで説明した通りの動作をそのまま提供していました。
以前のシリアライザブルの動作を維持するためには、リピータブルリードを要求しなければならなくなりました。
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="XACT-SERIALIZABLE"
>13.2.3. シリアライザブル分離レベル</A
></H2
><P
><I
CLASS="FIRSTTERM"
>シリアライザブル</I
>分離レベルは、最も厳しいトランザクションの分離性を提供します。
このレベルではトランザクションが同時にではなく、次から次へと、あたかも順に実行されているように逐次的なトランザクションの実行を全てのコミットされたトランザクションに対しエミュレートします。
しかし、このレベルを使ったアプリケーションでは、リピータブルリードレベルと同様に、直列化の失敗によるトランザクションの再実行に備えておく必要があります。
実際、この分離レベルは、（ある時点で）逐次実行可能なすべてのトランザクションにおいて、シリアライザブルトランザクションの同時実行の組が一貫性のないような振る舞いをしていないか監視することを除き、リピータブルリードと全く同じ動きをします。
この監視では、リピータブルリードが示すものを越えてブロックすることはありませんが、監視によりいくらかのオーバーヘッドがあり、<I
CLASS="FIRSTTERM"
>直列化異常</I
>を引き起こすような状態の検知は、<I
CLASS="FIRSTTERM"
>直列化の失敗</I
>を引き起こすでしょう。
   </P
><P
>例えば、以下の初期データを持つ<TT
CLASS="STRUCTNAME"
>mytab</TT
>というテーブルを考えてみます。
</P><PRE
CLASS="SCREEN"
> class | value
-------+-------
     1 |    10
     1 |    20
     2 |   100
     2 |   200</PRE
><P>
ここでシリアライザブルトランザクションAが以下を計算し、
</P><PRE
CLASS="SCREEN"
>SELECT SUM(value) FROM mytab WHERE class = 1;</PRE
><P>
そして、<TT
CLASS="STRUCTFIELD"
>value</TT
>にその結果（30）を、<TT
CLASS="STRUCTFIELD"
>class</TT
><TT
CLASS="LITERAL"
> = 2</TT
>の行として新たに挿入したとします。
同時にシリアライザブルトランザクションBが以下を計算し、
</P><PRE
CLASS="SCREEN"
>SELECT SUM(value) FROM mytab WHERE class = 2;</PRE
><P>
その結果300を得、そして、この結果を<TT
CLASS="STRUCTFIELD"
>class</TT
><TT
CLASS="LITERAL"
> = 1</TT
>の新たな行として挿入したとします。
その後、両方のトランザクションがコミットを試みます。
もし一方の処理がリピータブルリード分離レベルで実行していれば、両方のコミットが許されるでしょう。
しかし、この結果と一貫する実行順序が存在しないため、シリアライザブルトランザクションを使用した場合は、ひとつのトランザクションがコミットを許され、他方は次のメッセージとともにロールバックされることになります。

</P><PRE
CLASS="SCREEN"
>ERROR:  could not serialize access due to read/write dependencies among transactions</PRE
><P>

この理由は、もしAがBよりも前に実行されていた場合、Bの総和は300ではなく330と計算され、また同様に逆の順序で実行されたとすればAで計算される総和が異なる結果になるからです。
   </P
><P
>異常を防止するためにシリアライザブルトランザクションを使用するのであれば、恒久的なユーザテーブルから読み取られたいかなるデータも、それを読んだトランザクションがコミットされるまで有効とは認められない点は重要です。
このことは読み取り専用トランザクションにも当てはまりますが、<I
CLASS="FIRSTTERM"
>遅延可能な</I
>読み取り専用トランザクション内で読み込まれたデータは例外で、読み込まれてすぐに有効とみなされます。
なぜなら、遅延可能なトランザクションはすべてのデータを読み込む前にこのような問題がないことを保証されているスナップショットを取得できるまで待機するからです。
それ以外の全ての場合において、後に中止されたトランザクション内で読み込まれた結果をアプリケーションは信用してはならず、アプリケーションはトランザクションが成功するまで再試行すべきです。
   </P
><P
>真の直列性を保証するために<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、<I
CLASS="FIRSTTERM"
>述語ロック</I
>を使います。
述語ロックでは、トランザクションが最初に実行されたとしたら、それによる書き込みが同時実行トランザクションによる読み取り結果にいつ影響を及ぼしたかの決定を可能にするロックを保持します。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、これらのロックはブロッキングを引き起こさないため、デッドロックの要因となら<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ない</I
></SPAN
>ものです。
それらは、同時実行中のシリアライザブルトランザクションが、直列化異常につながる組み合わせであることを識別しフラグを立てることに使用されます。
それとは対照的に、データの一貫性を保証したいリードコミッティドあるいはリピータブルリードトランザクションでは、テーブル全体のロック（そのテーブルを使用しようとしている他のユーザをブロックするかもしれません）を必要とするかもしれませんし、あるいは、他のトランザクションをブロックするだけでなくディスク・アクセスを引き起こす<TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
>あるいは<TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>を使用するかもしれません。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の述語ロックは、他のほとんどのデータベースシステムと同様、トランザクションによって実際にアクセスされたデータを元にしています。
これらは、<A
HREF="view-pg-locks.html"
><TT
CLASS="STRUCTNAME"
>pg_locks</TT
></A
>システムビューに<TT
CLASS="LITERAL"
>mode</TT
>が<TT
CLASS="LITERAL"
>SIReadLock</TT
>のデータとして現れます。
問い合わせの実行期間中に獲得される個別のロックは、問い合わせが使用した計画に依存するでしょう。
また、ロックを追跡するために使用されるメモリの消耗を防ぐために、トランザクションの過程において、多数のよりきめの細かいロック（例えばタプル・ロック）が結合されて、より少数のよりきめの粗いロック（例えばページ・ロック）になるるかもしれません。
直列化異常につながるような競合が継続して生じないことを検知すると、<TT
CLASS="LITERAL"
>READ ONLY</TT
>トランザクションは、それが完了する前にSIReadロックを解放できるかもしれません。
実際、<TT
CLASS="LITERAL"
>READ ONLY</TT
>トランザクションは、よく開始時点でその事実を確証し、どんな述語ロックもとらないこともあります。
<TT
CLASS="LITERAL"
>SERIALIZABLE READ ONLY DEFERRABLE</TT
>トランザクションを明示的に要求した場合には、この事実を確証できるまでブロックします。
（これは、シリアライザブルトランザクションはブロックするけれども、リピータブルリードトランザクションはブロックしない<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>唯一</I
></SPAN
>のケースです。）
他方で、SIReadロックは、しばしば読み取りと書き込みが重なっているトランザクションが完了するまで、トランザクションのコミットが終わっても保持される必要があります。
   </P
><P
>シリアライザブルトランザクションの一貫した使用は開発を単純化することができます。
正常にコミットされた同時実行のシリアライザブルトランザクションのどんな集合も、あたかもそれらが一度に一つずつ実行されたのと同じ結果になることが保証されるので、単独で実行されたときに単一トランザクションが正しく動作するよう書かれていると実証できるなら、他のトランザクションが何をしているかの情報が全く無くとも、複数シリアライザブルトランザクションが混在する中で正しく動作するかコミットに成功しないかであると確証を持つことができます。
この技術を使用する環境では、直列化の失敗(常にSQLSTATE値が'40001'で常に返る)を扱うための、汎用的な手段を持っていることが重要です。
なぜなら、どのトランザクションが読み取り/書き込みの依存性に影響し、直列化異常を防ぐためにロールバックさせる必要があるかといこうとを、正確に予測することは非常に困難だからです。
読み取り/書き込みの依存性を監視したり、直列化異常で終了したトランザクションを再起動することはコストがかかります。
しかしながら、このコストと、明示的なロックと<TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
>または<TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>を使用したブロッキングとで比較検討すると、シリアライザブルトランザクションはいくつかの環境において最良な実行を選択することになります。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のシリアライザブルトランザクション隔離レベルが同じ結果を生む実行順序があることを証明できるときだけ、同時のトランザクションのコミットを許すとはいえ、本当のシリアル実行では起こらないエラーが常に防げるわけではありません。
特に、たとえそのキーが生成されていないことを挿入しようとする前に明示的に調査した後でも重複しているシリアライザブルトランザクションとの競合が原因で一意性制約違反を見ることになる可能性があります。
これは潜在的に競合しているキーを挿入する<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>全ての</I
></SPAN
>シリアライザブルトランザクションで確実に挿入できるかどうか最初に明示的に調査することで防ぐことができます。
例えば、ユーザに新しいキーを聞いてからまずselectでそれがすでに存在しているか確かめるアプリケーション、もしくは存在している中で一番大きなキーを選択しそれに1を足すことで新しいキーを生成するアプリケーションを想像してみてください。
もしいくつかのシリアライザブルトランザクションがこのプロトコルに沿わずに直接新しいキーを挿入すれば、たとえそれがシリアル実行の同時トランザクションでは起こりえないケースでも一意性制約違反が報告されることになります。
   </P
><P
>同時実行制御のためにシリアライザブルトランザクションを使用する場合、最適な性能のためには、以下の問題を考慮すべきです。

    <P
></P
></P><UL
><LI
><P
>可能であればトランザクションを<TT
CLASS="LITERAL"
>READ ONLY</TT
>として宣言してください。
      </P
></LI
><LI
><P
>もし必要ならばコネクションプールを使用して、活動中の接続数を制御してください。
これは常に重要な性能上の考慮点ですが、シリアライザブルトランザクションを使用した多忙なシステムにおいては、特に重要になる可能性があります。
      </P
></LI
><LI
><P
>完全性のために必要とされる以上のものを１つのトランザクションに入れないようにしてください。
      </P
></LI
><LI
><P
>必要以上に長く<SPAN
CLASS="QUOTE"
>"トランザクション内で待機状態"</SPAN
>で接続したまま放置しておかないようにしてください。
長引くセッションを自動的に切断するために、設定パラメータ<A
HREF="runtime-config-client.html#GUC-IDLE-IN-TRANSACTION-SESSION-TIMEOUT"
>idle_in_transaction_session_timeout</A
>を使うことができます。
      </P
></LI
><LI
><P
>シリアライザブルトランザクションにより自動的に提供される保護により、不必要な、明示的なロック、<TT
CLASS="LITERAL"
>SELECT FOR UPDATE</TT
>および<TT
CLASS="LITERAL"
>SELECT FOR SHARE</TT
>を取り除いてください。
      </P
></LI
><LI
><P
>述語ロックのテーブルがメモリ不足になると、複数のページレベルの述語ロックを単一のリレーションレベルの述語ロックへと結合するようシステムが強いられ、直列化失敗の発生割合が増加する恐れがあります。
これは、<A
HREF="runtime-config-locks.html#GUC-MAX-PRED-LOCKS-PER-TRANSACTION"
>max_pred_locks_per_transaction</A
>を増やすことにより回避することができます。
      </P
></LI
><LI
><P
>シーケンシャルスキャンは常にリレーションレベルでの述語ロックを必要とします。
これによって、直列化失敗の頻度が増える可能性があります。
<A
HREF="runtime-config-query.html#GUC-RANDOM-PAGE-COST"
>random_page_cost</A
>を縮小および(または)<A
HREF="runtime-config-query.html#GUC-CPU-TUPLE-COST"
>cpu_tuple_cost</A
>を増加することによりインデックススキャンの使用を促進することは有用かもしれません。
トランザクションのロールバックや再実行の減少を、問い合わせ実行時間の全体的な変化と比較検討するようにしてください。
      </P
></LI
></UL
><P>
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="mvcc-intro.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="explicit-locking.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>序文</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="mvcc.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>明示的ロック</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
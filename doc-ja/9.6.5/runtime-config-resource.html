<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>資源の消費</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="サーバの設定"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="接続と認証"
HREF="runtime-config-connection.html"><LINK
REL="NEXT"
TITLE="ログ先行書き込み（WAL）"
HREF="runtime-config-wal.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="接続と認証"
HREF="runtime-config-connection.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 19章サーバの設定</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="ログ先行書き込み（WAL）"
HREF="runtime-config-wal.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-RESOURCE"
>19.4. 資源の消費</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-MEMORY"
>19.4.1. メモリ</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-SHARED-BUFFERS"
></A
><TT
CLASS="VARNAME"
>shared_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
データベースサーバが共有メモリバッファのために使用するメモリ量を設定します。
デフォルトは一般的に128メガバイト(<TT
CLASS="LITERAL"
>128MB</TT
>)です。
しかし、稼働中のカーネルの設定がこの値をサポートしていない場合、より少なくなることがあります（<SPAN
CLASS="APPLICATION"
>initdb</SPAN
>の過程で決定されます）。
この設定は最低限128キロバイトなければなりません。
（<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>がデフォルト値と異なる場合、この最小値も異なる値になります。）
しかし、良い性能を引き出すためには、最小値よりかなり高い値の設定が通例必要です。
このパラメータはサーバ起動時にのみ設定可能です。
       </P
><P
>       
1GB以上のRAMを載せた専用データベースサーバを使用している場合、<TT
CLASS="VARNAME"
>shared_buffers</TT
>に対する妥当な初期値はシステムメモリの25%です。
<TT
CLASS="VARNAME"
>shared_buffers</TT
>をこれよりも大きな値に設定することが有効なワークロードもあります。
しかし、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はオペレーティングシステムキャッシュにも依存するため、<TT
CLASS="VARNAME"
>shared_buffers</TT
>にRAMの40%以上を割り当てても、それより小さい値の時より動作が良くなる見込みはありません。
<TT
CLASS="VARNAME"
>shared_buffers</TT
>をより大きく設定する場合は、大抵<TT
CLASS="VARNAME"
>max_wal_size</TT
>も合わせて増やす必要があります。これは、新規または変更された多量のデータを書き出す処理をより長い時間に渡って分散させるためです。
       </P
><P
>       
1GB未満のRAMのシステムでは、オペレーティングシステムに十分な余裕を残すために、RAMに対してより小さい割合を設定することが適切です。
また、Windowsでも<TT
CLASS="VARNAME"
>shared_buffers</TT
>に対し大きな値を設定することはあまり有効でありません。
設定値を比較的小さく保ち、代わりにオペレーティングシステムのキャッシュを使用することが、より良い結果になるでしょう。
Windowsシステムでの有効な<TT
CLASS="VARNAME"
>shared_buffers</TT
>の範囲は一般的に64MBから512MBです。
       </P
></DD
><DT
><A
NAME="GUC-HUGE-PAGES"
></A
><TT
CLASS="VARNAME"
>huge_pages</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)
      </DT
><DD
><P
>        huge memoryページの利用を有効/無効にします。
        可能な値は
        <TT
CLASS="LITERAL"
>try</TT
> (デフォルト), <TT
CLASS="LITERAL"
>on</TT
>,
         <TT
CLASS="LITERAL"
>off</TT
>です。
       </P
><P
>        今のところこの機能はLinuxでのみサポートされています。
        他のシステムでは<TT
CLASS="LITERAL"
>try</TT
>と設定しても無視されます。
       </P
><P
>        huge pageを使うと、ページテーブルが小さくなり、メモリ管理に使用されるCPU時間が少なくなり、性能が向上します。詳細は、<A
HREF="kernel-resources.html#LINUX-HUGE-PAGES"
>項18.4.4</A
>を見てください。
       </P
><P
>        <TT
CLASS="VARNAME"
>huge_pages</TT
>を<TT
CLASS="LITERAL"
>try</TT
>に設定すると、サーバはhuge pageの利用を試み、失敗すると通常のアロケーションを行います。
        <TT
CLASS="LITERAL"
>on</TT
>にすると、huge pageの利用に失敗した場合サーバは起動しなくなります。
        <TT
CLASS="LITERAL"
>off</TT
>にすると、huge pageは使用されません。
       </P
></DD
><DT
><A
NAME="GUC-TEMP-BUFFERS"
></A
><TT
CLASS="VARNAME"
>temp_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
それぞれのデータベースセッションが使用する一時バッファの最大数を設定します。
一時バッファは、一時テーブルにアクセスする時にのみ使用されるセッションローカルのバッファです。
デフォルトは8メガバイト（<TT
CLASS="LITERAL"
>8MB</TT
>）です。
設定はそれぞれのセッション内で変更できますが、そのセッション内で一時テーブルが最初に使用されるまでになります。それより後に値の変更を試みても、そのセッションでは効果がありません。
       </P
><P
>       
セッションは、<TT
CLASS="VARNAME"
>temp_buffers</TT
>を上限として、必要に応じて一時バッファを確保します。
多くの一時バッファを実際に必要としないセッションで大きな値を設定するコストとは、<TT
CLASS="VARNAME"
>temp_buffers</TT
>の増分毎に、1つのバッファ記述子、約64バイトだけです。
しかし、バッファが実際に使用されると、それに対して追加の8192バイト（汎用的に言えば<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>バイト）が消費されます。
       </P
></DD
><DT
><A
NAME="GUC-MAX-PREPARED-TRANSACTIONS"
></A
><TT
CLASS="VARNAME"
>max_prepared_transactions</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
同時に<SPAN
CLASS="QUOTE"
>"プリペアド"</SPAN
>状態にできるトランザクションの最大数を設定します（<A
HREF="sql-prepare-transaction.html"
>PREPARE TRANSACTION</A
>を参照してください）。
このパラメータをゼロ（これがデフォルトです）に設定すると、プリペアドトランザクション機能が無効になります。
このパラメータはサーバ起動時にのみ設定可能です。
       </P
><P
>       
プリペアドトランザクションの使用を意図しないのであれば、このパラメータはプリペアドトランザクションが偶然に作成されないようゼロに設定すべきです。
プリペアドトランザクションを使用する場合、全てのセッションがプリペアドトランザクションを保留できるように、<TT
CLASS="VARNAME"
>max_prepared_transactions</TT
>を少なくとも<A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
>と同じ大きさに設定するのが良いでしょう。
       </P
><P
>       
       スタンバイサーバを運用している場合、このパラメータはマスターサーバ上の設定よりも同等かもしくはより高水準に設定しなければなりません。そうしないと問い合わせがスタンバイサーバ内で受け入れられません。
       </P
></DD
><DT
><A
NAME="GUC-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
       一時ディスクファイルに書き込む前に、内部並べ替えとハッシュテーブル操作が使用するメモリ容量を指定します。
デフォルト値は4メガバイト（<TT
CLASS="LITERAL"
>4MB</TT
>）です。
        複雑な問い合わせの場合、いくつかの並び替えもしくはハッシュ操作が並行して実行されることに注意してください。
        それぞれの操作による一時メモリへの書き込み開始の前に、この値が指定するのと同じメモリ容量の使用をそれらの操作に許容します。さらに、いくつかの実行中のセッションはこれらの動作を同時に行います。したがって、使用されるメモリの合計は、<TT
CLASS="VARNAME"
>work_mem</TT
>の数倍になります。値を選択する時には、この事実に留意することが必要です。並び替え操作は<TT
CLASS="LITERAL"
>ORDER BY</TT
>、<TT
CLASS="LITERAL"
>DISTINCT</TT
>、およびマージ結合に対して使われます。ハッシュテーブルはハッシュ結合、ハッシュに基づいた集約、および<TT
CLASS="LITERAL"
>IN</TT
>副問い合わせのハッシュに基づいた処理で使用されます。
       </P
></DD
><DT
><A
NAME="GUC-MAINTENANCE-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>maintenance_work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
       <TT
CLASS="COMMAND"
>VACUUM</TT
>、<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>、および<TT
CLASS="COMMAND"
>ALTER TABLE ADD FOREIGN KEY</TT
>の様な保守操作で使用されるメモリの最大容量を指定します。
デフォルト値は64メガバイト（<TT
CLASS="LITERAL"
>64MB</TT
>）です。
1つのデータベースセッションでは、一度に1つしか上記操作はできませんし、通常インストレーションでこうした操作が同時に非常に多く発生することはありませんので、これを<TT
CLASS="VARNAME"
>work_mem</TT
>よりもかなり多めの値にしても安全です。
大きい値を設定することでvacuum処理と、ダンプしたデータベースのリストア性能が向上します。
       </P
><P
>       
自動バキュームが稼動すると、最大でこのメモリの<A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS"
>autovacuum_max_workers</A
>倍が配分されるので、デフォルトの値をあまり高く設定しないよう注意してください。
別の設定項目<A
HREF="runtime-config-resource.html#GUC-AUTOVACUUM-WORK-MEM"
>autovacuum_work_mem</A
>で制御するのが良いかもしれません。
       </P
></DD
><DT
><A
NAME="GUC-REPLACEMENT-SORT-TUPLES"
></A
><TT
CLASS="VARNAME"
>replacement_sort_tuples</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>ソート対象のタプル数がこの指定値よりも小さい場合、クイックソートではなく、置換選択法を使ってソート処理の最初のラン出力を作ります。
メモリが限られた環境で、物理から論理への強い相関性を持つタプルが大量のソート処理に投入される場合に有用かもしれません。
なお、入力タプルが<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>逆</I
></SPAN
>相関性を示す場合にはこの限りではありません。
デフォルトの戦略が多数のランを実行してしまい、その結果を最後にマージしなければならないのと違って、置換選択アルゴリズムにおいては、マージを必要としない一つの長いランを実行できる可能性があります。
このことにより、ソート処理を素早く完了できるかもしれません。
       </P
><P
>デフォルト値は150,000タプルです。
多くの場合、より高い設定値がより良い効率をもたらすどころか、むしろ非生産的かもしれません。
なぜなら、優先度キューは、利用可能なCPUキャッシュの大きさに敏感な一方、デフォルトのソート戦略は<I
CLASS="FIRSTTERM"
>キャッシュに縛られない（cache-oblivious）</I
>アルゴリズムを使用して実行されるからです。
この性質により、デフォルトのソート戦略では自動的かつ透過的に利用可能なCPUキャッシュを有効に利用できます。
       </P
><P
><TT
CLASS="VARNAME"
>maintenance_work_mem</TT
>をデフォルト値に設定すると、入力タプルの幅が非常に大きい場合を除き、通常ユーティリティコマンドが外部ソート(たとえば、<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>がB-Treeインデックスを作成するために行うソート)が置換選択アルゴリズムを使うことはなくなります。
       </P
></DD
><DT
><A
NAME="GUC-AUTOVACUUM-WORK-MEM"
></A
><TT
CLASS="VARNAME"
>autovacuum_work_mem</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>        個々の自動バキュームワーカプロセスが使用する最大のメモリ量を指定します。
デフォルトは-1で、<A
HREF="runtime-config-resource.html#GUC-MAINTENANCE-WORK-MEM"
>maintenance_work_mem</A
>が代わりに使われる設定になります。
       別の文脈で実行される<TT
CLASS="COMMAND"
>VACUUM</TT
>にはこの設定は影響しません。
       </P
></DD
><DT
><A
NAME="GUC-MAX-STACK-DEPTH"
></A
><TT
CLASS="VARNAME"
>max_stack_depth</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
サーバの実行スタックの最大安全深度を指定します。
このパラメータの理想的な設定はカーネルにより強要される実際のスタック容量の（<TT
CLASS="LITERAL"
>ulimit -s</TT
>もしくはそれと同等の機能で設定された）限界から、1メガバイト程度の安全余地を差し引いたものです。
安全余地は、サーバがすべてのルーチンではスタック深度を検査をせず、式評価などの主要な潜在的に再帰的なルーチンでのみ検査をするために必要となるものです。
デフォルト設定は2メガバイト（<TT
CLASS="LITERAL"
>2MB</TT
>）で、かなり控え目で、クラッシュの危険はなさそうです。
しかし、複雑な関数の実行を許容するには小さ過ぎるかも知れません。
スーパーユーザのみがこの設定を変更することができます。
       </P
><P
>       
       <TT
CLASS="VARNAME"
>max_stack_depth</TT
>を実際のカーネルの制限よりも高い値に設定した場合、暴走した再帰関数により、個々のバックエンドプロセスがクラッシュするかもしれません。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>がカーネルの制限を決定することができるプラットフォームでは、この変数を危険な値に設定させません。
しかし、すべてのプラットフォームがこの情報を提供できるわけではありません。
このため、値を選ぶ時には注意が必要です。
       </P
></DD
><DT
><A
NAME="GUC-DYNAMIC-SHARED-MEMORY-TYPE"
></A
><TT
CLASS="VARNAME"
>dynamic_shared_memory_type</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)
      </DT
><DD
><P
>        サーバが使う動的共有メモリの実装を指定します。可能な値は
        <TT
CLASS="LITERAL"
>posix</TT
> (<TT
CLASS="LITERAL"
>shm_open</TT
>で獲得するPOSIX共有メモリ)、
         <TT
CLASS="LITERAL"
>sysv</TT
>
        (<TT
CLASS="LITERAL"
>shmget</TT
>で獲得するSystem V共有メモリ)、
        <TT
CLASS="LITERAL"
>windows</TT
> (Windows共有メモリ)、 <TT
CLASS="LITERAL"
>mmap</TT
>
        (データディレクトリ内のメモリマップファイルを使ってシミュレートする共有メモリ)、
<TT
CLASS="LITERAL"
>none</TT
> (この機能を使用しない)です。
       すべての値がすべてのプラットフォームでサポートされているわけではありません。
       そのプラットフォームでの推奨実装がデフォルトになります。
       どのプラットフォームでもデフォルトになっていない<TT
CLASS="LITERAL"
>mmap</TT
>は、オペレーティングシステムが変更されたページをディスクに継続的に書き込み、I/O負荷を増加させるので一般的には利用が推奨されていません。
       しかし、デバッグ目的のために<TT
CLASS="LITERAL"
>pg_dynshmem</TT
>ディスクがRAMディスク上にある場合や、他の共有メモリ機能が使えない場合は有用かもしれません。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-DISK"
>19.4.2. ディスク</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-TEMP-FILE-LIMIT"
></A
><TT
CLASS="VARNAME"
>temp_file_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
あるプロセスが一時ファイルとして使用できるディスクの最大容量を設定します。
例えば、ソートやハッシュの一時ファイルであったり、カーソルを保持する格納ファイルです。
この制限値を超えようとするトランザクションはキャンセルされます。
値はキロバイト単位で指定され、（デフォルトである） <TT
CLASS="LITERAL"
>-1</TT
> の場合は制限がありません。
この設定はスーパーユーザのみ変更可能です。
       </P
><P
>       
       この設定により、ある <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> セッションによって使用される一時ファイルの合計の容量が常に制約されることになります。
       なお、問い合わせの実行において暗黙的に使用される一時ファイルとは異なり、一時テーブルとして明示的に使用されるディスク容量は、この制限には<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>含まれません</I
></SPAN
>。
       
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-KERNEL"
>19.4.3. カーネル資源使用</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-MAX-FILES-PER-PROCESS"
></A
><TT
CLASS="VARNAME"
>max_files_per_process</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
       それぞれのサーバ子プロセスが同時にオープンできるファイル数の最大値をセットします。
デフォルトは1000ファイルです。
もしもカーネルがプロセス毎の安全制限を強要している場合、この設定を気にかける必要はありません。
しかし、いくつかのプラットフォーム（特にほとんどのBSDシステム）では、もし多くのプロセス全てがそれだけ多くのファイルを開くことを試みたとした場合、実際にサポートできるファイル数より多くのファイルを開くことを許しています。もしも<SPAN
CLASS="QUOTE"
>"Too many open files"</SPAN
>エラーが発生した場合、この設定を削減してみてください。
このパラメータはサーバ起動時にのみ設定可能です。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-VACUUM-COST"
>19.4.4. コストに基づくVacuum遅延</A
></H2
><P
>     
      <A
HREF="sql-vacuum.html"
>VACUUM</A
> および <A
HREF="sql-analyze.html"
>ANALYZE</A
> コマンドの実行中、実行される各種I/O操作の予測コストを追跡し続ける内部カウンタをシステムが保守します。
      累積されたコストが（<TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
>で指定された）限度に達すると、操作を実行しているプロセスは<TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>で指定されたちょっとの間スリープします。その後、カウンタをリセットし、実行を継続します。
     </P
><P
>     
この機能の目的は、同時に実行されているデータベースの活動に対するこれらコマンドによるI/Oへの影響を、管理者が軽減できるようにすることです。
<TT
CLASS="COMMAND"
>VACUUM</TT
> および <TT
CLASS="COMMAND"
>ANALYZE</TT
>の様な保守用コマンドが即座に終了することが重要ではない事態が数多くあります。
しかし、他のデータベースの操作を行うに当たって、これらのコマンドがシステムの能力に多大な阻害を与えないことは通常とても重要です。
コストに基づいたvacuum遅延はこれを実現するための方法を管理者に提供します。
     </P
><P
>     
手動で実行した<TT
CLASS="COMMAND"
>VACUUM</TT
>コマンドについては、デフォルトでこの機能は無効になっています。
有効にするには、<TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>変数をゼロでない値に設定します。
     </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-VACUUM-COST-DELAY"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
        コストの限度を越えた場合、プロセスがスリープするミリ秒単位の時間の長さです。
デフォルトの値は0で、コストに基づいたvacuum遅延機能を無効にします。
正の整数はコストに基づいたvacuumを有効にします。
多くのシステムで、スリープ遅延の有効な分解能は10ミリ秒です。
<TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>の値の設定を10の倍数としない場合、次に大きい10の倍数に設定した結果と同一になるかもしれないことを覚えておいてください。
        </P
><P
>       
        コストに基づいたバキューム処理を使用する場合、<TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
>の適切な値は通常かなり小さくなり、たいていは10または20ミリ秒になります。
        バキュームによるリソース消費の調整は、他のバキュームのコストパラメータを変更して行うことが最善です。
        </P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-HIT"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_hit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
        共有バッファキャッシュの中のバッファにvacuumを掛ける予測コストです。バッファプールのロック、共有ハッシュテーブルの検索、およびページ内容走査のコストを示します。デフォルトの値は1です。
        </P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-MISS"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_miss</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
        ディスクから読み込まれなければならないバッファにvacuumを掛ける予測コストです。これが示すものは、バッファプールロックの試み、共有ハッシュテーブルの参照、ディスクから目的ブロックの読み込み、そしてその内容走査です。デフォルトの値は10です。
        </P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-PAGE-DIRTY"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_page_dirty</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
        vacuumが、先だって掃除したブロックを変更する時に果たされた予測コストです。
        ダーティブロックを再度ディスクに吐き出すのに必要な余分なI/Oを表します。デフォルトの値は20です。
        </P
></DD
><DT
><A
NAME="GUC-VACUUM-COST-LIMIT"
></A
><TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
        vacuumを掛けるプロセスをスリープさせることになる累計されたコストです。
        デフォルトの値は200です。
        </P
></DD
></DL
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>      
重要なロックを保有し可能なかぎり早急に完了しなければならないある種の操作があります。コストに基づいたvacuum遅延はこの様な操作では起こりません。
したがって、コストの累計が指定された限度をかなり高く越える可能性があります。
このような場合無駄な長い遅延を防止するため、実際の遅延は<TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> * 4 を上限として、以下のように計算されます。
       <TT
CLASS="VARNAME"
>vacuum_cost_delay</TT
> * <TT
CLASS="VARNAME"
>accumulated_balance</TT
> / <TT
CLASS="VARNAME"
>vacuum_cost_limit</TT
>
      </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-BACKGROUND-WRITER"
>19.4.5. バックグラウンドライタ</A
></H2
><P
>     
<I
CLASS="FIRSTTERM"
>バックグラウンドライタ</I
>と呼ばれる個別のサーバプロセスがあり、その機能は（新規または更新された）<SPAN
CLASS="QUOTE"
>"ダーティ"</SPAN
>な共有バッファの書き込みを行うことです。
ユーザの問い合わせを処理するサーバプロセスが、書き込みが起きるまで滅多に待つ必要がない、あるいは決して待つ必要がないように、共有バッファの書き込みを行います。
しかし、バックグラウンドライタは正味の全体的I/O負荷の増加を引き起こします。
その理由は、繰り返しダーティ化されるページは、バックグランドライタを使わなければチェックポイント間隔で一度だけ書き出されれば十分なのに対し、バックグラウンドライタは同じ間隔内で何度もダーティ化されると、それを複数回書き出すかもしれないからです。
本節で説明する各パラメータは、サイト独自の必要に応じて動作を調整することに使用できます。
     </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-BGWRITER-DELAY"
></A
><TT
CLASS="VARNAME"
>bgwriter_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
        バックグラウンドライタの動作周期間の遅延を指定します。
それぞれの周期でライタは、（以下のパラメータで管理される）一部のダーティバッファの書き込みを行います。
そして<TT
CLASS="VARNAME"
>bgwriter_delay</TT
>ミリ秒スリープした後、これを繰りかえします。
しかし、バッファプールにダーティバッファが存在しない場合、<TT
CLASS="VARNAME"
>bgwriter_delay</TT
>に係わらずより長くスリープします。
デフォルトの値は200ミリ秒（<TT
CLASS="LITERAL"
>200ms</TT
>）です。
多くのシステムで、スリープ遅延の実精度は10ミリ秒です。
<TT
CLASS="VARNAME"
>bgwriter_delay</TT
>の値の設定を10の倍数としない場合、次に大きい10の倍数に設定した結果と同一になるかもしれないことを覚えておいてください。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインで設定可能です。

        </P
></DD
><DT
><A
NAME="GUC-BGWRITER-LRU-MAXPAGES"
></A
><TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
        それぞれの周期で、この数以上のバッファはバックグラウンドライタにより書き込まれません。
         ゼロに設定することでバックグラウンド書き込みは無効になります。
        （分離し、そして専用の補助プロセスにより管理されるチェックポイントは影響を受けません。）
         デフォルト値は100バッファです。
         このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル内、または、サーバのコマンドラインでのみで設定可能です。
        </P
></DD
><DT
><A
NAME="GUC-BGWRITER-LRU-MULTIPLIER"
></A
><TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>)
       </DT
><DD
><P
>       
        各周期で書き出されるダーティバッファ数は、最近の周期でサーバプロセスが必要とした新しいバッファ数を基にします。
次の周期で必要となるバッファ数を推定するために、最近必要とされた平均が<TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
>と掛け合わせられます。
ダーティバッファの書き出しは、同数の整理済み、再利用可能なバッファが利用できるようになるまで行われます。
（しかし1周期に<TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
>を越えるバッファ数を書き出しません。）
したがって、1.0と設定することは、必要と予想されるバッファ数の書き込みについて<SPAN
CLASS="QUOTE"
>"必要なときに必要なだけ"</SPAN
>というポリシーを表します。
より大きな値は突発的な要求に対する多少の緩衝材を提供します。
より小さな値はサーバプロセスでなされる書き込みを意図的に残します。
デフォルトは2.0です。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみで設定可能です。
        </P
></DD
><DT
><A
NAME="GUC-BGWRITER-FLUSH-AFTER"
></A
><TT
CLASS="VARNAME"
>bgwriter_flush_after</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>bgwriterが<TT
CLASS="VARNAME"
>bgwriter_flush_after</TT
>バイトより多く書く度に、OSが記憶装置に書き込むことを強制しようとします。
このことにより、カーネルのページキャッシュが持つダーティデータの量を一定量に制限し、チェックポイントの最後にfsyncが実行される際、あるいはOSがバックグラウンドでデータを大きな塊で書き出す際に性能の急激な低下を招く可能性を減らします。
多くの場合これによってトランザクションの遅延が大幅に少なくなりますが、あるケース、特にワークロードが<A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
>shared_buffers</A
>よりも大きく、OSのページキャッシュよりも小さい時には性能が低下するかもしれません。
この設定が無効なプラットフォームがあります。
有効な設定値は、この強制書き込み機能が無効になる<TT
CLASS="LITERAL"
>0</TT
>から、<TT
CLASS="LITERAL"
>2MB</TT
>までです。
デフォルト値は、Linuxでは<TT
CLASS="LITERAL"
>512kB</TT
>で、それ以外は<TT
CLASS="LITERAL"
>0</TT
>です。
(<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>が8kbでなければ、この設定のデフォルト値と最大値が<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>に比例して変更されます。)
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみで設定可能です。

        </P
></DD
></DL
></DIV
><P
>     
      <TT
CLASS="VARNAME"
>bgwriter_lru_maxpages</TT
>および<TT
CLASS="VARNAME"
>bgwriter_lru_multiplier</TT
>の値がより少ないと、バックグラウンドライタで引き起こされる追加のI/O負荷を軽減しますが、サーバプロセスが自分自身で行わなければならない書き込みが増加することになり、会話型問い合わせを遅らせることになります。
     </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-RESOURCE-ASYNC-BEHAVIOR"
>19.4.6. 非同期動作</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-EFFECTIVE-IO-CONCURRENCY"
></A
><TT
CLASS="VARNAME"
>effective_io_concurrency</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>       
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が同時実行可能であると想定する同時ディスクI/O操作の数を設定します。
この値を大きくすると、あらゆる個別の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>セッションが並行して開始を試みるI/O操作の数が増加します。
設定可能な範囲は1から1000まで、または非同期I/Oリクエストの発行を無効にするゼロです。
現在、この設定はビットマップヒープスキャンのみに影響します。
        </P
><P
>       
磁気ディスクドライブにおいては、データベースに使用されるRAID 0ストライプ、RAID 1ミラーを構成する個々のドライブ数から始めると良いでしょう。（RAID 5ではパリティ用のドライブを数に含めません）
しかし、同時実行セッションで発行される複数の問い合わせでデータベースが頻繁にビジーとなる場合、小さめの値で十分ディスクアレイがビジーになるかもしれません。
ディスクをビジーにするのに必要な値より大きな値を設定しても、余計なCPUオーバーヘッドを発生させるだけです。
SSDやそれ以外のメモリーベースの記憶装置は、多くの同時リクエストをこなすことができるので、最適な値は数百になるかもしれません。
        </P
><P
>       
        非同期I/Oは実質的に<CODE
CLASS="FUNCTION"
>posix_fadvise</CODE
>関数に依存します。
        これは一部のオペレーティングシステムには存在しません。
        この関数が存在しない場合、この値をゼロ以外に設定するとエラーとなります。
        一部のオペレーティングシステム（例えばSolaris）では存在するけれども、実際何も行わないものもあります。
        </P
><P
>デフォルトは、サポートされているシステムでは1、そうでなければ0です。
この値は、テーブルスペースパラメータの同じ名前のパラメータを設定することで、特定のテーブルスペース内のテーブルに対して上書きできます。
(<A
HREF="sql-altertablespace.html"
>ALTER TABLESPACE</A
>を参照ください)。
        </P
></DD
><DT
><A
NAME="GUC-MAX-WORKER-PROCESSES"
></A
><TT
CLASS="VARNAME"
>max_worker_processes</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>システムがサポートするバックグラウンドプロセスの最大数を指定します。
このパラメータはサーバ起動時にのみ設定できます。
デフォルトは8です。
        </P
><P
>         スタンバイサーバを起動しているときは、このパラメータを、マスタサーバの設定値と同じかそれ以上にしなければなりません。さもなければ、スタンバイサーバで問い合わせの実行ができなくなります。
        </P
></DD
><DT
><A
NAME="GUC-MAX-PARALLEL-WORKERS-PER-GATHER"
></A
><TT
CLASS="VARNAME"
>max_parallel_workers_per_gather</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>一つの<TT
CLASS="LITERAL"
>Gather</TT
>ノードに対して起動できるワーカー数の最大値を設定します。
パラレルワーカーは、<A
HREF="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES"
>max_worker_processes</A
>で確立されたプロセスのプールから取得されます。
実行時には、要求された数のワーカーは取得できないかもしれないことに注意してください。
そうなると、実行プランは期待していたよりも少ない数のワーカーで実行されることになり、効率は悪化するかもしれません。
この設定値をデフォルト値の0にすると、パラレルクエリの実行は行われません。
        </P
><P
>パラレルクエリの実行により、パラレルクエリではない場合に比べて非常に多くのリソースが使用されるかもしれないことに注意してください。
これは、個々のワーカープロセスは完全に別個のプロセスであり、システムに対してユーザセッションが追加されたのと大体同じくらいの影響があるからです。
この設定値を選択する際には、他のリソースの消費量を制御する他の設定値、たとえば<A
HREF="runtime-config-resource.html#GUC-WORK-MEM"
>work_mem</A
>を設定するときと同様に、この点を考慮しておく必要があります。
<TT
CLASS="VARNAME"
>work_mem</TT
>のような設定値によるリソース制限は、個々のワーカーに対して個別に適用されます。
つまり、ひとつのプロセス対するよりも、すべてのプロセスの全体のリソース消費はずっと多いかもしれないということです。
たとえば、あるパラレルクエリが4つのワーカーを使っているとすると、ワーカーを使わない場合に比べて、最大5倍のCPU時間、メモリ、I/Oバンド幅、その他を使うかもしれません。
        </P
><P
>         パラレルクエリに関する更なる情報については、<A
HREF="parallel-query.html"
>第15章</A
>をご覧ください。
        </P
></DD
><DT
><A
NAME="GUC-BACKEND-FLUSH-AFTER"
></A
><TT
CLASS="VARNAME"
>backend_flush_after</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
><TT
CLASS="VARNAME"
>backend_flush_after</TT
>バイトが単一のバックエンドによって書き込まれる度に、OSが記憶装置に書き込むことを強制します。
このことにより、カーネルのページキャッシュが持つダーティデータの量を一定量に制限し、チェックポイントの最後にfsyncが実行される際、あるいはバックグラウンドで実行される大きなバッチの中でOSがデータを書き出す際に性能の急激な低下を招く可能性を減らします。
多くの場合これによってトランザクションの遅延を大幅に少なくなりますが、あるケース、特にワークロードが<A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
>shared_buffers</A
>よりも大きく、OSのページキャッシュよりも小さい時には性能が低下するかもしれません。
この設定が無効なプラットフォームがあります。
有効な設定値は、この強制書き込み機能が無効になる<TT
CLASS="LITERAL"
>0</TT
>から、<TT
CLASS="LITERAL"
>2MB</TT
>までです。
デフォルト値は<TT
CLASS="LITERAL"
>0</TT
>です(すなわち書き出し制御を行いません)。
(<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>が8kbでなければ、最大値が<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>に比例して変更されます。)
        </P
></DD
><DT
><A
NAME="GUC-OLD-SNAPSHOT-THRESHOLD"
></A
><TT
CLASS="VARNAME"
>old_snapshot_threshold</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
       </DT
><DD
><P
>スナップショットが使用されるときに、<TT
CLASS="LITERAL"
>snapshot too old</TT
>エラーを引き起こす危険性なしにスナップショットを利用できる最小時間を設定します。
このパラメータはサーバ起動時にのみ設定できます。
        </P
><P
>この制限値を越えると、古いデータはバキュームされます。
これにより、長い間残っていたスナップショットによりデータが溢れてしまうのを防ぐことができます。
スナップショットから見えるデータが消えることによる不正な結果を防ぐため、スナップショットがこの制限値よりも古く、かつこのスナップショットが作られた以降に変更されたページを読むためにスナップショットが使用されるときはエラーが発生します。
        </P
><P
><TT
CLASS="LITERAL"
>-1</TT
>を設定するとこの機能が無効になります。
これがデフォルトです。
実際の環境でのおすすめの値はおそらく数時間から2, 3日の間となるでしょう。
設定値は、分の粒度に書き換えられます。
小さな値(たとえば<TT
CLASS="LITERAL"
>0</TT
>や<TT
CLASS="LITERAL"
>1min</TT
>)は、テストの際に有用だということで許可されています。
<TT
CLASS="LITERAL"
>60d</TT
>のような大きな値の設定もできますが、多くのワークロードにおいて、大きなデータ溢れやトランザクションIDの周回がそれよりはずっと短い期間で起こる可能性があることに注意してください。
        </P
><P
>この機能が有効であると、リレーションの終端部にあるフリースペースはオペレーティングシステムには返却されません。
そうしないと、<TT
CLASS="LITERAL"
>snapshot too old</TT
>の条件の検出に必要な情報を削除してしまうことになるからです。
明示的に解放されない限り（たとえば<TT
CLASS="COMMAND"
>VACUUM FULL</TT
>によって）、リレーションに割り当てられた領域は、そのリレーションの中での再利用に限定して紐付けられます。
        </P
><P
>この設定は、どのような状況でもエラーが検出されることを保証するものではありません。
（たとえば）マテリアライズされた結果集合を持つカーソルから正しい結果を得ることができるのであれば、たとえ参照している元のテーブルからVACUUMによって行が削除されたとしてもエラーにはなりません。
ある種のテーブルでは、早期にVACUUMできないので、この設定の影響を受けません。
例としては、システムカタログやハッシュインデックスが貼られたテーブルが挙げられます。
このようなテーブルにおいては、この設定によってデータ溢れを防ぐことも、スキャンの際に<TT
CLASS="LITERAL"
>snapshot too old</TT
>エラーを起こす可能性を作り出すこともできません。
        </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-connection.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-wal.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>接続と認証</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>ログ先行書き込み（WAL）</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
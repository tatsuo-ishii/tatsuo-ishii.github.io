<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>intarray</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="追加で提供されるモジュール"
HREF="contrib.html"><LINK
REL="PREVIOUS"
TITLE="intagg"
HREF="intagg.html"><LINK
REL="NEXT"
TITLE="isn"
HREF="isn.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="intagg"
HREF="intagg.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="contrib.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>付録 F. 追加で提供されるモジュール</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="isn"
HREF="isn.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INTARRAY"
>F.18. intarray</A
></H1
><P
><TT
CLASS="FILENAME"
>intarray</TT
>モジュールはNULLのない整数の配列の操作に便利な関数と演算子を多く提供します。
また、一部の演算子を使用したインデックス検索をサポートします。
 </P
><P
>配列にNULL要素が一つでも含まれていれば、これらの操作はすべてエラーを発生します。
 </P
><P
>これらの操作の多くは一次元配列に対してのみ適当なものです。
高次元の入力配列を受け付けますが、データは格納された順の一次元の配列であるかのように扱われます。
 </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN181916"
>F.18.1. <TT
CLASS="FILENAME"
>intarray</TT
>の関数および演算子</A
></H2
><P
><TT
CLASS="FILENAME"
>intarray</TT
>モジュールで提供される関数を<A
HREF="intarray.html#INTARRAY-FUNC-TABLE"
>表F-10</A
>に、演算子を<A
HREF="intarray.html#INTARRAY-OP-TABLE"
>表F-11</A
>に示します。
  </P
><DIV
CLASS="TABLE"
><A
NAME="INTARRAY-FUNC-TABLE"
></A
><P
><B
>表 F-10. <TT
CLASS="FILENAME"
>intarray</TT
>関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><COL><COL><THEAD
><TR
><TH
>関数</TH
><TH
>戻り値の型</TH
><TH
>説明</TH
><TH
>例</TH
><TH
>結果</TH
></TR
></THEAD
><TBODY
><TR
><TD
><CODE
CLASS="FUNCTION"
>icount(int[])</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>配列内の要素数</TD
><TD
><TT
CLASS="LITERAL"
>icount('{1,2,3}'::int[])</TT
></TD
><TD
><TT
CLASS="LITERAL"
>3</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>sort(int[], text dir)</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>配列のソート。<TT
CLASS="PARAMETER"
>dir</TT
>は<TT
CLASS="LITERAL"
>asc</TT
>または<TT
CLASS="LITERAL"
>desc</TT
>のいずれかでなければなりません。</TD
><TD
><TT
CLASS="LITERAL"
>sort('{1,2,3}'::int[], 'desc')</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{3,2,1}</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>sort(int[])</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>昇順ソート</TD
><TD
><TT
CLASS="LITERAL"
>sort(array[11,77,44])</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{11,44,77}</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>sort_asc(int[])</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>昇順ソート</TD
><TD
><TT
CLASS="LITERAL"
></TT
></TD
><TD
><TT
CLASS="LITERAL"
></TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>sort_desc(int[])</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>降順ソート</TD
><TD
><TT
CLASS="LITERAL"
></TT
></TD
><TD
><TT
CLASS="LITERAL"
></TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>uniq(int[])</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>隣接する重複を削除</TD
><TD
><TT
CLASS="LITERAL"
>uniq(sort('{1,2,3,2,1}'::int[]))</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{1,2,3}</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>idx(int[], int item)</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
><TT
CLASS="PARAMETER"
>item</TT
>に一致する要素番号（存在しなければ0）</TD
><TD
><TT
CLASS="LITERAL"
>idx(array[11,22,33,22,11], 22)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>2</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>subarray(int[], int start, int len)</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
><TT
CLASS="PARAMETER"
>start</TT
>から始まり<TT
CLASS="PARAMETER"
>len</TT
>個の要素の部分配列</TD
><TD
><TT
CLASS="LITERAL"
>subarray('{1,2,3,2,1}'::int[], 2, 3)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{2,3,2}</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>subarray(int[], int start)</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
><TT
CLASS="PARAMETER"
>start</TT
>から始まる部分配列</TD
><TD
><TT
CLASS="LITERAL"
>subarray('{1,2,3,2,1}'::int[], 2)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{2,3,2,1}</TT
></TD
></TR
><TR
><TD
><CODE
CLASS="FUNCTION"
>intset(int)</CODE
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>単一要素の配列を作成</TD
><TD
><TT
CLASS="LITERAL"
>intset(42)</TT
></TD
><TD
><TT
CLASS="LITERAL"
>{42}</TT
></TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="INTARRAY-OP-TABLE"
></A
><P
><B
>表 F-11. <TT
CLASS="FILENAME"
>intarray</TT
>演算子</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>演算子</TH
><TH
>戻り値</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
>int[] &amp;&amp; int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>重なり。配列間で少なくとも1つの共通要素がある場合<TT
CLASS="LITERAL"
>true</TT
>を返します。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] @&gt; int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>包含。左辺の配列が右辺の配列を含む場合<TT
CLASS="LITERAL"
>true</TT
>を返します。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] &lt;@ int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>包含される。左辺の配列が右辺の配列に含まれる場合<TT
CLASS="LITERAL"
>true</TT
>を返します。</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
># int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>配列内の要素数</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] # int</TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>インデックス（<CODE
CLASS="FUNCTION"
>idx</CODE
>関数と同じです）</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] + int</TT
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>配列に要素をプッシュ（配列の末尾に追加）します</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] + int[]  </TT
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>配列を連結（右辺配列を左辺配列の末尾に追加）します</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] - int</TT
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>配列から右辺の引数に一致する項目を削除します</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] - int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>左辺の配列から右辺の配列要素を削除します</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] | int</TT
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>引数をまとめます</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] | int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>配列をまとめます</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] &amp; int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>int[]</TT
></TD
><TD
>配列の共通部分</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>int[] @@ query_int</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>配列が問い合わせを満たす場合<TT
CLASS="LITERAL"
>true</TT
>（後述）</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
>query_int ~~ int[]</TT
></TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>配列が問い合わせを満たす場合<TT
CLASS="LITERAL"
>true</TT
>（<TT
CLASS="LITERAL"
>@@</TT
>の交代演算子）</TD
></TR
></TBODY
></TABLE
></DIV
><P
>（PostgreSQL 8.2以前では、包含演算子<TT
CLASS="LITERAL"
>@&gt;と</TT
><TT
CLASS="LITERAL"
>&lt;@</TT
>はそれぞれ<TT
CLASS="LITERAL"
>@</TT
>と<TT
CLASS="LITERAL"
>~</TT
>と呼ばれていました。
これらの名前はまだ利用できますが、廃止予定であり、最終的にはなくなります。
古い名前はコアの幾何データ型が以前従っていた規約とは反対であることに注意してください。）
  </P
><P
>演算子<TT
CLASS="LITERAL"
>&amp;&amp;</TT
>、<TT
CLASS="LITERAL"
>@&gt;</TT
>と<TT
CLASS="LITERAL"
>&lt;@</TT
>は、これらはNULLを含まない整数配列のみで動作し、組み込み演算子はどの配列型に対しても動作する点を除き、同じ名前の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の組み込み演算子とそれぞれほぼ等価です。
この制限により、多くの場合、組み込み演算子より高速です。
  </P
><P
><TT
CLASS="LITERAL"
>@@</TT
>および<TT
CLASS="LITERAL"
>~~</TT
>演算子は、配列が特化したデータ型<TT
CLASS="TYPE"
>query_int</TT
>で表現される<I
CLASS="FIRSTTERM"
>問い合わせ</I
>を満たすかどうかを試験します。
<I
CLASS="FIRSTTERM"
>問い合わせ</I
>は、おそらく<TT
CLASS="LITERAL"
>&amp;</TT
>(論理積)、<TT
CLASS="LITERAL"
>|</TT
> (論理和)、<TT
CLASS="LITERAL"
>!</TT
> (否定)演算子を組み合わせて使用した、配列要素に対して検査される整数値からなります。
例えば<TT
CLASS="LITERAL"
>1&amp;(2|3)</TT
>という問い合わせは1および、2か3のいずれかを含む配列に一致します。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182179"
>F.18.2. インデックスサポート</A
></H2
><P
><TT
CLASS="FILENAME"
>intarray</TT
>は<TT
CLASS="LITERAL"
>&amp;&amp;</TT
>、<TT
CLASS="LITERAL"
>@&gt;</TT
>、<TT
CLASS="LITERAL"
>&lt;@</TT
>、<TT
CLASS="LITERAL"
>@@</TT
>演算子に関して通常の配列等価性と同様にインデックスサポートを提供します。
  </P
><P
>2つのGiSTインデックス演算子クラスが提供されます。
<TT
CLASS="LITERAL"
>gist__int_ops</TT
>（デフォルトで使用されます）は小中規模要素数のデータセットに適します。
一方、<TT
CLASS="LITERAL"
>gist__intbig_ops</TT
>はより大きな署名を使用しますので、大規模データセット（つまり、異なった配列値を多数持つ列）のインデックスにより適しています。
実装は組み込みの非可逆圧縮を持ったRD-treeデータ構造を使用します。
  </P
><P
>また、同じ演算子をサポートするデフォルトではないGIN演算子クラス<TT
CLASS="LITERAL"
>gin__int_ops</TT
>も存在します。
  </P
><P
>GiSTおよびGINインデックスのどちらを選択するかは、別途説明されるGiSTとGINの相対的な性能特徴に依存します。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182193"
>F.18.3. 例</A
></H2
><PRE
CLASS="PROGRAMLISTING"
>-- メッセージ(message)は1つ以上の<SPAN
CLASS="QUOTE"
>"節(section)"</SPAN
>の中にある
CREATE TABLE message (mid INT PRIMARY KEY, sections INT[], ...);

-- 特化したインデックスを作成
CREATE INDEX message_rdtree_idx ON message USING GIST (sections gist__int_ops);

-- 節1 OR 2のメッセージを選択 - OVERLAP演算子
SELECT message.mid FROM message WHERE message.sections &amp;&amp; '{1,2}';

-- 節1 AND 2のメッセージを選択 - CONTAINS演算子
SELECT message.mid FROM message WHERE message.sections @&gt; '{1,2}';

-- 同上、QUERY演算子を使用
SELECT message.mid FROM message WHERE message.sections @@ '1&amp;2'::query_int;</PRE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182197"
>F.18.4. ベンチマーク</A
></H2
><P
>ソースディレクトリ以下の<TT
CLASS="FILENAME"
>contrib/intarray/bench</TT
>にはベンチマーク試験一式があり、インストールされた<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバで実行できます。
(<TT
CLASS="FILENAME"
>DBD::Pg</TT
>もインストールされていないといけません。)
以下のように実行します。
  </P
><PRE
CLASS="PROGRAMLISTING"
>cd .../contrib/intarray/bench
createdb TEST
psql -c "CREATE EXTENSION intarray" TEST
./create_test.pl | psql TEST
./bench.pl</PRE
><P
><TT
CLASS="FILENAME"
>bench.pl</TT
>スクリプトには多くのオプションがあります。
これらは引数を付けずに実行すると表示されます。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN182206"
>F.18.5. 作者</A
></H2
><P
>Teodor Sigaev (<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:teodor@sigaev.ru"
>teodor@sigaev.ru</A
>&#62;</CODE
>)とOleg Bartunov (<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:oleg@sai.msu.su"
>oleg@sai.msu.su</A
>&#62;</CODE
>)によりすべての作業がなされました。
さらなる情報については<A
HREF="http://www.sai.msu.su/~megera/postgres/gist/"
TARGET="_top"
>http://www.sai.msu.su/~megera/postgres/gist/</A
>を参照してください。
Andrey Oktyabrskiは新しい関数、演算子の追加において素晴らしい作業を行いました。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="intagg.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="isn.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>intagg</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="contrib.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>isn</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
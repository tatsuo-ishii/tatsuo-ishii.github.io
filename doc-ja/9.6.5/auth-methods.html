<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>認証方式</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="クライアント認証"
HREF="client-authentication.html"><LINK
REL="PREVIOUS"
TITLE="ユーザ名マップ"
HREF="auth-username-maps.html"><LINK
REL="NEXT"
TITLE="認証における問題点"
HREF="client-authentication-problems.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="ユーザ名マップ"
HREF="auth-username-maps.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 20章クライアント認証</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="認証における問題点"
HREF="client-authentication-problems.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="AUTH-METHODS"
>20.3. 認証方式</A
></H1
><P
>   以下の小節では、認証方式について詳細に説明します。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-TRUST"
>20.3.1. trust認証</A
></H2
><P
><TT
CLASS="LITERAL"
>trust</TT
>認証が指定されると<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、サーバに接続できる全ての人に対して
（データベーススーパーユーザさえも）その人が指定する任意のデータベースユーザ名としてのアクセス権限が付与されていると想定します。
当然ながら<TT
CLASS="LITERAL"
>database</TT
>と<TT
CLASS="LITERAL"
>user</TT
>列にある制限は適用されます。
この方式はサーバに接続する際に適切なオペレーティングシステムレベルの保護が掛けられている場合にのみ使用すべきです。
   </P
><P
><TT
CLASS="LITERAL"
>trust</TT
>認証はユーザが1人のみのワークステーション上でローカル接続を行う場合は適切であると同時に非常に便利です。
複数ユーザが存在するマシン上では一般的に適切では<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ありません</I
></SPAN
>。
とは言っても、ファイルシステムの許可属性を使ってサーバのUnixドメインソケットファイルへのアクセスを制限すれば<TT
CLASS="LITERAL"
>trust</TT
>認証を複数ユーザのマシン上で使用することも可能です。
その方法は、<A
HREF="runtime-config-connection.html"
>項19.3</A
>に記載されているように<TT
CLASS="VARNAME"
>unix_socket_permissions</TT
>（および<TT
CLASS="VARNAME"
>unix_socket_group</TT
>パラメータの可能性もあります）パラメータを設定します。
もしくは、<TT
CLASS="VARNAME"
>unix_socket_directories</TT
>設定パラメータでソケットファイルをそれに相応しく制限されているディレクトリにします。
   </P
><P
>Unixソケット接続を行うただ1つの方法は、ファイルシステムの許可を設定することです。
ローカルのTCP/IP接続は、ファイルシステムにより制限はされていません。
よってローカルでファイルシステムの許可を使用したい場合は<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>から
<TT
CLASS="LITERAL"
>host ... 127.0.0.1 ...</TT
>の行を削除するか、<TT
CLASS="LITERAL"
>trust</TT
>認証とは異なる方法に変更する必要があります。
   </P
><P
>TCP/IP接続における<TT
CLASS="LITERAL"
>trust</TT
>認証は、<TT
CLASS="LITERAL"
>trust</TT
>を指定する<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>の行によってサーバに接続を許可される全てのマシン上の全てのユーザを信用（trust）できる場合にのみ相応しいものです。
<SPAN
CLASS="SYSTEMITEM"
>ローカルホスト</SPAN
>（127.0.0.1）以外からのTCP/IP接続に<TT
CLASS="LITERAL"
>trust</TT
>認証を用いる理由はほとんど見当たりません。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PASSWORD"
>20.3.2. パスワード認証</A
></H2
><P
>パスワードをベースにした認証方式には <TT
CLASS="LITERAL"
>md5</TT
>および<TT
CLASS="LITERAL"
>password</TT
>があります。
これらの方式はパスワードが接続間でどのように送信されるか（すなわち、それぞれMD5-hashed、平文）を別にすれば似たような動作をします。
   </P
><P
>もしパスワード<SPAN
CLASS="QUOTE"
>"盗聴"</SPAN
>攻撃に最大の関心があれば<TT
CLASS="LITERAL"
>md5</TT
>を使うのがよいでしょう。
可能ならば、平文の<TT
CLASS="LITERAL"
>password</TT
>の使用は常に避けなければなりません。
しかし<TT
CLASS="LITERAL"
>md5</TT
>は<A
HREF="runtime-config-connection.html#GUC-DB-USER-NAMESPACE"
>db_user_namespace</A
>機能といっしょに使用することはできません。
接続がSSL暗号化により保護されているのであれば、<TT
CLASS="LITERAL"
>password</TT
>を安全に使用することができます。
（ただしSSLの使用に依存するという点では、SSL証明書認証を使用した方が良いかもしれません。）
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>データベースパスワードはオペレーティングシステムのユーザパスワードとも別のものです。
各データベースユーザのパスワードは<TT
CLASS="LITERAL"
>pg_authid</TT
>システムカタログテーブルの中に格納されます。
<KBD
CLASS="USERINPUT"
>CREATE USER foo WITH PASSWORD 'secret';</KBD
>のように、パスワードはSQLコマンド<A
HREF="sql-createuser.html"
>CREATE USER</A
>と<A
HREF="sql-alterrole.html"
>ALTER ROLE</A
>を使って管理できます。
もしユーザに対してパスワードが設定されない場合、格納されるパスワードはNULLとなり、そのユーザのパスワード認証は常に失敗します。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="GSSAPI-AUTH"
>20.3.3. GSSAPI認証</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>は、RFC 2743で定義されている安全な認証のための業界標準のプロトコルです。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、RFC 1964により<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>認証での<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>をサポートします。
<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>は、<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>をサポートしているシステムに対して自動認証（シングルサインオン）を提供します。
認証自体は安全ですが、データベース接続を通じて送信されるデータは、<ACRONYM
CLASS="ACRONYM"
>SSL</ACRONYM
>が使用されていない場合は平文となります。
   </P
><P
>GSSAPIサポートは、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を構築する時に有効にしなければなりません。詳細は、<A
HREF="installation.html"
>第16章</A
>を参照してください。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>が<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>を使用しているとき、<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>は、<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>servicename</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
>@<TT
CLASS="REPLACEABLE"
><I
>realm</I
></TT
></TT
>という書式の標準のプリンシパルを使用します。
[訳注：プリンシパルとは大雑把に2つのものを指します。1つはサービスを受けるクライアントで、もう1つはサービスを提供するサーバアプリケーションです。どちらも、認証に関してはKerberosのKDCから見るとクライアントになります]
PostgreSQLサーバはサーバにより使われるkeytabに含まれるいかなるプリンシパルも受け付けますが、<TT
CLASS="LITERAL"
>krbsrvname</TT
>接続パラメータを使ってクライアントから接続する場合には、プリンシパルの詳細を正確に指定することに注意を払う必要があります。
(<A
HREF="libpq-connect.html#LIBPQ-PARAMKEYWORDS"
>項32.1.2</A
>も参照してください。)
ビルド時に<TT
CLASS="LITERAL"
>./configure --with-krb-srvnam=whatever</TT
>を使用することで、インストール時のデフォルトはデフォルトの<TT
CLASS="LITERAL"
>postgres</TT
>から変更が可能です。
多くの環境では、このパラメータは変更する必要はないでしょう。
いくつかのKerberosの実装では、異なるサービス名が必要になります。Microsoftアクティブディレクトリではサービス名は（<TT
CLASS="LITERAL"
>POSTGRES</TT
>）のように大文字にする必要があります。
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>hostname</I
></TT
>はサーバマシンの完全修飾されたホスト名です。
サービスプリンシパルのrealmはサーバマシンが提起したrealmです。
   </P
><P
>クライアントのプリンシパルは<TT
CLASS="FILENAME"
>pg_ident.conf</TT
>で異なる<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のデータベースユーザ名にマップできます。
例えば、<TT
CLASS="LITERAL"
>pgusername@realm</TT
>を単なる<TT
CLASS="LITERAL"
>pgusername</TT
>にマップできます。
もう1つの方法として、プリンシパル名全体<TT
CLASS="LITERAL"
>username@realm</TT
>を<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のロール名としてマッピングなしに使うこともできます。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はプリンシパルからrealmを外すパラメータもサポートしています。
この方法は後方互換のためにサポートされているものであり、異なるrealmから来た同じユーザ名の異なるユーザを区別することができませんので、使用しないことを強く薦めます。
この方法を有効にするには<TT
CLASS="LITERAL"
>include_realm</TT
>を0に設定してください。
単純な単一realmの設定では、(プリンシパルのrealmが<TT
CLASS="LITERAL"
>krb_realm</TT
>パラメータ内のものと正確に一致するか確認する)<TT
CLASS="LITERAL"
>krb_realm</TT
>パラメータと組み合わせることが安全です。
しかし、これは<TT
CLASS="FILENAME"
>pg_ident.conf</TT
>で明示的なマッピングを指定するのに比べてあまり適切でない選択でしょう。 
   </P
><P
>サーバ鍵ファイルが<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバアカウントによって読み込み可能（そしてできれば読み込み専用で書き込み不可）であることを確認してください。
（<A
HREF="postgres-user.html"
>項18.1</A
>を参照してください。）
鍵ファイルの保存場所は<A
HREF="runtime-config-connection.html#GUC-KRB-SERVER-KEYFILE"
>krb_server_keyfile</A
>設定パラメータで指定されます
デフォルトは、<TT
CLASS="FILENAME"
>/usr/local/pgsql/etc/krb5.keytab</TT
>（もしくはビルド時に<TT
CLASS="VARNAME"
>sysconfdir</TT
>で指定されたディレクトリ）です。
セキュリティ上の理由から、システムkeytabファイルで許可するよりも、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバ用に別のkeytabファイルを使うことをお薦めします。
   </P
><P
>keytabファイルはKerberosのソフトウェアによって作成されます。詳細はKerberosのドキュメントを参照してください。
MIT互換のKerberos5実装の例を以下に示します。
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>kadmin% </SAMP
><KBD
CLASS="USERINPUT"
>ank -randkey postgres/server.my.domain.org</KBD
>
<SAMP
CLASS="PROMPT"
>kadmin% </SAMP
><KBD
CLASS="USERINPUT"
>ktadd -k krb5.keytab postgres/server.my.domain.org</KBD
></PRE
><P>
   </P
><P
>データベースに接続しようとしている時要求されるデータベースユーザ名に一致するプリンシパルのチケットを所有しているか確認してください。
例えば、データベースユーザ名<TT
CLASS="LITERAL"
>fred</TT
>に対し、<TT
CLASS="LITERAL"
>fred@EXAMPLE.COM</TT
>のプリンシパルは接続できるでしょう。
<TT
CLASS="LITERAL"
>fred/users.example.com@EXAMPLE.COM</TT
>のプリンシパルも許可するためには<A
HREF="auth-username-maps.html"
>項20.2</A
>内に記述されているユーザ名マップを使用して下さい。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>include_realm</TT
></DT
><DD
><P
>0に設定されている場合は、認証されたユーザプリンシパルからのrealm名が、ユーザ名マッピング（<A
HREF="auth-username-maps.html"
>項20.2</A
>）で渡されるシステムユーザ名から外されています。
<TT
CLASS="LITERAL"
>krb_realm</TT
>も一緒に使われていない限り、これは複数realm環境で安全ではありませんので、非推奨であり、主に後方互換性のために利用できます。
<TT
CLASS="LITERAL"
>include_realm</TT
>をデフォルト(1)にしたまま、プリンシパル名を<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ユーザ名に変換するために<TT
CLASS="FILENAME"
>pg_ident.conf</TT
>で明示的なマッピングを指定することをお薦めします。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースの間のマッピングを許可します。詳細は<A
HREF="auth-username-maps.html"
>項20.2</A
>を参照してください。
GSSAPI/Kerberosプリンシパル<TT
CLASS="LITERAL"
>username@EXAMPLE.COM</TT
>(もしくは、あまり一般的ではありませんが<TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>)に対しては、もし<TT
CLASS="LITERAL"
>include_realm</TT
>が0に設定されていない限り、マッピングに使われるユーザ名は<TT
CLASS="LITERAL"
>username@EXAMPLE.COM</TT
>(もしくは<TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>)です。
0に設定されている場合には、<TT
CLASS="LITERAL"
>username</TT
>(もしくは<TT
CLASS="LITERAL"
>username/hostbased</TT
>)がマッピング時のシステムユーザ名です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_realm</TT
></DT
><DD
><P
>realmをユーザプリンシパル名に一致するように設定します。
もしこのパラメータが設定されている場合はそのrealmのユーザのみが受け付けられます。
もしこれが設定されていない場合は、どのようなrealmのユーザも接続可能で、ユーザ名マッピングが設定されていれば、どれでも影響を受けます。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SSPI-AUTH"
>20.3.4. SSPI認証</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>は、シングルサインオンで安全な認証を行うための<SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>の技術です。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、<TT
CLASS="LITERAL"
>negotiate</TT
>モードにおいてSSPIを使用します。
これは、可能な場合は<SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>を使用し、他の場合については自動的に<SPAN
CLASS="PRODUCTNAME"
>NTLM</SPAN
>を使用することを意味しています。
<SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>認証は、サーバ、クライアントが共に<SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>上もしくは<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>が利用可能な場合はWindowsではないプラットフォームで稼動しているときにのみ動作します。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>Kerberos</SPAN
>認証を使用しているとき、
<SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>は、<SPAN
CLASS="PRODUCTNAME"
>GSSAPI</SPAN
>と同じように動作します。
詳細は<A
HREF="auth-methods.html#GSSAPI-AUTH"
>項20.3.3</A
>を参照してください。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>SSPI</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>include_realm</TT
></DT
><DD
><P
>0に設定されている場合は、認証されたユーザプリンシパルからのrealm名が、ユーザ名マッピング（<A
HREF="auth-username-maps.html"
>項20.2</A
>）で渡されるシステムユーザ名から外されています。
<TT
CLASS="LITERAL"
>krb_realm</TT
>も一緒に使われていない限り、これは複数realm環境で安全ではありませんので、非推奨であり、主に後方互換性のために利用できます。
<TT
CLASS="LITERAL"
>include_realm</TT
>をデフォルト(1)にしたまま、プリンシパル名を<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ユーザ名に変換するために<TT
CLASS="FILENAME"
>pg_ident.conf</TT
>で明示的なマッピングを指定することをお薦めします。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>compat_realm</TT
></DT
><DD
><P
>1に設定されている場合は、（NetBIOS名としても知られている）ドメインのSAM互換名が<TT
CLASS="LITERAL"
>include_realm</TT
>オプションのために使用されます。
これはデフォルトの動作です。
0に設定されている場合は、ケルベロスユーザプリンシパル名からの真のrealm名が使用されます。
       </P
><P
>ドメインアカウント（これはドメインメンバーシステムの仮想サービスアカウントを含みます）にて実行されているサーバで、SSPIで認証されているすべてのクライアントがドメインアカウントを使用してる場合を除き、このオプションを無効にしないでください。
さもなくば認証は失敗します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>upn_username</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>compat_realm</TT
>と共にこのオプションが有効の場合、認証にはケルベルスUPNからユーザ名が使用されます。
無効（デフォルト）である場合は、SAM互換ユーザ名が使用されます。
デフォルトでは、これらの2つのユーザ名は新しいユーザアカウントでは同じものとなります。
       </P
><P
>明示的なユーザ名が指定されない場合、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>はSAM互換名を使用することに注意してください。
<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>もしくは<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>を基礎としたドライバを使用する場合は、このオプションを無効のままにするか、明示的なユーザ名を接続文字列にて指定してください。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<A
HREF="auth-username-maps.html"
>項20.2</A
>を参照してください。
GSSAPI/Kerberosプリンシパル<TT
CLASS="LITERAL"
>username@EXAMPLE.COM</TT
>(もしくは、あまり一般的ではありませんが<TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>)に対しては、もし<TT
CLASS="LITERAL"
>include_realm</TT
>が0に設定されていない限り、マッピングに使われるユーザ名は<TT
CLASS="LITERAL"
>username@EXAMPLE.COM</TT
>(もしくは<TT
CLASS="LITERAL"
>username/hostbased@EXAMPLE.COM</TT
>)です。
0に設定されている場合には、<TT
CLASS="LITERAL"
>username</TT
>(もしくは<TT
CLASS="LITERAL"
>username/hostbased</TT
>)がマッピング時のシステムユーザ名です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>krb_realm</TT
></DT
><DD
><P
>realmをユーザプリンシパル名に一致するように設定します。もしこのパラメータが設定されている場合は
realmのユーザのみが受け付けられます。もしこれが設定されていない場合は、
どのようなrealmのユーザも接続可能で、ユーザ名マッピングが設定されていれば、どれでも影響を受けます。
       </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-IDENT"
>20.3.5. Ident認証</A
></H2
><P
>ident認証方式は、クライアントのオペレーティングシステムのユーザ名をidentサーバから入手し、それを（オプションのユーザ名マップとともに）許可されているデータベースのユーザ名として使用します。
これはTCP/IP接続のみサポートされます。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>identが（TCP/IPではない）ローカル接続で指定されている場合、
ピア認証（<A
HREF="auth-methods.html#AUTH-PEER"
>項20.3.6</A
>を参照してください）が代わりに使用されます。
    </P
></BLOCKQUOTE
></DIV
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>ident</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<A
HREF="auth-username-maps.html"
>項20.2</A
>を参照してください。
       </P
></DD
></DL
></DIV
><P>
   </P
><P
><SPAN
CLASS="QUOTE"
>"身元特定（Identification）プロトコル"</SPAN
>についてはRFC 1413で説明されています。
事実上全てのUnix系のオペレーティングシステムの配布には、デフォルトでTCPポート113を監視するidentサーバが付属しています。
identサーバの基本的な機能は<SPAN
CLASS="QUOTE"
>"どのユーザがポート<TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
>からの接続を開始し、自分のポート<TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>への接続を初期化したのか？"</SPAN
>というような質問に答えることです。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は物理的な接続が確立された時に<TT
CLASS="REPLACEABLE"
><I
>X</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>Y</I
></TT
>の両方を認識するので、接続するクライアントのホスト上のidentサーバに応答指令信号を送ることができ、理論的には与えられたどの接続にもオペレーティングシステムユーザを決定できます。
   </P
><P
>この手続きの欠点は、クライアントの正直さに頼るところが大きいということです。
もしクライアントマシンが信用されない、もしくは危険に晒されている場合、攻撃者はポート113上でほぼどんなプログラムでも実行することができ、どのユーザ名でも好きに選んで返すことができます。
したがってこの認証方式は、各々のクライアントマシンが厳格な管理下にあり、データベースとシステム管理者が密接に連絡を取り合って動作している、外界から閉ざされたネットワークにのみ適していると言えます。
言い換えると、identサーバが稼働しているマシンを信用しなければなりません。
次の警告に注意してください。
    <A
NAME="AEN37717"
></A
><TABLE
BORDER="0"
WIDTH="100%"
CELLSPACING="0"
CELLPADDING="0"
CLASS="BLOCKQUOTE"
><TR
><TD
WIDTH="10%"
VALIGN="TOP"
>&nbsp;</TD
><TD
VALIGN="TOP"
><P
>      身元特定プロトコルは、認証、あるいはアクセス管理プロトコルには意図されていません。
     </P
></TD
><TD
WIDTH="10%"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
COLSPAN="2"
ALIGN="RIGHT"
VALIGN="TOP"
>--<SPAN
CLASS="ATTRIBUTION"
>RFC 1413</SPAN
></TD
><TD
WIDTH="10%"
>&nbsp;</TD
></TR
></TABLE
>
   </P
><P
>いくつかの身元特定サーバは、ユーザ名を（マシンの管理者のみが知っているキーで）暗号化して返すような非標準のオプションを持っています。
このオプションは、身元特定サーバと<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>とを一緒に使用する場合には、使用しては<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>いけません</I
></SPAN
>。
理由は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、返された文字列を復号化して本当のユーザを決定するための手段を持っていないためです。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PEER"
>20.3.6. Peer認証</A
></H2
><P
>peer認証方式はカーネルからクライアント上のオペレーティングシステムのユーザ名を取得し、
それをデータベースユーザ名（オプションのユーザ名マップとともに）として使用することにより動作します。この方法はローカル接続でのみ使用可能です。
   </P
><P
>次の設定オプションは<SPAN
CLASS="PRODUCTNAME"
>peer</SPAN
>のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースのユーザ名のマッピングを許可します。詳細は<A
HREF="auth-username-maps.html"
>項20.2</A
>を参照してください。
       </P
></DD
></DL
></DIV
><P>
   </P
><P
>Peer認証はオペレーティングシステムが、<CODE
CLASS="FUNCTION"
>getpeereid()</CODE
>関数、<TT
CLASS="SYMBOL"
>SO_PEERCRED</TT
>のソケットパラメータ、もしくは同じような仕組みを提供しているときにのみ使用可能です。現状では、<SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
>、<SPAN
CLASS="SYSTEMITEM"
>OS X</SPAN
>を含む<SPAN
CLASS="SYSTEMITEM"
>BSD</SPAN
>系、そして<SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
>に含まれています。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-LDAP"
>20.3.7. LDAP認証</A
></H2
><P
>この認証方式は<TT
CLASS="LITERAL"
>password</TT
>と似ていますが、パスワード確認にLDAPを使用する点が異なります。
LDAPはユーザの名前とパスワードの組み合わせの検証のみに使用されます。
そのため、LDAPを使用して認証を行うようにする前に、ユーザはデータベースに存在しなければなりません。
   </P
><P
>LDAP認証は2つのモードで動作します。1つ目のモードでは、それは単なるバインド・モードを呼び出すものですが、
サーバは<TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>username</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>suffix</I
></TT
>として区別された名前にバインドします。
一般的に、<TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>パラメータはActive Directory環境での<TT
CLASS="LITERAL"
>cn=</TT
>や<TT
CLASS="REPLACEABLE"
><I
>DOMAIN</I
></TT
><TT
CLASS="LITERAL"
>\</TT
>を特定するために使用されます。
<TT
CLASS="REPLACEABLE"
><I
>suffix</I
></TT
>は、Active Directory環境ではない場合でのDNの残りの部分を特定するために使用されます。
   </P
><P
>2つ目のモードでは、それはsearch/bindモードを呼び出すもので、サーバは最初に<TT
CLASS="REPLACEABLE"
><I
>ldapbinddn</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>ldapbindpasswd</I
></TT
>で指定された、
固定されたユーザ名とパスワードを使用してLDAPディレクトリにバインドします。
それからデータベースにログインしようとしているユーザを検索します。
もしユーザとパスワードが指定されていなかった場合は、ディレクトリに対して匿名でバインドします。
検索は<TT
CLASS="REPLACEABLE"
><I
>ldapbasedn</I
></TT
>のサブツリーまで行われ、<TT
CLASS="REPLACEABLE"
><I
>ldapsearchattribute</I
></TT
>で指定された属性に正確に一致するかどうかまで行われます。
この検索において、一度ユーザが見つかるとサーバは切断して、クライアントで指定されたパスワードを使用してこのユーザとして再度ディレクトリにバインドします。これはそのログインが正しいかどうかを検証するためです。
このモードはApache <TT
CLASS="LITERAL"
>mod_authnz_ldap</TT
>および<TT
CLASS="LITERAL"
>pam_ldap</TT
>のように他のソフトウェアと同じように、LDAP認証の仕組みで使用されるものと同じです。
この方法は、ユーザオブジェクトがディレクトリに配置されている場合に、かなりの柔軟性があります。
しかし、LDAPサーバへの2つの分離した接続が作成されます。
   </P
><P
>次の設定オプションは両方のモードで使用されます。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ldapserver</TT
></DT
><DD
><P
>接続するLDAPサーバの名称もしくはIPアドレスの名称。空白で区切ることで複数のサーバを指定できます。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapport</TT
></DT
><DD
><P
>LDAPサーバに接続するためのポート番号。もしポートが指定されていない場合は
LDAPライブラリ内のデフォルトポート設定が使用されます。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldaptls</TT
></DT
><DD
><P
>1に設定すると、PostgreSQLとLDAPサーバ間の接続にTLSによる暗号化を使用します。
これはLDAPサーバへのトラフィックのみを暗号化することに注意してください。&mdash;
クライアントへの接続はSSLを使用しない限り暗号化されません。
       </P
></DD
></DL
></DIV
><P>

以下のオプションは単純バインド・モードのみで使用されます。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ldapprefix</TT
></DT
><DD
><P
>単純なバインド認証を行う場合のDNを生成する際にユーザ名の前に追加する文字列
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapsuffix</TT
></DT
><DD
><P
>単純なバインド認証を行う場合のDNを生成する際にユーザ名の後に追加する文字列
       </P
></DD
></DL
></DIV
><P>

以下のオプションはsearch/bindモードのみで使用されます。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ldapbasedn</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合のユーザ名がログインするための検索を始めるためのルートDN
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapbinddn</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合のディレクトリと検索をバインドするためのユーザのDN
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapbindpasswd</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合のディレクトリと検索をバインドするためのユーザのパスワード
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapsearchattribute</TT
></DT
><DD
><P
>検索とバインドの認証を行う場合の検索時のユーザ名に対して一致させる属性。
属性が指定されない場合、属性<TT
CLASS="LITERAL"
>uid</TT
>が使用されます。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>ldapurl</TT
></DT
><DD
><P
>RFC 4516 LDAP URL。これはその他いくつかのLDAPオプションをより簡潔、かつ一般的な形式で記述する別の方法です。
フォーマットは以下のようになっています。
</P><PRE
CLASS="SYNOPSIS"
>ldap://<TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
>[:<TT
CLASS="REPLACEABLE"
><I
>port</I
></TT
>]/<TT
CLASS="REPLACEABLE"
><I
>basedn</I
></TT
>[?[<TT
CLASS="REPLACEABLE"
><I
>attribute</I
></TT
>][?[<TT
CLASS="REPLACEABLE"
><I
>scope</I
></TT
>]]]</PRE
><P>
<TT
CLASS="REPLACEABLE"
><I
>scope</I
></TT
>は<TT
CLASS="LITERAL"
>base</TT
>、<TT
CLASS="LITERAL"
>one</TT
>,、<TT
CLASS="LITERAL"
>sub</TT
>のいずれかでなくてはならず、一般的には最後のものです。
        </P
><P
>非匿名バインド（non-anonymous bind）に対し、<TT
CLASS="LITERAL"
>ldapbinddn</TT
>および<TT
CLASS="LITERAL"
>ldapbindpasswd</TT
>は個別のオプションとして指定されなければなりません。
        </P
><P
>暗号化されたLDAP接続を使用するには、<TT
CLASS="LITERAL"
>ldapurl</TT
>に加え<TT
CLASS="LITERAL"
>ldaptls</TT
>オプションを使用しなければなりません。<TT
CLASS="LITERAL"
>ldaps</TT
> URLの仕組み（直接SSL接続）はサポートされていません。
        </P
><P
>現在の所、LDAP URLはWindows上ではなく、OpenLDAPのみでサポートされています。
        </P
></DD
></DL
></DIV
><P>
   </P
><P
>seartch/bindオプションと単純バインドに対するオプションの設定を混在させるのはエラーです。
   </P
><P
>以下に単純バインドLDAP設定の例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>host ... ldap ldapserver=ldap.example.net ldapprefix="cn=" ldapsuffix=", dc=example, dc=net"</PRE
><P>
データベースのユーザ、<TT
CLASS="LITERAL"
>someuser</TT
>からデータベースサーバに接続を要求された場合、PostgreSQLはDN <TT
CLASS="LITERAL"
>cn=someuser, dc=example, dc=net</TT
>およびクライアントから提供されたパスワードを用いてLDAPサーバにバインドを試みます。
その接続が成功すればデータベースへのアクセスが認められます。
   </P
><P
>以下はsearch/bind設定の例です。
</P><PRE
CLASS="PROGRAMLISTING"
>host ... ldap ldapserver=ldap.example.net ldapbasedn="dc=example, dc=net" ldapsearchattribute=uid</PRE
><P>
データベースユーザ<TT
CLASS="LITERAL"
>someuser</TT
>としてデータベースに接続するとき、PostgreSQLは（<TT
CLASS="LITERAL"
>ldapbinddn</TT
>が指定されていないので）匿名的にバインドを試み、指定されたベースDNの基で<TT
CLASS="LITERAL"
>(uid=someuser)</TT
>の検索を行います。あるエントリが見つかると、見つかった情報とクライアントから与えられたパスワードを用いて、その結果バインドを試みます。その二番目の接続が成功するとデータベースアクセスが認められます。
   </P
><P
>URLとして記述した同じsearch/bind設定の例です。
</P><PRE
CLASS="PROGRAMLISTING"
>host ... ldap ldapurl="ldap://ldap.example.net/dc=example,dc=net?uid?sub"</PRE
><P>
LDAPに対し認証をサポートする幾つかの他のソフトウェアは同じURLフォーマットを使用します。
従って、設定をより簡易に共有することができます。
   </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>ティップ: </B
>LDAPはDNの異なる構成要素を区別するため往々にしてコンマとスペースを使用します。
例で示されたように、LDAPオプションを設定する場合、二重引用符で括られたパラメータ値を使用することが必須となることがしばしば必須となります。
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-RADIUS"
>20.3.8. RADIUS認証</A
></H2
><P
>この認証方法は、RADIUSをパスワード検証として使用するという点を除いて<TT
CLASS="LITERAL"
>password</TT
>と似た動作をします。
RADIUSはユーザ名/パスワードの組のみを検証するために使用されます。
よってユーザはRADIUSが認証に使用される以前にデータベースにすでに存在していなければいけません。
   </P
><P
>RADIUS認証を使用する場合に、設定されたRADIUSサーバにアクセスリクエストメッセージが送信されます。
このリクエストは<TT
CLASS="LITERAL"
>Authenticate Only</TT
>の形式になり、<TT
CLASS="LITERAL"
>ユーザ名</TT
>, （暗号化された）<TT
CLASS="LITERAL"
>パスワード</TT
>、<TT
CLASS="LITERAL"
>NAS識別子</TT
>を含んでいます。
リクエストはサーバと共有している秘密を用いて暗号化されます。
RADIUSサーバは、このサーバに対して<TT
CLASS="LITERAL"
>Access Accept</TT
>もしくは<TT
CLASS="LITERAL"
>Access Reject</TT
>を返します。
RADIUSアカウントのサポートはありません。
   </P
><P
>RADIUSのために次の設定オプションがサポートされています。
     <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>radiusserver</TT
></DT
><DD
><P
>接続するRADIUSサーバの名称もしくはIPアドレス。このパラメータは必要です。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>radiussecret</TT
></DT
><DD
><P
>RADIUSサーバとのやり取りに使用される共有の秘密。これはPostgreSQLとRADIUSサーバにおいて
厳密に同じ値にする必要があります。少なくとも16文字以上の文字列が推奨されます。このパラメータは必要です。
         </P><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>使用されている暗号化ベクターは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が<SPAN
CLASS="PRODUCTNAME"
>OpenSSL</SPAN
>をサポートするよう構築している場合にのみ暗号論的に強力です。
他の場合にはRADIUSサーバへの伝送は難読化されているだけで、安全ではなく必要な場合は外部のセキュリティ方法を適用すべきです。
         </P
></BLOCKQUOTE
></DIV
><P>
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>radiusport</TT
></DT
><DD
><P
>接続するRADIUSサーバのポート番号。もしポート番号が指定されていない場合は、デフォルトポートである<TT
CLASS="LITERAL"
>1812</TT
>が使用されます。
        </P
></DD
><DT
><TT
CLASS="LITERAL"
>radiusidentifier</TT
></DT
><DD
><P
>RADIUSリクエスト内で<TT
CLASS="LITERAL"
>NAS Identifier</TT
>として使用されている文字列。
ユーザがどのデータベースユーザに対して認証しようとしているか、RADIUSサーバにおいてポリシーを一致させるために何が使用されるか、
を識別するために、このパラメータは2番目のパラメータとして使用されます。
もし識別子が指定されていない場合は、デフォルトの<TT
CLASS="LITERAL"
>postgresql</TT
>が使用されます。
        </P
></DD
></DL
></DIV
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-CERT"
>20.3.9. 証明書認証</A
></H2
><P
>この認証方法は、認証のためにSSLクライアント証明書を使用します。
よってこの方法は、SSL接続を使用します。
この認証方法を使用する際は、サーバはクライアントが有効かつ信頼された証明書を提供することを要求します。
パスワードのプロンプトはクライアントに送信されません。
証明書の<TT
CLASS="LITERAL"
>cn</TT
>（Common Name）属性は、要求されたデータベースユーザ名と比較されます。
もしそれらが一致した場合はログインが許可されます。ユーザ名マッピングは、<TT
CLASS="LITERAL"
>cn</TT
>がデータベースユーザ名と異なるものであることを許可するために使用されます。
   </P
><P
>次の設定オプションはSSL証明書認証のためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>map</TT
></DT
><DD
><P
>システムとデータベースユーザ名の間のマッピングを許可します。
詳細は<A
HREF="auth-username-maps.html"
>項20.2</A
>を参照してください。
       </P
></DD
></DL
></DIV
><P>
   </P
><P
>証明書認証を指定する<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>のレコードにおいて、認証オプションである<TT
CLASS="LITERAL"
>clientcert</TT
>は<TT
CLASS="LITERAL"
>1</TT
>であるとみなされ、クライアント証明書がこの方式のために必要であるゆえに無効にできません。
<TT
CLASS="LITERAL"
>cert</TT
>方式が基本的な<TT
CLASS="LITERAL"
>clientcert</TT
>証明書の妥当性確認に追加するのは、<TT
CLASS="LITERAL"
>cn</TT
>属性がデータベースユーザ名と合致することの確認となります。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-PAM"
>20.3.10. PAM認証</A
></H2
><P
>この認証方式は認証機構としてPAM（Pluggable Authentication Modules）を使用することを除いて<TT
CLASS="LITERAL"
>password</TT
>のように動作します。
デフォルトのPAMサービス名は<TT
CLASS="LITERAL"
>postgresql</TT
>です。
PAMはユーザ名/パスワードの組の確認と接続されたリモートホスト名またはIPアドレスを任意に確認するためだけに使用されます。
PAMについての詳細は<A
HREF="http://www.kernel.org/pub/linux/libs/pam/"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>Linux-PAM</SPAN
>ページ</A
>を読んでください。
   </P
><P
>次の設定オプションはPAMのためにサポートされています。
    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>pamservice</TT
></DT
><DD
><P
>PAMサービス名。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>pam_use_hostname</TT
></DT
><DD
><P
><TT
CLASS="SYMBOL"
>PAM_RHOST</TT
>アイテムを通じてPAMモジュールに提供されるものがリモートのIPアドレスかホスト名かを決定します。
デフォルトではIPアドレスが使用されます。
ホスト名にて使用するためにはこのオプションを1にセットしてください。
ホスト名の解決はログインの遅延をもたらします。（ほとんどのPAM設定はこの情報を利用せず、PAM設定がホスト名を使用するために明確に作成された場合のみ、この設定値を考慮する必要があります。）
       </P
></DD
></DL
></DIV
><P>
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>PAMが<TT
CLASS="FILENAME"
>/etc/shadow</TT
>を読み取るように設定されている場合は、PostgreSQLがルートユーザで起動されていないため、認証は失敗するでしょう。
しかしPAMがLDAPや他の認証方法を使用するように設定されている場合は、これは問題ではありません。
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AUTH-BSD"
>20.3.11. BSD認証</A
></H2
><P
>この認証方式は、パスワードを照合するためにBSD認証を使用すること以外は<TT
CLASS="LITERAL"
>password</TT
>と同じように動作します。
BSD認証は、ユーザ名/パスワードの組の確認のみに使用されます。
それゆえ、ユーザのロールはBSD認証が認証に使用可能となる前にデータベースに存在していなければいけません。
BSD認証フレームワークは現在OpenBSDでのみ利用可能です。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>でのBSD認証は、<TT
CLASS="LITERAL"
>auth-postgresql</TT
>ログイン型を使用し、<TT
CLASS="LITERAL"
>postgresql</TT
>ログインクラスが<TT
CLASS="FILENAME"
>login.conf</TT
>にて定義されている場合はそれを使った認証を使用します。
デフォルトでは、そのログインクラスは存在せず、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はデフォルトログインクラスを使用します。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>BSD認証を使用するために、PostgreSQLユーザアカウント（サーバを起動しているオペレーティングシステムユーザ）が、まずは<TT
CLASS="LITERAL"
>auth</TT
>グループに追加されていなければいけません。
<TT
CLASS="LITERAL"
>auth</TT
>グループはOpenBSDシステムではデフォルトで存在しています。
    </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="auth-username-maps.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="client-authentication-problems.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ユーザ名マップ</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="client-authentication.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>認証における問題点</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
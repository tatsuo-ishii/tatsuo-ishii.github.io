<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>COPYコマンド関連関数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="libpq - C ライブラリ"
HREF="libpq.html"><LINK
REL="PREVIOUS"
TITLE="非同期通知"
HREF="libpq-notify.html"><LINK
REL="NEXT"
TITLE="制御関数"
HREF="libpq-control.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="非同期通知"
HREF="libpq-notify.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 32章<SPAN
CLASS="APPLICATION"
>libpq</SPAN
> - C ライブラリ</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="制御関数"
HREF="libpq-control.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LIBPQ-COPY"
>32.9. <TT
CLASS="COMMAND"
>COPY</TT
>コマンド関連関数</A
></H1
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の<TT
CLASS="COMMAND"
>COPY</TT
>コマンドでは、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>が使っているネットワーク接続に対して読み込み、あるいは書き込みを選ぶことができるようになっています。
本節で説明する関数により、アプリケーションはコピーするデータの提供やコピーされるデータの使用が可能になるという利点を持ちます。
  </P
><P
>全体的な処理として、アプリケーションはまず<CODE
CLASS="FUNCTION"
>PQexec</CODE
>もしくは同等な関数経由で<TT
CLASS="COMMAND"
>COPY</TT
> SQLコマンドを発行します。
（コマンドでエラーが発生しなければ）この応答は、（指定したコピーの方向に応じて）<TT
CLASS="LITERAL"
>PGRES_COPY_OUT</TT
>もしくは<TT
CLASS="LITERAL"
>PGRES_COPY_IN</TT
>という状態コードを持った<TT
CLASS="STRUCTNAME"
>PGresult</TT
>になります。
その後、アプリケーションは本節の関数を使用して、行データを受信、もしくは、送信しなければなりません。
データの転送が完了した時、転送に成功したか失敗したかを示す別の<TT
CLASS="STRUCTNAME"
>PGresult</TT
>オブジェクトが返されます。
その状態は、成功時には<TT
CLASS="LITERAL"
>PGRES_COMMAND_OK</TT
>になり、何らかの問題が起きていた時には <TT
CLASS="LITERAL"
>PGRES_FATAL_ERROR</TT
>になります。
この時点で、別のSQLコマンドを<CODE
CLASS="FUNCTION"
>PQexec</CODE
>経由で発行することができます。
（<TT
CLASS="COMMAND"
>COPY</TT
>操作の実行中は、同じ接続を使用して他のSQLコマンドを実行することはできません。）
  </P
><P
><TT
CLASS="COMMAND"
>COPY</TT
>コマンドが、他にもコマンドを含んだ文字列として<CODE
CLASS="FUNCTION"
>PQexec</CODE
>経由で発行された場合、アプリケーションは<TT
CLASS="COMMAND"
>COPY</TT
>処理を終えた後に、<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>経由で結果の取り出しを続けなければなりません。
<CODE
CLASS="FUNCTION"
>PQexec</CODE
>コマンド文字列が完了し、その後のコマンドが安全に発行できることが確実になるのは、<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>が<TT
CLASS="SYMBOL"
>NULL</TT
>を返す時のみです。
  </P
><P
>本節の関数は、<CODE
CLASS="FUNCTION"
>PQexec</CODE
>もしくは<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>から<TT
CLASS="LITERAL"
>PGRES_COPY_OUT</TT
>もしくは<TT
CLASS="LITERAL"
>PGRES_COPY_IN</TT
>という結果状態を得た後のみに実行されなければなりません。
  </P
><P
>これらの状態値の一つを持つ<TT
CLASS="STRUCTNAME"
>PGresult</TT
>オブジェクトは、開始した<TT
CLASS="COMMAND"
>COPY</TT
>操作に関する追加データを持ちます。
この追加データは、以下の問い合わせ結果を持つ接続で使用される関数を使用して利用することができます。

   <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQNFIELDS-1"
></A
><CODE
CLASS="FUNCTION"
>PQnfields</CODE
>
      </DT
><DD
><P
>コピーされる列(フィールド)数を返します。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQBINARYTUPLES-1"
></A
><CODE
CLASS="FUNCTION"
>PQbinaryTuples</CODE
>
      </DT
><DD
><P
>0は、コピー全体の書式がテキスト(改行で区切られた行、区切り文字で区切られた列など)であることを示します。
1は、コピー全体の書式がバイナリであることを示します。
詳細は<A
HREF="sql-copy.html"
>COPY</A
>を参照してください。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQFFORMAT-1"
></A
><CODE
CLASS="FUNCTION"
>PQfformat</CODE
>
      </DT
><DD
><P
>コピー操作対象の列それぞれに関した書式コード(テキストでは0、バイナリでは1)を返します。
コピー全体の書式がテキストの場合は、列単位の書式コードは常にゼロです。
しかし、バイナリ書式はテキスト列もバイナリ列もサポートすることができます。
(しかし、現在の<TT
CLASS="COMMAND"
>COPY</TT
>実装では、バイナリコピーでのみバイナリ列が発生します。
そのため、今の所列単位の書式は常に全体の書式と一致します。)
      </P
></DD
></DL
></DIV
><P>
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>これらの追加データ値はプロトコル3.0を使用した場合にのみ利用可能です。
プロトコル2.0を使用する場合は、これらの関数はすべて0を返します。
   </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-COPY-SEND"
>32.9.1. <TT
CLASS="COMMAND"
>COPY</TT
>データ送信用関数</A
></H2
><P
>これらの関数は、<TT
CLASS="LITERAL"
>COPY FROM STDIN</TT
>期間にデータを送信するために使用されます。
接続が<TT
CLASS="LITERAL"
>COPY_IN</TT
>状態でない時に呼び出された場合、これらは失敗します。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQPUTCOPYDATA"
></A
><CODE
CLASS="FUNCTION"
>PQputCopyData</CODE
>
      </DT
><DD
><P
><TT
CLASS="LITERAL"
>COPY_IN</TT
>状態の間、サーバにデータを送信します。
</P><PRE
CLASS="SYNOPSIS"
>int PQputCopyData(PGconn *conn,
                  const char *buffer,
                  int nbytes);</PRE
><P>
      </P
><P
>指定した<TT
CLASS="PARAMETER"
>buffer</TT
>にある<TT
CLASS="COMMAND"
>COPY</TT
>データを<TT
CLASS="PARAMETER"
>nbytes</TT
>長分、サーバに送信します。
データがキューに入れられた場合、この結果は1になります。
バッファが一杯でキューに入らなかった場合はゼロになります。
（これは、接続が非ブロックモードの場合にのみ起こります。）
エラーが発生した場合は-1になります。
（戻り値が-1の場合、詳細を取り出すためには<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>を使用してください。
戻り値がゼロの場合は書き込み準備が整うまで待ち、再実行してください。）
      </P
><P
>アプリケーションは<TT
CLASS="COMMAND"
>COPY</TT
>データストリームを使いやすい大きさのバッファに分けて読み込むことができます。
送信時の読み込みバッファの境界には意味的な重要性はありません。
データストリームの内容は、<TT
CLASS="COMMAND"
>COPY</TT
>コマンドで想定しているデータ書式に一致している必要があります。
詳細は<A
HREF="sql-copy.html"
>COPY</A
>を参照してください。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQPUTCOPYEND"
></A
><CODE
CLASS="FUNCTION"
>PQputCopyEnd</CODE
>
      </DT
><DD
><P
><TT
CLASS="LITERAL"
>COPY_IN</TT
>状態の間に、サーバにデータ終了指示を送信します。
</P><PRE
CLASS="SYNOPSIS"
>int PQputCopyEnd(PGconn *conn,
                 const char *errormsg);</PRE
><P>
      </P
><P
><TT
CLASS="PARAMETER"
>errormsg</TT
>が<TT
CLASS="SYMBOL"
>NULL</TT
>の場合は、<TT
CLASS="LITERAL"
>COPY_IN</TT
>操作の終了に成功しました。
<TT
CLASS="PARAMETER"
>errormsg</TT
>が<TT
CLASS="SYMBOL"
>NULL</TT
>でない場合は、<TT
CLASS="COMMAND"
>COPY</TT
>は強制的に失敗させられました。
<TT
CLASS="PARAMETER"
>errormsg</TT
>が指し示す文字列はエラーメッセージとして使用されます。
（しかし、このエラーメッセージが正しくサーバから返ったものであるとは仮定すべきではありません。
サーバは既に別の原因で<TT
CLASS="COMMAND"
>COPY</TT
>に失敗していた可能性があります。
また、この強制的な失敗は3.0より前のプロトコルの接続を使用している場合は動作しません。）
      </P
><P
>終端メッセージが送信された場合は結果は1になります。
非ブロックモードでは、終端メッセージがキューに入れられたことしか意味しないかもしれません。
（非ブロックモードでデータが送信されたことを確認するには、次に書き込み準備ができるまで待ち、<CODE
CLASS="FUNCTION"
>PQflush</CODE
>を呼ぶことを、それが0を返すまでくり返します。）
バッファが一杯で終端メッセージがキューに入れられなかった場合はゼロになります。
これは、接続が非ブロックモードの場合にのみ起こります。
（この場合、書き込み準備ができるまで待ち、再度<CODE
CLASS="FUNCTION"
>PQputCopyEnd</CODE
>を呼び出してみてください。）
ハードエラーが発生した場合は-1になります。
このとき、詳細を取得するために<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>を使用できます。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQputCopyEnd</CODE
>の呼び出しに成功した後、<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>を呼び出して<TT
CLASS="COMMAND"
>COPY</TT
>コマンドの最終的な結果状態を取り出してください。
通常の方法でこの結果が使用できるようになるまで待機しても構いません。
そして、通常の操作に戻ってください。
      </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-COPY-RECEIVE"
>32.9.2. <TT
CLASS="COMMAND"
>COPY</TT
>データ受信用関数</A
></H2
><P
>これらの関数は<TT
CLASS="LITERAL"
>COPY TO STDOUT</TT
>時にデータを受信するために使用されます。
<TT
CLASS="LITERAL"
>COPY_OUT</TT
>状態以外の接続で呼び出すと、失敗します。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQGETCOPYDATA"
></A
><CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
>
      </DT
><DD
><P
><TT
CLASS="LITERAL"
>COPY_OUT</TT
>状態時にサーバからデータを受信します。

</P><PRE
CLASS="SYNOPSIS"
>int PQgetCopyData(PGconn *conn,
                  char **buffer,
                  int async);</PRE
><P>
      </P
><P
><TT
CLASS="COMMAND"
>COPY</TT
>期間中、サーバから別の行データの入手を試みます。
常に1度に1つの行データが返されます。
部分的な行のみが利用可能な場合は返されません。
行データの取得に成功することは、そのデータを保持するためのメモリチャンクの割り当てを意味します。
<TT
CLASS="PARAMETER"
>buffer</TT
>パラメータは非<TT
CLASS="SYMBOL"
>NULL</TT
>でなければなりません。
<TT
CLASS="PARAMETER"
>*buffer</TT
>は割り当てられたメモリへのポインタに、バッファが返されなかった場合は<TT
CLASS="SYMBOL"
>NULL</TT
>に設定されます。
非<TT
CLASS="SYMBOL"
>NULL</TT
>の結果バッファは、不要になったら<CODE
CLASS="FUNCTION"
>PQfreemem</CODE
>を使用して解放しなければなりません。
      </P
><P
>行の取り込みに成功した時、戻り値は行内のデータのバイト数になります。
(これは常に0より大きくなります。)
返された文字列は常にヌル終端ですが、おそらくテキスト<TT
CLASS="COMMAND"
>COPY</TT
>でのみ有用になるでしょう。
ゼロという結果は、<TT
CLASS="COMMAND"
>COPY</TT
>が進行中で、行がまだ利用できない状態であることを示します。
(<TT
CLASS="PARAMETER"
>async</TT
>が真の場合にのみ発生することがあります。)
-1という結果は、<TT
CLASS="COMMAND"
>COPY</TT
>が完了したことを示します。
-2という結果はエラーが発生したことを示します。
(その理由については<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>を参照してください。)
      </P
><P
><TT
CLASS="PARAMETER"
>async</TT
>が真(非0)の場合、<CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
>は入力待ちのためのブロックを行いません。
<TT
CLASS="COMMAND"
>COPY</TT
>実行中で完全な行を取り出せない場合<CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
>は0を返します。
(この場合、再試行の前に読み込み準備が整うまで待機してください。
<CODE
CLASS="FUNCTION"
>PQconsumeInput</CODE
>を呼び出したかどうかは関係ありません。)
<TT
CLASS="PARAMETER"
>async</TT
>が偽(0)の場合、<CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
>はデータが利用できるようになるまで、もしくは、操作が完了するまでブロックします。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQgetCopyData</CODE
>が-1を返した後、<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>を呼び出して、<TT
CLASS="COMMAND"
>COPY</TT
>コマンドの最終結果状態を取り出してください。
通常の方法で結果が利用できるようになるまで待機しても構いません。
そして、通常の操作に戻ってください。
      </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LIBPQ-COPY-DEPRECATED"
>32.9.3. 廃れた<TT
CLASS="COMMAND"
>COPY</TT
>用関数</A
></H2
><P
>以下の関数は<TT
CLASS="COMMAND"
>COPY</TT
>を取扱う、古めの手法を行います。
これらはまだ動作しますが、エラーの取扱いが貧弱であることやデータの終端を検知する方法が不便であることより使用を奨めません。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="LIBPQ-PQGETLINE"
></A
><CODE
CLASS="FUNCTION"
>PQgetline</CODE
>
      </DT
><DD
><P
>改行で終端する文字列（サーバから送信されたもの）を長さ<TT
CLASS="PARAMETER"
>length</TT
>のバッファ用文字列に読み込みます。
</P><PRE
CLASS="SYNOPSIS"
>int PQgetline(PGconn *conn,
              char *buffer,
              int length);</PRE
><P>
      </P
><P
>この関数はバッファに<TT
CLASS="PARAMETER"
>length</TT
>-1個までの文字をコピーし、終端の改行を1バイトのゼロに置き換えます。
<CODE
CLASS="FUNCTION"
>PQgetline</CODE
>は、入力の終端では<TT
CLASS="LITERAL"
>EOF</TT
>を、行全体が読み込まれれば0を返します。
そしてまだ終端の改行が読み込まれていないうちにバッファがいっぱいになってしまった場合は1を返します。
       </P
><P
>アプリケーションは新しく読み込んだ行が、<TT
CLASS="LITERAL"
>\.</TT
>という2文字であるかどうか確認しなければいけません。
この2文字は、<TT
CLASS="COMMAND"
>COPY</TT
>コマンドの結果をサーバが送信し終えたことを示すものです。
アプリケーションには、仮に<TT
CLASS="PARAMETER"
>length</TT
>-1文字より長い行を受け取るようなことがあっても、間違いなく<TT
CLASS="LITERAL"
>\.</TT
>行を認識するような配慮が必要です
（また例えば長いデータの行の終端を、最終行と取り違えないようにもしてください）。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQGETLINEASYNC"
></A
><CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
>
      </DT
><DD
><P
><TT
CLASS="COMMAND"
>COPY</TT
>データ行（サーバから送信されたもの）を、ブロッキングなしでバッファに読み込みます。
</P><PRE
CLASS="SYNOPSIS"
>int PQgetlineAsync(PGconn *conn,
                   char *buffer,
                   int bufsize);</PRE
><P>
      </P
><P
><CODE
CLASS="FUNCTION"
>PQgetline</CODE
>と似ていますが、<TT
CLASS="COMMAND"
>COPY</TT
>のデータを非同期的に、つまりブロッキングなしで読み出さなければならないアプリケーションで使用することができます。
<TT
CLASS="COMMAND"
>COPY</TT
>コマンドを発行し、そして<TT
CLASS="LITERAL"
>PGRES_COPY_OUT</TT
>応答を受け取ったら、アプリケーションはデータ終了の合図を受け取るまで<CODE
CLASS="FUNCTION"
>PQconsumeInput</CODE
>と<CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
>を呼び出します。
       </P
><P
><CODE
CLASS="FUNCTION"
>PQgetline</CODE
>と違い、この関数はデータ終了の検出に対して責任を持ちます。
      </P
><P
><CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
>の個々の呼び出しでは、<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>の入力バッファ内で完全な行データが利用できる場合にデータを返します。
さもなければ、行の残りが届くまでデータは返されません。
この関数は、コピーデータの終端を示す符号を認識すると-1を、また何もデータがなければ0を、そしてデータを返す場合はそのバイト数を正の値で返します。
もし-1が返されたら、呼び出し側は次に<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>を呼び出さなければいけません。
それから通常の処理に戻ります。
      </P
><P
>返されるデータは行データの境界を越えて拡張されることはありません。
可能であれば行全体を一度に返します。
しかし呼び出し側が準備したバッファが少なすぎ、サーバから送られてくる行を保持しておくことができない場合には、分割された行データを返します。
テキストデータでは、これは最後の1バイトが<TT
CLASS="LITERAL"
>\n</TT
>かどうかを確認すれば検出できます。
（バイナリ<TT
CLASS="COMMAND"
>COPY</TT
>の場合に同様の検出を行うためには、実際に<TT
CLASS="COMMAND"
>COPY</TT
>データの書式を解析しなければなりません。）
なお、返される文字列はヌル終端ではありません。
（ヌル終端を後から付け加えるのであれば、実際に確保するバッファサイズ-1を<TT
CLASS="PARAMETER"
>bufsize</TT
>として渡すようにしてください。）
      </P
></DD
><DT
><A
NAME="LIBPQ-PQPUTLINE"
></A
><CODE
CLASS="FUNCTION"
>PQputline</CODE
>
      </DT
><DD
><P
>サーバにヌル終端の文字列を送信します。
問題なければ0を返します。
文字列の送信ができなかった場合は<TT
CLASS="SYMBOL"
>EOF</TT
>を返します。
</P><PRE
CLASS="SYNOPSIS"
>int PQputline(PGconn *conn,
              const char *string);</PRE
><P>
      </P
><P
><CODE
CLASS="FUNCTION"
>PQputline</CODE
>の呼び出しによって送信される<TT
CLASS="COMMAND"
>COPY</TT
>データストリームは、<CODE
CLASS="FUNCTION"
>PQgetlineAsync</CODE
>で返される書式と同じ書式を持ちます。
ただし、アプリケーションは、<CODE
CLASS="FUNCTION"
>PQputline</CODE
>毎に正確に1つのデータ行を送信するように強制されていません。
呼び出し毎に行の一部や複数の行を送信しても問題ありません。
      </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>プロトコル3.0より前では、アプリケーションは、サーバに対して<TT
CLASS="COMMAND"
>COPY</TT
>データの送信を完了したことを通知するために、最終の行として<TT
CLASS="LITERAL"
>\.</TT
>という2文字を明示的に送信する必要がありました。
これはまだ動作します。
しかし、これは廃れたものとして、<TT
CLASS="LITERAL"
>\.</TT
>の特殊な意味は将来のリリースで無くなることが予想されます。
実際のデータの送信完了後に<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>を呼び出すことが重要です。
       </P
></BLOCKQUOTE
></DIV
></DD
><DT
><A
NAME="LIBPQ-PQPUTNBYTES"
></A
><CODE
CLASS="FUNCTION"
>PQputnbytes</CODE
>
      </DT
><DD
><P
>ヌル終端ではない文字列をサーバに送信します。
問題なければ0を返します。
文字列の送信ができなかった場合は<TT
CLASS="SYMBOL"
>EOF</TT
>を返します。
</P><PRE
CLASS="SYNOPSIS"
>int PQputnbytes(PGconn *conn,
                const char *buffer,
                int nbytes);</PRE
><P>
      </P
><P
>これはまさに<CODE
CLASS="FUNCTION"
>PQputline</CODE
>と同様です。
ただし、直接送信バイト数を指定するため、ヌル終端である必要がありません。
バイナリデータを送信する時はこのプロシージャを使用してください。
      </P
></DD
><DT
><A
NAME="LIBPQ-PQENDCOPY"
></A
><CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>
      </DT
><DD
><P
>サーバと同期します。
</P><PRE
CLASS="SYNOPSIS"
>int PQendcopy(PGconn *conn);</PRE
><P>
この関数はサーバがコピーを完了するのを待ちます。
この関数は、<CODE
CLASS="FUNCTION"
>PQputline</CODE
>を使ったサーバへの文字列送信が完了した時点、あるいは<CODE
CLASS="FUNCTION"
>PGgetline</CODE
>を使ったサーバからの文字列受信が完了した時点のいずれでも呼び出さなければなりません。
これを発行しないと、サーバはクライアントとの<SPAN
CLASS="QUOTE"
>"同期がずれた"</SPAN
>状態になってしまいます。
この関数から戻った時点で、サーバは次のSQLコマンドを受ける準備が整います。
正常に終了した場合、返り値は0です。 さもなくば、非ゼロです。
（戻り値が非ゼロの場合、<CODE
CLASS="FUNCTION"
>PQerrorMessage</CODE
>を使用して詳細を取り出してください。）
      </P
><P
><CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>を使う場合、アプリケーションは<CODE
CLASS="FUNCTION"
>PQgetline</CODE
>を繰り返し呼び出して<TT
CLASS="LITERAL"
>PGRES_COPY_OUT</TT
>に応答し、終端行を見つけたら続いて<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>を呼び出さなければなりません。
それから、<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>がヌルポインタを返すまで、<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>のループに戻らなければなりません。
同じように <TT
CLASS="LITERAL"
>PGRES_COPY_IN</TT
>は連続した<CODE
CLASS="FUNCTION"
>PQputline</CODE
>で処理し、それから<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>で締めくくった後に<CODE
CLASS="FUNCTION"
>PQgetResult</CODE
>のループに戻ります。
このようにすることで、一連の<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>コマンド群に含めた<TT
CLASS="COMMAND"
>COPY</TT
>コマンドを確実に、また正しく実行できるはずです。
      </P
><P
>比較的古いアプリケーションでは、<TT
CLASS="COMMAND"
>COPY</TT
>を<CODE
CLASS="FUNCTION"
>PQexec</CODE
>で実行し、<CODE
CLASS="FUNCTION"
>PQendcopy</CODE
>の実行でトランザクションは完了する、と想定していることがよくあります。
これはコマンド文字列中の<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>が<TT
CLASS="COMMAND"
>COPY</TT
>だけであった時にのみ正しく動作します。
      </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="libpq-notify.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="libpq-control.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>非同期通知</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="libpq.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>制御関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
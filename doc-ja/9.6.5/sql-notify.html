<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>NOTIFY</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="MOVE"
HREF="sql-move.html"><LINK
REL="NEXT"
TITLE="PREPARE"
HREF="sql-prepare.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="MOVE"
HREF="sql-move.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="PREPARE"
HREF="sql-prepare.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-NOTIFY"
></A
>NOTIFY</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN89083"
></A
><H2
>名前</H2
>NOTIFY&nbsp;--&nbsp;通知を生成する</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN89086"
></A
><H2
>概要</H2
><PRE
CLASS="SYNOPSIS"
>NOTIFY <TT
CLASS="REPLACEABLE"
><I
>channel</I
></TT
> [ , <TT
CLASS="REPLACEABLE"
><I
>payload</I
></TT
> ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89090"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>NOTIFY</TT
>コマンドは、現在のデータベース内で事前に指定チャネル名について<TT
CLASS="COMMAND"
>LISTEN <TT
CLASS="REPLACEABLE"
><I
>channel</I
></TT
></TT
>コマンドを実行したクライアントアプリケーションに<SPAN
CLASS="QUOTE"
>"ペイロード"</SPAN
>文字列(省略可能)を持つ通知イベントを送ります。
通知はすべてのユーザから可視です。
  </P
><P
><TT
CLASS="COMMAND"
>NOTIFY</TT
>は同一の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>データベースにアクセスするプロセスの集合に対する単純なプロセス間通信の仕組みを提供します。
通知の際にペイロード文字列を送信することができます。
また、データベース内のテーブルを使用して通知者から（1つまたは複数の）リスナに追加的なデータを渡すことにより、構造化されたデータを渡す高度な仕組みを構築することができます。
  </P
><P
>通知イベントとしてクライアントに渡される情報には、通知チャネル名と通知を行うセッションのサーバプロセスの<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>、ペイロード文字列(指定されていなければ空文字列)が含まれます。
  </P
><P
>各データベースにおいて使用される通知チャネル名とその意味についての定義は、データベース設計者に任されています。
通知チャネル名には、データベース内のテーブル名と同じものを使用するのが一般的です。
通知イベントは本質的に<SPAN
CLASS="QUOTE"
>"このテーブルを変更しました。変更された箇所を確認してください"</SPAN
>ということを意味するものです。
しかし、<TT
CLASS="COMMAND"
>NOTIFY</TT
>コマンドと<TT
CLASS="COMMAND"
>LISTEN</TT
>コマンドでは、そのような関連付けは強制されていません。
例えば、データベース設計者は、1つのテーブルに対する異なる種類の変更を通知するために、複数の異なる通知チャネル名を使用することができます。
他の方法としてペイロード文字列を使用して各種様々な状況に対応させることもできます。
  </P
><P
>特定のテーブルが変更されたことを通知するために<TT
CLASS="COMMAND"
>NOTIFY</TT
>を使用する場合、<TT
CLASS="COMMAND"
>NOTIFY</TT
>をテーブル更新時に発行される文トリガー内に配置すると便利です。
こうすると、通知はテーブルが変更された時に自動的に行われるので、アプリケーションプログラマが通知の実行を忘れるといった事故を防ぐことができます。
  </P
><P
><TT
CLASS="COMMAND"
>NOTIFY</TT
>とSQLトランザクションの間には、いくつかの重要な相互作用があります。
まず、<TT
CLASS="COMMAND"
>NOTIFY</TT
>がトランザクション内部で実行された場合、通知イベントはトランザクションがコミットされない限り配送されません。
トランザクションがアボートされた場合、<TT
CLASS="COMMAND"
>NOTIFY</TT
>だけでなく、そのトランザクション内で行われたコマンドが全て無効化されるので、これは妥当といえます。
しかし、通知イベントが即座に配送されることを期待していた場合、当惑するかもしれません。
次に、監視中のセッションがトランザクション処理中に通知シグナルを受け取った場合、そのトランザクションが（コミットもしくはアボートされて）完了するまで、通知イベントは接続しているクライアントに配送されません。
この理由も同じです。トランザクションに通知が配送された後にそのトランザクションがアボートされた場合、何とかして通知を取り消したくなりますが、サーバはいったんクライアントに送信した通知を<SPAN
CLASS="QUOTE"
>"取り戻す"</SPAN
>ことはできません。
したがって、通知イベントはトランザクションとトランザクションの合間にのみ配送されます。
結論として、<TT
CLASS="COMMAND"
>NOTIFY</TT
>を使用してシグナルの実時間処理をするアプリケーションではトランザクションを短くしておかなければなりません。
  </P
><P
>同じチャネル名が、同一トランザクションから同じペイロード文字列で複数回通知される場合、
データベースサーバは1つの通知のみを伝えるように決定することがあります。
一方、異なるペイロード文字列を持つ通知は常に別の通知として伝えられます。
同様に別のトランザクションからの通知が1つの通知にまとめられることは決してありません。
重複する通知インスタンスを後で削除する場合は例外ですが、<TT
CLASS="COMMAND"
>NOTIFY</TT
>は同一トランザクションからの通知は送信された順番に配送されることを保証します。
また異なるトランザクションからのメッセージがトランザクションのコミット順で配送されることも保証します。
  </P
><P
><TT
CLASS="COMMAND"
>NOTIFY</TT
>を実行するクライアント自身が、その通知の通知チャネルを監視していることはよくあります。
この場合、同じ通知名を監視する他のセッションに対するのと同じように通知イベントが戻ってきます。
アプリケーションのロジックにもよりますが、これは無駄な作業になることがあります。
例えば、そのセッションが書き出したばかりのデータベースに対する更新を調べるためにテーブルの再読み込みを行う場合などが考えられます。
通知元セッションのサーバプロセスの<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>(通知イベントメッセージ内にあります)と、自分自身の<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>(<SPAN
CLASS="APPLICATION"
>libpq</SPAN
>で得られます)が同じかどうか調べることで、こういった余計な作業を回避できます。
<ACRONYM
CLASS="ACRONYM"
>PID</ACRONYM
>が同じであれば、その通知イベントは自分自身から跳ね返ってきたものであり、無視することができます。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89123"
></A
><H2
>パラメータ</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>channel</I
></TT
></DT
><DD
><P
>シグナルとして送られる通知チャネル名です（任意の識別子）。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>payload</I
></TT
></DT
><DD
><P
>通知と一緒に通信される<SPAN
CLASS="QUOTE"
>"ペイロード"</SPAN
>文字列です。
これは単純な文字列リテラルとして指定されなければなりません。
デフォルトの設定では、8000バイト未満でなければなりません。
(バイナリデータまたは大規模な情報を渡さなければならないのであれば、データベーステーブル内に格納しレコードのキーを送信することが最善です。)
     </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89137"
></A
><H2
>注釈</H2
><P
>送信済みだがすべての監視セッションでは処理されていない通知を保持するためのキューが存在します。
このキューがいっぱいになると、<TT
CLASS="COMMAND"
>NOTIFY</TT
>を呼び出すトランザクションのコミットに失敗します。
キューはかなり大きなもの(標準のインストレーションで8ギガバイト)であり、ほとんどすべての環境で十分な大きさであるはずです。
しかしセッションが<TT
CLASS="COMMAND"
>NOTIFY</TT
>を実行した後に長期間のトランザクションに入った場合、キューからクリーンアップできなくなります。
キューの半分までたまると、ログファイル内にクリーンアップを妨げているセッションを指し示す警告が現れるようになります。
この場合、クリーンアップ処理が進むように、確実にそのセッションでその現在のトランザクションを完了させるようにしなければなりません
  </P
><P
>関数<CODE
CLASS="FUNCTION"
>pg_notification_queue_usage</CODE
>は現在、保留中の通知によって占められているキューの割合を返します。
詳細な情報については<A
HREF="functions-info.html"
>項9.25</A
>を参照してください。
  </P
><P
><TT
CLASS="COMMAND"
>NOTIFY</TT
>を実行したトランザクションでは二相コミットを準備することはできません。
  </P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN89147"
></A
><H3
>pg_notify</H3
><P
>通知を送信するために関数<TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_notify</CODE
>(<TT
CLASS="TYPE"
>text</TT
>,<TT
CLASS="TYPE"
>text</TT
>)</TT
>を使用することもできます。
この関数は第1引数としてチャネル名、第2引数としてペイロードを取ります。
不定のチャネル名、ペイロードで作業しなければならない場合は、<TT
CLASS="COMMAND"
>NOTIFY</TT
>コマンドよりこの関数を使用する方がかなり簡単です。
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89157"
></A
><H2
>例</H2
><P
><SPAN
CLASS="APPLICATION"
>psql</SPAN
>から監視/通知処理の設定と実行を行います。

</P><PRE
CLASS="PROGRAMLISTING"
>LISTEN virtual;
NOTIFY virtual;
Asynchronous notification "virtual" received from server process with PID 8448.
NOTIFY virtual, 'This is the payload';
Asynchronous notification "virtual" with payload "This is the payload" received from server process with PID 8448.

LISTEN foo;
SELECT pg_notify('fo' || 'o', 'pay' || 'load');
Asynchronous notification "foo" with payload "payload" received from server process with PID 14728.</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89162"
></A
><H2
>互換性</H2
><P
>標準SQLには<TT
CLASS="COMMAND"
>NOTIFY</TT
>はありません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN89166"
></A
><H2
>関連項目</H2
><A
HREF="sql-listen.html"
>LISTEN</A
>, <A
HREF="sql-unlisten.html"
>UNLISTEN</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-move.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-prepare.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>MOVE</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>PREPARE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
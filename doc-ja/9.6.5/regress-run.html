<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>テストの実行</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="リグレッションテスト"
HREF="regress.html"><LINK
REL="PREVIOUS"
TITLE="リグレッションテスト"
HREF="regress.html"><LINK
REL="NEXT"
TITLE="テストの評価"
HREF="regress-evaluation.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2017-10-17T11:51:21"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="リグレッションテスト"
HREF="regress.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="regress.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 31章リグレッションテスト</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="テストの評価"
HREF="regress-evaluation.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="REGRESS-RUN"
>31.1. テストの実行</A
></H1
><P
>リグレッションテストは既にインストールされ稼働中のサーバや、ビルドツリー内の一時的なインストレーションに対して実行することができます。
さらに、テストの実行には<SPAN
CLASS="QUOTE"
>"並行"</SPAN
>と<SPAN
CLASS="QUOTE"
>"連続"</SPAN
>モードがあります。
連続モードでは個々のテストスクリプトを単独で実行し、並行モードでは複数のサーバプロセスを実行し、テストをグループ化して並行的に実行します。
並行テストではプロセス間通信とロック機能が正常に作動しているかをテストします。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44847"
>31.1.1. 一時的なインストレーションに対するテストの実行</A
></H2
><P
>構築後、インストール前に並行リグレッションテストを行う場合には、最上位のディレクトリで以下のように入力してください。
</P><PRE
CLASS="SCREEN"
>make check</PRE
><P>
（または、<TT
CLASS="FILENAME"
>src/test/regress</TT
>ディレクトリに移動して、そこで実行してください。）
終了したら以下のような表示がされるはずです。
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="COMPUTEROUTPUT"
>=======================
 All 115 tests passed.
=======================</SAMP
></PRE
><P>
これが表示されなければ、テストは失敗したことになります。
<SPAN
CLASS="QUOTE"
>"失敗"</SPAN
>を深刻な問題であると推測する前に、以下の <A
HREF="regress-evaluation.html"
>項31.2</A
> を参照してください。
  </P
><P
>この試験方法では、一時的にサーバを起動するので、rootユーザとして構築を行なった場合には動作しません。
サーバがrootでは起動しないからです。
rootで構築をしないこと、もしくはインストール完了後に試験を実施することをお薦めします。
   </P
><P
>古い<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のインストレーションが既に存在している場所に<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>をインストールするように構築した場合、新しいバージョンをインストールする前に<TT
CLASS="LITERAL"
>make check</TT
>を行うと、新しいプログラムがインストール済みの共有ライブラリを使用しようとするために試験が失敗することになります。
（典型的な症状は、未定義シンボルに関するエラーメッセージです。）
古いインストレーションを上書きする前に試験を行いたいのであれば、<TT
CLASS="LITERAL"
>configure --disable-rpath</TT
>で構築する必要があります。
しかし、このオプションを最終的なインストレーションで使用することは推奨しません。
   </P
><P
>並行リグレッションテストは、実行したユーザのユーザIDを使用して相当数のプロセスを起動します。
現在、最大で20個の並行テストスクリプトが同時に実行されますが、これは合計40個のプロセスが実行されることを意味します。
各テストスクリプトに対して、1つのサーバプロセスと1つの<SPAN
CLASS="APPLICATION"
>psql</SPAN
>プロセスが存在するためです。
ですので、使用するシステムでユーザ当たりのプロセス数に制限を加えている場合は、その上限が少なくとも50程度であることを確認してください。
さもないと、並行テストにおいて、ランダムに発生しているように見える失敗が発生するかもしれません。
この上限を変更できない場合は、<TT
CLASS="LITERAL"
>MAX_CONNECTIONS</TT
>パラメータを編集して、並行度を減らすことができます。
例えば、以下は同時実行数を10以下で実行します。
</P><PRE
CLASS="SCREEN"
>make MAX_CONNECTIONS=10 check</PRE
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44866"
>31.1.2. 既存のインストレーションに対するテストの実行</A
></H2
><P
>インストール（<A
HREF="installation.html"
>第16章</A
>を参照）後にテストを実行するには、<A
HREF="runtime.html"
>第18章</A
>で説明したようにデータ領域を初期化し、サーバを起動し、そして以下を入力してください。
</P><PRE
CLASS="SCREEN"
>make installcheck</PRE
><P>
もしくは、並行テストの場合は以下を入力してください。
</P><PRE
CLASS="SCREEN"
>make installcheck-parallel</PRE
><P>
テストでは、<TT
CLASS="ENVAR"
>PGHOST</TT
>環境変数と<TT
CLASS="ENVAR"
>PGPORT</TT
>環境変数で指定がない限り、ローカルホストのサーバに接続し、デフォルトのポート番号を使用します。
テストは<TT
CLASS="LITERAL"
>regression</TT
>という名前のデータベースで行なわれます。
この名前の既存のデータベースはすべて削除されます。
  </P
><P
>テストは、ロールやテーブル空間のようなクラスタ全体にわたるオブジェクトも一時的に作成します。
このオブジェクトの名前は<TT
CLASS="LITERAL"
>regress_</TT
>で始まります。
実際のユーザーやテーブル空間がそのように名付けられたインストレーションで<TT
CLASS="LITERAL"
>installcheck</TT
>モードを使う場合には注意してください。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44879"
>31.1.3. 追加のテストスイート</A
></H2
><P
><TT
CLASS="LITERAL"
>make check</TT
>と<TT
CLASS="LITERAL"
>make installcheck</TT
>コマンドは<SPAN
CLASS="QUOTE"
>"コア"</SPAN
>リグレッションテストだけを実行します。
そのテストは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバに組み込まれている機能のみをテストします。
ソース配布には、オプションとなっている手続き言語のような追加機能とその多くが関係のある追加のテストスイートも含まれています。
  </P
><P
>コアテストを含む、構築するよう選択されたモジュールに適用できるテストスイートをすべて実行するにはビルドツリーの最上位で以下のコマンドの一つを入力して下さい。
</P><PRE
CLASS="SCREEN"
>make check-world
make installcheck-world</PRE
><P>
<TT
CLASS="LITERAL"
>make check</TT
>と<TT
CLASS="LITERAL"
>make installcheck</TT
>で以前述べたように、このコマンドは、それぞれ、一時的なサーバもしくは既にインストールされているサーバを使ってテストを行ないます。
それ以外に考慮すべきことはそれぞれのところで以前述べたことと同じです。
<TT
CLASS="LITERAL"
>make check-world</TT
>はテストするモジュール毎に別の一時的なインストールツリーを構築しますので、<TT
CLASS="LITERAL"
>make installcheck-world</TT
>よりもずっとより多くの時間とディスク容量が必要です。
  </P
><P
>代わりに、構築ツリーの適切なサブディレクトリで<TT
CLASS="LITERAL"
>make check</TT
>または<TT
CLASS="LITERAL"
>make installcheck</TT
>と入力することで個々のテストスイートを実行することもできます。
<TT
CLASS="LITERAL"
>make installcheck</TT
>はコアサーバだけでなく、関係のあるモジュールもインストール済みであると仮定することを覚えておいて下さい。
  </P
><P
>このように実行できる追加のテストには以下のものが含まれます。
  </P
><P
></P
><UL
><LI
><P
>オプションとなっている手続き言語のリグレッションテスト（<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>を除きます。そちらはコアテストでテストされます）。
これは<TT
CLASS="FILENAME"
>src/pl</TT
>にあります。
    </P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>contrib</TT
>の下にある<TT
CLASS="FILENAME"
>contrib</TT
>モジュールのリグレッションテスト。
すべての<TT
CLASS="FILENAME"
>contrib</TT
>モジュールにテストがあるわけではありません。
    </P
></LI
><LI
><P
>ECPGインタフェースライブラリのリグレッションテスト。
<TT
CLASS="FILENAME"
>src/interfaces/ecpg/test</TT
>にあります。
    </P
></LI
><LI
><P
>同時実行中のセッションの振舞いの負荷テスト。
<TT
CLASS="FILENAME"
>src/test/isolation</TT
>にあります。
    </P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>src/bin</TT
>以下のクライアントプログラムのテスト。
<A
HREF="regress-tap.html"
>項31.4</A
>も参照してください。
    </P
></LI
></UL
><P
><TT
CLASS="LITERAL"
>installcheck</TT
>モードを使う場合には、上記のテストは<TT
CLASS="LITERAL"
>regression</TT
>だけでなく<TT
CLASS="LITERAL"
>pl_regression</TT
>、<TT
CLASS="LITERAL"
>contrib_regression</TT
>、<TT
CLASS="LITERAL"
>isolation_regression</TT
>、<TT
CLASS="LITERAL"
>ecpg1_regression</TT
>、<TT
CLASS="LITERAL"
>ecpg2_regression</TT
>という名前の既存のデータベースも破壊します。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44925"
>31.1.4. ロケールと符号化方式</A
></H2
><P
>デフォルトでは、一時的なインストレーションを使うテストは、現在の環境で定義されたロケールと<TT
CLASS="COMMAND"
>initdb</TT
>で決定される対応するデータベース符号化方式を使用します。
異なるロケールを試験する際は、以下の例のように適切な環境変数を設定することが有用です。
</P><PRE
CLASS="SCREEN"
>make check LANG=C
make check LC_COLLATE=en_US.utf8 LC_CTYPE=fr_CA.utf8</PRE
><P>
実装上の理由のため、<TT
CLASS="ENVAR"
>LC_ALL</TT
>はこの目的には動作しません。
この他のロケール関連の環境変数は動作します。
   </P
><P
>既存のインストレーションに対するテストでは、ロケールは既存のデータベースクラスタによって決まり、テスト実行時に別の値に設定することができません。
   </P
><P
>また、以下の例のように<TT
CLASS="ENVAR"
>ENCODING</TT
>変数を設定することで明示的にデータベース符号化方式を選択することができます。
</P><PRE
CLASS="SCREEN"
>make check LANG=C ENCODING=EUC_JP</PRE
><P>
この方法でデータベース符号化方式を設定することは、通常ロケールがCだった場合にのみ意味があります。
この他の場合、ロケールから自動的に符号化方式が選択されます。
ロケールと一致しない符号化方式を指定してもエラーになるだけです。
   </P
><P
>データベース符号化方式は一時的なインストレーションに対するテストでも既存のインストレーションに対するテストでも設定することができます。
ただし、後者の場合にはインストレーションのロケールと互換性がなければなりません。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44936"
>31.1.5. 追加のテスト</A
></H2
><P
>プラットフォームに依存する、または非常に時間がかかる可能性があるという理由で、コアリグレッションテスト一式にはデフォルトでは動作しないテストがいくつか含まれています。
<TT
CLASS="ENVAR"
>EXTRA_TESTS</TT
>変数を設定することでこれらの追加テストやその他のテストを実行することができます。
例えば、<TT
CLASS="LITERAL"
>numeric_big</TT
>テストを以下のように実行します。
</P><PRE
CLASS="SCREEN"
>make check EXTRA_TESTS=numeric_big</PRE
><P>
以下のように照合順序テストを実行します。
</P><PRE
CLASS="SCREEN"
>make check EXTRA_TESTS=collate.linux.utf8 LANG=en_US.utf8</PRE
><P>
<TT
CLASS="LITERAL"
>collate.linux.utf8</TT
>テストは、Linux/glibcプラットフォームにおいてUTF-8符号化方式を使用するデータベースで実行した場合のみ動作します。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN44944"
>31.1.6. ホットスタンバイのテスト</A
></H2
><P
>ソース配布は、ホットスタンバイの静的な挙動に対するリグレッションテストも含んでいます。
これらのテストは、稼働しているプライマリサーバと、（ファイルベースのログ転送、またはストリーミングレプリケーションによって）プライマリからの新規のWALの変更を受け付けられる稼働中のスタンバイサーバを必要とします。
これらのサーバは、自動的に作成されませんし、ここにはレプリケーション設定ドキュメントもありません。
必要なコマンドや関連する問題について記述されている、ドキュメントのさまざまなセクションを参照してください。
  </P
><P
>ホットスタンバイテストを実行するには、最初に"regression"という名前のデータベースをプライマリに作成します。
</P><PRE
CLASS="SCREEN"
>psql -h primary -c "CREATE DATABASE regression"</PRE
><P>
次に、準備のためのスクリプト<TT
CLASS="FILENAME"
>src/test/regress/sql/hs_primary_setup.sql</TT
>をプライマリのregressionデータベース上で以下のように実行します。
</P><PRE
CLASS="SCREEN"
>psql -h primary -f src/test/regress/sql/hs_primary_setup.sql regression</PRE
><P>
この変更がスタンバイに伝搬するようにします。
  </P
><P
>ここで、デフォルトデータベース接続がスタンバイサーバの試験環境になるように（例えば、<TT
CLASS="ENVAR"
>PGHOST</TT
>と<TT
CLASS="ENVAR"
>PGPORT</TT
>環境変数を設定することで）手配してください。
最後に、リグレッションテスト用のディレクトリから<TT
CLASS="LITERAL"
>make standbycheck</TT
>を実行してください。
</P><PRE
CLASS="SCREEN"
>cd src/test/regress
make standbycheck</PRE
><P>
  </P
><P
>いくつかの極端な挙動を、スタンバイのテストのための挙動を実現するスクリプト<TT
CLASS="FILENAME"
>src/test/regress/sql/hs_primary_extremes.sql</TT
>を用いることでプライマリサーバ上で生成することができます。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="regress.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="regress-evaluation.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>リグレッションテスト</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="regress.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>テストの評価</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
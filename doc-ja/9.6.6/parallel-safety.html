<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>パラレル安全</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="パラレルクエリ"
HREF="parallel-query.html"><LINK
REL="PREVIOUS"
TITLE="パラレルプラン"
HREF="parallel-plans.html"><LINK
REL="NEXT"
TITLE="サーバの管理"
HREF="admin.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="パラレルプラン"
HREF="parallel-plans.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="parallel-query.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 15章パラレルクエリ</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="サーバの管理"
HREF="admin.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PARALLEL-SAFETY"
>15.4. パラレル安全</A
></H1
><P
>プランナは、クエリ中に実行される操作を<I
CLASS="FIRSTTERM"
>パラレル安全（parallel safe）</I
>、<I
CLASS="FIRSTTERM"
>パラレル制限（parallel restricted）</I
>、<I
CLASS="FIRSTTERM"
>パラレル非安全（parallel unsafe）</I
>に分類します。
パラレル安全操作は、パラレルクエリとコンフリクトしない操作です。
パラレル制限操作は、パラレルクエリを利用中に、パラレルワーカー中では実行できないが、リーダーによって実行できる操作です。
したがって、パラレル制限操作は、<TT
CLASS="LITERAL"
>Gather</TT
>ノードより下では決して実行されませんが、<TT
CLASS="LITERAL"
>Gather</TT
>ノードを含むプランの別の場所では実行されるかもしれません。
パラレル非安全操作は、パラレルクエリ利用中に、リーダも含めて実行できない操作です。
クエリがパラレル非安全なものを含む場合は、クエリ中でのパラレルクエリの利用は全くできなくなります。
  </P
><P
>次の操作は常にパラレル制限です。
  </P
><P
></P
><UL
><LI
><P
>共通テーブル式（CTE）のスキャン
      </P
></LI
><LI
><P
>一時テーブルのスキャン
      </P
></LI
><LI
><P
>外部テーブルのスキャン。
外部データラッパが<TT
CLASS="LITERAL"
>IsForeignScanParallelSafe</TT
>APIを持ち、パラレル安全を返す場合を除く。
      </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>InitPlan</TT
>あるいは<TT
CLASS="LITERAL"
>SubPlan</TT
>へのアクセス。
      </P
></LI
></UL
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PARALLEL-LABELING"
>15.4.1. 関数と集約のためのパラレルラベル付け</A
></H2
><P
>プランナは、自動的にはユーザ定義関数や集約がパラレル安全か、パラレル制限か、あるいはパラレル非安全かを決定することはできません。
この関数が潜在的に実行する可能性のあるすべての操作を予測することが、このために要求されるからです。
一般的には、これは停止性問題と同等で、それ故に不可能です。
思いつく限りにおいては、終了すると思われる単純な関数においてさえ、私達は予測をしようとは思いません。
なぜなら、そうした予測は高価でエラーを起こしやすいからです。
その代わりに、そうではないとマークされない限り、すべてのユーザ定義関数は、パラレル非安全と見なされます。
<A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>あるいは<A
HREF="sql-alterfunction.html"
>ALTER FUNCTION</A
>を使用するときは、
適当な<TT
CLASS="LITERAL"
>PARALLEL SAFE</TT
>、<TT
CLASS="LITERAL"
>PARALLEL RESTRICTED</TT
>、<TT
CLASS="LITERAL"
>PARALLEL UNSAFE</TT
>を指定することによってマーキングを行うことができます。
<A
HREF="sql-createaggregate.html"
>CREATE AGGREGATE</A
>を利用するときは、対応する値にしたがって、<TT
CLASS="LITERAL"
>SAFE</TT
>、<TT
CLASS="LITERAL"
>RESTRICTED</TT
>、<TT
CLASS="LITERAL"
>UNSAFE</TT
>のどれかを<TT
CLASS="LITERAL"
>PARALLEL</TT
>オプションに指定します。
  </P
><P
>データベースに書き込むか、シーケンスにアクセスするか、あるいはトランザクションの状態を一時的にであっても変更する（たとえばエラーを捕捉するために<TT
CLASS="LITERAL"
>EXCEPTION</TT
>ブロック確立するPL/pgsql関数）、恒久的な設定変更を行う関数あるいは集約は、<TT
CLASS="LITERAL"
>PARALLEL UNSAFE</TT
>とマークされなければなりません。
同様に、一時テーブル、クライアントの接続状態、カーソル、準備された文、システムがワーカーの間で同期できないその他のバックエンドローカルな状態にアクセスする関数あるいは集約は、<TT
CLASS="LITERAL"
>PARALLEL RESTRICTED</TT
>とマークされなければなりません。
たとえば、<TT
CLASS="LITERAL"
>setseed</TT
>と<TT
CLASS="LITERAL"
>random</TT
>は、最後の理由により、パラレル制限です。
  </P
><P
>一般的に制限あるいは非安全な関数が安全とラベル付されたり、実際には非安全なのに制限付きとラベル付されると、パラレルクエリの中で使用される際に、エラーを生じたり、間違った結果を生成するかもしれません。
誤ったラベル付をされると、C言語関数は理論的にはまったく未定義の振る舞いを示すことがあります。
システムは任意のCコードから身を守るすべがないからです。
しかしもっとも起こりえる可能性としては、他の関数のよりも悪いということはなさそうです。
もし自信がないなら、たぶんその関数を<TT
CLASS="LITERAL"
>UNSAFE</TT
>とラベル付するのが最善でしょう。
  </P
><P
>パラレルワーカーの中で実行される関数がリーダーが獲得していないロックを獲得する場合、たとえばクエリ中で参照されていないテーブルに対して問い合わせを実行する場合などは、これらのロックはトランザクションが終了した時点ではなく、ワーカーが終了する際に解放されます
もしあなたがこれを行う関数を作成し、こうした振る舞いの違いがあなたにとって重要ならば、関数がリーダーの中だけで実行されることを保証するために、関数を<TT
CLASS="LITERAL"
>PARALLEL RESTRICTED</TT
>とマーク付けしてください。
  </P
><P
>より良いプランを得るために、プランナがクエリの中で実行されるパラレル制限な関数や集約の評価の遅延を考慮することはないことに注意してください。
したがって、たとえばあるテーブルに適用される<TT
CLASS="LITERAL"
>WHERE</TT
>句がパラレル制限であるときに、クエリプランナは<TT
CLASS="LITERAL"
>Gather</TT
>ノードの下にそのテーブルのスキャンを配置することを考慮しません。
ある場合においては、クエリ中のパラレル部分におけるテーブルのスキャンを含むようにして、<TT
CLASS="LITERAL"
>WHERE</TT
>句の評価を遅らせ、<TT
CLASS="LITERAL"
>Gather</TT
>ノード上で実行されるようにすることも可能でしょう（そしてその方が効率が良いことさえあります）。
しかし、プランナはそうしたことは行いません。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="parallel-plans.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="admin.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>パラレルプラン</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="parallel-query.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>サーバの管理</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
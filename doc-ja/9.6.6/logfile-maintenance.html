<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>ログファイルの保守</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="定常的なデータベース保守作業"
HREF="maintenance.html"><LINK
REL="PREVIOUS"
TITLE="定常的なインデックスの再作成"
HREF="routine-reindex.html"><LINK
REL="NEXT"
TITLE="バックアップとリストア"
HREF="backup.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="定常的なインデックスの再作成"
HREF="routine-reindex.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="maintenance.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 24章定常的なデータベース保守作業</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="バックアップとリストア"
HREF="backup.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="LOGFILE-MAINTENANCE"
>24.3. ログファイルの保守</A
></H1
><P
>データベースサーバのログ出力を<TT
CLASS="FILENAME"
>/dev/null</TT
>に渡して単に破棄するのではなく、どこかに保存しておくことを推奨します。
問題の原因を究明する時にログ出力は貴重です。
しかし、ログ出力は（特により高いデバッグレベルの時に）巨大になりがちですので、際限なく保存したくはないでしょう。
新しいログファイルを開始させ、適切な期間を経過した古いログファイルを捨てるために、ログファイルを<SPAN
CLASS="QUOTE"
>"回転"</SPAN
>させる必要があります。
  </P
><P
>単に<TT
CLASS="COMMAND"
>postgres</TT
>の<SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>をファイルに渡している場合、ログ出力を保持できますが、そのログファイルを切り詰めるためにはサーバを停止させ、再度起動させるしか方法がありません。
開発環境で<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を使用しているのであればこれで構いませんが、実運用サーバでこの振舞いが適切となることはほぼありません。
  </P
><P
>サーバの<SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>を何らかのログ回転プログラムに送信する方が良いでしょう。
組み込みのログ回転機能があり、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>の<TT
CLASS="VARNAME"
>logging_collector</TT
>設定パラメータを<TT
CLASS="LITERAL"
>true</TT
>に設定することでこれを使用することができます。
このプログラムを制御するパラメータについては<A
HREF="runtime-config-logging.html#RUNTIME-CONFIG-LOGGING-WHERE"
>項19.8.1</A
>で説明します。
また、この方法を使用して、機械読み取りしやすい<ACRONYM
CLASS="ACRONYM"
>CSV</ACRONYM
>(カンマ区分値)書式でログデータを取り込むことができます。
  </P
><P
>また、既に他のサーバソフトウェアで使用している外部のログ回転プログラムがあるのであれば、それを使用したいと考えるでしょう。
例えば、<SPAN
CLASS="PRODUCTNAME"
>Apache</SPAN
>配布物に含まれる<SPAN
CLASS="APPLICATION"
>rotatelogs</SPAN
>を<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>で使用することができます。
これを行うには、単にサーバの<SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>を目的のプログラムにパイプで渡してください。
<TT
CLASS="COMMAND"
>pg_ctl</TT
>を使用してサーバを起動している場合は<SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>は既に<SPAN
CLASS="SYSTEMITEM"
>stdout</SPAN
>にリダイレクトされていますので、以下の例のようにコマンドをパイプする必要があるだけです。

</P><PRE
CLASS="PROGRAMLISTING"
>pg_ctl start | rotatelogs /var/log/pgsql_log 86400</PRE
><P>
  </P
><P
>この他の実運用レベルのログ出力の管理方法は、<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>に送信し、<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>にファイルの回転を行わせることです。
このためには、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>の<TT
CLASS="VARNAME"
>log_destination</TT
>設定パラメータを<TT
CLASS="LITERAL"
>syslog</TT
>（<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>のみにログを出力）に設定してください。
そして、新しいログファイルへの書き込みを始めたい時に、<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>デーモンに<TT
CLASS="LITERAL"
>SIGHUP</TT
>シグナルを送信してください。
ログ回転を自動化させたい場合は、<SPAN
CLASS="APPLICATION"
>logrotate</SPAN
>プログラムを設定することで、<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>からのログファイルを扱うことができます。
  </P
><P
>しかし、多くのシステムでは<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>は特に巨大なログメッセージに関してあまり信頼できません。
必要なメッセージを切り詰めてしまったり、破棄してしまったりする可能性があります。
また、<SPAN
CLASS="PRODUCTNAME"
>Linux</SPAN
>では、<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>はメッセージごとにディスクに書き出すため、性能が良くありません。
（同期化を無効にするため、<SPAN
CLASS="APPLICATION"
>syslog</SPAN
>設定ファイル内のファイル名の先頭に<TT
CLASS="LITERAL"
>-</TT
>を使うことができます。）
  </P
><P
>上述の手法は全て、新しいログファイルを開始する周期を設定することができますが、古い、既に役に立たなくなったログファイルの削除は扱わないことに注意してください。
おそらく定期的に古いログファイルを削除するバッチジョブを設定することになるでしょう。
他に、回転用プログラムを設定して古いログファイルを周期的に上書きさせるという方法もあります。
  </P
><P
><A
HREF="http://dalibo.github.io/pgbadger/"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>pgBadger</SPAN
></A
>という外部プロジェクトは洗練されたログファイルの解析を行います。
<A
HREF="http://bucardo.org/wiki/Check_postgres"
TARGET="_top"
><SPAN
CLASS="PRODUCTNAME"
>check_postgres</SPAN
></A
>は、通常ではない多くの状態の検出を行うのと同時にログファイルに重要なメッセージが現れた時にNagiosで警告する機構を提供します。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="routine-reindex.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>定常的なインデックスの再作成</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="maintenance.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>バックアップとリストア</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
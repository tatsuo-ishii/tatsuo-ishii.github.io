<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>インデックスオンリースキャン</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="インデックス"
HREF="indexes.html"><LINK
REL="PREVIOUS"
TITLE="インデックスと照合順序"
HREF="indexes-collations.html"><LINK
REL="NEXT"
TITLE="インデックス使用状況の検証"
HREF="indexes-examine.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="インデックスと照合順序"
HREF="indexes-collations.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexes.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 11章インデックス</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="インデックス使用状況の検証"
HREF="indexes-examine.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="INDEXES-INDEX-ONLY-SCANS"
>11.11. インデックスオンリースキャン</A
></H1
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>におけるすべてのインデックスは<I
CLASS="FIRSTTERM"
>二次的な</I
>インデックス、つまり各インデックスはテーブルの主要なデータ領域（<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の用語ではテーブルの<I
CLASS="FIRSTTERM"
>ヒープ</I
>と呼ばれます）とは別に格納されています。
このことは、通常のインデックススキャンにおいて、各行の検索にはインデックスとヒープの両方からデータを取得する必要があることを意味します。
さらに、指定のインデックス可能な<TT
CLASS="LITERAL"
>WHERE</TT
>条件に適合するインデックスのエントリは、通常、インデックス内の近い位置にあるのに対し、そこから参照されるテーブルの行はヒープ内のあらゆるところにあるかもしれません。
このため、インデックススキャンにおけるヒープアクセスの部分では、ヒープに対する多くのランダムアクセスがありますが、これは遅い可能性があり、特に伝統的な回転型メディアでは遅くなります。
（<A
HREF="indexes-bitmap-scans.html"
>項11.5</A
>で説明したように、ビットマップインデックスはヒープアクセスをソートした順で行うことでこのコストを緩和しようとするものですが、それはある程度までしかできません。）
  </P
><P
>このパフォーマンス問題を解決するため、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は<I
CLASS="FIRSTTERM"
>インデックスオンリースキャン</I
>をサポートします。
これは、問い合わせに対してヒープアクセスをせずにインデックスのみで回答できるものです。
基本的な考え方は、関連するヒープのエントリを参照せずに、各インデクスエントリから直接に値を返すというものです。
この方法が使用できるためには2つの基本的な制限があります。

   <P
></P
></P><OL
TYPE="1"
><LI
><P
>インデックスの種類がインデックスオンリースキャンをサポートする必要があります。
Bツリーインデックスはいつでもインデックスオンリースキャンをサポートします。
GiSTとSP-GiSTは一部の演算子クラスでインデックスオンリースキャンをサポートしますが、サポートしない演算子クラスもあります。
他のインデックスの種類はインデックスオンリースキャンをサポートしません。
根本的な必要条件は、インデックスが各インデックスのエントリに対応する元のデータ値を物理的に格納していなければならない、あるいはそれを再構築できる必要がある、ということです。
その反例として、GINインデックスでは、各インデックスエントリが通常は元のデータ値の一部しか保持していないため、インデックスオンリースキャンをサポートすることができません。
     </P
></LI
><LI
><P
>問い合わせはインデックスに格納されている列だけを参照しなければなりません。
例えばテーブルの列<TT
CLASS="LITERAL"
>x</TT
>と<TT
CLASS="LITERAL"
>y</TT
>にインデックスがあり、そのテーブルにはさらに列<TT
CLASS="LITERAL"
>z</TT
>がある場合、次の問い合わせはインデックスオンリースキャンを使用できます。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT x, y FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND y &lt; 42;</PRE
><P>
しかし、以下の問い合わせはインデックスオンリースキャンを使用できません。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT x, z FROM tab WHERE x = 'key';
SELECT x FROM tab WHERE x = 'key' AND z &lt; 42;</PRE
><P>
（以下で説明するように、式によるインデックスや部分インデックスは、この規則を複雑にします。）
     </P
></LI
></OL
><P>
  </P
><P
>この2つの基本的な要件が満たされるなら、問い合わせで要求されるすべてのデータ値はインデックスから利用できるので、インデックスオンリースキャンが物理的に可能になります。
しかし、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のすべてのテーブルスキャンにおいて、さらなる必要条件があります。
それは、<A
HREF="mvcc.html"
>第13章</A
>で説明するように、検索された各行が問い合わせのMVCCスナップショットに対して<SPAN
CLASS="QUOTE"
>"可視"</SPAN
>であることを確認しなければならない、ということです。
可視性の情報はインデックスのエントリには格納されず、ヒープのエントリにのみあります。
そのため、一見すると、すべての行検索はいずれにせよヒープアクセスが必要なように思われます。
そして、テーブルの行が最近に更新された場合は、まさにその通りなのです。
しかし、あまり更新されないデータについてはこの問題を回避する方法があります。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ではテーブルのヒープの各ページについて、そのページに格納されているすべての行が、十分に古く、すべての現在および将来のトランザクションに対して可視であるかどうかを追跡しています。
この情報はテーブルの<I
CLASS="FIRSTTERM"
>可視性マップ</I
>のビットに格納されます。
インデックスオンリースキャンでは、候補となるインデックスのエントリを見つけた後、対応するヒープページの可視性マップのビットを検査します。
それがセットされていれば、行が可視であることがわかるので、それ以上の作業をすることなく、データを返すことができます。
セットされていない場合は、それが可視かどうかを調べるためにヒープエントリにアクセスする必要があり、そのため標準的なインデックススキャンに対するパフォーマンス上の利点はありません。
うまくいく場合であっても、この方法はヒープアクセスと引き換えに可視性マップにアクセスします。
しかし、可視性マップはヒープに比べ、4桁の規模で小さいため、アクセスに必要な物理的I/Oははるかに少ないです。
ほとんどの状況では、可視性マップは常にメモリ内にキャッシュされて残っています。
  </P
><P
>要するに、2つの基本的条件が満たされていればインデックスオンリースキャンが可能ですが、テーブルのヒープページのかなりの部分に対し、その全可視のビットがセットされている場合にのみ、性能が向上します。
しかし大部分の行が変化しないテーブルは一般的であり、現実にはこの種のスキャンは非常に有効です。
  </P
><P
>インデックスオンリースキャンの機能を有効に利用するため、先頭の列のみが<TT
CLASS="LITERAL"
>WHERE</TT
>句に適合し、残りの列は問い合わせによって返される<SPAN
CLASS="QUOTE"
>"ペイロード"</SPAN
>データとなっているインデックスを作成することを選択するかもしれません。
例えば、次のような問い合わせをよく実行する場合を考えます。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT y FROM tab WHERE x = 'key';</PRE
><P>
このような問い合わせを高速化する伝統的な手法は、<TT
CLASS="LITERAL"
>x</TT
>のみにインデックスを作成することです。
しかし<TT
CLASS="LITERAL"
>(x, y)</TT
>にインデックスを作ることで、この問い合わせをインデックスオンリースキャンとして実現できる可能性が出てきます。
前に説明した通り、そのようなインデックスは大きくなり、<TT
CLASS="LITERAL"
>x</TT
>だけのインデックスよりも高価になるため、このテーブルがほぼ静的であることがわかっている場合にのみ魅力的です。
インデックスを<TT
CLASS="LITERAL"
>(y, x)</TT
>ではなく<TT
CLASS="LITERAL"
>(x, y)</TT
>と宣言するのが重要であることに注意してください。
ほとんどの種類のインデックス（特にBツリー）において、先頭のインデックスによる制約がない検索はあまり効率的ではないからです。
  </P
><P
>原則として、インデックスオンリースキャンは式によるインデックスでも使うことができます。
例えば、<TT
CLASS="LITERAL"
>x</TT
>がテーブルの列で、<TT
CLASS="LITERAL"
>f(x)</TT
>上にインデックスがある場合、次の問い合わせをインデックスオンリースキャンとして実行できるはずです。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT f(x) FROM tab WHERE f(x) &lt; 1;</PRE
><P>
そして、関数<TT
CLASS="LITERAL"
>f()</TT
>の計算が高価なら、この方法は非常に魅力的です。
しかし<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のプランナは現在のところ、このような場合についてあまり賢くありません。
プランナは、問い合わせで必要となるすべての<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>列</I
></SPAN
>がインデックスから利用可能な場合にのみ、その問い合わせが潜在的にインデックスオンリースキャンで実行可能と考えます。
この例では、<TT
CLASS="LITERAL"
>f(x)</TT
>という文脈でしか<TT
CLASS="LITERAL"
>x</TT
>は必要になりませんが、プランナはそのことに気付かないため、インデックスオンリースキャンは不可能であると結論します。
インデックスオンリースキャンは十分に価値があると思われるなら、これはインデックスを<TT
CLASS="LITERAL"
>(f(x), x)</TT
>上に宣言することで回避できます。
ここで2番目の列は現実には使用されないでしょうが、プランナにインデックスオンリースキャンが可能であると確信させるためだけに存在しています。
目的が<TT
CLASS="LITERAL"
>f(x)</TT
>の再計算を避けることの場合、さらなる注意として、プランナはインデックス可能な<TT
CLASS="LITERAL"
>WHERE</TT
>句にない<TT
CLASS="LITERAL"
>f(x)</TT
>の使用を必ずしもインデックス列とマッチしないという事があります。
上記のような単純な問い合わせの場合は通常は正しく処理できるでしょうが、結合を含む問い合わせでは駄目でしょう。
これらの欠点は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の将来のバージョンで解決されるかもしれません。
  </P
><P
>部分インデックスもインデックスオンリースキャンとの間に興味深い関係があります。
<A
HREF="indexes-partial.html#INDEXES-PARTIAL-EX3"
>例11-3</A
>に示す部分インデックスを考えます。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX tests_success_constraint ON tests (subject, target)
    WHERE success;</PRE
><P>
原則として、次のような問い合わせに対して、このインデックスを使ったインデックスオンリースキャンが可能です。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT target FROM tests WHERE subject = 'some-subject' AND success;</PRE
><P>
しかし、<TT
CLASS="LITERAL"
>WHERE</TT
>句で参照される<TT
CLASS="LITERAL"
>success</TT
>がインデックスの結果列として利用できないという問題があります。
それにも関わらず、インデックスオンリースキャンが可能です。
なぜなら、このプランでは<TT
CLASS="LITERAL"
>WHERE</TT
>句のその部分を実行時に再検査する必要がない、つまりインデックス内にあるすべてのエントリは必ず<TT
CLASS="LITERAL"
>success = true</TT
>なので、プラン内でこれを明示的に検査する必要がないからです。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のバージョン9.6およびそれ以降ではこのような場合を認識し、インデックスオンリースキャンを生成可能ですが、それより古いバージョンではできません。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="indexes-collations.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="indexes-examine.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>インデックスと照合順序</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="indexes.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>インデックス使用状況の検証</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
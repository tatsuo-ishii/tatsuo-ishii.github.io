<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>サンプリングメソッドサポート関数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="テーブルサンプリングメソッドの書き方"
HREF="tablesample-method.html"><LINK
REL="PREVIOUS"
TITLE="テーブルサンプリングメソッドの書き方"
HREF="tablesample-method.html"><LINK
REL="NEXT"
TITLE="カスタムスキャンプロバイダの作成"
HREF="custom-scan.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="テーブルサンプリングメソッドの書き方"
HREF="tablesample-method.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="tablesample-method.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 56章テーブルサンプリングメソッドの書き方</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="カスタムスキャンプロバイダの作成"
HREF="custom-scan.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="TABLESAMPLE-SUPPORT-FUNCTIONS"
>56.1. サンプリングメソッドサポート関数</A
></H1
><P
>TSMハンドラ関数は、以下に示すサポート関数へのポインタを含むpallocされた<TT
CLASS="TYPE"
>TsmRoutine</TT
>構造体を返します。
大半の関数は必須ですが、いくつかオプションのものがあり、そうした関数へのポインタはNULLにできます。
  </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
SampleScanGetSampleSize (PlannerInfo *root,
                         RelOptInfo *baserel,
                         List *paramexprs,
                         BlockNumber *pages,
                         double *tuples);</PRE
><P>

この関数はプランニングの際に呼び出されます。
サンプルスキャン中に読み出すリレーションのページ数と、スキャン中に選択されるタプル行数の見積もりを行わなければなりません。
(たとえば、サンプル比率を推定し、それに<TT
CLASS="LITERAL"
>baserel-&gt;pages</TT
>と<TT
CLASS="LITERAL"
>baserel-&gt;tuples</TT
>を掛け、整数値になるように丸めることで見積もりが可能となるでしょう。)
<TT
CLASS="LITERAL"
>paramexprs</TT
>リストは、<TT
CLASS="LITERAL"
>TABLESAMPLE</TT
>句への引数となる式を格納します。
見積のためにその推測値が必要なら、<CODE
CLASS="FUNCTION"
>estimate_expression_value()</CODE
>を使ってこれらの式を定数に簡約化してみることをおすすめします。
ただし、関数は簡約化ができない場合でもサイズに関する見積は提供しなければなりませんし、値が正しくない場合でも関数がエラーになってはいけません(推測値は、実行時には値がそうなるであろうということに過ぎないことを思い出してください)。
<TT
CLASS="LITERAL"
>pages</TT
>と<TT
CLASS="LITERAL"
>tuples</TT
>パラメータは出力です。
  </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
InitSampleScan (SampleScanState *node,
                int eflags);</PRE
><P>

SampleScan計画ノードを実行するための初期化を行います。
この関数はエグゼキュータの起動時に呼び出されます。
処理を開始する前に必要な初期化をすべて行う必要があります。
<TT
CLASS="STRUCTNAME"
>SampleScanState</TT
>ノードは作成済みですが、<TT
CLASS="STRUCTFIELD"
>tsm_state</TT
>フィールドはNULLです。
<CODE
CLASS="FUNCTION"
>InitSampleScan</CODE
>関数はサンプリングメソッドが必要とする内部データをすべてpallocし、<TT
CLASS="LITERAL"
>node-&gt;tsm_state</TT
>に格納します。
スキャン対象のテーブルに関する情報は<TT
CLASS="STRUCTNAME"
>SampleScanState</TT
>ノードの他のフィールドを通じてアクセスできます
(ただし、<TT
CLASS="LITERAL"
>node-&gt;ss.ss_currentScanDesc</TT
>スキャンディスクリプタはまだ設定されていません)。
<TT
CLASS="LITERAL"
>eflags</TT
>には、この計画ノードにおけるエグゼキュータの動作モードを記述するフラグビットが含まれます。
  </P
><P
><TT
CLASS="LITERAL"
>(eflags &amp; EXEC_FLAG_EXPLAIN_ONLY)</TT
>が真ならば、スキャンは実際には行われず、この関数は<TT
CLASS="COMMAND"
>EXPLAIN</TT
>と<CODE
CLASS="FUNCTION"
>EndSampleScan</CODE
>にとってノードの状態が意味のあるように最低限必要な処理を行うことになります。
  </P
><P
>この関数は(ポインタをNULLにすることにより)省略できますが、この場合、<CODE
CLASS="FUNCTION"
>BeginSampleScan</CODE
>がサンプリングメソッドに必要なすべての初期化を行なわなければなりません。
  </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
BeginSampleScan (SampleScanState *node,
                 Datum *params,
                 int nparams,
                 uint32 seed);</PRE
><P>

サンプルスキャンの実行を開始します。
これははじめてタプルを取得する直前に呼び出されます。
また、再スキャンを行う必要が出た場合にも呼び出されます。
スキャン対象のテーブルに関する情報は<TT
CLASS="STRUCTNAME"
>SampleScanState</TT
>ノードのフィールドを通じてアクセスできます
(ただし、<TT
CLASS="LITERAL"
>node-&gt;ss.ss_currentScanDesc</TT
>スキャンディスクリプタはまだ設定されていません)。
<TT
CLASS="LITERAL"
>nparams</TT
>の長さを持つ<TT
CLASS="LITERAL"
>params</TT
>配列は、<TT
CLASS="LITERAL"
>TABLESAMPLE</TT
>句で指定された引数の値を保持ししています。
これらは、サンプリングメソッドの<TT
CLASS="LITERAL"
>parameterTypes</TT
>リストで指定された数と型を持ち、NULLでないことがチェック済みです。
<TT
CLASS="LITERAL"
>seed</TT
>には、サンプリングメソッド内で使われる乱数のために使われるシードが格納されます。
これは、<TT
CLASS="LITERAL"
>REPEATABLE</TT
>の値が指定されている場合はそこから派生したハッシュか、でなければ<TT
CLASS="LITERAL"
>random()</TT
>の結果です。
  </P
><P
>この関数は<TT
CLASS="LITERAL"
>node-&gt;use_bulkread</TT
>と<TT
CLASS="LITERAL"
>node-&gt;use_pagemode</TT
>フィールドによって動作を変更します
<TT
CLASS="LITERAL"
>node-&gt;use_bulkread</TT
>が<TT
CLASS="LITERAL"
>true</TT
>なら(これはデフォルトです)、スキャンは使用後のバッファの再利用を推奨するバッファアクセス戦略を使います。
テーブルのわずかな部分だけをスキャンがアクセスするようなら、<TT
CLASS="LITERAL"
>false</TT
>にするのが妥当かもしれません。
<TT
CLASS="LITERAL"
>node-&gt;use_pagemode</TT
>が<TT
CLASS="LITERAL"
>true</TT
>なら(これはデフォルトです)、スキャンはアクセスするページ上のすべてのタプルに対して一括で可視性チェックを行います。
スキャンがアクセスするページ上のわずかな部分のタプルだけを選択するのであれば、<TT
CLASS="LITERAL"
>false</TT
> にするのが妥当かもしれません。
これにより、より少ないタプルに対して可視性チェックが行われます。
ただし、個々の操作はより高くつきます。
というのも、より多くのロックが必要になるからです。
  </P
><P
>サンプリングメソッドに<TT
CLASS="LITERAL"
>repeatable_across_scans</TT
>という印があれば、最初にスキャンした時と同じタプルの集合を、再スキャンでも選択できることになります。
つまり、新しい<CODE
CLASS="FUNCTION"
>BeginSampleScan</CODE
>が、前回と同じタプルを選択することになるわけです。
(もし<TT
CLASS="LITERAL"
>TABLESAMPLE</TT
>の引数とシードが変わらなければ、の話ですが)
  </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>BlockNumber
NextSampleBlock (SampleScanState *node);</PRE
><P>

次にスキャンするページのブロック番号を返します。
もはやスキャンするページがない場合には<TT
CLASS="LITERAL"
>InvalidBlockNumber</TT
>を返します。
  </P
><P
>この関数は(ポインタをNULLにすることにより)省略できます。
この場合コアのコードはリレーション全体を順スキャンします。
そのようなスキャンは同期スキャンを行う可能性があるので、毎回のスキャンで同じ順番でリレーションのページをアクセスするとは、サンプリングメソッドは仮定できません。
  </P
><P
></P><PRE
CLASS="PROGRAMLISTING"
>OffsetNumber
NextSampleTuple (SampleScanState *node,
                 BlockNumber blockno,
                 OffsetNumber maxoffset);</PRE
><P>

サンプル対象の指定ページ内の次のタプルのオフセットを返します。
サンプル対象のタプルが残っていない場合は、<TT
CLASS="LITERAL"
>InvalidOffsetNumber</TT
>を返します。
<TT
CLASS="LITERAL"
>maxoffset</TT
>は、使用中のページ中の最大オフセットです。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><CODE
CLASS="FUNCTION"
>NextSampleTuple</CODE
>は、範囲<TT
CLASS="LITERAL"
>1 .. maxoffset</TT
>の中のどのオフセット番号が有効なタプルにあたるのかは明示的には教えてもらえません。
通常コアのコードは、存在しない、あるいは不可視のタプルは無視するため、通常はこれは問題になりません。
サンプルの偏りも起きません。
それでも必要ならば、関数は<TT
CLASS="LITERAL"
>node-&gt;ss.ss_currentScanDesc-&gt;rs_vistuples[]</TT
>を調べ、どのタプルが有効で可視なのかを調べることもできます(このためには<TT
CLASS="LITERAL"
>node-&gt;use_pagemode</TT
>が<TT
CLASS="LITERAL"
>true</TT
>である必要があります)。

   </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><CODE
CLASS="FUNCTION"
>NextSampleTuple</CODE
>は、直近の<CODE
CLASS="FUNCTION"
>NextSampleBlock</CODE
>の呼び出しが返したページ番号と<TT
CLASS="LITERAL"
>blockno</TT
>が同じであると見なすべきでは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ありません</I
></SPAN
>。
ページ番号は、以前の<CODE
CLASS="FUNCTION"
>NextSampleBlock</CODE
>の呼び出しが返したものではありますが、コアのコードは、先読みのために実際のスキャンに先立って<CODE
CLASS="FUNCTION"
>NextSampleBlock</CODE
>を呼び出すことが認められています。
一旦あるページのサンプリングが開始すれば、<TT
CLASS="LITERAL"
>InvalidOffsetNumber</TT
>が返るまでは、続く<CODE
CLASS="FUNCTION"
>NextSampleTuple</CODE
>に呼び出しがすべて同じページを参照すると見なすことは問題ありません。
   </P
></BLOCKQUOTE
></DIV
><P
></P><PRE
CLASS="PROGRAMLISTING"
>void
EndSampleScan (SampleScanState *node);</PRE
><P>

スキャンを終了し、リソースを解放します。
通常pallocされたメモリを解放するのは重要なことではありませんが、外部から見えるリソースはすべて解放しなければなりません。
そのようなリソースが存在しない場合は、この関数は(ポインタをNULLにすることにより)省略できます。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="tablesample-method.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="custom-scan.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>テーブルサンプリングメソッドの書き方</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="tablesample-method.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>カスタムスキャンプロバイダの作成</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
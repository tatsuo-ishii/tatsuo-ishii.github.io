<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>ログ先行書き込み（WAL）</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="サーバの設定"
HREF="runtime-config.html"><LINK
REL="PREVIOUS"
TITLE="資源の消費"
HREF="runtime-config-resource.html"><LINK
REL="NEXT"
TITLE="レプリケーション"
HREF="runtime-config-replication.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="資源の消費"
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 19章サーバの設定</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="レプリケーション"
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="RUNTIME-CONFIG-WAL"
>19.5. ログ先行書き込み（WAL）</A
></H1
><P
>   
    これらの設定をチューニングする追加情報は<A
HREF="wal-configuration.html"
>項30.4</A
>を参照してください。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-SETTINGS"
>19.5.1. 諸設定</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-WAL-LEVEL"
></A
><TT
CLASS="VARNAME"
>wal_level</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)
      </DT
><DD
><P
>       
<TT
CLASS="VARNAME"
>wal_level</TT
>はどれだけの情報がWALに書かれるかを決定します。
デフォルト値は<TT
CLASS="LITERAL"
>minimal</TT
>で、クラッシュまたは即時停止から回復するのに必要な情報のみ書き出します。
<TT
CLASS="LITERAL"
>replica</TT
>はWALアーカイビングに必要なログ出力、およびスタンバイサーバ上で読み取り専用問い合わせを実行するために必要な情報を追加します。
最後に、<TT
CLASS="LITERAL"
>logical</TT
>は、更にロジカルデコーディングをサポートするのに必要な情報を追加します。
それぞれのレベルは、下位のレベルのログ出力を含んでいます。
このパラメータはサーバ起動時のみ設定可能です。
       </P
><P
>       
<TT
CLASS="LITERAL"
>minimal</TT
>レベルでは、一部の巨大な操作でのWAL出力は安全に省略でき、そうすることで、それらの操作が大幅に高速になります（<A
HREF="populate.html#POPULATE-PITR"
>項14.4.7</A
>を参照してください）。
この最適化が適用される操作には以下のものがあげられます。
        <P
></P
><TABLE
BORDER="0"
><TBODY
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE TABLE AS</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CREATE INDEX</TT
></TD
></TR
><TR
><TD
><TT
CLASS="COMMAND"
>CLUSTER</TT
></TD
></TR
><TR
><TD
>同一トランザクション内で作成されたか、もしくは切り詰められたテーブルに対する<TT
CLASS="COMMAND"
>COPY</TT
></TD
></TR
></TBODY
></TABLE
><P
></P
>
しかしminimal WALはベースバックアップとWALログからデータを再構築するための充分な情報を持ち合わせていません。
したがって、WALアーカイビング（<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE"
>archive_mode</A
>）とストリーミングレプリケーションを有効にするには、<TT
CLASS="LITERAL"
>replica</TT
>以上を使用しなければなりません。
       </P
><P
><TT
CLASS="LITERAL"
>logical</TT
>レベルでは、<TT
CLASS="LITERAL"
>replica</TT
>と同じ情報がログされるのに加え、ロジカルチェンジセットをWALから取り出すのに必要な情報が追加されます。
<TT
CLASS="LITERAL"
>logical</TT
>を使うとWALの量が増えます。
とりわけ、多数のテーブルが<TT
CLASS="LITERAL"
>REPLICA IDENTITY FULL</TT
>と設定されていて(訳注: ALTER TABLE参照)、多くの<TT
CLASS="COMMAND"
>UPDATE</TT
>と<TT
CLASS="COMMAND"
>DELETE</TT
>文が実行される場合はこのことが言えます。
       </P
><P
>9.6よりも前のリリースでは、このパラメータは<TT
CLASS="LITERAL"
>archive</TT
>と<TT
CLASS="LITERAL"
>hot_standby</TT
>という設定値も可能でした。
引き続きこれらも受け付けられますが、<TT
CLASS="LITERAL"
>replica</TT
>へとマップされます。
       </P
></DD
><DT
><A
NAME="GUC-FSYNC"
></A
><TT
CLASS="VARNAME"
>fsync</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
      </DT
><DD
><P
>このパラメータがオンの場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバは<CODE
CLASS="FUNCTION"
>fsync()</CODE
>システムコールを発行するか、もしくはこれに相当する方法（<A
HREF="runtime-config-wal.html#GUC-WAL-SYNC-METHOD"
>wal_sync_method</A
>を参照）で、更新が物理的にディスクに確実に書き込まれるように試みます。
これは、オペレーティングシステムもしくはハードウェアがクラッシュした後、データベースクラスタを一貫した状態に復旧させることを確実にします。
       </P
><P
>       
<TT
CLASS="VARNAME"
>fsync</TT
>を停止することはしばしば性能上の利益になるとは言っても、停電やクラッシュの際に回復不可能なデータ破壊になることがあります。
従って外部データから全てのデータベースを簡単に再構築できる場合のみ<TT
CLASS="VARNAME"
>fsync</TT
>を停止してください。
       </P
><P
>       
<TT
CLASS="VARNAME"
>fsync</TT
>を停止しても安全な状況の例としては、以下があげられます。
バックアップファイルから新しいデータベースクラスタにデータの初期読み込みを行う場合、バッチデータの処理のためにデータベースクラスタを使用し、その後データベースを削除して再構築する場合、読み込み専用のデータベースのクローンを頻繁に再作成するが、それをフェイルオーバーに使用しない場合、などです。
高性能なハードウェアであるからと言って、<TT
CLASS="VARNAME"
>fsync</TT
>を停止することは正当性を主張する十分な理由とはなりません。
       </P
><P
>       
<TT
CLASS="VARNAME"
>fsync</TT
>を無効(off)から有効(on）に変更したときの信頼できるリカバリのためには、カーネル内の全ての変更されたバッファを恒久的ストレージに強制的に吐き出させることが必要です。
これは、クラスタがシャットダウンしている間、またはfsyncが有効のときに、<TT
CLASS="COMMAND"
>initdb --sync-only</TT
>を実行する、<TT
CLASS="COMMAND"
>sync</TT
>を実行する、ファイルシステムをアンマウントする、またはサーバを再起動することによって可能となります。
       </P
><P
>       
多くの場合、重要でないトランザクションに対して<A
HREF="runtime-config-wal.html#GUC-SYNCHRONOUS-COMMIT"
>synchronous_commit</A
>を無効にすることにより、データ破壊という付随的危険性を伴うことなく、<TT
CLASS="VARNAME"
>fsync</TT
>を無効にすることで得られるであろう性能上のメリットの多くを得ることができます。
       </P
><P
>       
<TT
CLASS="VARNAME"
>fsync</TT
> は<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
このパラメータを無効にする場合、<A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>も同時に無効にすることを検討してください。
       </P
></DD
><DT
><A
NAME="GUC-SYNCHRONOUS-COMMIT"
></A
><TT
CLASS="VARNAME"
>synchronous_commit</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)
      </DT
><DD
><P
>       
トランザクションのコミットがクライアントに<SPAN
CLASS="QUOTE"
>"成功"</SPAN
>の報告を返す前に、WALレコードがディスク上に書き込まれるまで待つかどうかの指定をします。
有効な値は<TT
CLASS="LITERAL"
>on</TT
>、<TT
CLASS="LITERAL"
>remote_apply</TT
>、<TT
CLASS="LITERAL"
>remote_write</TT
>、<TT
CLASS="LITERAL"
>local</TT
>、および<TT
CLASS="LITERAL"
>off</TT
>です。
デフォルトかつ安全な設定は<TT
CLASS="LITERAL"
>on</TT
>です。
<TT
CLASS="LITERAL"
>off</TT
>の場合、クライアントに成功を報告する時点とトランザクションが本当にサーバクラッシュに対して安全になるまでの間に遅延が発生する場合があります。
（遅延は最大で、<A
HREF="runtime-config-wal.html#GUC-WAL-WRITER-DELAY"
>wal_writer_delay</A
>の3倍です。）
<A
HREF="runtime-config-wal.html#GUC-FSYNC"
>fsync</A
>と異なり、このパラメータを<TT
CLASS="LITERAL"
>off</TT
>に設定することによって、データベースの一貫性が損なわれる可能性はありません。
オペレーティングシステムやデータベースのクラッシュにより最近コミットされたということになっているトランザクションの一部が失われる可能性がありますが、これらのトランザクションが正常にアボートされた時とデータベースの状態は変わりません。
ですので、<TT
CLASS="VARNAME"
>synchronous_commit</TT
>を無効にすることは、トランザクションの信頼性が確実であることよりも性能が重要である場合に有効な方法です。
詳細は<A
HREF="wal-async-commit.html"
>項30.3</A
>を参照してください。
       </P
><P
><A
HREF="runtime-config-replication.html#GUC-SYNCHRONOUS-STANDBY-NAMES"
>synchronous_standby_names</A
>が空文字でない場合は、このパラメータは、WALレコードが、スタンバイサーバに複製されるまでトランザクションコミットを待機するか否かも制御します。
<TT
CLASS="LITERAL"
>on</TT
>に設定すると、現在の同期スタンバイがトランザクションのコミットレコードを受け取り、記憶装置に吐き出したことを報告するまでコミットは待機します。
このモードでは、プライマリおよびすべての同期スタンバイがデータベース記憶装置の故障を被った場合を除いて、トランザクションが失われないことが保証されます。
<TT
CLASS="LITERAL"
>remote_apply</TT
>に設定すると、現在の同期スタンバイがトランザクションのコミットレコードを受け取って適用し、スタンバイ上で発行されたクエリから見えるようになったことを報告するまでコミットは待機します。
<TT
CLASS="LITERAL"
>remote_write</TT
>に設定すると、現在の同期スタンバイがトランザクションのコミットレコードを受け取り、スタンバイのオペレーティングシステムに書き出したことを報告するまでコミットは待機します。
この設定は仮に<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のスタンバイインスタンスがクラッシュしたとしても、データ保護を保証するのに充分です。
しかし、スタンバイがオペレーティングシステムのレベルでクラッシュした場合はこの限りではありません。
データが必ずしもスタンバイの永続的な記憶装置に到達したとは言えないからです。
最後に、<TT
CLASS="LITERAL"
>local</TT
>設定は、コミットがローカルにディスクに吐出されるまで待機しますが、レプリケーションされるまでは待機しません。
これは通常同期レプリケーションが使用されている場合は望ましい設定ではありませんが、完全さのために提供されています。
       </P
><P
>もし <TT
CLASS="VARNAME"
>synchronous_standby_names</TT
> が設定されていなければ、<TT
CLASS="LITERAL"
>on</TT
>、<TT
CLASS="LITERAL"
>remote_apply</TT
>、<TT
CLASS="LITERAL"
>remote_write</TT
> および <TT
CLASS="LITERAL"
>local</TT
> の設定は全て同一の同期レベルを提供します。
すなわちトランザクションのコミットはローカルディスクへの吐き出しのみを待機します。
       </P
><P
>       
このパラメータはいつでも変更可能です。
どのトランザクションの動作も、コミット時に有効であった設定によって決まります。
したがって、一部のトランザクションのコミットを同期的に、その他を非同期的にすることが可能で、かつ、有用です。
例えば、デフォルトが同期コミットの場合に複数文トランザクションを一つだけ非同期にコミットさせるためには、トランザクション内で<TT
CLASS="COMMAND"
>SET LOCAL synchronous_commit TO OFF</TT
>を発行します。
       </P
></DD
><DT
><A
NAME="GUC-WAL-SYNC-METHOD"
></A
><TT
CLASS="VARNAME"
>wal_sync_method</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)
      </DT
><DD
><P
>       
       WALの更新をディスクへ強制するのに使用される方法です。<TT
CLASS="VARNAME"
>fsync</TT
>がオフの場合この設定は役に立ちません。と言うのはWALファイルの更新が全く強制されないからです。取り得る値は以下のものです。
       </P
><P
></P
><UL
><LI
><P
>       
        <TT
CLASS="LITERAL"
>open_datasync</TT
>（<CODE
CLASS="FUNCTION"
>open()</CODE
>のオプション<TT
CLASS="SYMBOL"
>O_DSYNC</TT
>でWALファイルに書き込む）
        </P
></LI
><LI
><P
>       
        <TT
CLASS="LITERAL"
>fdatasync</TT
>（コミット毎に<CODE
CLASS="FUNCTION"
>fdatasync()</CODE
>を呼び出す）
        </P
></LI
><LI
><P
>        
        <TT
CLASS="LITERAL"
>fsync</TT
>（コミット毎に<CODE
CLASS="FUNCTION"
>fsync()</CODE
>を呼び出す）
        </P
></LI
><LI
><P
>       
        <TT
CLASS="LITERAL"
>fsync_writethrough</TT
>（すべてのディスク書き込みキャッシュをライトスルーさせるため、コミット毎に<CODE
CLASS="FUNCTION"
>fsync()</CODE
>を呼び出す）
        </P
></LI
><LI
><P
>       
        <TT
CLASS="LITERAL"
>open_sync</TT
>（<CODE
CLASS="FUNCTION"
>open()</CODE
>のオプション<TT
CLASS="SYMBOL"
>O_SYNC</TT
>でWALファイルに書き込む）
        </P
></LI
></UL
><P
>       
可能なら<TT
CLASS="LITERAL"
>open_</TT
>*オプションも<TT
CLASS="LITERAL"
>O_DIRECT</TT
>を使用します。
全てのプラットフォームでこれら全ての選択肢が使えるわけではありません。
デフォルトは、上のリストのプラットフォームでサポートされるものの最初に列挙されているものです。
ただしLinuxでは<TT
CLASS="LITERAL"
>fdatasync</TT
>がデフォルトです。
デフォルトは必ずしも理想的なものではありません。
クラッシュに適応した構成にする、あるいはアーカイブの最適性能を導くためには、この設定あるいはシステム構成の他の部分を変更することが必要かもしれません。
これらの側面は <A
HREF="wal-reliability.html"
>項30.1</A
>で解説されます。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-FULL-PAGE-WRITES"
></A
><TT
CLASS="VARNAME"
>full_page_writes</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
      </DT
><DD
><P
>       
このパラメータが有効の場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバは、チェックポイントの後にそのページが最初に変更された過程で、ディスクページの全ての内容をWALに書き込みます。
オペレーティングシステムがクラッシュした時に進行中のページ書き込みは途中までしか終わっていない可能性があり、ディスク上のページが古いデータと新しいデータが混在する状態になるため、この機能が必要です。
通常WAL内に保存される行レベルの変更データは、クラッシュ後のリカバリ時にこうしたページを完全に復旧させるには不十分です。
完全なページイメージを保存することにより、ページを正しく復旧できることを保証しますが、その代わりに、WALに書き込まなければならないデータ量が増加することになります。
（WAL再生は常にチェックポイントから始まるため、チェックポイント後のそれぞれのページの最初の変更時にこれを行えば十分です。
従って、完全ページ書き出しのコストを低減する方法の1つは、チェックポイント間隔パラメータを大きくすることです。）
       </P
><P
>       
       このパラメータを無効にすると、通常の操作速度が上がりますが、システム障害後に、回復不能なデータ破損、あるいは警告なしのデータ損壊をもたらすかもしれません。
このリスクは小さいながら<TT
CLASS="VARNAME"
>fsync</TT
>を無効にした場合と似ています。そしてその<TT
CLASS="VARNAME"
>fsync</TT
>に対して推奨されている同一の状況に基づく限りにおいて停止されなければなりません。
       </P
><P
>       
       このパラメータを無効にしてもポイントインタイムリカバリ（PITR）用のWALアーカイブの使用に影響ありません（ <A
HREF="continuous-archiving.html"
>項25.3</A
>を参照してください）。
       </P
><P
>       
       このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル内、または、サーバのコマンドラインでのみ設定可能です。
デフォルトは<TT
CLASS="LITERAL"
>on</TT
>です。
       </P
></DD
><DT
><A
NAME="GUC-WAL-LOG-HINTS"
></A
><TT
CLASS="VARNAME"
>wal_log_hints</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
      </DT
><DD
><P
>        このパラメータが<TT
CLASS="LITERAL"
>on</TT
>の場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバはチェックポイント後にはじめてページを変更する際に、ディスクページの全内容をWALに書き出します。
これは、あまり重要でない、ヒントビットと呼ばれるものに対する変更にさえ当てはまります。
       </P
><P
>        データチェックサムが有効であると、ヒントビットの更新は常にWALにログされ、この設定パラメータは無視されます。この設定パラメータを使って、データチェックサムが有効なときにどれだけのWALログは余計に書きだされるかをテストすることができます。
       </P
><P
>       このパラメータはサーバ起動時のみ設定可能です。
デフォルト値は<TT
CLASS="LITERAL"
>off</TT
>です。
       </P
></DD
><DT
><A
NAME="GUC-WAL-COMPRESSION"
></A
><TT
CLASS="VARNAME"
>wal_compression</TT
> (<TT
CLASS="TYPE"
>boolean</TT
>)
      </DT
><DD
><P
>このパラメータが<TT
CLASS="LITERAL"
>on</TT
>なら、<A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>がonあるいはベースバックアップの際、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバはWALに書き出すフルページイメージを圧縮します。
圧縮されたページイメージは、WALリプレイのときに伸張されます。
デフォルト値は<TT
CLASS="LITERAL"
>off</TT
>です。
スーパーユーザだけがこの設定を変更できます。
       </P
><P
>このパラメータを有効にすると、回復不可能なデータ破壊のリスクを増やすこと無しにWALの量を減らすことができます。
しかし、WALロギングの際の圧縮のため、またWALリプレイの際には伸張のために余分なCPUを使用するというコストが発生します。
       </P
></DD
><DT
><A
NAME="GUC-WAL-BUFFERS"
></A
><TT
CLASS="VARNAME"
>wal_buffers</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
       未だディスクに書き込まれていないWALデータに対して使用される共有メモリ容量です。
       デフォルトの設定である-1は、<A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
>shared_buffers</A
>の1/32（約3%）の容量に等しい大きさを選択します。
       しかし、<TT
CLASS="LITERAL"
>64kB</TT
>未満ではなく、かつ典型的に<TT
CLASS="LITERAL"
>16MB</TT
>であるWALセグメントの大きさを越えることはありません。
       もし、自動設定による選択が大きすぎたり、小さすぎる場合この値は手作業で設定可能です。
       しかし、<TT
CLASS="LITERAL"
>32kB</TT
>未満のどんな正の値であっても、<TT
CLASS="LITERAL"
>32kB</TT
>
として取り扱われます。
このパラメータはサーバ起動時のみ設定可能です。
       </P
><P
>       
       WALバッファの内容はトランザクションのコミット毎にディスクに書き込まれます。
       したがって、極端に大きな値は有意な効果を期待できません。
       しかし、この値を数メガバイトに設定することにより、多くのクライアントが同時にコミットするトラフィック量の多いサーバでは書き込み性能が向上します。
       デフォルト設定の-1で選択される自動チューニングによると、ほとんどの場合妥当な結果が得られます。
       </P
></DD
><DT
><A
NAME="GUC-WAL-WRITER-DELAY"
></A
><TT
CLASS="VARNAME"
>wal_writer_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>WALライタがWALを吐き出す頻度を指定します。
WALを吐き出したとあと、非同期コミットしているトランザクションに起こされない限り、<TT
CLASS="VARNAME"
>wal_writer_delay</TT
>ミリ秒待機します。
最後の吐き出しが過去<TT
CLASS="VARNAME"
>wal_writer_delay</TT
>ミリ秒以内に起こなわれ、かつそれ以降<TT
CLASS="VARNAME"
>wal_writer_flush_after</TT
>バイト以内のWALが生成されている場合は、WALはオペレーティングシステムに書き込まれますが、ディスクには吐出されません。
デフォルト値は200ミリ秒（<TT
CLASS="LITERAL"
>200ms</TT
>）です。
多くのシステムでは、待機間隔の実質的な分解能は10ミリ秒です。
10の倍数以外の値を<TT
CLASS="VARNAME"
>wal_writer_delay</TT
>に設定しても、その次に大きい10の倍数を設定した場合と同じ結果となります。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル内またはサーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-WAL-WRITER-FLUSH-AFTER"
></A
><TT
CLASS="VARNAME"
>wal_writer_flush_after</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>WALライタがWALを吐き出す頻度を指定します。
最後の吐き出しが過去<TT
CLASS="VARNAME"
>wal_writer_delay</TT
>ミリ秒以内に起こなわれ、かつそれ以降<TT
CLASS="VARNAME"
>wal_writer_flush_after</TT
>バイト以内のWALが生成されている場合は、WALはオペレーティングシステムに書き込まれますが、ディスクには吐出されません。
<TT
CLASS="VARNAME"
>wal_writer_flush_after</TT
>が<TT
CLASS="LITERAL"
>0</TT
>に設定されている場合は、WALが書かれるたびにWALが吐出されます。
デフォルト値は<TT
CLASS="LITERAL"
>1MB</TT
>です。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル内またはサーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-COMMIT-DELAY"
></A
><TT
CLASS="VARNAME"
>commit_delay</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
><TT
CLASS="VARNAME"
>commit_delay</TT
>は、WALフラッシュを開始する前の時間遅延を追加します。単位はマイクロ秒です。
このことにより、もし追加のトランザクションが与えられた時間間隔内でコミットが可能になるほどシステム負荷が充分に高い場合、一回のWALフラッシュでより多くの数のトランザクションをコミットできるようになり、コミット群のスループットを改善できます。
とは言っても、それぞれのWALフラッシュに対して最大<TT
CLASS="VARNAME"
>commit_delay</TT
>マイクロ秒の待ち時間の増加をきたします。
コミットの準備が完了したトランザクションが他に存在しない場合、遅延は無駄になるため、遅延はフラッシュが開始されようとしている時点で少なくとも<TT
CLASS="VARNAME"
>commit_siblings</TT
>だけのトランザクションが活動している場合にだけ機能します。
同様に、<TT
CLASS="VARNAME"
>fsync</TT
>が無効の場合も遅延は機能しません。
デフォルトの<TT
CLASS="VARNAME"
>commit_delay</TT
>はゼロ（遅延無し）です。
この設定はスーパーユーザのみ変更可能です。
       </P
><P
>       
        9.3より前の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、<TT
CLASS="VARNAME"
>commit_delay</TT
>の振る舞いは異なっており、あまり効果がありませんでした。
       全てのWALフラッシュではなく、コミットだけに影響していました。また、そしてWALフラッシュが早めに完了しても設定された遅延分待機していました。
       <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.3以降では、フラッシュの準備が整った最初のプロセスが設定値分待機し、後続のプロセスは最初のプロセスがフラッシュ操作を完了するまでの間だけ待機をします。
       </P
></DD
><DT
><A
NAME="GUC-COMMIT-SIBLINGS"
></A
><TT
CLASS="VARNAME"
>commit_siblings</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
<TT
CLASS="VARNAME"
>commit_delay</TT
>の遅延を実行するときに必要とされる同時に開いているトランザクションの最小数です。
より大きい値にすると、遅延周期の間に、少なくとも1つの他のトランザクションのコミットの準備が整う確率が高くなります。
デフォルトは5トランザクションです。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-CHECKPOINTS"
>19.5.2. チェックポイント</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-CHECKPOINT-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>checkpoint_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
自動的WALチェックポイント間の最大間隔を秒単位で指定します。
有効な範囲は、30秒から1日の間です。
デフォルトは5分（<TT
CLASS="LITERAL"
>5min</TT
>）です。
このパラメータを増やすと、クラッシュリカバリで必要となる時間が増加します。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-COMPLETION-TARGET"
></A
><TT
CLASS="VARNAME"
>checkpoint_completion_target</TT
> (<TT
CLASS="TYPE"
>floating point</TT
>)
      </DT
><DD
><P
>       
       チェックポイントの完了目標をチェックポイント間の総時間の割合として指定します。
デフォルトは0.5です。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-FLUSH-AFTER"
></A
><TT
CLASS="VARNAME"
>checkpoint_flush_after</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>チェックポイント実行中に<TT
CLASS="VARNAME"
>checkpoint_flush_after</TT
>バイトより多く書く度に、OSが記憶装置に書き込むことを強制しようとします。
このことにより、カーネルのページキャッシュが持つダーティデータの量を一定量に制限し、チェックポイントの最後にfsyncが実行される際、あるいはOSがバックグラウンドでデータを大きな塊で書き出す際に性能の急激な低下を招く可能性を減らします。
多くの場合これによってトランザクションの遅延が大幅に少なくなりますが、あるケース、特にワークロードが<A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
>shared_buffers</A
>よりも大きく、OSのページキャッシュよりも小さい時には性能が低下するかもしれません。
この設定が無効なプラットフォームがあります。
有効な設定値は、この強制書き込み機能が無効になる<TT
CLASS="LITERAL"
>0</TT
>から、<TT
CLASS="LITERAL"
>2MB</TT
>までです。
デフォルト値は、Linuxでは<TT
CLASS="LITERAL"
>256kB</TT
>で、それ以外は<TT
CLASS="LITERAL"
>0</TT
>です。
(<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>が8kbでなければ、この設定のデフォルト値と最大値が<TT
CLASS="SYMBOL"
>BLCKSZ</TT
>に比例して変更されます。)
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみで設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-CHECKPOINT-WARNING"
></A
><TT
CLASS="VARNAME"
>checkpoint_warning</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
チェックポイントセグメントファイルが溢れることが原因で起きるチェックポイントが、ここで指定した秒数よりも短い間隔で発生したとき、サーバログにメッセージを書き出します
（これは、<TT
CLASS="VARNAME"
>max_wal_size</TT
>を増やす必要があることを示唆しています）。
デフォルトは30秒（<TT
CLASS="LITERAL"
>30s</TT
>）です。
零の場合は警告を出しません。
<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>が<TT
CLASS="VARNAME"
>checkpoint_warning</TT
>より小さい場合は警告を出しません。
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
       </P
></DD
><DT
><A
NAME="GUC-MAX-WAL-SIZE"
></A
><TT
CLASS="VARNAME"
>max_wal_size</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>自動WALチェックポイントの間にWALが増加する最大サイズです。
これはソフトリミットです。特別な状況下、たとえば高負荷、<TT
CLASS="VARNAME"
>archive_command</TT
>の失敗、<TT
CLASS="VARNAME"
>wal_keep_segments</TT
>が大きな値に設定されている、などの時には、WALサイズは<TT
CLASS="VARNAME"
>max_wal_size</TT
>を超えることがあります。
デフォルトは1GBです。
このパラメータを大きくすると、クラッシュリカバリに必要な時間が長くなります。
このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>で設定するか、サーバのコマンドラインでのみ指定できます。
       </P
></DD
><DT
><A
NAME="GUC-MIN-WAL-SIZE"
></A
><TT
CLASS="VARNAME"
>min_wal_size</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>この設定以下にWALのディスク使用量が保たれる限り、古いWALファイルは、消去されることなく今後のチェックポイントで使用するために常にリサイクルされます。
この設定は、たとえば大きなバッチジョブを走らせる際のWALの利用スパイクを取り扱うために、十分なWALのスペースが予約されていることを保証するために使用できます。
デフォルトは80MBです。
このパラメータは、<TT
CLASS="FILENAME"
>postgresql.conf</TT
>で設定するか、サーバのコマンドラインでのみ指定できます。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="RUNTIME-CONFIG-WAL-ARCHIVING"
>19.5.3. アーカイビング</A
></H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><A
NAME="GUC-ARCHIVE-MODE"
></A
><TT
CLASS="VARNAME"
>archive_mode</TT
> (<TT
CLASS="TYPE"
>enum</TT
>)
      </DT
><DD
><P
>       
       <TT
CLASS="VARNAME"
>archive_mode</TT
>が有効な場合、<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>を設定することにより、完了したWALセグメントはアーカイブ格納領域に送信されます。
無効にするための<TT
CLASS="LITERAL"
>off</TT
>に加え、2つのモードがあります。<TT
CLASS="LITERAL"
>on</TT
>と<TT
CLASS="LITERAL"
>always</TT
>です。
通常の運用ではこの2つのモードには違いはありませんが、<TT
CLASS="LITERAL"
>always</TT
>に設定すると、アーカイブリカバリおよびスタンバイモードでWALアーカイバが有効になります。
<TT
CLASS="LITERAL"
>always</TT
>モードでは、アーカイブからリストアされたファイルや、ストリーミングレプリケーションでストリームされたファイルもすべて(再び)アーカイブされます。
詳細は<A
HREF="warm-standby.html#CONTINUOUS-ARCHIVING-IN-STANDBY"
>項26.2.9</A
>を参照してください。
       </P
><P
>アーカイブモードを抜けることなく<TT
CLASS="VARNAME"
>archive_command</TT
>を変更できるように、<TT
CLASS="VARNAME"
>archive_mode</TT
>と<TT
CLASS="VARNAME"
>archive_command</TT
>は分離されました。
このパラメータはサーバ起動時のみ設定可能です。
<TT
CLASS="VARNAME"
>wal_level</TT
> が
<TT
CLASS="LITERAL"
>minimal</TT
>に設定されている場合、<TT
CLASS="VARNAME"
>archive_mode</TT
>は有効になりません。
       </P
></DD
><DT
><A
NAME="GUC-ARCHIVE-COMMAND"
></A
><TT
CLASS="VARNAME"
>archive_command</TT
> (<TT
CLASS="TYPE"
>string</TT
>)
      </DT
><DD
><P
>       
完了したWALファイルセグメントのアーカイブを実行するローカルのシェルコマンドです。
文字列内のすべての<TT
CLASS="LITERAL"
>%p</TT
>は、格納されるファイルのパスで置き換えられ、そして、<TT
CLASS="LITERAL"
>%f</TT
>はファイル名のみ置換します。
（このパス名はサーバの作業用ディレクトリ、つまり、クラスタのデータディレクトリからの相対パスです。）
コマンド内に<TT
CLASS="LITERAL"
>%</TT
>文字そのものを埋め込むには<TT
CLASS="LITERAL"
>%%</TT
>を使用します。
コマンドが成功した場合にのみ終了ステータスゼロを返すことが重要です。
より詳しくは<A
HREF="continuous-archiving.html#BACKUP-ARCHIVING-WAL"
>項25.3.1</A
>を参照ください。
       </P
><P
>       
このパラメータは<TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみ設定可能です。
サーバ起動時に<TT
CLASS="VARNAME"
>archive_mode</TT
>が有効でなければ、これは無視されます。
<TT
CLASS="VARNAME"
>archive_command</TT
>が空文字列（デフォルト）、かつ、<TT
CLASS="VARNAME"
>archive_mode</TT
>が有効な場合、WALアーカイブ処理は一時的に無効になりますが、コマンドが後で提供されることを見越して、サーバはWALセグメントの蓄積を続けます。
例えば、<TT
CLASS="LITERAL"
>/bin/true</TT
>（Windowsでは<TT
CLASS="LITERAL"
>REM</TT
>）のように、真を返すだけで何もしないコマンドを<TT
CLASS="VARNAME"
>archive_command</TT
>に設定すると、実質的にアーカイブ処理が無効になりますが、アーカイブからの復帰に必要なWALファイルの連鎖も同時に断ち切るため、特別な場合のみ使用するようにしなければなりません。
       </P
></DD
><DT
><A
NAME="GUC-ARCHIVE-TIMEOUT"
></A
><TT
CLASS="VARNAME"
>archive_timeout</TT
> (<TT
CLASS="TYPE"
>integer</TT
>)
      </DT
><DD
><P
>       
<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>は完了したWALセグメントに対してのみ呼び出されます。
従って、サーバのWAL転送量が少ししかない（あるいは処理が少ないなぎの期間がある）場合、トランザクションの完了とアーカイブ格納領域への安全な記録との間に長期にわたる遅延があることになります。
データが未アーカイブのままでいられる期間を制限するために、<TT
CLASS="VARNAME"
>archive_timeout</TT
>を設定して、強制的にサーバを新しいWALセグメントに定期的に切り替えるようにすることができます。
このパラメータが0より大きければ、サーバは前回のセグメントファイル切り替えから指定秒数経過し、かつ単一のチェックポイントを含む何らかのデータベース操作が行われた場合、新しいセグメントファイルに切り替えます。
（<TT
CLASS="VARNAME"
>checkpoint_timeout</TT
>を大きくすると待機状態のシステム上のなくてもいいチェックポイントを削減します。）
強制切り替えにより早期に閉ざされたアーカイブ済みファイルは完全に完了したファイルと同じ大きさを持つことに注意してください。
そのため、非常に小さな<TT
CLASS="VARNAME"
>archive_timeout</TT
>を使用することは賢明ではなく、格納領域を膨張させてしまいます。
１分程度の<TT
CLASS="VARNAME"
>archive_timeout</TT
>設定が通常は妥当です。
もしそれより高速にデータをマスターサーバからコピーをしてしまいたいのであれば、アーカイブするよりストリーミングレプリケーションの選択を検討すべきです。
このパラメータは <TT
CLASS="FILENAME"
>postgresql.conf</TT
>ファイル、または、サーバのコマンドラインでのみで設定可能です。
       </P
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime-config-resource.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="runtime-config-replication.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>資源の消費</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime-config.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>レプリケーション</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
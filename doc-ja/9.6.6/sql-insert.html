<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>INSERT</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="IMPORT FOREIGN SCHEMA"
HREF="sql-importforeignschema.html"><LINK
REL="NEXT"
TITLE="LISTEN"
HREF="sql-listen.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="IMPORT FOREIGN SCHEMA"
HREF="sql-importforeignschema.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="LISTEN"
HREF="sql-listen.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-INSERT"
></A
>INSERT</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN88414"
></A
><H2
>名前</H2
>INSERT&nbsp;--&nbsp;テーブルに新しい行を作成する</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN88417"
></A
><H2
>概要</H2
><PRE
CLASS="SYNOPSIS"
>[ WITH [ RECURSIVE ] <TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
> [, ...] ]
INSERT INTO <TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
> [ AS <TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
> ] [ ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) ]
    { DEFAULT VALUES | VALUES ( { <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> | DEFAULT } [, ...] ) [, ...] | <TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
> }
    [ ON CONFLICT [ <TT
CLASS="REPLACEABLE"
><I
>conflict_target</I
></TT
> ] <TT
CLASS="REPLACEABLE"
><I
>conflict_action</I
></TT
> ]
    [ RETURNING * | <TT
CLASS="REPLACEABLE"
><I
>output_expression</I
></TT
> [ [ AS ] <TT
CLASS="REPLACEABLE"
><I
>output_name</I
></TT
> ] [, ...] ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>ここで<TT
CLASS="REPLACEABLE"
><I
>conflict_target</I
></TT
>は以下のいずれかです。</SPAN
></SPAN
>

    ( { <TT
CLASS="REPLACEABLE"
><I
>index_column_name</I
></TT
> | ( <TT
CLASS="REPLACEABLE"
><I
>index_expression</I
></TT
> ) } [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
> ] [, ...] ) [ WHERE <TT
CLASS="REPLACEABLE"
><I
>index_predicate</I
></TT
> ]
    ON CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
>

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>また<TT
CLASS="REPLACEABLE"
><I
>conflict_action</I
></TT
>は以下のいずれかです。</SPAN
></SPAN
>

    DO NOTHING
    DO UPDATE SET { <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> = { <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> | DEFAULT } |
                    ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) = ( { <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> | DEFAULT } [, ...] ) |
                    ( <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [, ...] ) = ( <TT
CLASS="REPLACEABLE"
><I
>sub-SELECT</I
></TT
> )
                  } [, ...]
              [ WHERE <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
> ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88446"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>INSERT</TT
>はテーブルに新しい行を挿入します。
値式を使用して行（複数可）を挿入すること、および、問い合わせの結果を使って0行以上の行を挿入することができます。
  </P
><P
>対象の列名はどのような順番でも指定できます。
列名リストが指定されなかった場合は、テーブル内の全ての列を宣言時の順番に並べたものがデフォルトとして使われます。
また、<TT
CLASS="LITERAL"
>VALUES</TT
>句や<TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>で<TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
>列のみが与えられた場合は、先頭の<TT
CLASS="REPLACEABLE"
><I
>N</I
></TT
>列の名前が指定されたものとみなされます。
<TT
CLASS="LITERAL"
>VALUES</TT
>句や<TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>で提供される値は、明示的または暗黙的な列リストと左から右への順で関連付けられます
  </P
><P
>明示的または暗黙的な列リストにない各列にはデフォルト値（デフォルト値が宣言されていればその値、未宣言ならばNULL）が挿入されます。
  </P
><P
>各列の式が正しいデータ型でない場合は、自動的に型の変換が行われます。
  </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT</TT
>は一意制約または排他制約について、違反のエラーを発生させるのに代わる動作を指定するのに使うことができます。
（以下の<A
HREF="sql-insert.html#SQL-ON-CONFLICT"
><I
><I
>ON CONFLICT</I
>句</I
></A
>を参照してください。）
  </P
><P
><TT
CLASS="LITERAL"
>RETURNING</TT
>句を指定すると、<TT
CLASS="COMMAND"
>INSERT</TT
>は実際に挿入された（あるいは<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>句によって更新された）各行に基づいて計算された値を返すようになります。
これは、通番のシーケンス番号など、デフォルトで与えられた値を取り出す時に主に便利です。
しかし、そのテーブルの列を使用した任意の式を指定することができます。
<TT
CLASS="LITERAL"
>RETURNING</TT
>リストの構文は<TT
CLASS="COMMAND"
>SELECT</TT
>の出力リストと同一です。
挿入または更新に成功した行だけが返されます。
例えば、行がロックされていて、<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE ... WHERE</TT
>句の <TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
>が満たされなかったために更新されなかった行は返されません。
  </P
><P
>テーブルに行を追加するには、そのテーブルに対して<TT
CLASS="LITERAL"
>INSERT</TT
>権限を持っている必要があります。
<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>がある場合は、テーブルの<TT
CLASS="LITERAL"
>UPDATE</TT
>権限も必要です。
  </P
><P
>列リストを指定する場合は、列挙された列に対する<TT
CLASS="LITERAL"
>INSERT</TT
>権限のみが必要です。
同様に、<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>が指定されている場合、更新対象として列挙されている列についてのみ、<TT
CLASS="LITERAL"
>UPDATE</TT
>権限が必要です。
しかし、<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>はまた、その式あるいは<TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
>で読み取られるすべての列についての<TT
CLASS="LITERAL"
>SELECT</TT
>権限も必要です。
  </P
><P
><TT
CLASS="LITERAL"
>RETURNING</TT
>句を使用するには、<TT
CLASS="LITERAL"
>RETURNING</TT
>で使用するすべての列に対する<TT
CLASS="LITERAL"
>SELECT</TT
>権限が必要です。
<TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>を使用して問い合わせ結果を元に行を挿入する場合は当然ながら、その問い合わせ内で使われる全てのテーブルまたは列に対して<TT
CLASS="LITERAL"
>SELECT</TT
>権限を持っている必要があります。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88487"
></A
><H2
>パラメータ</H2
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-INSERTING-PARAMS"
></A
><H3
>挿入</H3
><P
>この節では新しい行を挿入するときにのみ使われるパラメータについて説明します。
<TT
CLASS="LITERAL"
>ON CONFLICT</TT
>句において<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>のみ</I
></SPAN
>使われるパラメータについては、別に説明します。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>WITH</TT
>句により、<TT
CLASS="COMMAND"
>INSERT</TT
>問い合わせ内で名前により参照することができる１つ以上の副問い合わせを指定することができます。
詳しくは<A
HREF="queries-with.html"
>項7.8</A
>と<A
HREF="sql-select.html"
>SELECT</A
>を参照してください。
       </P
><P
><TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>（<TT
CLASS="COMMAND"
>SELECT</TT
>文）でもまた、<TT
CLASS="LITERAL"
>WITH</TT
>句を含めることができます。
こうした場合、<TT
CLASS="REPLACEABLE"
><I
>with_query</I
></TT
>の集合との両方を<TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>内で参照することができます。
しかし、第二の問い合わせがより近くにネストされているため優先します。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
></DT
><DD
><P
>既存のテーブルの名前です（スキーマ修飾名も可）。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>alias</I
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>の代替名です。
aliasを指定すると、テーブルの実際の名前が完全に隠されます。
これは、除外対象としたテーブルを<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>が対象にしている場合、それが挿入で処理される行を表現する特別なテーブルの名前でもあるため、特に有用となります。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>で指名されたテーブル内の列名です。
必要なら列名を副フィールドの名前や配列の添え字で修飾することができます。
（複合型の列の一部のフィールドのみを挿入すると他のフィールドはNULLになります。）
<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>で列を参照する場合、対象列の指定にテーブル名を含めてはいけません。
例えば、<TT
CLASS="LITERAL"
>INSERT INTO table_name ... ON CONFLICT DO UPDATE SET table_name.col = 1</TT
>は無効です（これは<TT
CLASS="COMMAND"
>UPDATE</TT
>の一般的な動作に従います）。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>DEFAULT VALUES</TT
></DT
><DD
><P
>全ての列に、それぞれのデフォルト値が設定されます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
></DT
><DD
><P
>対応する列に代入する式または値を指定します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>DEFAULT</TT
></DT
><DD
><P
>対応する列にデフォルト値を設定します。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
></DT
><DD
><P
>挿入する行を提供する問い合わせ（<TT
CLASS="COMMAND"
>SELECT</TT
>文）を指定します。
構文の説明については<A
HREF="sql-select.html"
>SELECT</A
>文を参照してください。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>output_expression</I
></TT
></DT
><DD
><P
>各行が挿入または更新された後、<TT
CLASS="COMMAND"
>INSERT</TT
>により計算され、返される式です。
この式には<TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>で指名されたテーブルの任意の列名を使用することができます。
挿入または更新された行のすべての列を返す場合は<TT
CLASS="LITERAL"
>*</TT
>と記載してください。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>output_name</I
></TT
></DT
><DD
><P
>返される列で使用される名前です。
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-ON-CONFLICT"
></A
><H3
><TT
CLASS="LITERAL"
>ON CONFLICT</TT
>句</H3
><P
>オプションの<TT
CLASS="LITERAL"
>ON CONFLICT</TT
>句では、一意制約や排他制約の違反について、エラーを発生させる代替となる動作を指定します。
挿入しようとされた各行について、挿入の処理が進められるか、あるいは、<TT
CLASS="PARAMETER"
>conflict_target</TT
>により指定された<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>競合</I
></SPAN
>制約またはインデックスに違反した場合の代替の<TT
CLASS="PARAMETER"
>conflict_action</TT
>が実行されるか、のいずれかです。
<TT
CLASS="LITERAL"
>ON CONFLICT DO NOTHING</TT
>は代替の動作として、単に行の挿入をしなくなるだけです。
<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>は代替の動作として、挿入されようとしていた行と競合する既存の行を更新します。
   </P
><P
><TT
CLASS="PARAMETER"
>conflict_target</TT
>は<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>一意インデックスの推定</I
></SPAN
>を実行することができます。
推定を実行するとき、それは1つ以上の<TT
CLASS="REPLACEABLE"
><I
>index_column_name</I
></TT
>列、または<TT
CLASS="REPLACEABLE"
><I
>index_expression</I
></TT
>式、あるいはその両方、およびオプションで<TT
CLASS="REPLACEABLE"
><I
>index_predicate</I
></TT
>から構成されます。
<TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>の一意インデックスで<TT
CLASS="PARAMETER"
>conflict_target</TT
>で指定された列と式を（順序は関係なく）正確に含むものは、すべて競合解決インデックスとして推定されます（選ばれます）。
<TT
CLASS="REPLACEABLE"
><I
>index_predicate</I
></TT
>が指定されている場合は、推定のさらなる条件として、それは競合解決インデックスを満たさなければなりません。
これは、部分インデックスでない一意インデックス（述語のない一意インデックス）は、それが他のすべての条件を満たすのであれば推定される（従って<TT
CLASS="LITERAL"
>ON CONFLICT</TT
>で使用される）ことを意味することに注意して下さい。
推定に失敗した時は、エラーが発生します。
   </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>は<TT
CLASS="COMMAND"
>INSERT</TT
>または<TT
CLASS="COMMAND"
>UPDATE</TT
>の原子的な結果を保証します。
無関係のエラーが発生しなければ、多数の同時実行がある状況においてさえも、それら2つの結果のうちの1つになります。
これは<I
CLASS="FIRSTTERM"
>UPSERT</I
>、つまり<SPAN
CLASS="QUOTE"
>"UPDATE or INSERT"</SPAN
>としても知られています。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>conflict_target</I
></TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>ON CONFLICT</TT
>が<I
CLASS="FIRSTTERM"
>競合解決インデックス</I
>を選ぶことで代替の動作をするときの競合を指定します。
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>一意インデックスの推定</I
></SPAN
>を実行するか、あるいは制約を明示的に指定するかのいずれかです。
<TT
CLASS="LITERAL"
>ON CONFLICT DO NOTHING</TT
>では<TT
CLASS="PARAMETER"
>conflict_target</TT
>を指定するのはオプションです。
省略すると、利用可能なすべての制約（および一意インデックス）との競合が処理されます。
<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>では<TT
CLASS="PARAMETER"
>conflict_target</TT
>を指定<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>しなければなりません</I
></SPAN
>。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>conflict_action</I
></TT
></DT
><DD
><P
><TT
CLASS="PARAMETER"
>conflict_action</TT
>では<TT
CLASS="LITERAL"
>ON CONFLICT</TT
>の代替の動作を指定します。
これは<TT
CLASS="LITERAL"
>DO NOTHING</TT
>あるいは<TT
CLASS="LITERAL"
>DO UPDATE</TT
>句のいずれかをとることができ、後者では競合が発生した場合に実行される<TT
CLASS="LITERAL"
>UPDATE</TT
>の動作の正確な詳細を記述します。
<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>の<TT
CLASS="LITERAL"
>SET</TT
>句と<TT
CLASS="LITERAL"
>WHERE</TT
>は既存の行にテーブルの名前（または別名）を使ってアクセスでき、また挿入されようとしていた行には、特別な<TT
CLASS="VARNAME"
>excluded</TT
>テーブルを使ってアクセスできます。
<TT
CLASS="VARNAME"
>excluded</TT
>の列を読み取るときには、対象テーブルの対応する列の<TT
CLASS="LITERAL"
>SELECT</TT
>権限が必要です。
       </P
><P
>すべての行レベルの<TT
CLASS="LITERAL"
>BEFORE INSERT</TT
>トリガーの結果が<TT
CLASS="VARNAME"
>excluded</TT
>の値に反映されることに注意して下さい。
これらの結果として、行が挿入から除外されることになったかもしれないからです。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>index_column_name</I
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>の列の名前です。
競合解決インデックスを推定するのに使われます。
<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>の形式に従います。
<TT
CLASS="REPLACEABLE"
><I
>index_column_name</I
></TT
>の<TT
CLASS="LITERAL"
>SELECT</TT
>が必要です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>index_expression</I
></TT
></DT
><DD
><P
><TT
CLASS="REPLACEABLE"
><I
>index_column_name</I
></TT
>と似ていますが、インデックスの定義に現れる<TT
CLASS="REPLACEABLE"
><I
>table_name</I
></TT
>の列の式（単純な列ではない）の推定に使われます。
<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>の形式に従います。
<TT
CLASS="REPLACEABLE"
><I
>index_expression</I
></TT
>に現れるすべての列の<TT
CLASS="LITERAL"
>SELECT</TT
>権限が必要です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
></DT
><DD
><P
>これを指定すると、推定時に、対応する<TT
CLASS="REPLACEABLE"
><I
>index_column_name</I
></TT
>あるいは<TT
CLASS="REPLACEABLE"
><I
>index_expression</I
></TT
>をマッチさせるときに、特定の照合順序を指定することになります。
普通は照合順序は制約違反が発生するかどうかに関係しないので、通常は省略されます。
<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>の形式に従います。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>opclass</I
></TT
></DT
><DD
><P
>これを指定すると、推定時に、対応する<TT
CLASS="REPLACEABLE"
><I
>index_column_name</I
></TT
>あるいは<TT
CLASS="REPLACEABLE"
><I
>index_expression</I
></TT
>をマッチさせるときに、特定の演算子クラスを指定することになります。
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>等価</I
></SPAN
>の意味は、いずれにせよ、型の演算子クラスをまたがって同等であることが多いですし、また定義された一意インデックスは等価を適切に定義していると信頼すれば十分なので、通常はこれは省略されます。
<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>の形式に従います。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>index_predicate</I
></TT
></DT
><DD
><P
>部分一意インデックスの推定を可能にします。
述語を満たすすべてのインデックス（実際に部分インデックスである必要はありません）は推定可能になります。
<TT
CLASS="COMMAND"
>CREATE INDEX</TT
>の形式に従います。
<TT
CLASS="REPLACEABLE"
><I
>index_predicate</I
></TT
>に現れるすべての列について<TT
CLASS="LITERAL"
>SELECT</TT
>権限が必要です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
></DT
><DD
><P
>競合解決の<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>制約</I
></SPAN
>を制約やインデックスの推定によるのではなく、明示的に名前で指定します。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
></DT
><DD
><P
><TT
CLASS="TYPE"
>boolean</TT
>型の値を返す式です。
この式が<TT
CLASS="LITERAL"
>true</TT
>を返す行のみが更新されます。
ただし、<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>の動作が行われるときは、すべての行がロックされます。
<TT
CLASS="REPLACEABLE"
><I
>condition</I
></TT
>は最後に評価される、競合が更新対象候補として特定された後であることに注意して下さい。
       </P
></DD
></DL
></DIV
><P
>排他制約は<TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>の競合解決としてはサポートされないことに注意して下さい。
すべての場合について、<TT
CLASS="LITERAL"
>NOT DEFERRABLE</TT
>である制約と一意インデックスのみが競合解決としてサポートされます。
   </P
><P
><TT
CLASS="LITERAL"
>ON CONFLICT DO UPDATE</TT
>句のある<TT
CLASS="COMMAND"
>INSERT</TT
>は<SPAN
CLASS="QUOTE"
>"決定論的な"</SPAN
>文です。
これは、そのコマンドが既存のどの行に対しても、2回以上影響を与えることが許されない、ということを意味します。
これに反する状況が発生した時は、カーディナリティ違反のエラーが発生します。
挿入されようとする行は、競合解決インデックスあるいは制約により制限される属性の観点で、複製されてはなりません。
   </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>ティップ: </B
><TT
CLASS="LITERAL"
>ON CONFLICT ON CONSTRAINT</TT
> <TT
CLASS="REPLACEABLE"
><I
> constraint_name</I
></TT
>を使って制約を直接指定するより、一意インデックスの推定を使う方が望ましいことが多いです。
背景にあるインデックスが、他のほぼ同等のインデックスと重なり合う形で置換されるとき、推定は正しく動作し続けます。
例えば、置換されるインデックスを削除する前に<TT
CLASS="LITERAL"
>CREATE UNIQUE INDEX ...  CONCURRENTLY</TT
>を使う場合です。
    </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88700"
></A
><H2
>出力</H2
><P
>正常に終了すると、<TT
CLASS="COMMAND"
>INSERT</TT
>は以下のようなコマンドタグを返します。
</P><PRE
CLASS="SCREEN"
>INSERT <TT
CLASS="REPLACEABLE"
><I
>oid</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
></PRE
><P>
<TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>は挿入または更新された行数です。
<TT
CLASS="REPLACEABLE"
><I
>count</I
></TT
>が正確に1であり、対象のテーブルがOIDを持つ場合、<TT
CLASS="REPLACEABLE"
><I
>oid</I
></TT
>は挿入された行に割り当てられた<ACRONYM
CLASS="ACRONYM"
>OID</ACRONYM
>です。
その1行は、更新ではなく挿入された行です。
その他の場合、<TT
CLASS="REPLACEABLE"
><I
>oid</I
></TT
>は0となります。
  </P
><P
><TT
CLASS="COMMAND"
>INSERT</TT
>コマンドが<TT
CLASS="LITERAL"
>RETURNING</TT
>句を持つ場合、その結果は、<TT
CLASS="LITERAL"
>RETURNING</TT
>リストで定義した列と値を持ち、そのコマンドで挿入または更新された行全体に対して計算を行う<TT
CLASS="COMMAND"
>SELECT</TT
>文の結果と似たものになるでしょう。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88717"
></A
><H2
>例</H2
><P
><TT
CLASS="LITERAL"
>films</TT
>テーブルに1行を挿入します。

</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, '1971-07-13', 'Comedy', '82 minutes');</PRE
><P>
  </P
><P
>次の例では、<TT
CLASS="LITERAL"
>len</TT
>列を省略しています。
したがって、ここにはデフォルト値が入ります。

</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, '1961-06-16', 'Drama');</PRE
><P>
  </P
><P
>次の例では、日付列に対して値を指定する代わりに<TT
CLASS="LITERAL"
>DEFAULT</TT
>を使用します。

</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO films VALUES
    ('UA502', 'Bananas', 105, DEFAULT, 'Comedy', '82 minutes');
INSERT INTO films (code, title, did, date_prod, kind)
    VALUES ('T_601', 'Yojimbo', 106, DEFAULT, 'Drama');</PRE
><P>
  </P
><P
>全てデフォルト値からなる行を挿入します。

</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO films DEFAULT VALUES;</PRE
><P>
  </P
><P
>複数行の<TT
CLASS="COMMAND"
>VALUES</TT
>構文を使用して複数行を挿入します。

</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO films (code, title, did, date_prod, kind) VALUES
    ('B6717', 'Tampopo', 110, '1985-02-10', 'Comedy'),
    ('HG120', 'The Dinner Game', 140, DEFAULT, 'Comedy');</PRE
><P>
  </P
><P
>次の例では、<TT
CLASS="LITERAL"
>films</TT
>テーブルと同じ列レイアウトを持つ<TT
CLASS="LITERAL"
>tmp_films</TT
>テーブルから<TT
CLASS="LITERAL"
>films</TT
>テーブルへいくつか行を挿入します。

</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO films SELECT * FROM tmp_films WHERE date_prod &lt; '2004-05-07';</PRE
><P>
  </P
><P
>次の例では、配列型の列に挿入します。

</P><PRE
CLASS="PROGRAMLISTING"
>-- 三目並べ用の3×3マスのゲーム盤を作成します。
INSERT INTO tictactoe (game, board[1:3][1:3])
    VALUES (1, '{{" "," "," "},{" "," "," "},{" "," "," "}}');
--上の例の添え字は本当は必要ありません。
INSERT INTO tictactoe (game, board)
    VALUES (2, '{{X," "," "},{" ",O," "},{" ",X," "}}');</PRE
><P>
  </P
><P
><TT
CLASS="LITERAL"
>distributors</TT
>テーブルに一行を挿入し、その<TT
CLASS="LITERAL"
>DEFAULT</TT
>句により生成されたシーケンス番号を返します。

</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO distributors (did, dname) VALUES (DEFAULT, 'XYZ Widgets')
   RETURNING did;</PRE
><P>
  </P
><P
>Acme社の顧客を担当する営業担当者の売り上げ数を増やし、ログテーブルに更新行全体と更新時刻を記録します。
</P><PRE
CLASS="PROGRAMLISTING"
>WITH upd AS (
  UPDATE employees SET sales_count = sales_count + 1 WHERE id =
    (SELECT sales_person FROM accounts WHERE name = 'Acme Corporation')
    RETURNING *
)
INSERT INTO employees_log SELECT *, current_timestamp FROM upd;</PRE
><P>
  </P
><P
>新しい販売店(distributors)を適切に挿入または更新します。
<TT
CLASS="LITERAL"
>did</TT
>列に現れる値を制限する一意インデックスが定義されているものとします。
元々挿入されようとしていた値を参照するために、特別な<TT
CLASS="VARNAME"
>excluded</TT
>テーブルが使用されていることに注意して下さい。
</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO distributors (did, dname)
    VALUES (5, 'Gizmo Transglobal'), (6, 'Associated Computing, Inc')
    ON CONFLICT (did) DO UPDATE SET dname = EXCLUDED.dname;</PRE
><P>
  </P
><P
>販売店を挿入するか、あるいは挿入しようとした行について既存の除外行（before insertの行トリガを実行した後で制約列にマッチした行）がある場合は何もしません。
例では<TT
CLASS="LITERAL"
>did</TT
>列に現れる値を制限する一意インデックスがあるものとしています。
</P><PRE
CLASS="PROGRAMLISTING"
>INSERT INTO distributors (did, dname) VALUES (7, 'Redline GmbH')
    ON CONFLICT (did) DO NOTHING;</PRE
><P>
  </P
><P
>新しい販売店を適切に挿入または更新します。
例では<TT
CLASS="LITERAL"
>did</TT
>列に現れる値を制限する一意インデックスがあるものとしています。
実際に更新される行を制限するために<TT
CLASS="LITERAL"
>WHERE</TT
>句が使われています（ただし、更新されない既存の行もすべてロックされます）。
</P><PRE
CLASS="PROGRAMLISTING"
>-- 特定の郵便番号については既存の販売店を更新しません
INSERT INTO distributors AS d (did, dname) VALUES (8, 'Anvil Distribution')
    ON CONFLICT (did) DO UPDATE
    SET dname = EXCLUDED.dname || ' (formerly ' || d.dname || ')'
    WHERE d.zipcode &lt;&gt; '21201';

-- 文中で制約を直接指定します（DO NOTHINGの動作をする競合解決のため
-- 関連するインデックスを指定します）
INSERT INTO distributors (did, dname) VALUES (9, 'Antwerp Design')
    ON CONFLICT ON CONSTRAINT distributors_pkey DO NOTHING;</PRE
><P>
  </P
><P
>可能であれば新しい販売店を挿入しますが、できないときは<TT
CLASS="LITERAL"
>DO NOTHING</TT
>とします。
この例では、<TT
CLASS="LITERAL"
>is_active</TT
>というブーリアン列が<TT
CLASS="LITERAL"
>true</TT
>である行という条件で、<TT
CLASS="LITERAL"
>did</TT
>列に一意インデックスが定義されているものとしています。
</P><PRE
CLASS="PROGRAMLISTING"
>-- この文は"WHERE is_active"という述語を使って、部分インデックスを
-- 推定できますが、単に"did"上の通常の一意制約を使うこともできます
INSERT INTO distributors (did, dname) VALUES (10, 'Conrad International')
    ON CONFLICT (did) WHERE is_active DO NOTHING;</PRE
><P>
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN88763"
></A
><H2
>互換性
  </H2
><P
><TT
CLASS="COMMAND"
>INSERT</TT
>は標準SQLに準拠します。
ただし、<TT
CLASS="LITERAL"
>RETURNING</TT
>句、<TT
CLASS="COMMAND"
>INSERT</TT
>で<TT
CLASS="LITERAL"
>WITH</TT
>が可能であること、<TT
CLASS="LITERAL"
>ON CONFLICT</TT
>で代替の動作を指定できることは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。
また、標準SQLでは、列名リストが省略された時に、<TT
CLASS="LITERAL"
>VALUES</TT
>句または<TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>で一部の列のみを指定することはできません。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>query</I
></TT
>句の制限については、<A
HREF="sql-select.html"
>SELECT</A
>にて記述されています。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-importforeignschema.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-listen.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>IMPORT FOREIGN SCHEMA</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>LISTEN</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
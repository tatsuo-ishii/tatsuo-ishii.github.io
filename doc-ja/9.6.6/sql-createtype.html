<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>CREATE TYPE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="CREATE TRIGGER"
HREF="sql-createtrigger.html"><LINK
REL="NEXT"
TITLE="CREATE USER"
HREF="sql-createuser.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="CREATE TRIGGER"
HREF="sql-createtrigger.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="CREATE USER"
HREF="sql-createuser.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-CREATETYPE"
></A
>CREATE TYPE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN83859"
></A
><H2
>名前</H2
>CREATE TYPE&nbsp;--&nbsp;新しいデータ型を定義する</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN83862"
></A
><H2
>概要</H2
><PRE
CLASS="SYNOPSIS"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> AS
    ( [ <TT
CLASS="REPLACEABLE"
><I
>attribute_name</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [, ... ] ] )

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> AS ENUM
    ( [ '<TT
CLASS="REPLACEABLE"
><I
>label</I
></TT
>' [, ... ] ] )

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> AS RANGE (
    SUBTYPE = <TT
CLASS="REPLACEABLE"
><I
>subtype</I
></TT
>
    [ , SUBTYPE_OPCLASS = <TT
CLASS="REPLACEABLE"
><I
>subtype_operator_class</I
></TT
> ]
    [ , COLLATION = <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ]
    [ , CANONICAL = <TT
CLASS="REPLACEABLE"
><I
>canonical_function</I
></TT
> ]
    [ , SUBTYPE_DIFF = <TT
CLASS="REPLACEABLE"
><I
>subtype_diff_function</I
></TT
> ]
)

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> (
    INPUT = <TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
>,
    OUTPUT = <TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
>
    [ , RECEIVE = <TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
> ]
    [ , SEND = <TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
> ]
    [ , TYPMOD_IN = <TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
> ]
    [ , TYPMOD_OUT = <TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
> ]
    [ , ANALYZE = <TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
> ]
    [ , INTERNALLENGTH = { <TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
> | VARIABLE } ]
    [ , PASSEDBYVALUE ]
    [ , ALIGNMENT = <TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
> ]
    [ , STORAGE = <TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
> ]
    [ , LIKE = <TT
CLASS="REPLACEABLE"
><I
>like_type</I
></TT
> ]
    [ , CATEGORY = <TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
> ]
    [ , PREFERRED = <TT
CLASS="REPLACEABLE"
><I
>preferred</I
></TT
> ]
    [ , DEFAULT = <TT
CLASS="REPLACEABLE"
><I
>default</I
></TT
> ]
    [ , ELEMENT = <TT
CLASS="REPLACEABLE"
><I
>element</I
></TT
> ]
    [ , DELIMITER = <TT
CLASS="REPLACEABLE"
><I
>delimiter</I
></TT
> ]
    [ , COLLATABLE = <TT
CLASS="REPLACEABLE"
><I
>collatable</I
></TT
> ]
)

CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN83895"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>は、現在のデータベースで使用できる新しいデータ型を登録します。
型を定義したユーザがその所有者となります。
  </P
><P
>スキーマ名が与えられている場合、型は指定されたスキーマに作成されます。
スキーマ名がなければ、その型は現在のスキーマに作成されます。
型名は、同じスキーマにある既存の型もしくはドメインとは、異なる名前にする必要があります
（さらに、テーブルはデータ型と関連しているため、データ型名は同じスキーマのテーブル名とも競合しないようにしてください）。
  </P
><P
>上の構文概要に示すように、<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>には５つの構文があります。
これらはそれぞれ、<I
CLASS="FIRSTTERM"
>複合型</I
>, <I
CLASS="FIRSTTERM"
>列挙型</I
>、<I
CLASS="FIRSTTERM"
>範囲型</I
>、<I
CLASS="FIRSTTERM"
>基本型</I
>、<I
CLASS="FIRSTTERM"
>シェル型</I
>を作成します。
これらの内最初の４個についてはここで順番に説明します。
シェル型は、後で定義される型用の単なるプレースホルダで、型名以外のパラメータをつけずに<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>を実行することで作成されます。
シェル型は、範囲型と基本型を作成するときの前方参照として必要となるもので、それぞれの節で説明します。
  </P
><DIV
CLASS="REFSECT2"
><A
NAME="AEN83908"
></A
><H3
>複合型</H3
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>の最初の構文を使用すると、複合型を作成できます。
複合型は、属性名およびデータ型のリストにより指定されます。
データ型の照合順序が設定可能である場合、属性の照合順序も指定することができます。
複合型は本質的にはテーブルの行型と同じです。
しかし、型を定義することだけが必要なのであれば、<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>を使用することで、実際のテーブルを作成する必要がなくなります。
スタンドアローンの複合型は、例えば関数の引数や戻り値の型として有用です。
  </P
><P
>複合型を作成するためには、すべての属性型に対して<TT
CLASS="LITERAL"
>USAGE</TT
>権限を持たなければなりません。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATETYPE-ENUM"
></A
><H3
>列挙型</H3
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>の2つ目の構文を使用すると、<A
HREF="datatype-enum.html"
>項8.7</A
>で説明する列挙型（enum）を作成します。
列挙型は、1つ以上の引用符付きのラベルのリストを取ります。
ラベルは<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>（<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の標準のビルドでは64バイト）バイトよりも少ない長さでなければなりません。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="SQL-CREATETYPE-RANGE"
></A
><H3
>範囲型</H3
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>の三番目の構文は、<A
HREF="rangetypes.html"
>項8.17</A
>で説明する範囲型を新規に作成します。
   </P
><P
>範囲型の<TT
CLASS="REPLACEABLE"
><I
>subtype</I
></TT
>は、関連する（範囲型の値を順序を決定するための）b-tree演算子クラスを持つ任意の型を取ることができます。
通常、派生元型のデフォルトのb-tree演算子クラスが順序を決定するために使用されます。
デフォルト以外の演算子クラスを使用するためには、<TT
CLASS="REPLACEABLE"
><I
>subtype_opclass</I
></TT
>でその名前を指定してください。
派生元型が照合順序変更可能であり、範囲の順序付けでデフォルト以外の照合順序を使用したい場合は、<TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
>オプションで使用したい照合順序を指定してください。
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>canonical</I
></TT
>関数(省略可能)は、定義する範囲型の引数を１つ取り、同じ型の値を返さなければなりません。
これは適切な時に範囲値を正規形式に変換するために使用されます。
詳細については<A
HREF="rangetypes.html#RANGETYPES-DEFINING"
>項8.17.8</A
>を参照してください。
<TT
CLASS="REPLACEABLE"
><I
>canonical</I
></TT
>関数を作成することは多少厄介です、というのは、範囲型を定義できるようになる前に定義されている必要があるからです。
このためには、まず、名前と所有者以外の属性を持たないプレースホルダであるシェル型を作成しなければなりません。
これは、他にパラメータをつけずに<TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
>を実行することで行われます。
その後、このシェル型を引数と結果として使用する関数を宣言することができます。
最後に同じ名前を用いて範囲型を宣言することができます。
これは自動的にシェル型の項目を有効な範囲型に置き換えます。
   </P
><P
><TT
CLASS="REPLACEABLE"
><I
>subtype_diff</I
></TT
>関数(省略可能)は、<TT
CLASS="REPLACEABLE"
><I
>subtype</I
></TT
>型の２つの値を引数として取り、与えられた２つの値の差異を表す<TT
CLASS="TYPE"
>double precision</TT
>型を返さなければなりません。
これは省略することができますが、提供することでその範囲型の列に対するGiSTインデックスの効率を大きく向上させることができます。
詳細については<A
HREF="rangetypes.html#RANGETYPES-DEFINING"
>項8.17.8</A
>を参照してください。
   </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN83942"
></A
><H3
>基本型</H3
><P
><TT
CLASS="COMMAND"
>CREATE TYPE</TT
>の４つ目の構文を使用すると、基本型（スカラ型）を新しく作成できます。
新しい基本型を作成するにはスーパーユーザでなければなりません。
（エラーがある型定義が混乱を招き、サーバがクラッシュすることすらあるため、この制限がなされました。）
  </P
><P
>パラメータは、上述の順番である必要はなく、任意の順番で指定することができ、多くは省略可能です。
型を定義する前に、（<TT
CLASS="COMMAND"
>CREATE FUNCTION</TT
>を用いて）2つ以上の関数を登録しておく必要があります。
サポート関数である<TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
>は必須です。
<TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
>関数、<TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
>関数、<TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>関数、<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>関数、および<TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
>関数は省略可能です。
通常、これらの関数は、C言語やその他の低レベル言語で作成されなければなりません。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
>は、型のテキストによる外部表現を内部表現形式に変換するものであり、その型用に定義される演算子や関数で使用されます。
<TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
>はこの逆の変換を行うものです。
入力関数は、1つの<TT
CLASS="TYPE"
>cstring</TT
>型の引数、あるいは、<TT
CLASS="TYPE"
>cstring</TT
>型、<TT
CLASS="TYPE"
>oid</TT
>型、<TT
CLASS="TYPE"
>integer</TT
>型という3つの引数を取るように宣言されます。
最初の引数にはC言語文字列の入力テキスト、2番目には型自体のOID（配列型の場合は例外で要素の型のOIDとなります）、3番目は、判明していれば対象列の<TT
CLASS="LITERAL"
>typmod</TT
>を渡します
（不明な場合は-1を渡します）。
この入力関数では、データ型自身の値を返さなければなりません。
通常入力関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でもエラーを発生させるのでなければ、関数はNULLを返さなければなりません。
（こうした状況はほとんどの場合、ドメイン入力関数をサポートすることを意図しています。ドメイン入力関数ではNULL入力を拒絶しなければならない可能性があります。）
出力関数は、新しいデータ型の引数を1つ取るように宣言しなければなりません。
出力関数は、<TT
CLASS="TYPE"
>cstring</TT
>型を返さなければなりません。
出力関数はNULL値に対して呼び出されることはありません。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
>では、型のバイナリによる外部表現を内部表現に変換します。この関数は省略可能です。
この関数が与えられない場合、この型ではバイナリ入力を行うことができません。
バイナリ表現の方法は、適度な可搬性を保ちつつ、内部表現への変換コストが小さくなるよう選択すべきです
（例えば標準の整数データ型は、外部バイナリ表現としてはネットワークバイトオーダを使用し、内部表現ではマシン固有のバイトオーダを使用します）。
この受信関数では、値が有効かどうかを判定するための適切な検査を行わなければなりません。
受信関数は、<TT
CLASS="TYPE"
>internal</TT
>型の引数1つ、または、<TT
CLASS="TYPE"
>internal</TT
>型と<TT
CLASS="TYPE"
>oid</TT
>、<TT
CLASS="TYPE"
>integer</TT
>型の3つの引数を取るように宣言されます。
最初の引数は受信したバイト文字列を保持する<TT
CLASS="TYPE"
>StringInfo</TT
>バッファへのポインタ、省略可能な引数は、テキスト入力関数の説明と同じです。
受信関数は、データ型自体の値を返す必要があります。
通常受信関数はSTRICTとして宣言しなければなりません。
そうしないと、NULLという入力値を読み取った時、NULLという最初のパラメータを持って呼び出されます。
この場合でも関数はエラーを発生させるのでなければNULLを返さなければなりません。
（こうした状況はほとんどの場合、ドメイン受信関数をサポートすることを意図しています。ドメイン受信関数ではNULL入力を拒絶しなければならない可能性があります。）
同様に、<TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
>は、内部表現からバイナリによる外部表現に変換します。この関数も省略可能です。
この関数が与えられない場合、この型ではバイナリ出力を行うことができません。
この送信関数は、新しいデータ型の引数1つを取るように宣言しなければなりません。
送信関数は<TT
CLASS="TYPE"
>bytea</TT
>型を返さなければなりません。
送信関数はNULL値に対して呼び出されません。
  </P
><P
>ここで、新しいデータ型を作成する前に入力関数と出力関数を作成する必要があるのに、どのようにしてそれらの関数で新しいデータ型を戻り値や入力として宣言できるのか、疑問に思うかもしれません。
その答えは、まず型が最初に<I
CLASS="FIRSTTERM"
>シェル型</I
>として定義されます。
これは名称と所有者以外の属性を持たないプレースホルダ型です。
これは、コマンド<TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
>を他にパラメータをつけずに発行することで行われます。
この後、Cの入出力関数をこのシェル型を参照するように定義することができます。
最後に完全な定義を持った<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>によって、シェル型の項目が完全かつ有効な型定義に置き換わり、新しい型を普通に使用することができるようになります。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>は必須ではありませんが、型が修飾子をサポートする場合は必要です。
修飾子とは、<TT
CLASS="LITERAL"
>char(5)</TT
>や<TT
CLASS="LITERAL"
>numeric(30,2)</TT
>などの型宣言に付与されるオプションの制約です。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では、ユーザ定義型が1つ以上の整数定数または識別子を修飾子として取ることができます。
しかし、この情報はシステムカタログに格納される時に0以上の整数1つにまとめられるものでなければなりません。
<TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>には、<TT
CLASS="TYPE"
>cstring</TT
>型配列の形で宣言された修飾子が渡されます。
その値について妥当性を検査しなければなりません（不当な場合はエラーとします）。
そして、正しい場合は、<SPAN
CLASS="QUOTE"
>"typmod"</SPAN
>列として格納される、0以上の<TT
CLASS="TYPE"
>integer</TT
>値を1つ返さなければなりません。
型が<TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
>を持たない場合、型修飾子は拒否されます。
<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>は内部的な整数typmod値をユーザ側の表示に合わせて変換します。
この関数は型名に付与する正確な文字列となる<TT
CLASS="TYPE"
>cstring</TT
>値を返さなければなりません。
たとえば<TT
CLASS="TYPE"
>numeric</TT
>用の関数では<TT
CLASS="LITERAL"
>(30,2)</TT
>を返すかもしれません。
デフォルトの表示用書式が保管されたtypmod整数値を括弧で括ったものと一致している場合は、<TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
>を省略することができます。

  </P
><P
>オプションの<TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
>は、このデータ型の列に対する、型固有の統計情報の収集を行います。
その型用のデフォルトのB-tree演算子クラスがあれば、<TT
CLASS="COMMAND"
>ANALYZE</TT
>はデフォルトでは型の<SPAN
CLASS="QUOTE"
>"等価"</SPAN
>演算子と<SPAN
CLASS="QUOTE"
>"小なり"</SPAN
>演算子を使用して統計情報を集めようと試みます。
非スカラ型には、この振舞いはあまり適していません。
そのため、独自の解析関数を指定することで、この振舞いを上書きすることができます。
この解析関数は、<TT
CLASS="TYPE"
>internal</TT
>型の引数を1つ取り、戻り値として<TT
CLASS="TYPE"
>boolean</TT
>を返すように宣言する必要があります。
解析関数用のAPIの詳細は、<TT
CLASS="FILENAME"
>src/include/commands/vacuum.h</TT
>にあります。
  </P
><P
>新しい型の内部表現の詳細を理解しなければならないのは、これらのI/O関数とその型に関連して動作するユーザ定義の関数のみですが、内部表現には、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に対し宣言しなければならない複数の属性値があります。
属性の中で最も重要なものは<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>です。
基本データ型は、<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>に正の整数を指定して固定長として作成するだけでなく、<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>に<TT
CLASS="LITERAL"
>VARIABLE</TT
>と設定し可変長として作成することもできます
（内部的には、これは<TT
CLASS="LITERAL"
>typlen</TT
>を-1に設定することで表現されます）。
全ての可変長型の内部表現は、型の値の全長を示す4バイトの整数値から始まらなければなりません。
（長さフィールドは多くの場合<A
HREF="storage-toast.html"
>項65.2</A
>に記述されているようにエンコードされており、それに直接アクセスすることは賢明ではないことに注意してください。）
  </P
><P
>オプションの<TT
CLASS="OPTION"
>PASSEDBYVALUE</TT
>フラグは、このデータ型の値が参照ではなく値によって渡されることを示します。
値によって渡される型は固定長でなければならず、その内部表現は<TT
CLASS="TYPE"
>Datum</TT
>型のサイズ（4バイトのマシンもあれば8バイトのマシンもあります）を超えてはいけません。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
>パラメータは、そのデータ型の格納の際に必要な整列を指定します。
設定可能な値は、1、2、4、8バイト境界での整列です。
可変長の型は最低でも4の整列を持たなければならないことに注意してください。
最初の要素として<TT
CLASS="TYPE"
>int4</TT
>を持たなければならないからです。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>パラメータを使用することで、可変長データ型を格納する際の戦略を選択することができます
（固定長の型には<TT
CLASS="LITERAL"
>plain</TT
>のみが使用できます）。
<TT
CLASS="LITERAL"
>plain</TT
>を指定すると、その型のデータは常にインラインで格納され、圧縮されません。
<TT
CLASS="LITERAL"
>extended</TT
>を指定すると、システムはまず長いデータ値を圧縮しようとし、それでもまだ長過ぎる場合は値をメインテーブルの行から削除して移動します。
<TT
CLASS="LITERAL"
>external</TT
>はメインテーブルから値を削除して移動することを許しますが、システムはデータを圧縮しようとしません。
<TT
CLASS="LITERAL"
>main</TT
>はデータの圧縮を許しますが、できるだけ値をメインテーブルから削除しないようにします
（行を収めるために他に方法がない場合にはメインテーブルから削除されてしまう可能性がありますが、<TT
CLASS="LITERAL"
>extended</TT
>や<TT
CLASS="LITERAL"
>external</TT
>が指定されたアイテムよりも優先してメインテーブルに残されます）。
  </P
><P
><TT
CLASS="LITERAL"
>plain</TT
>を除くすべての<TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>の値は、そのデータ型の関数が、<A
HREF="storage-toast.html"
>項65.2</A
>および<A
HREF="xtypes.html#XTYPES-TOAST"
>項36.11.1</A
>に記述されているように<I
CLASS="FIRSTTERM"
>toast</I
>された値を処理できることを暗示します。
その他の特定の値を指定するのは、TOAST可能なデータ型の列について、単にデフォルトのTOAST戦略を決めるだけです。
ユーザは個々の列について<TT
CLASS="LITERAL"
>ALTER TABLE SET STORAGE</TT
>を使って他の戦略を選択できます。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>like_type</I
></TT
>パラメータは、何らかの既存のデータ型から複製するという、データ型の基本表現プロパティを指定する、別の方法を提供します。
<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>passedbyvalue</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>の値が指定された型から複製されます。
（通常は望ましくありませんが、<TT
CLASS="LITERAL"
>LIKE</TT
>句と一緒にこれらの値を指定することで、値を上書きすることも可能です。）
新しい型の低レベル実装にある流儀に従った既存の型を<SPAN
CLASS="QUOTE"
>"移す"</SPAN
>時に、この方法で表現を指定することが特に有用です。
  </P
><P
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
>と<TT
CLASS="REPLACEABLE"
><I
>preferred</I
></TT
>パラメータは、あいまいな状況でどの暗黙的なキャストが適用されるかについての制御を補助するために使用することができます。
各データ型は単一のASCII文字で命名されるカテゴリに属しており、各型はそのカテゴリ内で<SPAN
CLASS="QUOTE"
>"優先される（preferred）"</SPAN
>か否かです。
オーバーロードされた関数または演算子の解決に、この規則が有用な場合には、パーサは優先される型へのキャストを優先します（ただし、同一のカテゴリ内の他の型からだけです）。
より詳細は<A
HREF="typeconv.html"
>第10章</A
>を参照してください。
他の型への、または、ほかの型からの暗黙的なキャストを持たない型では、これらの設定をデフォルトのままにしておくことで十分です。
しかし、暗黙的なキャストを持つ関連する型のグループでは、それらすべてを1つのカテゴリに属すものとし、<SPAN
CLASS="QUOTE"
>"最も汎用的な"</SPAN
>型の1つまたは2つをカテゴリ内で優先されるものとして選択することが有用となる場合が多くあります。
ユーザ定義型を、数値型や文字列型などの既存の組み込みカテゴリに追加する場合に、<TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
>パラメータは特に有用です。
しかし、完全にユーザ定義の新しい型カテゴリを作成することもできます。
そのようなカテゴリの命名には大文字以外の任意のASCII文字を選択してください。
  </P
><P
>ユーザがそのデータ型の列のデフォルトをNULL以外にしたい場合は、デフォルト値を指定することができます。
デフォルト値は<TT
CLASS="OPTION"
>DEFAULT</TT
>キーワードで指定してください
（この方法で指定されたデフォルト値を、特定の列に付与された、明示的な<TT
CLASS="OPTION"
>DEFAULT</TT
>句によって上書きすることができます）。
  </P
><P
>データ型が配列であることを示すには、<TT
CLASS="OPTION"
>ELEMENT</TT
>キーワードを使用して配列要素の型を指定してください。
例えば、4バイト整数（<TT
CLASS="TYPE"
>int4</TT
>）の配列を定義するには、<TT
CLASS="LITERAL"
>ELEMENT = int4</TT
>と指定してください。
配列型の詳細は後述します。
  </P
><P
>この型による配列の外部形式における値間の区切り文字を示すために、<TT
CLASS="REPLACEABLE"
><I
>delimiter</I
></TT
>で特定の文字を設定することができます。
デフォルトの区切り文字はカンマ（'<TT
CLASS="LITERAL"
>,</TT
>'）です。
この区切り文字は、配列要素の型に関係するものであり、配列型自体に関係するものでないことに注意してください。
  </P
><P
>論理型の<TT
CLASS="REPLACEABLE"
><I
>collatable</I
></TT
>パラメータ(省略可能)が真の場合、<TT
CLASS="LITERAL"
>COLLATE</TT
>句を使用することによって、型の列定義と式は照合順序情報を持つことができます。
照合順序情報を実際に使用するかどうかは、型に対する操作を行う関数実装に任されています。
照合順序を設定可能な型を作成することにより、これが自動的に行われることはありません。
  </P
></DIV
><DIV
CLASS="REFSECT2"
><A
NAME="AEN84060"
></A
><H3
>配列型</H3
><P
>ユーザ定義型が作成されると、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、自動的に関連する配列型を作成します。
その要素型の名前の前にアンダースコアを付け、必要に応じて<TT
CLASS="SYMBOL"
>NAMEDATALEN</TT
>長より短くなるように切り詰められた名前になります。
（こうして付けられた名前が既存の型名と競合する場合、競合する名称がなくなるまでこの処理が繰り返されます。）
この暗黙的に作成される配列型は可変長で、組み込み入出力関数<TT
CLASS="LITERAL"
>array_in</TT
>と<TT
CLASS="LITERAL"
>array_out</TT
>を使用します。
配列型はその要素となる型の所有者とスキーマのなんらかの変更に追従し、また、要素となる型が削除された場合に削除されます。
   </P
><P
>「システムが自動的に配列型を正しく作成するのであれば、<TT
CLASS="OPTION"
>ELEMENT</TT
>オプションはどうして存在するのだろう」と疑問に思うのも道理です。
<TT
CLASS="OPTION"
>ELEMENT</TT
>が意味を持つ、唯一の場合は次のような条件を満たす固定長の型を作成する時です。
その条件とは、内部的に複数の同一の要素からなる配列となっていること、その配列に対して添字を指定して直接アクセスできること、加えて、今後作成する型全体に対する操作がどのようなものであっても、それらから直接アクセスできることです。
例えば、<TT
CLASS="TYPE"
>point</TT
>型は、2つの浮動小数点だけから構成され、それらは<TT
CLASS="LITERAL"
>point[0]</TT
>および<TT
CLASS="LITERAL"
>point[1]</TT
>を用いてアクセスすることができます。
この機能は、その内部形式が同一の固定長フィールドの正確な並びである、固定長の型でのみ動作することに注意してください。
添字による指定が可能な可変長型は、<TT
CLASS="LITERAL"
>array_in</TT
>と<TT
CLASS="LITERAL"
>array_out</TT
>を使用して、一般化された内部表現を持つ必要があります。
歴史的な理由（明らかに間違いなのですが、変更するには遅すぎたため）により、固定長配列型への要素番号指定は0から始まり、可変長配列の場合は1から始まります。
   </P
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN84075"
></A
><H2
>パラメータ</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>作成するデータ型の名前です（スキーマ修飾名も可）。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>attribute_name</I
></TT
></DT
><DD
><P
>複合型用の属性（列）名です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
></DT
><DD
><P
>複合型の列となる、既存のデータ型の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
></DT
><DD
><P
>複合型の列または範囲型に関連付けされる、既存の照合順序の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>label</I
></TT
></DT
><DD
><P
>列挙型の1つの値に関連付けられるテキスト形式のラベルを表す、文字列リテラルです。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>subtype</I
></TT
></DT
><DD
><P
>範囲型がその範囲の対象として表現する、要素型の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>subtype_operator_class</I
></TT
></DT
><DD
><P
>派生元型のb-tree演算子クラスの名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>canonical_function</I
></TT
></DT
><DD
><P
>範囲型の正規化関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>subtype_diff_function</I
></TT
></DT
><DD
><P
>派生元型の差異をとる関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>input_function</I
></TT
></DT
><DD
><P
>指定された型のテキストによる外部形式のデータを内部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>output_function</I
></TT
></DT
><DD
><P
>指定された型の内部形式のデータをテキストによる外部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>receive_function</I
></TT
></DT
><DD
><P
>指定された型のバイナリによる外部形式のデータを内部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>send_function</I
></TT
></DT
><DD
><P
>指定された型の内部形式のデータをバイナリによる外部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>type_modifier_input_function</I
></TT
></DT
><DD
><P
>型に関する修飾子の配列を内部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>type_modifier_output_function</I
></TT
></DT
><DD
><P
>内部形式の型修飾子をテキストの外部形式に変換する関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>analyze_function</I
></TT
></DT
><DD
><P
>指定したデータ型の統計情報解析を行う関数の名前です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
></DT
><DD
><P
>新しいデータ型の内部表現のバイト長を表す数値定数です。
デフォルトでは、可変長であるとみなされます。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
></DT
><DD
><P
>データ型の格納整列条件です。
このオプションを指定する場合は、<TT
CLASS="LITERAL"
>char</TT
>、<TT
CLASS="LITERAL"
>int2</TT
>、<TT
CLASS="LITERAL"
>int4</TT
>、<TT
CLASS="LITERAL"
>double</TT
>のいずれかでなければなりません。
デフォルトは<TT
CLASS="LITERAL"
>int4</TT
>です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
></DT
><DD
><P
>データ型の格納戦略です。
このオプションを指定する場合は、<TT
CLASS="LITERAL"
>plain</TT
>、<TT
CLASS="LITERAL"
>external</TT
>、<TT
CLASS="LITERAL"
>extended</TT
>、<TT
CLASS="LITERAL"
>main</TT
>のいずれかでなければなりません。
デフォルトは<TT
CLASS="LITERAL"
>plain</TT
>です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>like_type</I
></TT
></DT
><DD
><P
>新しい型に同じ表現を持たせる既存のデータ型の名前です。
<TT
CLASS="REPLACEABLE"
><I
>internallength</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>passedbyvalue</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>alignment</I
></TT
>、<TT
CLASS="REPLACEABLE"
><I
>storage</I
></TT
>の値が、この<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>コマンドのどこかで明示的な指定により上書きされない限り、型から複製されます。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>category</I
></TT
></DT
><DD
><P
>この型用のカテゴリコード（単一のASCII文字）です。
デフォルトは<SPAN
CLASS="QUOTE"
>"ユーザ定義型"</SPAN
>を表す<TT
CLASS="LITERAL"
>'U'</TT
>です。
他の標準カテゴリコードを<A
HREF="catalog-pg-type.html#CATALOG-TYPCATEGORY-TABLE"
>表50-56</A
>に示します。
独自のカテゴリを作成するために他のASCII文字を選択することもできます。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>preferred</I
></TT
></DT
><DD
><P
>この型がカテゴリ内で優先される型である場合に真、さもなくば偽です。
デフォルトは偽です。
動作に予想外の変化を引き起こしますので既存の型カテゴリに新しく優先される型を作成することには十分注意してください。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>default</I
></TT
></DT
><DD
><P
>そのデータ型のデフォルト値です。
省略された場合、デフォルトはNULLです。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>element</I
></TT
></DT
><DD
><P
>配列型を作成する場合、その配列の要素の型を指定します。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>delimiter</I
></TT
></DT
><DD
><P
>このデータ型による配列で、値間の区切り文字として使われる文字です。
     </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>collatable</I
></TT
></DT
><DD
><P
>この型を操作する時に照合順序情報を使用することができる場合に真を取ります。
デフォルトは偽です。
     </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-NOTES"
></A
><H2
>注釈</H2
><P
>一度作成したデータ型の使用には制限はありませんので、基本型または範囲型の作成は型定義で言及した関数の実行権をPUBLICに対して付与することと同じです。
この種の型定義において有用な関数では、これは通常問題になりません。
しかし、外部形式から、または、外部形式への変換を行う時に、その関数が<SPAN
CLASS="QUOTE"
>"秘密の"</SPAN
>情報を必要とする場合、型を設計する前に熟考してください。
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>バージョン8.3より前のバージョンでは、生成される配列型の名前は常に要素型の名前の前に１つのアンダースコア文字（<TT
CLASS="LITERAL"
>_</TT
>）を付けたものになりました。
（このため型の名前は他の名前よりも1文字短く制限されていました。）
通常はこのように名付けられることは変わりありませんが、最大長の名前の場合やアンダースコアから始まるユーザ定義の型と競合する場合、配列型の名前はこの変換とは変わることがあります。
このため、この規則に依存したコードを書くことは避けてください。
代わりに、<TT
CLASS="STRUCTNAME"
>pg_type</TT
>.<TT
CLASS="STRUCTFIELD"
>typarray</TT
>を使用して、指定した型に関連した配列型を特定してください。
  </P
><P
>アンダースコアから始まる型やテーブル名の使用を避けることが賢明です。
サーバは生成された配列型名称をユーザ指定の名前と競合しないように変更しますが、混乱する危険があります。
特に古いクライアントソフトウェアを使用する場合、名前がアンダースコアから始まる型を常に配列を表すものと想定しているかもしれません。
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>バージョン8.2より前まででは、シェル型を作成する<TT
CLASS="LITERAL"
>CREATE TYPE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></TT
>構文は存在しません。
新規に基本型を作成する方法は、最初に入力関数を作成することでした。
この方法では、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は新しいデータ型の名称を、入力関数の戻り値型で初めて見ます。
このときに、シェル型が暗黙的に作成され、残りの入出力関数の定義で参照することができます。
この方法もまだ使用できますが、廃止予定であり、将来のリリースで禁止される可能性があります。
また、関数定義における単純なタイプミスの結果作成されるシェル型によって起こるカタログの混乱を防止するため、入力関数がCで作成された場合にのみこの方法によってシェル型が作成されます。
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.3より前のバージョンでは、関数の下位参照を、プレースホルダとなる疑似データ型である<TT
CLASS="TYPE"
>opaque</TT
>型のデータ型名と置き換えることによって、shell型を作成することを完全に、慣習的に避けていました。
また、7.3より前のバージョンでは、<TT
CLASS="TYPE"
>cstring</TT
>型の引数および結果も<TT
CLASS="TYPE"
>opaque</TT
>型として宣言する必要がありました。
古いダンプファイルのロードをサポートするため、<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>では<TT
CLASS="TYPE"
>opaque</TT
>型を使用するよう宣言された入出力関数を受け入れます。
しかし、注意を促すメッセージを表示し、正しいデータ型を使用するように関数の宣言を変更します。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN84248"
></A
><H2
>例</H2
><P
>次の例では、複合型を作成し、それを関数定義で使用します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE compfoo AS (f1 int, f2 text);

CREATE FUNCTION getfoo() RETURNS SETOF compfoo AS $$
    SELECT fooid, fooname FROM foo
$$ LANGUAGE SQL;</PRE
><P>
  </P
><P
>次の例では、列挙型を作成し、それをテーブル定義に使用します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE bug_status AS ENUM ('new', 'open', 'closed');

CREATE TABLE bug (
    id serial,
    description text,
    status bug_status
);</PRE
><P>
  </P
><P
>次の例では、範囲型を作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE float8_range AS RANGE (subtype = float8, subtype_diff = float8mi);</PRE
><P>
  </P
><P
>次の例では、基本データ型<TT
CLASS="TYPE"
>box</TT
>を作成し、その型をテーブル定義の中で使用しています。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE box;

CREATE FUNCTION my_box_in_function(cstring) RETURNS box AS ... ;
CREATE FUNCTION my_box_out_function(box) RETURNS cstring AS ... ;

CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function
);

CREATE TABLE myboxes (
    id integer,
    description box
);</PRE
><P>
  </P
><P
><TT
CLASS="TYPE"
>box</TT
>型の内部構造が<TT
CLASS="TYPE"
>float4</TT
>型が4つの配列の場合、このように書き換えることもできます。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE box (
    INTERNALLENGTH = 16,
    INPUT = my_box_in_function,
    OUTPUT = my_box_out_function,
    ELEMENT = float4
);</PRE
><P>
このようにすると、box値の要素に要素番号でアクセスできます。
その他は、上の例と同様の動作をします。
  </P
><P
>次の例では、ラージオブジェクト型を作成し、テーブル定義にてそれを使用します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE TYPE bigobj (
    INPUT = lo_filein, OUTPUT = lo_fileout,
    INTERNALLENGTH = VARIABLE
);
CREATE TABLE big_objs (
    id integer,
    obj bigobj
);</PRE
><P>
  </P
><P
>その他の例は、<A
HREF="xtypes.html"
>項36.11</A
>を参照してください。ここには、入力関数、出力関数などを使った例があります。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-COMPATIBILITY"
></A
><H2
>互換性</H2
><P
>複合型を作成する、最初の<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>コマンドの構文は標準<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>に従います。
他の構文は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。
標準<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>ではまた他の<TT
CLASS="COMMAND"
>CREATE TYPE</TT
>構文を定義していますが、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では実装されていません。
  </P
><P
>ゼロ個の要素を持つ複合型を作成する機能は標準から派生した<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>固有のもの（<TT
CLASS="COMMAND"
>CREATE TABLE</TT
>の場合と同様）です。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="SQL-CREATETYPE-SEE-ALSO"
></A
><H2
>関連項目</H2
><A
HREF="sql-altertype.html"
>ALTER TYPE</A
>, <A
HREF="sql-createdomain.html"
>CREATE DOMAIN</A
>, <A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>, <A
HREF="sql-droptype.html"
>DROP TYPE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-createtrigger.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-createuser.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>CREATE TRIGGER</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>CREATE USER</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>関数の変動性分類</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLの拡張"
HREF="extend.html"><LINK
REL="PREVIOUS"
TITLE="関数のオーバーロード"
HREF="xfunc-overload.html"><LINK
REL="NEXT"
TITLE="手続き型言語関数"
HREF="xfunc-pl.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="関数のオーバーロード"
HREF="xfunc-overload.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 36章<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の拡張</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="手続き型言語関数"
HREF="xfunc-pl.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="XFUNC-VOLATILITY"
>36.6. 関数の変動性分類</A
></H1
><P
>すべての関数は<I
CLASS="FIRSTTERM"
>変動性</I
>区分を持ちます。
取り得る区分は、<TT
CLASS="LITERAL"
>VOLATILE</TT
>、<TT
CLASS="LITERAL"
>STABLE</TT
>、もしくは<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>です。
<A
HREF="sql-createfunction.html"
>CREATE FUNCTION</A
>コマンドで分類の指定がなければデフォルトで<TT
CLASS="LITERAL"
>VOLATILE</TT
>になります。
変動性に関する分類は、その関数の動作に関するオプティマイザへの約束事です。

   <P
></P
></P><UL
><LI
><P
><TT
CLASS="LITERAL"
>VOLATILE</TT
>関数は、データベースの変更を含む、すべてを行うことができます。
同一引数で続けて呼び出したとしても異なる結果を返すことができます。
オプティマイザはこうした関数の振舞いに対する前提を持ちません。
VOLATILE関数を使用した問い合わせは、その行の値を必要とするすべての行においてその関数を再評価します。
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>STABLE</TT
>関数はデータベースを変更することができません。
また、単一の文内ですべての行に対して同一の引数を渡した場合に同一の結果を返すことが保証されています。
この区分により、オプティマイザは複数の関数の呼び出しを１つの呼び出しに最適化することができます。
特に、インデックススキャン条件内でこうした関数を含んだ式を使用することは安全です。
（インデックススキャンは行ごとに一度ではなく、一度だけ比較値の評価を行いますので、インデックススキャン条件内で<TT
CLASS="LITERAL"
>VOLATILE</TT
>関数を使用することは意味がありません。）
     </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>IMMUTABLE</TT
>関数はデータベースを変更することができません。
また、同一引数に対する呼び出しは常に同一の結果を返すことが保証されています。
問い合わせが定数の引数でこうした関数を呼び出した場合、オプティマイザはこの関数を事前に評価することができます。
例えば、<TT
CLASS="LITERAL"
>SELECT ... WHERE x = 2 + 2</TT
>といった問い合わせは、<TT
CLASS="LITERAL"
>SELECT ... WHERE x = 4</TT
>のように単純化することができます。
これは、整数加算演算子の基になる関数が<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>として宣言されているためです。
     </P
></LI
></UL
><P>
   </P
><P
>最適化の結果を最善にするためには、関数に対して有効かつ最も厳密な変動性区分を付けなければなりません。
   </P
><P
>副作用を持つ関数はすべて<TT
CLASS="LITERAL"
>VOLATILE</TT
>と付けなければなりません。
こうした関数は最適化することができないためです。
関数が副作用を持たなかったとしても、単一問い合わせ内で値が変動する場合は<TT
CLASS="LITERAL"
>VOLATILE</TT
>と付けなければなりません。
例えば、<TT
CLASS="LITERAL"
>random()</TT
>、<TT
CLASS="LITERAL"
>currval()</TT
>、<TT
CLASS="LITERAL"
>timeofday()</TT
>などです。
   </P
><P
>その他の重要な例は、<CODE
CLASS="FUNCTION"
>current_timestamp</CODE
>系列の関数は、それらの値がトランザクション内で変わらないことから、<TT
CLASS="LITERAL"
>STABLE</TT
>と見なされます。
   </P
><P
>計画作成を行い、すぐに実行されるような単一の対話式問い合わせを考えた場合、相対的に<TT
CLASS="LITERAL"
>STABLE</TT
>区分と<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>区分との違いはあまりありません。
このような場合、関数が計画作成中に一度実行されるか、問い合わせ実行中に一度実行されるかがあまり問題になりません。
しかし、計画が保存され、後で再利用される場合は大きな違いが現れます。
本来ならば関数が計画作成段階で早めに定数を保持することができない場合に<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>を付けると、その後にこの計画を使用する時に古くて意味のない値が再利用されてしまうことになります。
これは、プリペアド文や計画をキャッシュする関数言語（<SPAN
CLASS="APPLICATION"
>PL/pgSQL</SPAN
>など）を使用する場合は危険です。
   </P
><P
>SQLもしくは標準手続き言語で作成された関数では、変動性分類で決定される２番目に重要な性質があります。
すなわち、その関数を呼び出すSQLコマンドによりなされてきたすべてのデータ変更の可視性です。
<TT
CLASS="LITERAL"
>VOLATILE</TT
>関数はそのような変更を捕らえますが、<TT
CLASS="LITERAL"
>STABLE</TT
>または<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>関数はそうしません。
この動作はMVCC（<A
HREF="mvcc.html"
>第13章</A
>を参照）のスナップショット処理の動作を使用して実装されています。
<TT
CLASS="LITERAL"
>STABLE</TT
>と<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>関数は、呼び出す問い合わせの開始時点で成立したスナップショットを使用しますが、<TT
CLASS="LITERAL"
>VOLATILE</TT
>関数はそれぞれの問い合わせの実行開始時点の作りたてのスナップショットを取得します。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>しかし、C言語で作成された関数は、どのようにでもスナップショットを管理することができますが、通常C関数でもこのように動作させることは良い考えです。
    </P
></BLOCKQUOTE
></DIV
><P
>このスナップショット処理の動作のため、同時実行の問い合わせによって別途変更されている可能性があるテーブルから選択していたとしても、<TT
CLASS="COMMAND"
>SELECT</TT
>コマンドのみを含む関数は、安全に<TT
CLASS="LITERAL"
>STABLE</TT
>とすることができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、呼び出し元の問い合わせに対して確立されたスナップショットを使用して<TT
CLASS="LITERAL"
>STABLE</TT
>関数のすべてのコマンドを実行します。
したがってその問い合わせの間、データベースに対して固定された視点で値を参照することになります。
   </P
><P
><TT
CLASS="LITERAL"
>IMMUTABLE</TT
>関数内の<TT
CLASS="COMMAND"
>SELECT</TT
>コマンドも同様のスナップショット処理の動作を使用します。
ただし、一般的に、<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>関数内でデータベースのテーブルを検索（SELECT）することは勧められません。
テーブルの内容が変わってしまった場合にその不変性が壊れてしまうためです。
しかし、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では強制的に検索（SELECT）できないようにはしていません。
   </P
><P
>よくあるエラーは、設定パラメータに依存する結果となる関数に<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>と付けることです。
例えば、タイムスタンプを操作する関数は、おそらく<A
HREF="runtime-config-client.html#GUC-TIMEZONE"
>TimeZone</A
>の設定に依存した結果になります。
こうした関数は、安全のため代わりに<TT
CLASS="LITERAL"
>STABLE</TT
>と付けてください。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はデータの変更を防ぐために<TT
CLASS="LITERAL"
>STABLE</TT
>関数と<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>関数が<TT
CLASS="COMMAND"
>SELECT</TT
>以外のSQLコマンドを含まないことを要求します。
（こうした関数はまだデータベースを変更する<TT
CLASS="LITERAL"
>VOLATILE</TT
>関数を呼び出すことができますので、これは防弾条件として完全ではありません。
これを行うと、<TT
CLASS="LITERAL"
>STABLE</TT
>もしくは<TT
CLASS="LITERAL"
>IMMUTABLE</TT
>関数は、そのスナップショットからそれらが隠されていることから、呼び出した関数によるデータベースの変更に気がつきません。）
    </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="xfunc-overload.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="xfunc-pl.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>関数のオーバーロード</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="extend.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>手続き型言語関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>どのような時にパラレルクエリは使用できるのか？</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="パラレルクエリ"
HREF="parallel-query.html"><LINK
REL="PREVIOUS"
TITLE="パラレルクエリはどのように動くのか"
HREF="how-parallel-query-works.html"><LINK
REL="NEXT"
TITLE="パラレルプラン"
HREF="parallel-plans.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="パラレルクエリはどのように動くのか"
HREF="how-parallel-query-works.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="parallel-query.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 15章パラレルクエリ</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="パラレルプラン"
HREF="parallel-plans.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WHEN-CAN-PARALLEL-QUERY-BE-USED"
>15.2. どのような時にパラレルクエリは使用できるのか？</A
></H1
><P
>どのような状況においても、プランナにパラレルクエリプランを生成させなくしてしまう設定があります。
とにかくパラレルクエリプランを生成させるためには、次に示すように設定しなければなりません。
  </P
><P
></P
><UL
><LI
><P
><A
HREF="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER"
>max_parallel_workers_per_gather</A
>は0より大きい値に設定しなければなりません。
<TT
CLASS="VARNAME"
>max_parallel_workers_per_gather</TT
>で設定した数以上のワーカーは使用されないという一般原則に含まれる個別のケースです。
      </P
></LI
><LI
><P
><A
HREF="runtime-config-resource.html#GUC-DYNAMIC-SHARED-MEMORY-TYPE"
>dynamic_shared_memory_type</A
>は<TT
CLASS="LITERAL"
>none</TT
>以外に設定しなければなりません。
パラレルクエリは、協調動作するプロセスの間でデータのやり取りを行うために、動的な共有メモリが必要です。
      </P
></LI
></UL
><P
>加えて、システムはシングルユーザーモードで動いていてはいけません。
この場合はデータベースシステム全体が一つのプロセスで動いているので、バックグラウンドワーカーが使えません。
  </P
><P
>一般にパラレルクエリプランが生成可能な場合でも、以下のうち一つでも真であると、プランナはクエリに対するパラレルクエリプランを生成しません。
  </P
><P
></P
><UL
><LI
><P
> 
クエリがデータを書き込むか、データベースの行をロックする場合。
クエリがデータ更新操作をトップレベルあるいはCTE内で含むと、そのクエリに対するパラレルプランは生成されません。
これは現在の実装の制限で、将来のリリースでは解除される可能性があります。
      </P
></LI
><LI
><P
>クエリが実行中に一時停止する場合。
クエリの一部あるいは増分の実行が発生するとシステムが判断すると、パラレルプランは生成されません。
たとえば、<A
HREF="sql-declare.html"
>DECLARE CURSOR</A
>で作られるカーソルは、決してパラレルプランを使用しません。
同様に、<TT
CLASS="LITERAL"
>FOR X IN QUERY LOOP .. END LOOP</TT
>のPL/pgsqlループは、決してパラレルプランを使用しません。
パラレルクエリが実行中に、ループの中のコードを実行しても安全かどうか、パラレルクエリシステムが判断できないからです。
      </P
></LI
><LI
><P
>クエリが<TT
CLASS="LITERAL"
>PARALLEL UNSAFE</TT
>とマーク付されている関数を使っています。
ほとんどのシステム定義の関数は<TT
CLASS="LITERAL"
>PARALLEL SAFE</TT
>です。
しかし、ユーザ定義関数はデフォルトで<TT
CLASS="LITERAL"
>PARALLEL UNSAFE</TT
>とマーク付されます。
<A
HREF="parallel-safety.html"
>項15.4</A
>の議論をご覧ください。
      </P
></LI
><LI
><P
>クエリが、すでにパラレル実行している別のクエリの内部で走っている場合。
たとえば、パラレルクエリから呼ばれている関数自身がSQLクエリを発行すると、そのクエリは決してパラレルプランを使用しません。
これは現在の実装の制限によるものですが、この制限を取り外すのは好ましくないかもしれません。
なぜなら、単一のクエリが非常に大きな数のプロセスを使用する結果となることがあり得るからです。
      </P
></LI
><LI
><P
>トランザクション分離レベルがシリアライザブルである場合。
これは現在の実装の制限によるものです。
      </P
></LI
></UL
><P
>あるクエリに対してパラレルクエリプランが生成された場合でも、実行時にプランを並列に実行できないような状況があります。
この状況においては、まるで<TT
CLASS="LITERAL"
>Gather</TT
>ノードが存在しなかったかのように、リーダは<TT
CLASS="LITERAL"
>Gather</TT
>ノード以下部分のプランのすべてを自分自身で実行します。
これは、以下の条件のどれかが当てはまると起こります。
  </P
><P
></P
><UL
><LI
><P
> 
バックグラウンドワーカー数の合計が<A
HREF="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES"
>max_worker_processes</A
>を超えてはいけない、という制限によってバックグラウンドワーカーが得られない場合。
      </P
></LI
><LI
><P
> 
クライアントが0ではないフェッチカウント付きのExecuteメッセージを送信した場合。
<A
HREF="protocol-flow.html#PROTOCOL-FLOW-EXT-QUERY"
>拡張問い合わせプロトコル</A
>の議論をご覧ください。
現在の<A
HREF="libpq.html"
>libpq</A
>にはそのようなメッセージを送る方法がないため、これはlibpqに依存しないクライアントを使った時にだけ起こります。
これが頻繁に起こるようなら、順次実行したときに最適ではないプランが生成されるのを防ぐために、それが起こりそうなセッションの中で、<A
HREF="runtime-config-resource.html#GUC-MAX-PARALLEL-WORKERS-PER-GATHER"
>max_parallel_workers_per_gather</A
>を設定すると良いかもしれません。
      </P
></LI
><LI
><P
> 
準備された文が<TT
CLASS="LITERAL"
>CREATE TABLE .. AS EXECUTE ..</TT
>文を使って実行される場合。
この構文は、読み取り専用操作であったはずのものを、読み書き操作に変換し、パラレルクエリには適さないものにします。
      </P
></LI
><LI
><P
>トランザクション分離レベルがシリアライザブルである場合。
この状況は通常は起こりません。
なぜならトランザクション分離レベルがシリアライザブルのときにはパラレルクエリプランは生成されないからです。
しかし、プランが生成されてから、実行されるまでの間にトランザクション分離レベルが変更されると起こる可能性があります。
      </P
></LI
></UL
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="how-parallel-query-works.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="parallel-plans.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>パラレルクエリはどのように動くのか</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="parallel-query.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>パラレルプラン</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
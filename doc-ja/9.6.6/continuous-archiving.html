<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>継続的アーカイブとポイントインタイムリカバリ（PITR）</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.6.5文書"
HREF="index.html"><LINK
REL="UP"
TITLE="バックアップとリストア"
HREF="backup.html"><LINK
REL="PREVIOUS"
TITLE="ファイルシステムレベルのバックアップ"
HREF="backup-file.html"><LINK
REL="NEXT"
TITLE="高可用性、負荷分散およびレプリケーション"
HREF="high-availability.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2018-02-10T07:29:51"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.6.5文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="ファイルシステムレベルのバックアップ"
HREF="backup-file.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 25章バックアップとリストア</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="高可用性、負荷分散およびレプリケーション"
HREF="high-availability.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="CONTINUOUS-ARCHIVING"
>25.3. 継続的アーカイブとポイントインタイムリカバリ（PITR）</A
></H1
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は常に、クラスタのデータディレクトリ以下の<TT
CLASS="FILENAME"
>pg_xlog/</TT
>ディレクトリ内で<I
CLASS="FIRSTTERM"
>先行書き込みログ</I
>（WAL）を管理しています。
このログはデータベースのデータファイルに行われた全ての変更を記録します。
このログは主にクラッシュ時の安全性を目的としています。
システムがクラッシュしたとしても、最後のチェックポイント以降に作成されたログ項目を<SPAN
CLASS="QUOTE"
>"やり直し"</SPAN
>することで、データベースを整合性を維持した状態にリストアすることができます。
しかし、この存在するログファイルを使用して、データベースのバックアップ用の第3の戦略が可能になりました。
ファイルシステムレベルのバックアップとWALファイルのバックアップを組み合わせるという戦略です。
復旧が必要ならば、ファイルシステムバックアップをリストアし、その後にバックアップされたWALファイルを再生することで、システムを最新の状態にできます。
管理者にとって、この方法はこれまで説明した方法よりかなり複雑になりますが、以下のような大きな利点が複数あります。
  <P
></P
></P><UL
><LI
><P
>開始時点のファイルシステムバックアップは完全な整合状態である必要はありません。
そのバックアップ内の内部的な不整合はログのやり直しによって修正されます
（これは、クラッシュからの復旧時に行われることと大きな違いはありません）。
ですので、ファイルシステムのスナップショット機能を必要としません。
単に<SPAN
CLASS="APPLICATION"
>tar</SPAN
>などのアーカイブツールが必要です。
    </P
></LI
><LI
><P
>再生の際にWALファイルの並びを数に制限なく連ねて組み合わせられますので、単にWALファイルのアーカイブを続けることで連続したバックアップを達成できます。
これは、頻繁に完全なバックアップを行うことが困難な、大規模なデータベースでは特に価値があります。
    </P
></LI
><LI
><P
>WAL項目の再生を最後まで行わなければならないということはありません。
やり直しを任意の時点までで停止することができ、それにより、その時点までのデータベースの整合性を持ったスナップショットを得ることができます。
このような技術が<I
CLASS="FIRSTTERM"
>ポイントインタイムリカバリ</I
>を補助するものであり、元となるベースバックアップの取得時点以降の任意の時点の状態にデータベースをリストアすることが可能になります。
    </P
></LI
><LI
><P
>連続的に一連のWALファイルを、同一のベースバックアップをロードしている別のマシンに配送することで、<I
CLASS="FIRSTTERM"
>ウォームスタンバイ</I
>システムを保有することができます。
つまり、任意の時点でその2番目のマシンを、ほぼ現時点のデータベースの複製を持った状態で有効にすることができます。
    </P
></LI
></UL
><P>
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>と<SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>はファイルシステムレベルのバックアップを生成しませんので、継続的アーカイブ方式の一部として使うことはできません。
そのダンプは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>論理的</I
></SPAN
>なものであり、WALのやり直しで使うのに十分な情報を含んでいません。
   </P
></BLOCKQUOTE
></DIV
><P
>通常のファイルシステムバックアップ技術の場合と同様、この方法は、一部ではなく、データベースクラスタ全体のリストア処理のみをサポートできます。
また、アーカイブ用に大量の格納領域を必要とします。
ベースバックアップはかさばる場合があり、また、高負荷なシステムではアーカイブしなければならないWALの流量をメガバイト単位で生成します。
しかし、これは、高信頼性が必要な、多くの状況でむしろ好まれるバックアップ手法です。
  </P
><P
>継続的アーカイブ（多くのデータベースベンダで<SPAN
CLASS="QUOTE"
>"オンラインバックアップ"</SPAN
>とも呼ばれます）を使用して復旧を成功させるためには、少なくともバックアップの開始時点まで遡る、連続した一連のアーカイブ済みWALファイルが必要です。
ですので、運用するためには、最初のベースバックアップを取得する<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>前</I
></SPAN
>にWALファイルをアーカイブする手順を設定し試験しなければなりません。
したがって、まずWALファイルのアーカイブ機構について説明します。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-ARCHIVING-WAL"
>25.3.1. WALアーカイブの設定</A
></H2
><P
>抽象的な意味では、実行中の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>システムは無限に長い一連のWALレコードを生成します。
システムは物理的にこの並びを、通常1つ16メガバイト（このセグメントサイズは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の構築時に変更可能です）の、WAL<I
CLASS="FIRSTTERM"
>セグメントファイル</I
>に分割します。
このセグメントファイルには、概念的なWALの並び内の位置を反映した、数字の名前が付与されます。
WALアーカイブを行わない場合、システムは通常数個のセグメントファイルを生成し、不要となったセグメントファイルの名前をより大きなセグメント番号に変更することでそれを<SPAN
CLASS="QUOTE"
>"リサイクル"</SPAN
>します。
前々回のチェックポイントより前の内容を持つセグメントファイルはもはや重要でなく、リサイクルできると見なされます。
   </P
><P
>WALデータをアーカイブする場合、完成したセグメントファイルのそれぞれの内容を取り出し、再利用のために回収される前にそのデータをどこかに保存することが必要です。
アプリケーションと利用できるハードウェアに依存しますが、数多くの<SPAN
CLASS="QUOTE"
>"データをどこかに保存する"</SPAN
>方法があります。
例えば、NFSでマウントした他のマシンのディレクトリにセグメントファイルをコピーすること、あるいは、テープ装置に書き出すこと（元々のファイル名を識別する手段があることを確認してください）、それらを一度にまとめてCDに焼くこと、そのほか全く異なったなんらかの方法などです。
柔軟性をデータベース管理者に提供するために、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、どのようにアーカイブがなされたかについて一切想定しないようになっています。
その代わりに<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、管理者に完全なセグメントファイルをどこか必要な場所にコピーするシェルコマンドを指定させます。
このコマンドは単純な<TT
CLASS="LITERAL"
>cp</TT
>でも構いませんし、また、複雑なシェルスクリプトを呼び出しても構いません。
全て管理者に任されています。
   </P
><P
>WALアーカイブを有効にするには<A
HREF="runtime-config-wal.html#GUC-WAL-LEVEL"
>wal_level</A
>設定パラメータを<TT
CLASS="LITERAL"
>replica</TT
>（またはreplicaより高いパラメータ）に、<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-MODE"
>archive_mode</A
>を<TT
CLASS="LITERAL"
>on</TT
>に設定し、<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-COMMAND"
>archive_command</A
>設定パラメータで使用するシェルコマンドを指定します。
実行するには、これらの設定を <TT
CLASS="FILENAME"
>postgresql.conf</TT
> ファイルに常に置きます。
<TT
CLASS="VARNAME"
>archive_command</TT
> では、<TT
CLASS="LITERAL"
>%p</TT
>はアーカイブするファイルのパス名に置換され、<TT
CLASS="LITERAL"
>%f</TT
>はファイル名部分のみに置換されます。
（パス名は、サーバの現在の作業用ディレクトリ、つまり、クラスタのデータディレクトリから見て相対的なものです。）
コマンド内に<TT
CLASS="LITERAL"
>%</TT
>文字自体を埋め込む必要があれば<TT
CLASS="LITERAL"
>%%</TT
>を使ってください。
最も簡単でよく使用されるコマンドは以下のようなものになります。
</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'test ! -f /mnt/server/archivedir/%f &amp;&amp; cp %p /mnt/server/archivedir/%f'  # Unix
archive_command = 'copy "%p" "C:\\server\\archivedir\\%f"'  # Windows</PRE
><P>
これは、アーカイブ可能なWALセグメントを<TT
CLASS="LITERAL"
>/mnt/server/archivedir</TT
>ディレクトリにコピーします
（これは一例です。
推奨するものではなく、また、全てのプラットフォームで動作しない可能性があります）。
<TT
CLASS="LITERAL"
>%p</TT
>および<TT
CLASS="LITERAL"
>%f</TT
>パラメータが置き換えられたあと、実行された実コマンドは以下のようになります。
</P><PRE
CLASS="PROGRAMLISTING"
>test ! -f /mnt/server/archivedir/00000001000000A900000065 &amp;&amp; cp pg_xlog/00000001000000A900000065 /mnt/server/archivedir/00000001000000A900000065</PRE
><P>
類似したコマンドがアーカイブされるそれぞれの新規ファイルに生成されます。
   </P
><P
>このアーカイブ用コマンドは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバを稼動させるユーザと同じ所有権で実行されます。
アーカイブされる一連のWALファイルには、実質、データベース内の全てが含まれていますので、アーカイブしたデータをのぞき見から確実に保護しなければならないでしょう。
例えば、グループや全員に読み込み権限を付与していないディレクトリにデータをアーカイブしてください。
   </P
><P
>アーカイブ用コマンドが成功した場合のみにゼロという終了ステータスを返すことが重要です。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、ゼロという結果に基づいて、そのファイルのアーカイブが成功したことを想定し、そのファイルを削除したり回収するかもしれません。
しかし、非ゼロのステータスは、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に対してファイルがアーカイブされなかったことを通知し、成功するまで定期的に再試行させます。
   </P
><P
>通常アーカイブ用コマンドは既存のアーカイブ済みファイルの上書きを行わないように設計されなければなりません。
これは、管理者のミス（例えば2つの異なるサーバの出力を同一のアーカイブ用ディレクトリに送信してしまうなど）といった場合からアーカイブ状況の整合性を保護するための安全策として重要です。
   </P
><P
>実際に既存のファイルを上書きしないこと、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>かつ、その場合に非ゼロのステータスを返すこと</I
></SPAN
>を確認するために使用するアーカイブ用コマンドを試験することを勧めます。
上のUnix用のコマンド例では、別途<TT
CLASS="COMMAND"
>test</TT
>という段階を含めることでこれを確認しています。
いくつかのUnixプラットフォームでは<TT
CLASS="COMMAND"
>cp</TT
>コマンドには<TT
CLASS="OPTION"
>-i</TT
> 引数を使うことで煩雑な出力を少なくし使うことができますが、正しい終了コードが返ることを確認せずに使用するべきではありません。
(具体的にはGNUの<TT
CLASS="COMMAND"
>cp</TT
>コマンドは<TT
CLASS="OPTION"
>-i</TT
> オプションを使い、ターゲットファイルがすでに存在している場合、ゼロのステータスを返します。これは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>期待していない</I
></SPAN
>動作です。）
   </P
><P
>アーカイブ設定を設計する時には、操作者の介入が必要であったり、アーカイブ場所の容量不足の理由でアーカイブ用コマンドが繰り返し失敗した時にどうなるかを考慮してください。
例えば、これはオートチェンジャ機能のないテープに書き出している場合に発生する可能性があります。
テープが一杯になった場合、テープを交換するまでアーカイブを行うことができなくなります。
こうした状況を相応の早さで解消できるよう、適切に操作者に対しエラーや要求を確実に連絡できるようにしなければなりません。
この状況が解消するまで、WALセグメントファイルは<TT
CLASS="FILENAME"
>pg_xlog/</TT
>ディレクトリ内に格納され続けます。
（<TT
CLASS="FILENAME"
>pg_xlog/</TT
>を含むファイルシステムがいっぱいになると、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はパニック停止します。コミットされたトランザクションは失われませんが、データベースはいくらかの容量を開放するまでオフラインのままです。）
   </P
><P
>サーバのWALデータの生成に要する平均速度に追いついている限り、アーカイブ用コマンドの処理速度は重要ではありません。
アーカイブプロセスが多少遅れたとしても通常の操作は続けられます。
アーカイブ処理がかなり遅くれると、災害時に損失するデータの量が増加することになります。
また、これは<TT
CLASS="FILENAME"
>pg_xlog/</TT
>ディレクトリ内に多くのアーカイブ処理待ちのセグメントファイルが格納され、ディスク容量が不足する状況になる可能性があることを意味します。
アーカイブ処理が確実に意図通りに動作しているかを監視することを推奨します。
   </P
><P
>アーカイブ用コマンドを作成する時、アーカイブされるファイル名は最長64文字までで、ASCII文字と数字とドットのどんな組合せを使用しても構いません。
元の相対パス（<TT
CLASS="LITERAL"
>%p</TT
>）を保存する必要はありませんが、ファイル名（<TT
CLASS="LITERAL"
>%f</TT
>）を保存する必要はあります。
   </P
><P
>WALアーカイブによって<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>データベースでなされた変更は全てリストアすることができますが、設定ファイルはSQL操作ではなく手作業で変更されますので、設定ファイル（<TT
CLASS="FILENAME"
>postgresql.conf</TT
>、<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>、および<TT
CLASS="FILENAME"
>pg_ident.conf</TT
>）になされた変更までリストアしないことに注意してください。
通常のファイルシステムバックアップ手続きでバックアップされる場所に設定ファイルを保持したい場合があります。
設定ファイルの設置場所を変更するには<A
HREF="runtime-config-file-locations.html"
>項19.2</A
>を参照してください。
   </P
><P
>アーカイブコマンドは完全なWALセグメントに対してのみ呼び出されます。
このため、サーバが少ししかWAL流量がない（処理を行わないなぎの期間がある）場合、トランザクションの完了とアーカイブ格納領域への安全な記録との間に長期にわたる遅延があることになります。
古い未アーカイブのデータをどうするかについて制限を付けるために、<A
HREF="runtime-config-wal.html#GUC-ARCHIVE-TIMEOUT"
>archive_timeout</A
>を設定して、強制的にサーバを新しいWALセグメントにある程度の間隔で切り替えるようにすることができます。
強制切り替えにより早期にアーカイブされたアーカイブ済みファイルは完全に完了したファイルと同じ大きさを持つことに注意してください。
そのため、非常に小さな<TT
CLASS="VARNAME"
>archive_timeout</TT
>を使用することはお勧めしません。
格納領域を膨張させてしまいます。
通常ならば分単位の<TT
CLASS="VARNAME"
>archive_timeout</TT
>設定が合理的です。
   </P
><P
>終わったばかりのトランザクションをできるだけ早くアーカイブさせたい場合、<CODE
CLASS="FUNCTION"
>pg_switch_xlog</CODE
>を使用して手作業でセグメント切り替えを強制することができます。
この他のWAL管理に関連した関数を<A
HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE"
>表9-78</A
>に列挙します。
   </P
><P
><TT
CLASS="VARNAME"
>wal_level</TT
>が<TT
CLASS="LITERAL"
>minimal</TT
>の場合、<A
HREF="populate.html#POPULATE-PITR"
>項14.4.7</A
>に書かれているように、いくつかのSQLコマンドはWALロギングを回避するため最適化されます。
アーカイビングもしくはストリーミングレプリケーションがこれら構文の１つを実行中に作動させられると、アーカイブ復旧のための十分な情報をWALが含まなくなります。（クラッシュ復旧は影響を受けません。）
このことにより、<TT
CLASS="VARNAME"
>wal_level</TT
>はサーバの起動時のみ変更可能です。
とは言っても、<TT
CLASS="VARNAME"
>archive_command</TT
>は構成ファイルを再読み込みすることで変更できます。
一時的にアーカイビングを停止したい場合、１つの方法は<TT
CLASS="VARNAME"
>archive_command</TT
>を空文字列（<TT
CLASS="LITERAL"
>''</TT
>）に設定することです。
このようにすると、動作する<TT
CLASS="VARNAME"
>archive_command</TT
>が再構築されるまでWALファイルは<TT
CLASS="FILENAME"
>pg_xlog/</TT
>に蓄積します。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-BASE-BACKUP"
>25.3.2. ベースバックアップの作成</A
></H2
><P
>ベースバックアップを取得する最も簡単な方法は<A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
> を実行する方法です。
通常のファイルやTAR形式のファイルとしてベースバックアップを取得することができます。
もし、<A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>より柔軟性が求められる場合は、低レベルなAPIを使ってバックアップを作成することもできます(詳細は <A
HREF="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP"
>項25.3.3</A
>を参照)。
   </P
><P
>ベースバックアップを取得するための時間を考慮する必要はありません。
しかし、普段、<TT
CLASS="VARNAME"
>full_page_writes</TT
>を無効にして運用している場合、バックアップ取得中は強制的に<TT
CLASS="VARNAME"
>full_page_writes</TT
>が有効になるため、パフォーマンスが落ちていると感じる可能性があります。
   </P
><P
>バックアップを使用するためには、ファイルシステムのバックアップ取得中、および、その後に生成されるWALセグメントファイル全てが保存されている必要があります。
この目的のために、ベースバックアップの過程で即座にWALアーカイブ領域に<I
CLASS="FIRSTTERM"
>バックアップ履歴ファイル</I
>が作成されます。
このファイルにはファイルシステムのバックアップに最初に必要とされるWALセグメントの名前が付けられます。
例えば、最初のWALファイルが <TT
CLASS="LITERAL"
>0000000100001234000055CD</TT
>である場合、バックアップ履歴ファイルは<TT
CLASS="LITERAL"
>0000000100001234000055CD.007C9330.backup</TT
>というように名付けられます。
(ファイル名の2番目のパートはWALファイルの厳密な位置が記載されます。通常は無視することができます。)
一旦、安全にファイルシステムのバックアップとそのバックアップ中に使用されたWALセグメントファイル(バックアップ履歴ファイルから特定できます)を取得すると、それより数値の小さな全てのWALアーカイブセグメントはファイルシステムのリカバリには必要が無く、削除することができます。
しかし、データを確実に復旧させるためには数世代のバックアップセットを保持することを考慮すべきです。

   </P
><P
>バックアップ履歴ファイルは、ほんの小さなテキストファイルです。
これには<A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>で与えたラベル文字列の他、バックアップの開始、終了時間およびバックアップのWALセグメントが含まれます。
このラベルをバックアップを構成するために使うことで、アーカイブ履歴ファイルはどのバックアップをリストアするべきか間違いなく判断することができます。
   </P
><P
>最後のベースバックアップ以降のWALアーカイブを保持し続ける必要があるため、通常、ベースバックアップを取得すべき期間は、WALアーカイブを保持するためにどのくらいのストレージを拡張できるかによって決定されます。
また、リカバリが必要になった場合に、どのくらいの時間をリカバリに使うと覚悟するのかも考慮すべきです。&mdash;
システムは全てのWALセグメントを適用する必要があるため、もし、最後のベースバックアップを取得してから長い時間が経過している場合、適用に時間を要する可能性があります。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-LOWLEVEL-BASE-BACKUP"
>25.3.3. 低レベルAPIを使用したベースバックアップの作成</A
></H2
><P
>低レベルのAPIを使ったベースバックアップを取得するには<A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
> を使う方法に加えて数ステップが必要ですが、比較的簡単です。
これらのステップは順番に実行することが重要で、次のステップに進む前にこれらのステップが成功していることを確認する必要があります。
   </P
><P
>低レベルのベースバックアップは非排他的または排他的な手法で作成することができます。
非排他的な手法が推奨され、排他的な手法は推奨されず、将来的に削除されます。
   </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-LOWLEVEL-BASE-BACKUP-NONEXCLUSIVE"
>25.3.3.1. 非排他的な低レベルバックアップの作成</A
></H3
><P
>非排他的な低レベルバックアップは、実行中の（同じバックアップAPIを使用して起動したものと、<A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>を使用して起動したものいずれも）他の同時バックアップを許可するものです。
    </P
><P
>  <P
></P
></P><OL
TYPE="1"
><LI
><P
>WALアーカイブが有効であり、正常に動作することを確認してください。
    </P
></LI
><LI
><P
>pg_start_backupを実行する権限のあるユーザ（スーパーユーザまたは関数のEXECUTE権限を付与されたユーザ）としてサーバ（どのデータベースでも構いません）に接続し、以下のコマンドを実行してください。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_start_backup('label', false, false);</PRE
><P>
ここで<TT
CLASS="LITERAL"
>label</TT
>は、バックアップ操作を一意に識別するために使用する任意の文字列です。
<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>を呼び出す接続は、バックアップの完了まで維持される必要があります。さもなくばバックアップは自動的に中止されます。
    </P
><P
>デフォルトで、<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>は終了までに長い時間がかかる場合があります。
その理由はあるチェックポイントを実行し、そのチェックポイントに必要なI/Oはかなりの時間にわたって広がるためです。そして、デフォルトでは設定したチェックポイント間隔の半分です（設定パラメータについては<A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET"
>checkpoint_completion_target</A
>を参照してください）。
通常これは、問い合わせ処理における影響を極小化するので望ましいことです。
すぐにバックアップを開始したい場合は、第2パラメータを<TT
CLASS="LITERAL"
>true</TT
>にすると、使えるだけのI/Oを使用して即座にチェックポイントを発行します。
    </P
><P
>第3パラメータの<TT
CLASS="LITERAL"
>false</TT
>は、<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>が非排他ベースバックアップを開始すること指示します。
    </P
></LI
><LI
><P
>（<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>や<SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>ではなく）<SPAN
CLASS="APPLICATION"
>tar</SPAN
>や<SPAN
CLASS="APPLICATION"
>cpio</SPAN
>などの使い慣れた任意のファイルシステムバックアップツールを使用して、バックアップを実行してください。
この作業時に、データベースの通常の操作を停止することは不要ですし、望ましい方法でもありません。
このバックアップの実行中に考慮すべき点は<A
HREF="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP-DATA"
>項25.3.3.3</A
>を参照してください。
    </P
></LI
><LI
><P
>以前と同じ接続の中で、以下のコマンドを実行します。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM pg_stop_backup(false);</PRE
><P>
これはバックアップモードを終了し、次のWALセグメントへの自動切換えを行います。
この切換えの理由は、バックアップ期間中に書き出された最後のWALファイルがアーカイブできるよう準備することです。
    </P
><P
><CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>は3つの値を含んだ1行を返します。
2番目の値は、バックアップのルートディレクトリ内の<TT
CLASS="FILENAME"
>backup_label</TT
>という名称のファイルを作成の上、値を書き込む必要があります。
3番目の値は、空でない限りは<TT
CLASS="FILENAME"
>tablespace_map</TT
>という名称のファイルを作成の上、値を書き込む必要があります。
これらのファイルは、バックアップの動作にきわめて重要であり、返り値の内容から変更なしに書き込む必要があります。
    </P
></LI
><LI
><P
>バックアップ中に使用されたWALセグメントファイルがアーカイブされれば完了です。
<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>の返り値の1番目の値で識別されるファイルは、バックアップファイル一式を完結させるのに必要となる最終セグメントです。
<TT
CLASS="VARNAME"
>archive_mode</TT
>が有効であれば<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> は最終セグメントがアーカイブされるまで戻りません。
すでに<TT
CLASS="VARNAME"
>archive_command</TT
>を設定していますので、これらのファイルのアーカイブ操作は自動的に発生します。
ほとんどの場合、これは瞬時に行われます。
しかし、バックアップの完了を確認できるよう、アーカイブシステムを監視し、遅延が無いことの確認をお勧めします。
アーカイブコマンドの失敗によりアーカイブ処理が遅れてしまったとしても、アーカイブが成功し、そしてバックアップが完了するまで再試行を繰り返すようになっています。
<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>実行においての時間期限を設けたい場合、適切な<TT
CLASS="VARNAME"
>statement_timeout</TT
>の値を設定できますが、この設定値によって<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>が中断したときにバックアップが正当ではない可能性があるということを肝に銘じてください。
    </P
></LI
></OL
><P>
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-LOWLEVEL-BASE-BACKUP-EXCLUSIVE"
>25.3.3.2. 排他的低レベルバックアップの作成</A
></H3
><P
>排他的バックアップの手順は、ほぼ非排他的バックアップのものと同様ですが、いくつかのキーとなる手順に違いがあります。
バックアップの複数同時実行を許可せず、バックアップ中にクラッシュした場合、サーバ上にいくつかの問題が残ります。
PostgreSQL 9.6より前では唯一利用可能な低レベル手法でしたが、今日では可能であればすべてのユーザが自身のスクリプトを非排他的バックアップを使用するようにアップグレードすることが推奨されています。
    </P
><P
>  <P
></P
></P><OL
TYPE="1"
><LI
><P
>WALアーカイブが有効であり、正常に動作することを確認してください。
    </P
></LI
><LI
><P
>pg_start_backupを実行する権限のあるユーザ（スーパーユーザまたは関数のEXECUTE権限を付与されたユーザ）としてサーバ（どのデータベースでも構いません）に接続し、以下のコマンドを実行してください。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_start_backup('label');</PRE
><P>
ここで<TT
CLASS="LITERAL"
>label</TT
>は、バックアップ操作を一意に識別するために使用する任意の文字列です。
<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>は、開始時刻やラベル文字列などのバックアップ情報を持つ<TT
CLASS="FILENAME"
>backup_label</TT
>という名前の<I
CLASS="FIRSTTERM"
>バックアップラベル</I
>ファイルを、クラスタディレクトリ内に作成します。
この関数は<TT
CLASS="FILENAME"
>tablespace_map</TT
>という名前の<I
CLASS="FIRSTTERM"
>テーブル空間マップ</I
>ファイルもクラスタディレクトリ内に作ります。
テーブル空間マップファイルには、もしそのようなリンクが1つ以上存在すれば<TT
CLASS="FILENAME"
>pg_tblspc/</TT
>内のテーブル空間シンボリックリンクに関する情報が入っています。
どちらのファイルもバックアップの完全性保持のために重要な意味を持ちますので、バックアップから必ずリストアする必要があるでしょう。
    </P
><P
>デフォルトで、<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>は終了までに長い時間がかかる場合があります。
その理由はあるチェックポイントを実行し、そして、デフォルトでは設定したチェックポイント間隔の半分である、そのチェックポイントに必要なI/Oがかなりの時間にわたって広がるためです（設定パラメータについては<A
HREF="runtime-config-wal.html#GUC-CHECKPOINT-COMPLETION-TARGET"
>checkpoint_completion_target</A
>を参照してください）。
通常これは、問い合わせ処理における影響を極小化するので望ましいことです。
バックアップをなるべく早く行いたいのであれば、以下を使用します。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_start_backup('label', true);</PRE
><P>
これはチェックポイントをできる限り早く行うよう強制します。
    </P
></LI
><LI
><P
>(<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>や<SPAN
CLASS="APPLICATION"
>pg_dumpall</SPAN
>ではなく)<SPAN
CLASS="APPLICATION"
>tar</SPAN
>や<SPAN
CLASS="APPLICATION"
>cpio</SPAN
>などの使い慣れた任意のファイルシステムバックアップツールを使用して、バックアップを実行してください。
この作業時に、データベースの通常の操作を停止することは不要ですし、望ましい方法でもありません。
このバックアップの実行中に考慮すべき点は<A
HREF="continuous-archiving.html#BACKUP-LOWLEVEL-BASE-BACKUP-DATA"
>項25.3.3.3</A
>を参照してください。
    </P
></LI
><LI
><P
>再度、pg_stop_backupを実行する権限のあるユーザ（スーパーユーザまたは関数のEXECUTE権限を付与されたユーザ）としてデータベースに接続し、以下のコマンドを実行してください。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT pg_stop_backup();</PRE
><P>
これはバックアップモードを終了し、次のWALセグメントへの自動切換えを行います。
この切換えの理由は、バックアップ期間中に書き出された最後のWALファイルがアーカイブできるよう準備することです。
    </P
></LI
><LI
><P
>バックアップ中で使用されたWALセグメントファイルがアーカイブされれば完了です。
<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>の結果で識別されるファイルは、バックアップファイル一式を完結させるのに必要となる最終セグメントです。
<TT
CLASS="VARNAME"
>archive_mode</TT
>が有効であれば<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
> は最終セグメントがアーカイブされるまで戻りません。
すでに<TT
CLASS="VARNAME"
>archive_command</TT
>を設定していますので、これらのファイルのアーカイブ操作は自動的に発生します。
ほとんどの場合、これは瞬時に行われます。
しかし、バックアップの完了を確認できるよう、アーカイブシステムを監視し、遅延が無いことの確認をお勧めします。
アーカイブコマンドの失敗によりアーカイブ処理が遅れてしまったとしても、アーカイブが成功し、そしてバックアップが完了するまで再試行を繰り返すようになっています。
<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>実行においての時間期限を設けたい場合、適切な<TT
CLASS="VARNAME"
>statement_timeout</TT
>の値を設定できますが、この設定値によって<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>が中断したときにバックアップが正当ではない可能性があるということを肝に銘じてください。
    </P
></LI
></OL
><P>
    </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-LOWLEVEL-BASE-BACKUP-DATA"
>25.3.3.3. データディレクトリのバックアップ</A
></H3
><P
>&#13;ファイルシステムのバックアップツール中には複写している途中でファイルが変更されると警告もしくはエラーを報告するものがあります。
稼働しているデータベースのベースバックアップを取っている場合には、この情況は正常でエラーではありません。
しかし、この種の警告と本当のエラーとを区別できるか確認が必要です。
例えば、<SPAN
CLASS="APPLICATION"
>rsync</SPAN
>のバージョンによっては<SPAN
CLASS="QUOTE"
>"消滅したソースファイル"</SPAN
>に対して別の終了コードを返し、そしてこの終了コードをエラーではないと受け付けるドライバスクリプトを記述することができます。
同時にGNU <SPAN
CLASS="APPLICATION"
>tar</SPAN
>のバージョンによっては、<SPAN
CLASS="APPLICATION"
>tar</SPAN
>がそれを複写していた途中でファイルが切り詰められると、致命的エラーと識別できないエラーコードを返します。
ありがたいことに、GNU <SPAN
CLASS="APPLICATION"
>tar</SPAN
>のバージョン1.16もしくはそれ以降では、バックアップ中にファイルが変更されると1で、それ以外のエラーの時は2でプログラムから抜けます。
GNUの <SPAN
CLASS="APPLICATION"
>tar</SPAN
>で1.23以降のバージョンを使用しているのであれば、<TT
CLASS="LITERAL"
>--warning=no-file-changed --warning=no-file-removed</TT
>オプションをつけることで関連する警告メッセージを隠すオプションを使用することができます。
   </P
><P
>バックアップに、データベースクラスタディレクトリ（例えば<TT
CLASS="FILENAME"
>/usr/local/pgsql/data</TT
>）以下にある全てのファイルが含まれていることを確認してください。
このディレクトリ以下に存在しないテーブル空間を使用している場合、注意して、同様にそれらを含めてください
（そして、バックアップがリンクとしてシンボリックリンクをアーカイブしていることを確認してください。
さもないとリストアはテーブル空間を壊してしまいます）。
   </P
><P
>しかし、クラスタの<TT
CLASS="FILENAME"
>pg_xlog/</TT
>サブディレクトリにあるファイルをバックアップから省いてください。
このちょっとした調整は、リストア処理中の失敗の危険性を低減できますので、行う価値があります。
<TT
CLASS="FILENAME"
>pg_xlog/</TT
>がクラスタディレクトリ外のどこかを指し示すシンボリックリンクの場合は調整が簡単です。
これは性能上の理由でよく使用される設定です。
また、いずれこのバックアップを使う<SPAN
CLASS="APPLICATION"
>postmaster</SPAN
>ではなく、今起動している<SPAN
CLASS="APPLICATION"
>postmaster</SPAN
>の情報を記録している<TT
CLASS="FILENAME"
>postmaster.pid</TT
>と<TT
CLASS="FILENAME"
>postmaster.opts</TT
>も除外できます。
(これらのファイルは<SPAN
CLASS="APPLICATION"
>pg_ctl</SPAN
>を誤作動させる可能性があります。)
   </P
><P
>マスター上に存在するレプリケーションスロットがバックアップに含まれないようにするために、クラスタの中の<TT
CLASS="FILENAME"
>pg_replslot/</TT
>ディレクトリをバックアップから除くのもしばしば良い考えです。
もし、スタンバイを作成するためのバックアップを続けて使用すると、スタンバイのWALファイルの保持を無制限に保留する結果になり、ホットスタンバイからのフィードバックを有効にしている場合、マスターのWALを膨張させます。
これは、これらのレプリケーションスロットを使っているクライアントはまだ、スタンバイではなく、マスターのスロットを接続し続け、更新しているからです。
バックアップが新しいマスターを作成するためだけに作成されたとしても、レプリケーションスロットをコピーすることは特に有益であるとは考えられません。
このようにバックアップにレプリケーションスロットを含むことは、新しいマスターがオンラインになったときにはスロットの内容が期限切れしており、有害である可能性があります。
   </P
><P
>バックアップラベルファイルには、<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>に付与したラベル文字列と<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>が実行された時刻、最初のWALファイルの名前が含まれます。
したがって、当惑した時にバックアップファイルの中身を検索し、そのダンプファイルがどのバックアップセッションに由来したものかを確認することができます。
テーブル空間マップファイルにはディレクトリ<TT
CLASS="FILENAME"
>pg_tblspc/</TT
>に存在するシンボリックリンク名と各シンボリックリンクのフルパスが含まれています。
このファイルはあなたのためだけの情報ではありません。
その存在と内容はシステムのリカバリプロセスが適切に動作するために非常に重要です。
   </P
><P
>サーバが停止している時にバックアップを作成することも可能です。
この場合、わかりきったことですが、<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>や<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>を使用することができません。
そのため、どのバックアップが、どのWALファイルと関連し、どこまで戻せばよいかを独自の方法で残さなければなりません。
通常は、上述の継続的アーカイブ手順に従う方をお勧めします。
   </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-PITR-RECOVERY"
>25.3.4. 継続的アーカイブによるバックアップを使用した復旧</A
></H2
><P
>さて、最悪の事態が発生し、バックアップから復旧する必要が出てきたものとします。
以下にその手順を説明します。
  <P
></P
></P><OL
TYPE="1"
><LI
><P
>もし稼動しているのであればサーバを停止してください。
    </P
></LI
><LI
><P
>もし容量があるのであれば、後で必要になる場合に備えてクラスタデータディレクトリ全体とテーブル空間を全て一時的な場所にコピーしてください。
この予防措置は、既存のデータベースを2つ分保持できるだけの空き領域を必要とします。
十分な領域がない場合でも、少なくともクラスタの<TT
CLASS="FILENAME"
>pg_xlog</TT
>サブディレクトリの内容は保存すべきです。
ここには、システムが停止する前にアーカイブされなかったログファイルが含まれているかも知れないからです。
    </P
></LI
><LI
><P
>クラスタデータディレクトリ以下、および、使用中のテーブル空間の最上位ディレクトリ以下にある既存の全てのファイルとサブディレクトリを削除してください。
    </P
></LI
><LI
><P
>ファイルシステムバックアップからデータベースファイルをリストアします。
ファイルが正しい所有権（<TT
CLASS="LITERAL"
>root</TT
>ではなくデータベースシステムユーザです！）でリストアされていることを確認してください。
テーブル空間を使用している場合は、<TT
CLASS="FILENAME"
>pg_tblspc/</TT
>内のシンボリックリンクが正しくリストアされていることを検証する必要があります。
    </P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>pg_xlog/</TT
>内にあるファイルをすべて削除してください。
これらはファイルシステムバックアップから生成されたものであり、おそらく現在のものより古く使用できないものです。
<TT
CLASS="FILENAME"
>pg_xlog/</TT
>をまったくアーカイブしていなければ、適切な権限で再作成してください。
以前シンボリックリンクとして設定していたのであれば、そのように確実に再構築するように注意してください。
    </P
></LI
><LI
><P
>手順2で退避させた未アーカイブのWALセグメントファイルがあるのであれば、<TT
CLASS="FILENAME"
>pg_xlog/</TT
>にコピーしてください。
（問題が発生し、初めからやり直さなければならない場合に未変更のファイルが残るように、移動させるのではなくコピーすることが最善です。）
    </P
></LI
><LI
><P
>復旧コマンドファイル<TT
CLASS="FILENAME"
>recovery.conf</TT
>（<A
HREF="recovery-config.html"
>第27章</A
>を参照）をクラスタデータディレクトリに作成してください。
また、一時的に<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>を編集し、復旧の成功を確認できるまで一般ユーザが接続できないようにする必要があるかもしれません。
    </P
></LI
><LI
><P
>サーバを起動してください。
サーバは復旧モードに入り、必要なアーカイブ済みWALファイル群の読み込みを行います。
外部的なエラーにより復旧が中断したら、サーバを単に再起動させて、復旧処理を継続してください。
復旧処理が完了したら、（誤って後で復旧モードに再度入らないように）postmasterは<TT
CLASS="FILENAME"
>recovery.conf</TT
>の名前を<TT
CLASS="FILENAME"
>recovery.done</TT
>に変更します。
その後通常のデータベース操作を開始します。
    </P
></LI
><LI
><P
>データベースの内容を検査し、希望する状態まで復旧できていることを確認してください。
復旧できなかった場合は手順1に戻ってください。
全て問題なければ、ユーザが接続できるように<TT
CLASS="FILENAME"
>pg_hba.conf</TT
>を正常状態に戻してください。
    </P
></LI
></OL
><P>
   </P
><P
>ここで重要となるのは、復旧設定ファイルを設定することです。
このファイルで、どのように復旧させたいのかやどこまで復旧させたいかを記述します。
<TT
CLASS="FILENAME"
>recovery.conf.sample</TT
>（通常はインストレーションの<TT
CLASS="FILENAME"
>share/</TT
>ディレクトリに格納されています）を手本として使用することができます。
<TT
CLASS="FILENAME"
>recovery.conf</TT
>で絶対に指定しなければならないことは、アーカイブ済みWALファイルセグメントをどのように戻すかを<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に通知する<TT
CLASS="VARNAME"
>restore_command</TT
>です。
<TT
CLASS="VARNAME"
>archive_command</TT
>同様、これはシェルコマンド文字列です。
ここには、対象のログファイルの名前で置換される<TT
CLASS="LITERAL"
>%f</TT
>やログファイルのコピー先を示すパスで置換される<TT
CLASS="LITERAL"
>%p</TT
>を含めることができます。
（パス名は現在の作業用ディレクトリ、つまり、クラスタのデータディレクトリから見た相対パスです。）
コマンド内に<TT
CLASS="LITERAL"
>%</TT
>文字自体を埋め込む必要があれば<TT
CLASS="LITERAL"
>%%</TT
>と記載してください。
最も簡単でよく使われるコマンドは以下のようなものです。
</P><PRE
CLASS="PROGRAMLISTING"
>restore_command = 'cp /mnt/server/archivedir/%f %p'</PRE
><P>
これは事前にアーカイブされたWALセグメントを<TT
CLASS="FILENAME"
>/mnt/server/archivedir</TT
>ディレクトリからコピーします。
当然ながら、もっと複雑なものを使用することができます。
例えば、操作者に適切なテープをマウントさせることを要求するようなシェルスクリプトでさえ可能です。
   </P
><P
>このコマンドが失敗した時に非ゼロの終了ステータスを返すことが重要です。
このコマンドは、アーカイブに存在しないファイルを要求する<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>かもしれません</I
></SPAN
>が、その場合でも非ゼロを返さなければなりません。
これはエラー状態ではありません。
例外は、コマンドがシグナルによって中断された場合(データベースの停止に使用される<SPAN
CLASS="SYSTEMITEM"
>SIGTERM</SPAN
>以外)か、シェルによるエラー(コマンドが見つかりませんなど)でリカバリが中断され、サーバが起動しない場合です。
   </P
><P
>要求されるファイルはWALセグメントファイルだけではありません。
<TT
CLASS="LITERAL"
>.backup</TT
>、または<TT
CLASS="LITERAL"
>.history</TT
>が付いているファイルが要求されることも想定しなければなりません。
同時に、<TT
CLASS="LITERAL"
>%p</TT
>パスのファイル名部分は<TT
CLASS="LITERAL"
>%f</TT
>と異なることに注意してください。
これらが相互に置き換え可能であるとは考えないでください。
   </P
><P
>アーカイブ場所で見つけられなかったWALセグメントは<TT
CLASS="FILENAME"
>pg_xlog/</TT
>から検索されます。
これにより、最近の未アーカイブのセグメントを使用することができます。
しかし、アーカイブ場所から利用できるセグメントは<TT
CLASS="FILENAME"
>pg_xlog/</TT
>内のファイルよりも優先的に使用されます。
   </P
><P
>通常は利用可能な全てのWALセグメントを使用して復旧処理が行われます。
その結果、データベースを現時点まで（もしくは、利用可能なWALセグメントで得られる限り現在に近い時点まで）リストアします。
従って、通常の復旧は<SPAN
CLASS="QUOTE"
>"file not found"</SPAN
>メッセージで終了します。
エラーメッセージの正確な文言は<TT
CLASS="VARNAME"
>restore_command</TT
>の選択によります。
また、復旧の開始時点で<TT
CLASS="FILENAME"
>00000001.history</TT
>のようなファイル名のエラーメッセージが出ることがあります。
これも単純な復旧作業では不具合を意味するものでなく正常です。
論議については<A
HREF="continuous-archiving.html#BACKUP-TIMELINES"
>項25.3.5</A
>を参照してください。
   </P
><P
>もし以前のある時点まで復旧させたい場合（例えば、経験不足のデータベース管理者が主トランザクションテーブルを消去した直前）、<TT
CLASS="FILENAME"
>recovery.conf</TT
>に要求する<A
HREF="recovery-target-settings.html"
>停止時点</A
>を指定するだけです。
停止時点は、<SPAN
CLASS="QUOTE"
>"recovery target"</SPAN
>として既知の停止時点で指定することも、日付と時刻で指定することも、リストアポイントか完了した特定のトランザクションIDで指定することもできます。
本ドキュメントの執筆時点では使用するトランザクションIDの識別を補助するツールがありませんので、ほとんどの場合は日付と時刻による指定のみを使用することになるでしょう。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>停止時点はバックアップの終了時刻、つまり、<CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>の最終時刻より後の時点でなければなりません。
バックアップを行っている最中のある時点までベースバックアップを使用して復旧させることはできません
（こうした時点まで復旧させるには、その前のベースバックアップまで戻って、そこからロールフォワードしてください）。
     </P
></BLOCKQUOTE
></DIV
><P
>復旧時にWALデータの破損がわかると、復旧はその時点で止まり、サーバは起動しません。
こうした場合、<SPAN
CLASS="QUOTE"
>"復旧対象"</SPAN
>に破損時点より前の時点を指定することで、復旧処理が正常に完了できるよう、復旧プロセスを初めからやり直すことができます。
システムクラッシュなど外的理由により復旧処理が失敗した場合やWALアーカイブがアクセスできなくなった場合、復旧処理を単に再起動させることができます。
この場合は失敗した時点とほぼ同じところから再開します。
復旧処理の再起動は、次のような通常操作時のチェックポイント処理とほぼ同様に動作します。
サーバは定期的にすべての状態をディスクに強制し、再度スキャンする必要がない処理済みのWALデータを示す<TT
CLASS="FILENAME"
>pg_control</TT
>ファイルを更新します。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-TIMELINES"
>25.3.5. タイムライン</A
></H2
><P
>過去のある時点までデータベースを復旧できる機能は、タイムトラベルやパラレルユニバースといったSFの物語に類似した、多少の複雑性があります。
例えば、データベースの元の履歴で、火曜日の夕方5:15PMに重要なテーブルを削除し、水曜日のお昼まで手違いに気が付かなかったとします。
慌てずに、バックアップを取り出して、火曜日の夕方5:14PMの時点にリストアし、データベースを起動させます。
データベース世界の<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>この</I
></SPAN
>履歴では、そのテーブルを削除していません。
しかし、後になって、これは大した問題ではなかったことが分かり、元の履歴における水曜日に朝の何時かにまで戻したいと考えたと仮定しましょう。
データベースは既に起動していますので、元に戻したい時点に至るWALセグメントファイルの一部は上書きされていて、戻すことはできないかもしれません。
ですので、このことを避けるために、ポイントインタイムで復旧させた後に生成された一連のWAL記録と元のデータベースの履歴において生成されたWAL記録とを区別する必要があります。
   </P
><P
>こうした問題を扱うために<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>には<I
CLASS="FIRSTTERM"
>タイムライン</I
>という概念があります。
アーカイブ復旧が完了したときはいつでも、その復旧後に生成されたWAL記録を識別するための新しいタイムラインが生成されます。
タイムラインID番号はWALセグメントファイル名の一部です。
ですので、新しいタイムラインはこれまでのタイムラインで生成されたWALデータを上書きしません。
実際、多くの異なるタイムラインをアーカイブすることができます。
不要な機能と考えるかもしれませんが、命綱になることがしばしばあります。
どの時点まで復旧すればよいか確実でないといった状況を考えてみてください。
その時は、過去の履歴からの分岐点として最善の時点を見つけるために、試行錯誤して何度もポイントインタイムの復旧を行う必要があるでしょう。
タイムラインがないと、この手続きはすぐに管理不能な混乱を招いてしまいます。
タイムラインを使用して、以前捨てたタイムライン分岐における状態を含む、過去の<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>任意</I
></SPAN
>の状態に復旧させることができます。
   </P
><P
>新しいタイムラインが生成される度に、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、どのタイムラインがいつどこから分岐したかを示す<SPAN
CLASS="QUOTE"
>"タイムライン履歴"</SPAN
>ファイルを作成します。
この履歴ファイルは、複数のタイムラインを含むアーカイブ場所から復旧する時にシステムが正しいWALセグメントファイルを選択できるようにするために必要です。
したがって、履歴ファイルは、WALセグメントファイル同様にWALアーカイブ領域にアーカイブされます。
履歴ファイルは（巨大になるセグメントファイルとは異なり）単なる小さなテキストファイルですので、安価かつ適切に無期限で保管できます。
必要ならば、履歴ファイルにコメントを追加し、この特定のタイムラインがどのように、なぜ生成されたかについて独自の注釈を付与することができます。
特にこうしたコメントは、実験の結果いくつものタイムラインのもつれがある場合に有用です。
   </P
><P
>復旧処理のデフォルトは、ベースバックアップが取得された時点のタイムラインと同一のタイムラインに沿った復旧です。
別の子タイムラインに沿って復旧させたい（つまり、復旧試行以降に生成されたある状態に戻りたい）場合は<TT
CLASS="FILENAME"
>recovery.conf</TT
>で対象のタイムラインIDを指定しなければなりません。
ベースバックアップより前に分岐したタイムラインに沿って復旧することはできません。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BACKUP-TIPS"
>25.3.6. ヒントと例</A
></H2
><P
>継続的アーカイブを構成するいくつかのヒントを以下にあげます。
   </P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-STANDALONE"
>25.3.6.1. スタンドアローンホットバックアップ</A
></H3
><P
>スタンドアローンホットバックアップを形成するため<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のバックアップ基盤を使用することができます。
これらのバックアップはポイントインタイムリカバリに使用することはできないのですが、<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>によるダンプよりバックアップとリストアが概してより速く行われます。
（同時に<SPAN
CLASS="APPLICATION"
>pg_dump</SPAN
>のダンプより大きくなるので、場合によっては速度による利点が打ち消されるかもしれません。）
     </P
><P
>ベースバックアップと同様に、スタンドアローンホットバックアップを作成する最も簡単な方法は <A
HREF="app-pgbasebackup.html"
>pg_basebackup</A
>ツールを使用する方法です。
実行時に<TT
CLASS="LITERAL"
>-X</TT
>オプションをつけることでバックアップに必要な全てのトランザクションログを自動的にバックアップに含めることができ、リストアするときには特に特別な作業を行う必要がありません。
     </P
><P
>バックアップファイルをコピーするのにより柔軟性が必要な場合、スタンドアローンホットバックアップのために低レベルのプロセスを使うこともできます。
低レベルのスタンドアローンホットバックアップを取得するためには、準備として<TT
CLASS="VARNAME"
>wal_level</TT
>を<TT
CLASS="LITERAL"
>replica</TT
>以上にセットし、<TT
CLASS="VARNAME"
>archive_mode</TT
>を<TT
CLASS="LITERAL"
>on</TT
>にセットし、<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>switch ファイル</I
></SPAN
>が存在する時のみに実行される<TT
CLASS="VARNAME"
>archive_command</TT
>をセットします。
例：
</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'test ! -f /var/lib/pgsql/backup_in_progress || (test ! -f /var/lib/pgsql/archive/%f &amp;&amp; cp %p /var/lib/pgsql/archive/%f)'</PRE
><P>
このコマンドは<TT
CLASS="FILENAME"
>/var/lib/pgsql/backup_in_progress</TT
> が存在する時のみ実行され、存在しない時は単に0の終了コードを返します(<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に必要の無いWALファイルを再利用することを許可します)。
     </P
><P
>この準備によって、バックアップは以下のようなスクリプトを使用して取得されます。
</P><PRE
CLASS="PROGRAMLISTING"
>touch /var/lib/pgsql/backup_in_progress
psql -c "select pg_start_backup('hot_backup');"
tar -cf /var/lib/pgsql/backup.tar /var/lib/pgsql/data/
psql -c "select pg_stop_backup();"
rm /var/lib/pgsql/backup_in_progress
tar -rf /var/lib/pgsql/backup.tar /var/lib/pgsql/archive/</PRE
><P>
完全なWALファイルのアーカイブが行われるように、スイッチファイル、<TT
CLASS="FILENAME"
>/var/lib/pgsql/backup_in_progress</TT
>が最初に作成されます。
バックアップの後、スイッチファイルは削除されます。
その後、ベースバックアップとすべての必要なWALファイルが共に同じ<SPAN
CLASS="APPLICATION"
>tar</SPAN
>ファイルの一部になるよう、アーカイブされたWALファイルはバックアップに追加されます。
バックアップスクリプトにエラー処理を加えておくことを忘れないでください。
     </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="COMPRESSED-ARCHIVE-LOGS"
>25.3.6.2. 圧縮アーカイブログ</A
></H3
><P
>もし、アーカイブのストレージ容量に懸念がある場合、アーカイブファイルを圧縮するために<SPAN
CLASS="APPLICATION"
>gzip</SPAN
>を使用することもできます。

</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'gzip &lt; %p &gt; /var/lib/pgsql/archive/%f'</PRE
><P>
リカバリ中は <SPAN
CLASS="APPLICATION"
>gunzip</SPAN
>を使う必要があります。
</P><PRE
CLASS="PROGRAMLISTING"
>restore_command = 'gunzip &lt; /mnt/server/archivedir/%f &gt; %p'</PRE
><P>
     </P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BACKUP-SCRIPTS"
>25.3.6.3. <TT
CLASS="VARNAME"
>archive_command</TT
>スクリプト</A
></H3
><P
><TT
CLASS="FILENAME"
>postgresql.conf</TT
>の記入事項が以下のように簡素となるため、多くの人が<TT
CLASS="VARNAME"
>archive_command</TT
>の定義にスクリプトの使用を選択します。
</P><PRE
CLASS="PROGRAMLISTING"
>archive_command = 'local_backup_script.sh "%p" "%f"'</PRE
><P>
アーカイブ処理手順において単一ではなくそれ以上の数のコマンドを使用したい場合はいつでも、別のスクリプトファイルの使用が推奨されます。
そうするとスクリプト内で全ての複雑性が管理されます。
スクリプトは<SPAN
CLASS="APPLICATION"
>bash</SPAN
>または<SPAN
CLASS="APPLICATION"
>perl</SPAN
>のようなよくあるスクリプト言語で記載できます。
     </P
><P
>スクリプト内で解決される要件の例として以下があります。
      <P
></P
></P><UL
><LI
><P
>セキュアなオフサイトデータストレージへのデータのコピー
        </P
></LI
><LI
><P
>一回に全てではなく３時間毎に転送されるようにWALファイルのバッチ
        </P
></LI
><LI
><P
>その他のバックアップとリカバリーソフトウェアとのインターフェイス
        </P
></LI
><LI
><P
>エラー報告を行う監視ソフトとのインターフェイス
        </P
></LI
></UL
><P>
     </P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>ティップ: </B
><TT
CLASS="VARNAME"
>archive_command</TT
>スクリプトを使うときは<A
HREF="runtime-config-logging.html#GUC-LOGGING-COLLECTOR"
>logging_collector</A
>を使えるようにすることが望ましい方法です。
そのスクリプトはメッセージを<SPAN
CLASS="SYSTEMITEM"
>stderr</SPAN
>で書き出し、それはデータベースのサーバーログとして書かれます。
このためスクリプトでエラーが発生した時に簡単に検知するための細かな設定を行なうことができるからです。
      </P
></BLOCKQUOTE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="CONTINUOUS-ARCHIVING-CAVEATS"
>25.3.7. 警告</A
></H2
><P
>本ドキュメント作成時点では、継続的アーカイブ技術にいくつかの制限があります。
将来のリリースでは修正されるはずです。

  <P
></P
></P><UL
><LI
><P
>ハッシュインデックスに対する操作は現在WALログに残りません。
したがって、再生してもこれらのインデックスは更新されません。
これは、新しい挿入はインデックスにより無視され、更新された行は見かけ上消え、削除された行はポインタを保持し続けるということです。
すなわち、ハッシュインデックス付きのテーブルを変更すると、スタンバイサーバでは不正確な問い合わせ結果が得られます。
復旧処理が終わった後に手作業でそうしたインデックスそれぞれに対して<A
HREF="sql-reindex.html"
>REINDEX</A
>を行うことが推奨されます。
    </P
></LI
><LI
><P
>もしもベースバックアップが行われている時、<A
HREF="sql-createdatabase.html"
>CREATE DATABASE</A
>コマンドが実行され、ベースバックアップが処理を実行している期間に<TT
CLASS="COMMAND"
>CREATE DATABASE</TT
>がコピーしているtemplateデータベースが変更されると、復旧処理はこれらの変更を作成されたデータベースにも同時に伝播させることは確実です。
もちろん、これは望まれる事ではありません。
この危険を回避するには、ベースバックアップ期間中にはすべてのtemplateデータベースを変更しないことが一番です。
    </P
></LI
><LI
><P
><A
HREF="sql-createtablespace.html"
>CREATE TABLESPACE</A
>コマンドはリテラルの絶対パス付でWALにログが記録され、したがって、同じ絶対パスでのテーブル空間作成の時に再生されます。
これは、もしログが異なったマシン上で再生される場合には好ましくありません。
ログ再生がたとえ同一のマシンであっても、新規のデータディレクトリであれば危険です。
なぜなら、再生は元のテーブル空間の内容を上書きし続けるからです。
この種の潜在的な振舞いを防ぐためには、テーブル空間を作成もしくは削除後に新規ベースバックアップを行うのが最良の手段です。
    </P
></LI
></UL
><P>
   </P
><P
>また、デフォルトの<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>フォーマットは数多くのディスクページのスナップショットを含んでいるため、かなりかさばるものになってしまっていることに触れておくべきでしょう。
これらのページスナップショットは、クラッシュから回復のために設計されています。
それというのも、回復処理の際には不完全に書き込まれているディスクページを修復しなければならないことがあるからです。
システムのハードウェアやソフトウェアによっては、不完全なディスクページの書き込みが起きてしまう危険性は無視してもよい程微小です。
この場合<A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>パラメータを設定してページスナップショットを無効にすることで、アーカイブされたログの総容量を大幅に縮小できます
（実際に設定を行う前に、<A
HREF="wal.html"
>第30章</A
>の注意事項と警告を読んでください）。
ページスナップショットを無効にしても PITR処理の際にログが使用できなくなることはありません。
将来の課題は、<TT
CLASS="VARNAME"
>full_page_writes</TT
>がたとえオンになっている場合であっても不要なページを取り除き、アーカイブ済みWALデータの圧縮を行うことでしょう。
差し当たり管理者は、可能な限りチェックポイント間隔パラメータを大きくすることによって、WALに含まれるページスナップショットの数を削減することができます。
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="backup-file.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="high-availability.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ファイルシステムレベルのバックアップ</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="backup.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>高可用性、負荷分散およびレプリケーション</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>シーケンス操作関数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="関数と演算子"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="JSON関数と演算子"
HREF="functions-json.html"><LINK
REL="NEXT"
TITLE="条件式"
HREF="functions-conditional.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="JSON関数と演算子"
HREF="functions-json.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 9章関数と演算子</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="条件式"
HREF="functions-conditional.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-SEQUENCE"
>9.16. シーケンス操作関数</A
></H1
><P
>本節では<I
CLASS="FIRSTTERM"
>シーケンスオブジェクト</I
>に対し演算を行う関数について説明します。
シーケンスオブジェクトは、シーケンスジェネレータ、あるいは単にシーケンスとも呼ばれます。
シーケンスオブジェクトは特殊な一行だけのテーブルで、<A
HREF="sql-createsequence.html"
>CREATE SEQUENCE</A
>で作成されます。
シーケンスオブジェクトは一般的にテーブルの行に一意の識別子を生成するために使用されます。
<A
HREF="functions-sequence.html#FUNCTIONS-SEQUENCE-TABLE"
>表9-44</A
>に列挙されているシーケンス関数は、シーケンスオブジェクトから連続したシーケンス値を取得するための、簡易でマルチユーザに対応した関数です。
  </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-SEQUENCE-TABLE"
></A
><P
><B
>表 9-44. シーケンス関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>関数</TH
><TH
>戻り値</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>currval(<TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定されたシーケンスに対し<CODE
CLASS="FUNCTION"
>nextval</CODE
>で得られた最新の値を返す</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>lastval()</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>すべてのシーケンスに対して<CODE
CLASS="FUNCTION"
>nextval</CODE
>により最も最近取得された値を返す</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>nextval(<TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>シーケンスを進め、新しい値を返す</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>setval(<TT
CLASS="TYPE"
>regclass</TT
>, <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>シーケンスの現在値を設定する</TD
></TR
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>setval(<TT
CLASS="TYPE"
>regclass</TT
>, <TT
CLASS="TYPE"
>bigint</TT
>, <TT
CLASS="TYPE"
>boolean</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>シーケンスの現在値と<TT
CLASS="LITERAL"
>is_called</TT
>フラグを設定する</TD
></TR
></TBODY
></TABLE
></DIV
><P
>シーケンス関数により操作されるシーケンスは<TT
CLASS="TYPE"
>regclass</TT
>引数で指定されますが、それは<TT
CLASS="STRUCTNAME"
>pg_class</TT
>システムカタログ内にある、そのシーケンスの単なるOIDです。
しかしながら、手作業でOIDを検索する必要はなく、<TT
CLASS="TYPE"
>regclass</TT
>データ型の入力変換器が代わってその作業を行ってくれます。
単一引用符で括られたシーケンス名を記述するだけで良いので、リテラル定数のように見えます。
通常の<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の名称での操作との互換のため、文字列はシーケンス名が二重引用符で括られていなければ、小文字に変換されます。
よって、以下のようになります。
</P><PRE
CLASS="PROGRAMLISTING"
>nextval('foo')      <I
CLASS="LINEANNOTATION"
>シーケンス<TT
CLASS="LITERAL"
>foo</TT
>の操作</I
>
nextval('FOO')      <I
CLASS="LINEANNOTATION"
>シーケンス<TT
CLASS="LITERAL"
>foo</TT
>の操作</I
>
nextval('"Foo"')    <I
CLASS="LINEANNOTATION"
>シーケンス<TT
CLASS="LITERAL"
>Foo</TT
>の操作</I
></PRE
><P>
必要であれば、以下のようにシーケンス名をスキーマで修飾することができます。
</P><PRE
CLASS="PROGRAMLISTING"
>nextval('myschema.foo')     <I
CLASS="LINEANNOTATION"
><TT
CLASS="LITERAL"
>myschema.foo</TT
>の操作</I
>
nextval('"myschema".foo')   <I
CLASS="LINEANNOTATION"
>上と同じ</I
>
nextval('foo')              <I
CLASS="LINEANNOTATION"
><TT
CLASS="LITERAL"
>foo</TT
>を検索パスで探す</I
></PRE
><P>
<TT
CLASS="TYPE"
>regclass</TT
>に関してのより詳細な情報は<A
HREF="datatype-oid.html"
>項8.18</A
>を参照してください。
  </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の8.1より前においては、シーケンス関数の引数は<TT
CLASS="TYPE"
>regclass</TT
>型ではなく、<TT
CLASS="TYPE"
>text</TT
>型で、そして上記のテキスト文字列からOID値への変換はそれぞれの呼び出し実行時に起こりました。
後方互換性のため、この仕組みはまだ存在しますが、内部的には関数が実行される前に<TT
CLASS="TYPE"
>text</TT
>から<TT
CLASS="TYPE"
>regclass</TT
>への暗黙的強制型変換として現在処理されています。
   </P
><P
>ありのままのリテラル文字列としてシーケンス関数の引数を記述すると、<TT
CLASS="TYPE"
>regclass</TT
>データ型の定数になります。
これは単なるOIDなので、後で名前付けが再び行われたとか、スキーマの再割り振りとかに関わらず、最初に特定されたシーケンスを引き継ぎます。
この<SPAN
CLASS="QUOTE"
>"初期束縛"</SPAN
>の動作は、列のデフォルトやビューからシーケンスを参照する場合は望ましいことが多いでしょう。
しかし、実行時にシーケンス参照が解決されるような<SPAN
CLASS="QUOTE"
>"動的束縛"</SPAN
>が望まれる場合もあります。
動的束縛の動作を得るには、その定数を<TT
CLASS="TYPE"
>regclass</TT
>ではなく<TT
CLASS="TYPE"
>text</TT
>定数として保存させます。
</P><PRE
CLASS="PROGRAMLISTING"
>nextval('foo'::text)      <I
CLASS="LINEANNOTATION"
>実行時に<TT
CLASS="LITERAL"
>foo</TT
>を探す</I
></PRE
><P>
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のリリース8.1より前では動的束縛のみがサポートされる動作だったので、旧来のアプリケーションのセマンティクスを保ちたい場合このようにする必要があるかもしれません。
   </P
><P
>もちろん、シーケンス関数の引数は定数だけでなく、評価式とすることも可能です。
テキスト式の場合は暗黙的型変換により、実行時検索が行われます。
   </P
></BLOCKQUOTE
></DIV
><P
>使用できるシーケンス関数には以下のものがあります。

    <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><CODE
CLASS="FUNCTION"
>nextval</CODE
></DT
><DD
><P
>シーケンスオブジェクトをその次の値に進め、その値を返します。
これは原子的に処理され、複数のセッションが同時に<CODE
CLASS="FUNCTION"
>nextval</CODE
>を実行したとしても、それぞれのセッションは異なるシーケンス値を安全に受け取ります。
       </P
><P
>デフォルトのパラメータによってシーケンスオブジェクトが作成されているなら、引き続く<CODE
CLASS="FUNCTION"
>nextval</CODE
>呼び出しは１から始まる連続的な値を返します。
その他の動作を<A
HREF="sql-createsequence.html"
>CREATE SEQUENCE</A
>コマンドの特別なパラメータを使用してさせることが可能です。より詳しくはコマンドのリファレンスガイドを参照ください。
       </P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>重要項目: </B
>同一のシーケンスから数値を取得する同時実行トランザクション同士のブロックを防止するため、<CODE
CLASS="FUNCTION"
>nextval</CODE
>演算は決してロールバックされません。
と言うことは、たとえ<CODE
CLASS="FUNCTION"
>nextval</CODE
>を実行したトランザクションが後にアボートしたとしても、値が一度取り出されたらそれは使用されたものと考えます。
つまり、中止されたトランザクションは、割り当てられた値のシーケンス内に未使用の<SPAN
CLASS="QUOTE"
>"欠損"</SPAN
>を残す可能性があります。
        </P
></BLOCKQUOTE
></DIV
></DD
><DT
><CODE
CLASS="FUNCTION"
>currval</CODE
></DT
><DD
><P
>現在のセッションにおいて、そのシーケンスから<CODE
CLASS="FUNCTION"
>nextval</CODE
>によって取得された直近の値を返します。
（セッション内でそのシーケンスに対し<CODE
CLASS="FUNCTION"
>nextval</CODE
>が呼ばれていない場合には、エラーが報告されます。）
これはセッションごとの個別の値を返すので、現在のセッションが<CODE
CLASS="FUNCTION"
>nextval</CODE
>を実行した後、他のセッションが<CODE
CLASS="FUNCTION"
>nextval</CODE
>を実行したかどうかに関わらず、期待通りの回答をもたらします。
       </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>lastval</CODE
></DT
><DD
><P
>現在のセッションの<CODE
CLASS="FUNCTION"
>nextval</CODE
>で直近に戻された値を返します。
この関数は<CODE
CLASS="FUNCTION"
>currval</CODE
>と同等ですが、引数としてシーケンス名をとる代わりに、現在のセッションで最後に<CODE
CLASS="FUNCTION"
>nextval</CODE
>で使用されたシーケンスの値を取得するところが異なります。
現在のセッションで<CODE
CLASS="FUNCTION"
>nextval</CODE
>が未だ呼ばれていなければエラーになります。
       </P
></DD
><DT
><CODE
CLASS="FUNCTION"
>setval</CODE
></DT
><DD
><P
>シーケンスオブジェクトの計数値をリセットします。
パラメータが２つの形式では、シーケンスの<TT
CLASS="LITERAL"
>last_value</TT
>フィールドを指定された値に設定し、<TT
CLASS="LITERAL"
>is_called</TT
>フィールドを<TT
CLASS="LITERAL"
>true</TT
>（真）に設定します。
この意味は、次の<CODE
CLASS="FUNCTION"
>nextval</CODE
>が値を返す前にシーケンスを進めるということです。
<CODE
CLASS="FUNCTION"
>currval</CODE
>で報告される値も指定された値に設定されます。
３パラメータ形式の場合、<TT
CLASS="LITERAL"
>is_called</TT
>を<TT
CLASS="LITERAL"
>true</TT
>（真）もしくは<TT
CLASS="LITERAL"
>false</TT
>（偽）に設定することができます。
<TT
CLASS="LITERAL"
>true</TT
>（真）は２パラメータ形式と同じ効果があります。
<TT
CLASS="LITERAL"
>false</TT
>（偽）に設定された場合、次の<CODE
CLASS="FUNCTION"
>nextval</CODE
>は指定されたその値を返し、シーケンスの進行は引き続く<CODE
CLASS="FUNCTION"
>nextval</CODE
>から始まります。
さらにこの場合、<CODE
CLASS="FUNCTION"
>currval</CODE
>で報告される値は変更されません。
例えば、次の例です。

</P><PRE
CLASS="SCREEN"
>SELECT setval('foo', 42);           <I
CLASS="LINEANNOTATION"
>次の<CODE
CLASS="FUNCTION"
>nextval</CODE
>は43を返す</I
>
SELECT setval('foo', 42, true);     <I
CLASS="LINEANNOTATION"
>上と同じ</I
>
SELECT setval('foo', 42, false);    <I
CLASS="LINEANNOTATION"
>次の<CODE
CLASS="FUNCTION"
>nextval</CODE
>は42を返す</I
></PRE
><P>

<CODE
CLASS="FUNCTION"
>setval</CODE
>によって返される結果は単にその第2番目の引数の値です。
       </P
><DIV
CLASS="IMPORTANT"
><BLOCKQUOTE
CLASS="IMPORTANT"
><P
><B
>重要項目: </B
>シーケンスはトランザクションとは異なる扱いを受けるため、<CODE
CLASS="FUNCTION"
>setval</CODE
>による変更は、そのトランザクションがロールバックされたとしても元に戻りません。
        </P
></BLOCKQUOTE
></DIV
></DD
></DL
></DIV
><P>
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-json.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-conditional.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>JSON関数と演算子</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>条件式</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
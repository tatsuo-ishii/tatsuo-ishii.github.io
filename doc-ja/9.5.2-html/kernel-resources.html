<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>カーネルリソースの管理</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="サーバの準備と運用"
HREF="runtime.html"><LINK
REL="PREVIOUS"
TITLE="データベースサーバの起動"
HREF="server-start.html"><LINK
REL="NEXT"
TITLE="サーバのシャットダウン"
HREF="server-shutdown.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="データベースサーバの起動"
HREF="server-start.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="runtime.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 17章サーバの準備と運用</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="サーバのシャットダウン"
HREF="server-shutdown.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="KERNEL-RESOURCES"
>17.4. カーネルリソースの管理</A
></H1
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、特に同一システム上で複数のサーバコピーを実行している場合や非常に大規模なインストレーションでは、オペレーティングシステムの様々なリソース制限を超えてしまうことがあります。
本節では、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>で使用されるカーネルリソース、およびカーネルリソース消費に関連した問題を解消する時に取ることができる手順について説明します。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SYSVIPC"
>17.4.1. 共有メモリとセマフォ</A
></H2
><P
>共有メモリとセマフォはひとまとめに<SPAN
CLASS="QUOTE"
>"<SPAN
CLASS="SYSTEMITEM"
>System V</SPAN
> <ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
>"</SPAN
>と呼ばれます
（メッセージキューも一緒ですが、これは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>とは関係ありません）。
これらの機能を独自の代替的な実装で提供している<SPAN
CLASS="SYSTEMITEM"
>Windows</SPAN
>を除き、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を実行させるためにはこれらの機能が必要です。
   </P
><P
>これらの機能の完全な欠落は、サーバ起動時の<SPAN
CLASS="ERRORNAME"
>Illegal system call</SPAN
>エラーによって判明します。
その場合はカーネルを設定し直すしかありません。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はこれらの機能なしでは動きません。
しかし最近のオペレーティングシステムではこうした状況はまれなものです。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>が様々な<ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
>のハードリミットの1つを超えると、サーバは起動を拒否し、問題および何をすべきかを説明するエラーメッセージを残します。
（<A
HREF="server-start.html#SERVER-START-FAILURES"
>項17.3.1</A
> も参照してください。）
関係するカーネルパラメータは別々のシステム上でも統一して名付けられています。
<A
HREF="kernel-resources.html#SYSVIPC-PARAMETERS"
>表17-1</A
>で概略がわかります。
しかしこれらを設定するための方法は異なります。
以下に、いくつかのプラットフォームへの提案を挙げます。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 9.3より前では、サーバを起動させるために必要なSystem V共有メモリの量は非常に大きなものでした。
より古いバージョンのサーバで実行しているのであれば、該当するバージョンのサーバの文書を参照してください。
     </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TABLE"
><A
NAME="SYSVIPC-PARAMETERS"
></A
><P
><B
>表 17-1. <SPAN
CLASS="SYSTEMITEM"
>System V</SPAN
> <ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
>パラメータ</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>説明</TH
><TH
>適切な値</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="VARNAME"
>SHMMAX</TT
></TD
><TD
>共有メモリセグメントの最大サイズ（バイト）</TD
><TD
>最小でも1キロバイト（複数のサーバのコピーを実行している場合はこれ以上）</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMMIN</TT
></TD
><TD
>共有メモリセグメントの最小サイズ（バイト）</TD
><TD
>1</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMALL</TT
></TD
><TD
>使用可能な共有メモリの総量（バイトまたはページ）</TD
><TD
>バイト指定の場合<TT
CLASS="VARNAME"
>SHMMAX</TT
>と同じです。 ページ指定の場合は<TT
CLASS="LITERAL"
>ceil(SHMMAX/PAGE_SIZE)</TT
>です。</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMSEG</TT
></TD
><TD
>プロセスごとの共有メモリセグメントの最大数</TD
><TD
>必要なのは1セグメントだけですが、デフォルトではもっと多くなっています</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SHMMNI</TT
></TD
><TD
>システム全体の共有メモリセグメントの最大数</TD
><TD
><TT
CLASS="VARNAME"
>SHMSEG</TT
>と同様 + 他のアプリケーション用の空間</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMNI</TT
></TD
><TD
>セマフォ識別子の最大数（つまりセット）</TD
><TD
>最低<TT
CLASS="LITERAL"
>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</TT
></TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMNS</TT
></TD
><TD
>システム全体のセマフォの最大数</TD
><TD
><TT
CLASS="LITERAL"
>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16) * 17</TT
> + 他のアプリケーション用の空間</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMSL</TT
></TD
><TD
>セットごとのセマフォの最大数</TD
><TD
>最低17</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMMAP</TT
></TD
><TD
>セマフォマップの中の項目の数</TD
><TD
>本文を参照</TD
></TR
><TR
><TD
><TT
CLASS="VARNAME"
>SEMVMX</TT
></TD
><TD
>セマフォの最大値</TD
><TD
>最低1000（デフォルトはしばしば32767ですが、必要がなければ変更しないでください）</TD
></TR
></TBODY
></TABLE
></DIV
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、サーバのコピー毎にSystem V共有メモリの数バイト（64ビットプラットフォームでは通常48バイト）を必要とします。
最近のほとんどのオペレーティングシステムでは、このくらいの量は簡単に割り当てられます。
しかし複数のサーバのコピーを実行している場合やSystem V共有メモリを使用する他のアプリケーションを実行している場合は、
共有メモリセグメントの最大サイズである<TT
CLASS="VARNAME"
>SHMMAX</TT
>をバイト単位で、あるいは、システム全体のSystem V共有メモリである<TT
CLASS="VARNAME"
>SHMALL</TT
>を増加させる必要があるかもしれません。
多くのシステムでは<TT
CLASS="VARNAME"
>SHMALL</TT
>をバイト単位ではなくページ単位で測ることに注意してください。
   </P
><P
>問題が少ないのは共有メモリセグメントの最小サイズ（<TT
CLASS="VARNAME"
>SHMMIN</TT
>）で、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では最大でもおよそ32バイトのはずです（通常では1です）。
システム全体のセグメントの最大数（<TT
CLASS="VARNAME"
>SHMMNI</TT
>）もしくはプロセスごとのセグメントの最大数（<TT
CLASS="VARNAME"
>SHMSEG</TT
>）に関して、使用しているシステムで0に設定されていない限り、問題が起きることはほぼありません。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、許可した接続（<A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
>max_connections</A
>）、許可したオートバキュームワーカプロセス（<A
HREF="runtime-config-autovacuum.html#GUC-AUTOVACUUM-MAX-WORKERS"
>autovacuum_max_workers</A
>）、許可したバックエンドプロセス(<A
HREF="runtime-config-resource.html#GUC-MAX-WORKER-PROCESSES"
>max_worker_processes</A
>)ごとに1つのセマフォを使用し、16個のセマフォをセットとして扱います。
それぞれそのようなセットは、他のアプリケーションに使われているセマフォセットとの衝突を検出するための<SPAN
CLASS="QUOTE"
>"マジックナンバー"</SPAN
>が含まれている17個目のセマフォを持っています。
システム内のセマフォの最大数は<TT
CLASS="VARNAME"
>SEMMNS</TT
>によって設定され、その結果としてその値は少なくとも<TT
CLASS="VARNAME"
>max_connections</TT
>＋<TT
CLASS="VARNAME"
>autovacuum_max_workers</TT
>＋<TT
CLASS="VARNAME"
>max_worker_processes</TT
>と同じ、ただし、許可された接続とワーカ16個ごとに余分な1個を加えた値以上はなければいけません（<A
HREF="kernel-resources.html#SYSVIPC-PARAMETERS"
>表17-1</A
>の公式を参照してください）。
<TT
CLASS="VARNAME"
>SEMMNI</TT
>パラメータはシステム上に同時に存在できるセマフォ集合の数の上限を決定します。
ですから、このパラメータは少なくとも<TT
CLASS="LITERAL"
>ceil((max_connections + autovacuum_max_workers + max_worker_processes + 5) / 16)</TT
>以上はなくてはいけません。
一時的な失敗の回避策としては許可される接続の数を下げることができますが、<SPAN
CLASS="QUOTE"
>"No space left on device"</SPAN
>という紛らわしい言葉が<CODE
CLASS="FUNCTION"
>semget</CODE
>関数から表示されます。
   </P
><P
>場合によっては<TT
CLASS="VARNAME"
>SEMMAP</TT
>を少なくとも<TT
CLASS="VARNAME"
>SEMMNS</TT
>と同程度に増やすことが必要になる場合があるかもしれません。
このパラメータはセマフォリソースマップのサイズを定義し、その中では有効なセマフォのそれぞれの隣接したブロックの項目が必要です。
セマフォ集合が解放されると、解放されたブロックに隣接する既に存在する項目に追加されるか、もしくは新しいマップの項目の下に登録されます。
もしマップが一杯だった場合、解放されたセマフォは（再起動するまで）失われます。
セマフォ空間の断片化により時間が経つごとに、有効なセマフォがあるべき量よりも少なくなる可能性があります。
   </P
><P
>1つの集合の中にいくつのセマフォがあるかを決める<TT
CLASS="VARNAME"
>SEMMSL</TT
>は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では少なくとも17はなくてはいけません。
   </P
><P
><TT
CLASS="VARNAME"
>SEMMNU</TT
>と<TT
CLASS="VARNAME"
>SEMUME</TT
>のような、その他の様々な<SPAN
CLASS="QUOTE"
>"semaphore undo"</SPAN
>に関する設定は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>には影響を与えません。
   </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="SYSTEMITEM"
>AIX</SPAN
>
      </DT
><DD
><P
>少なくともバージョン5.1では、すべてのメモリが共有メモリとして使用できるように設定されているようにみえますので、<TT
CLASS="VARNAME"
>SHMMAX</TT
>などのパラメータに対して特別な設定は必要ありません。
これは<SPAN
CLASS="APPLICATION"
>DB/2</SPAN
>などの他のデータベースでも使用される、一般的な設定方法です。</P
><P
>しかし、<TT
CLASS="FILENAME"
>/etc/security/limits</TT
>内の大域的な<TT
CLASS="COMMAND"
>ulimit</TT
>情報は変更しなければならないかもしれません。
デフォルトのファイルサイズ（<TT
CLASS="VARNAME"
>fsize</TT
>）とファイル数（<TT
CLASS="VARNAME"
>nofiles</TT
>）用のハードリミットは低過ぎるかもしれないためです。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>
      </DT
><DD
><P
>デフォルトの設定は<TT
CLASS="COMMAND"
>sysctl</TT
>または<TT
CLASS="COMMAND"
>loader</TT
>インタフェースを使用して変更を行うことができます。
以下では<TT
CLASS="COMMAND"
>sysctl</TT
>を使用してパラメータを変更しています。
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>#</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl kern.ipc.shmall=32768</KBD
>
<SAMP
CLASS="PROMPT"
>#</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl kern.ipc.shmmax=134217728</KBD
></PRE
><P>
これらの設定を再起動しても永続化するには、<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>を変更します。
       </P
><P
>セマフォ関連の設定は<TT
CLASS="COMMAND"
>sysctl</TT
>では読み取りのみとみなされていますが、<TT
CLASS="FILENAME"
>/boot/loader.conf</TT
>内で設定することができます。
</P><PRE
CLASS="PROGRAMLISTING"
>kern.ipc.semmni=256
kern.ipc.semmns=512
kern.ipc.semmnu=256</PRE
><P>
これらの値を変更した後、新しい設定を有効にするためには再起動が必要です。
(注意: FreeBSD は<TT
CLASS="VARNAME"
>SEMMAP</TT
>を使用しません。古いバージョンは<TT
CLASS="LITERAL"
>kern.ipc.semmap</TT
>の設定を受けれますが無視します; 新しいバージョンでは拒否します。)
       </P
><P
>また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<TT
CLASS="COMMAND"
>sysctl</TT
>を使用して<TT
CLASS="LITERAL"
>kern.ipc.shm_use_phys</TT
>を設定することで実現できます。
       </P
><P
><SPAN
CLASS="APPLICATION"
>sysctl</SPAN
>の<TT
CLASS="LITERAL"
>security.jail.sysvipc_allowed</TT
>を有効にしてFreeBSD jailを実行している場合、異なるjailで実行する<SPAN
CLASS="APPLICATION"
>postmaster</SPAN
>を別のオペレーティングシステムユーザで実行しなければなりません。
これは、非特権ユーザが別のjailの共有メモリやセマフォに干渉することを防止できるため、セキュリティが向上します。
また、これによりPostgreSQLのIPCを整理するコードを適切に動作させることができます。
（FreeBSD 6.0以降では、IPC整理コードは他のjailにおけるプロセスを適切に検出せず、異なるjailで同一ポートでpostmasterを実行させることができません。）
       </P
><P
><SPAN
CLASS="SYSTEMITEM"
>FreeBSD</SPAN
>バージョン4.0以前では、（後述の）<SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
>と同様に動作します。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
>
      </DT
><DD
><P
><SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
> 5.0以降では、以下の例のようにIPCパラメータを<TT
CLASS="COMMAND"
>sysctl</TT
>を用いて調整することができます。
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl -w kern.ipc.shmmax=16777216</KBD
></PRE
><P>
この設定を再起動しても永続化させるためには<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>を編集してください。
       </P
><P
>また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<TT
CLASS="COMMAND"
>sysctl</TT
>を使用して<TT
CLASS="LITERAL"
>kern.ipc.shm_use_phys</TT
>を設定することで実現できます。
       </P
><P
>5.0より前のバージョンの<SPAN
CLASS="SYSTEMITEM"
>NetBSD</SPAN
>では、（後述の）<SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
>のように動作します。
ただし、パラメータは<TT
CLASS="LITERAL"
>option</TT
>ではなく<TT
CLASS="LITERAL"
>options</TT
>キーワードを付けて設定する必要があります。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OpenBSD</SPAN
>
      </DT
><DD
><P
><TT
CLASS="VARNAME"
>SYSVSHM</TT
>オプションと<TT
CLASS="VARNAME"
>SYSVSEM</TT
>オプションはカーネルのコンパイル時に有効にする必要があります（デフォルトでは有効になっています）。
共有メモリの最大サイズは<TT
CLASS="VARNAME"
>SHMMAXPGS</TT
>オプション（ページ数）で決定されます。
以下に様々なパラメータの設定方法の例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>option        SYSVSHM
option        SHMMAXPGS=4096
option        SHMSEG=256

option        SYSVSEM
option        SEMMNI=256
option        SEMMNS=512
option        SEMMNU=256
option        SEMMAP=256</PRE
><P>
       </P
><P
>また、共有メモリをRAM上に固定して、スワップによってページアウトされるのを避けるために、カーネルを設定したいと考えるかもしれません。
これは<TT
CLASS="COMMAND"
>sysctl</TT
>を使用して<TT
CLASS="LITERAL"
>kern.ipc.shm_use_phys</TT
>を設定することで実現できます。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>HP-UX</SPAN
>
      </DT
><DD
><P
>デフォルトの設定は通常のインストールではほぼ十分です。
<SPAN
CLASS="PRODUCTNAME"
>HP-UX</SPAN
> 10では<TT
CLASS="VARNAME"
>SEMMNS</TT
>の出荷時のデフォルトは128ですが、これは大規模なデータベースサイトには低過ぎるかもしれません。
       </P
><P
><ACRONYM
CLASS="ACRONYM"
>IPC</ACRONYM
>パラメータは<SPAN
CLASS="APPLICATION"
>システム管理マネージャ</SPAN
>（<ACRONYM
CLASS="ACRONYM"
>SAM</ACRONYM
>）から<SPAN
CLASS="GUIMENU"
>Kernel Configuration</SPAN
>-&gt;<SPAN
CLASS="GUIMENUITEM"
>Configurable Parameters</SPAN
>の下で、設定することができます。
終わったら<SPAN
CLASS="GUIBUTTON"
>Create A New Kernel</SPAN
>を選択してください。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Linux</SPAN
>
      </DT
><DD
><P
>デフォルトの最大セグメントサイズは32メガバイト、デフォルトの最大総サイズは2097152ページです。
<SPAN
CLASS="QUOTE"
>"huge pages"</SPAN
>を持つ通常ではないカーネル設定を除き、1ページはほとんど常に4096バイトです。
(検証には<TT
CLASS="LITERAL"
>getconf PAGE_SIZE</TT
>を使用してください。)
       </P
><P
>共有メモリサイズの設定は<TT
CLASS="COMMAND"
>sysctl</TT
>インタフェースを使用して変更可能です。
例えば16ギガバイトまで許すには以下のようにします。
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl -w kernel.shmmax=17179869184</KBD
>
<SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>sysctl -w kernel.shmall=4194304</KBD
></PRE
><P>
更にこれらの設定を再起動時に保持できるように<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>に保存することができます。
こうすることを大いに勧めます。
       </P
><P
>古めのディストリビューションでは<TT
CLASS="COMMAND"
>sysctl</TT
>プログラムが存在しない可能性があります。
この場合、<TT
CLASS="FILENAME"
>/proc</TT
>ファイルシステムに対する操作で同等の変更を行うことができます。
</P><PRE
CLASS="SCREEN"
><SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>echo 17179869184 &gt;/proc/sys/kernel/shmmax</KBD
>
<SAMP
CLASS="PROMPT"
>$</SAMP
> <KBD
CLASS="USERINPUT"
>echo 4194304 &gt;/proc/sys/kernel/shmall</KBD
></PRE
><P>
       </P
><P
>他のデフォルトはかなり豊富なサイズですので、通常は変更する必要はありません。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>OS X</SPAN
>
      </DT
><DD
><P
>OS Xにおける共有メモリの推奨設定方法は、以下のような変数代入文からなる<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>という名称のファイルを作成することです。
</P><PRE
CLASS="PROGRAMLISTING"
>kern.sysv.shmmax=4194304
kern.sysv.shmmin=1
kern.sysv.shmmni=32
kern.sysv.shmseg=8
kern.sysv.shmall=1024</PRE
><P>
一部のバージョンのOS Xでは<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>内に共有メモリパラメータ<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>5つすべて</I
></SPAN
>を設定しなければならないという点に注意してください。
さもなくば値が無視されます。
       </P
><P
>最近のリリースのOS Xは、<TT
CLASS="VARNAME"
>SHMMAX</TT
>を4096の倍数以外に設定しようとすると無視しますので、注意してください。
       </P
><P
>このプラットフォームでは<TT
CLASS="VARNAME"
>SHMALL</TT
>は4キロバイトページ単位です。
       </P
><P
>古めのバージョンのOS Xでは、共有メモリパラメータの変更を有効にするために再起動が必要になります。
10.5から<TT
CLASS="VARNAME"
>SHMMNI</TT
>以外の変更は、<SPAN
CLASS="APPLICATION"
>sysctl</SPAN
>を用いることにより、その場で行うことができます。
しかしいずれにせよ<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>経由で望む値に設定することが最善です。
再起動を行っても値が保持されるからです。
       </P
><P
><TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>はOS X 10.3.9以降でのみ使用されます。
もしこれより前の10.3.xリリースを使用しているのであれば、<TT
CLASS="FILENAME"
>/etc/rc</TT
>ファイルを編集し、以下のコマンドで値を変更しなければなりません。
</P><PRE
CLASS="PROGRAMLISTING"
>sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall</PRE
><P>
通常<TT
CLASS="FILENAME"
>/etc/rc</TT
>はOS Xのアップデートで上書きされることに注意してください。
ですので、アップデートの度に編集し直す必要があるものと考えなければなりません。
       </P
><P
>OS X 10.2以前では、代わりに<TT
CLASS="FILENAME"
>/System/Library/StartupItems/SystemTuning/SystemTuning</TT
>ファイル内にあるこれらのコマンドを編集してください。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>SCO OpenServer</SPAN
>
      </DT
><DD
><P
>デフォルトの設定では、セグメント当たり512キロバイトの共有メモリが許されています。
この設定を増加させるには、まず、<TT
CLASS="FILENAME"
>/etc/conf/cf.d</TT
>ディレクトリに移動します。
<TT
CLASS="VARNAME"
>SHMMAX</TT
>の現在値を表示させるには、以下を実行します。
</P><PRE
CLASS="PROGRAMLISTING"
>./configure -y SHMMAX</PRE
><P>
<TT
CLASS="VARNAME"
>SHMMAX</TT
>に新しい値を設定するには以下を実行します。
</P><PRE
CLASS="PROGRAMLISTING"
>./configure SHMMAX=<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
></PRE
><P>
ここで、<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
>が希望する新しい値（バイト単位）です。
そして、以下のようにカーネルを再構築し、再起動します。
</P><PRE
CLASS="PROGRAMLISTING"
>./link_unix</PRE
><P>
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
> 2.6から2.9 (Solaris 6からSolaris 9)
      </DT
><DD
><P
>必要な設定は<TT
CLASS="FILENAME"
>/etc/system</TT
>で変えることができ、例えば以下のようになります。
</P><PRE
CLASS="PROGRAMLISTING"
>set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32</PRE
><P>
変更を反映させるには再起動する必要があります。
古めのバージョンのSolarisにおける共有メモリの情報は<A
HREF="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html"
TARGET="_top"
>http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html</A
>を参照してください。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>Solaris</SPAN
> 2.10 (Solaris 10)以降<BR><SPAN
CLASS="SYSTEMITEM"
>OpenSolaris</SPAN
></DT
><DD
><P
>Solaris 10以降とOpenSolarisでは、デフォルトの共有メモリとセマフォ設定は大抵の<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>アプリケーションで十分あります。
Solarisのデフォルトの<TT
CLASS="VARNAME"
>SHMMAX</TT
>はシステムの<ACRONYM
CLASS="ACRONYM"
>RAM</ACRONYM
>の1/4になりました。
さらにこの設定を調整するためには、<TT
CLASS="LITERAL"
>postgres</TT
>ユーザに関するプロジェクト設定を使用しなければなりません。
例えば以下を<TT
CLASS="LITERAL"
>root</TT
>権限で実行してください。
</P><PRE
CLASS="PROGRAMLISTING"
>projadd -c "PostgreSQL DB User" -K "project.max-shm-memory=(privileged,8GB,deny)" -U postgres -G postgres user.postgres</PRE
><P>
       </P
><P
>このコマンドは<TT
CLASS="LITERAL"
>user.postgres</TT
>プロジェクトを追加し、<TT
CLASS="LITERAL"
>postgres</TT
>ユーザの共有メモリの最大サイズを8GBに設定します。
この影響は次にこのユーザがログインした時、または<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を再起動した時（再読み込み時ではありません）に有効になります。
上では<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は<TT
CLASS="LITERAL"
>postgres</TT
>グループに属する<TT
CLASS="LITERAL"
>postgres</TT
>ユーザにより実行されていることを前提としています。
サーバの再起動は不要です。
       </P
><P
>多くの接続を受け付けるデータベースサーバにおいて推奨するカーネル設定にはこの他に以下があります。
</P><PRE
CLASS="PROGRAMLISTING"
>project.max-shm-ids=(priv,32768,deny)
project.max-sem-ids=(priv,4096,deny)
project.max-msg-ids=(priv,4096,deny)</PRE
><P>
       </P
><P
>さらに、ゾーン内で<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を実行している場合、ゾーンのリソース使用上限も上げる必要があるかもしれません。
<TT
CLASS="LITERAL"
>projects</TT
>と<TT
CLASS="COMMAND"
>prctl</TT
>については<I
CLASS="CITETITLE"
>System Administrator's Guide</I
>の第2章 プロジェクトとタスクを参照してください。
       </P
></DD
><DT
><SPAN
CLASS="SYSTEMITEM"
>UnixWare</SPAN
>
      </DT
><DD
><P
><SPAN
CLASS="PRODUCTNAME"
>UnixWare</SPAN
> 7では、共有メモリセグメントの最大サイズはデフォルト設定で512キロバイトです。
現在の<TT
CLASS="VARNAME"
>SHMMAX</TT
>値を表示するためには下記を実行してください。
</P><PRE
CLASS="PROGRAMLISTING"
>/etc/conf/bin/idtune -g SHMMAX</PRE
><P>
これは現在値、デフォルト値、最小値、および最大値を、バイト単位で表示します。
<TT
CLASS="VARNAME"
>SHMMAX</TT
>の新しい値を設定するためには、以下を実行します。
</P><PRE
CLASS="PROGRAMLISTING"
>/etc/conf/bin/idtune SHMMAX <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
></PRE
><P>
ここで<TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> は、希望する新しい値（バイト）です。
<TT
CLASS="VARNAME"
>SHMMAX</TT
>の設定が終わったらカーネルを再構築し、再起動します。
</P><PRE
CLASS="PROGRAMLISTING"
>/etc/conf/bin/idbuild -B</PRE
><P>
       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN29882"
>17.4.2. リソースの制限</A
></H2
><P
>Unixライクなオペレーティングシステムでは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバの操作と関係する可能性のある様々な種類のリソース制限があります。
特に重要なのは、ユーザごとのプロセス数の制限、プロセスごとのオープンファイルの数、プロセスごとの利用可能なメモリの量です。
これらのそれぞれが<SPAN
CLASS="QUOTE"
>"ハード"</SPAN
>と<SPAN
CLASS="QUOTE"
>"ソフト"</SPAN
>の2つの制限を持っています。
ソフト制限が実際に有効な制限ですが、ユーザによってハード制限まで変えることが可能です。
ハード制限はrootユーザによってのみ変えることができます。
<CODE
CLASS="FUNCTION"
>setrlimit</CODE
>システムコールがこれらのパラメータの設定を行います。
シェルの組み込みコマンド<TT
CLASS="COMMAND"
>ulimit</TT
>（Bourne シェル）もしくは<TT
CLASS="COMMAND"
>limit</TT
>（<SPAN
CLASS="APPLICATION"
>csh</SPAN
>）は、コマンドラインからリソース制限を制御するために使われます。
BSD派生システム上では<TT
CLASS="FILENAME"
>/etc/login.conf</TT
>ファイルが、ログイン時に設定される様々なリソース制限を制御します。
詳細はオペレーティングシステムの文書を参照してください。
関連するパラメータは<TT
CLASS="VARNAME"
>maxproc</TT
>、<TT
CLASS="VARNAME"
>openfiles</TT
>、<TT
CLASS="VARNAME"
>datasize</TT
>です。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...</PRE
><P>
（<TT
CLASS="LITERAL"
>-cur</TT
>はソフト制限です。
ハード制限を設定するためには<TT
CLASS="LITERAL"
>-max</TT
>を付けてください。）
   </P
><P
>カーネルはいくつかのリソースに対して、システム全体の制限も持つことができます。
    <P
></P
></P><UL
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>Linux</SPAN
>では、<TT
CLASS="FILENAME"
>/proc/sys/fs/file-max</TT
>が、カーネルがサポートするオープンファイル数の最大を決定します。
この数を変えるためには、そのファイルに別の数を書き込むか、あるいは<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>に代入式を追加します。
プロセスごとのファイルの最大制限はカーネルがコンパイルされた時に固定されます。
詳しい情報については<TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/proc.txt</TT
>を参照してください。
      </P
></LI
></UL
><P>
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>サーバは接続ごとに1つのプロセスを使うので、少なくとも許可された接続の数だけのプロセスに残りのシステムで必要な分を追加したものが必要になります。
通常はこれは問題ではありませんが、1つのマシン上でいくつかのサーバを起動している場合は厳しい状況になるかもしれません。
   </P
><P
>オープンファイルの制限の出荷時のデフォルトは、しばしば大多数のユーザはマシン上でシステムリソースの不正使用をしないという前堤に立った<SPAN
CLASS="QUOTE"
>"社会的に友好的な"</SPAN
>値を設定してしまいます。
もし1つのマシン上で複数のサーバを起動する場合はそれが必要でしょうが、専用サーバではこの制限を上げたいかもしれません。
   </P
><P
>反対に、個々のプロセスが多数のファイルをオープンすることを許可するシステムもあります。
そのようなプロセスが数個以上あれば、システム全体の制限は簡単に超えてしまいます。
この発生を検知し、システム全体の制限の変更を望まない場合は、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の<A
HREF="runtime-config-resource.html#GUC-MAX-FILES-PER-PROCESS"
>max_files_per_process</A
>設定パラメータを設定し、オープンファイルの消費を制限することができます。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LINUX-MEMORY-OVERCOMMIT"
>17.4.3. Linuxのメモリオーバーコミット</A
></H2
><P
>Linux 2.4以降では、デフォルトの仮想メモリの動作は<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>には最適ではありません。
カーネルがメモリオーバーコミットを実装する方法のため、カーネルは、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>や他のプロセスのメモリ要求がシステムの仮想メモリを枯渇させた場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> postmaster （マスタサーバプロセス）を終了させる可能性があります。
   </P
><P
>これが発生した場合、以下のようなカーネルメッセージが現れます
（こうしたメッセージを検索する場所についてはシステム文書と設定を参照してください）。
</P><PRE
CLASS="PROGRAMLISTING"
>Out of Memory: Killed process 12345 (postgres).</PRE
><P>
これは、<TT
CLASS="FILENAME"
>postgres</TT
>プロセスがメモリ不足のために終了してしまったことを示します。
起動中のデータベース接続は正常に動作しますが、新しい接続は受け付けられません。
復旧するには、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を再起動しなければなりません。
   </P
><P
>この問題を防止する1つの方法として、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>を他のプロセスがそのマシンのメモリを枯渇させないことが確実なマシンで起動するというものがあります。
物理メモリとスワップ領域が消費尽くされた時のみにメモリ不足（OOM）killerが発生するため、メモリが不足する場合、オペレーティングシステムのスワップ領域を増やすことが問題解決の役にたちます。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>自体が実行中のシステムのメモリ不足を引き起こした場合、設定を変更することで問題を防止することができます。
メモリ関連の設定パラメータ、具体的には<A
HREF="runtime-config-resource.html#GUC-SHARED-BUFFERS"
><TT
CLASS="VARNAME"
>shared_buffers</TT
></A
>および<A
HREF="runtime-config-resource.html#GUC-WORK-MEM"
><TT
CLASS="VARNAME"
>work_mem</TT
></A
>、を低くすることで回避できる場合もあります。
個の他にもデータベースサーバ自体への接続が多く許可しすぎることで問題が引き起こされる場合もあります。
多くの場合、<A
HREF="runtime-config-connection.html#GUC-MAX-CONNECTIONS"
><TT
CLASS="VARNAME"
>max_connections</TT
></A
>を減らし、外部のコネクションプールソフトウェアを使用することで改善されます。
   </P
><P
>Linux 2.6以降では、メモリを<SPAN
CLASS="QUOTE"
>"オーバーコミット"</SPAN
>させないようにカーネルの動作を変更することができます。
この設定は完全に<A
HREF="http://lwn.net/Articles/104179/"
TARGET="_top"
>OOM killer</A
>の発生を防ぐことはできませんが、その発生頻度をかなり軽減しますので、システム動作の堅牢性をより高めます。
これは、以下のように<TT
CLASS="COMMAND"
>sysctl</TT
>を使用して厳密なオーバーコミットモードを選択すること、もしくは、<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>に同等の項目を記述することで実施されます。
</P><PRE
CLASS="PROGRAMLISTING"
>sysctl -w vm.overcommit_memory=2</PRE
><P>
また、関連する<TT
CLASS="VARNAME"
>vm.overcommit_ratio</TT
>設定を変更した方が良いでしょう。
詳細は<TT
CLASS="FILENAME"
>Documentation/vm/overcommit-accounting</TT
>カーネル文書を参照してください。
   </P
><P
><TT
CLASS="VARNAME"
>vm.overcommit_memory</TT
>の変更と関係なく使用できるその他の方法は、プロセス固有の<I
CLASS="FIRSTTERM"
>OOMスコア調整</I
>値をpostmasterプロセス向けに<TT
CLASS="LITERAL"
>-1000</TT
>に設定することです。
これによりOOM killerの対象とならないことが保証されます。
このための最も簡単な方法は以下をpostmasterの起動スクリプト内でpostmasterを実行する直前に実行することです。
</P><PRE
CLASS="PROGRAMLISTING"
>echo -1000 &#62; /proc/self/oom_score_adj</PRE
><P>
この作業をrootで実行しなければならないことに注意して下さい。
さもないと効果がありません。
このためrootが所有する起動スクリプトが、これを行うための最も簡単な場所です。
その場合には、スタートアップスクリプトのpostmasterの起動前に以下の環境変数を設定することも推奨します。
</P><PRE
CLASS="PROGRAMLISTING"
>export PG_OOM_ADJUST_FILE=/proc/self/oom_score_adj
export PG_OOM_ADJUST_VALUE=0</PRE
><P>
これらの設定は、いざという時にpostmasterの子プロセスをOOM killerのターゲットに出来るようにOOMスコア調整を通常のゼロで実行します。
子プロセスを他のOOMスコア調整で実行したい場合には、<TT
CLASS="ENVAR"
>PG_OOM_ADJUST_VALUE</TT
>により別の値にすることが出来ます。
（<TT
CLASS="ENVAR"
>PG_OOM_ADJUST_VALUE</TT
>は省略することが出来て、その場合はデフォルトのゼロになります。）
<TT
CLASS="ENVAR"
>PG_OOM_ADJUST_FILE</TT
>を設定しない場合、子プロセスはpostmasterと同じOOMスコア調整で実行されますが、postmasterが優先される設定にすることが肝心なので、それは賢明とは言えません。
   </P
><P
>古いLinuxカーネルは<TT
CLASS="FILENAME"
>/proc/self/oom_score_adj</TT
>を提供していませんが、同様の機能を持つ<TT
CLASS="FILENAME"
>/proc/self/oom_adj</TT
>があるでしょう。
これは、無効にするための設定値が<TT
CLASS="LITERAL"
>-1000</TT
>ではなく<TT
CLASS="LITERAL"
>-17</TT
>であるという点を除いては同じように動作します。
   </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>Linux 2.4カーネルのベンダの中には、2.6のオーバーコミット<TT
CLASS="COMMAND"
>sysctl</TT
>版を持つものがあることが報告されています。
しかし、関係するコードを持たない2.4カーネルで<TT
CLASS="LITERAL"
>vm.overcommit_memory</TT
>を2に設定することはより状況を悪化させます。
2.4のインストレーションではこれを試す前に、実際のカーネルソースコードを調査し、その中でサポートしているかどうかを検証することをお勧めします（<TT
CLASS="FILENAME"
>mm/mmap.c</TT
>ファイル内の<CODE
CLASS="FUNCTION"
>vm_enough_memory</CODE
>関数を参照してください）。
<TT
CLASS="FILENAME"
>overcommit-accounting</TT
>文書ファイルの存在は、この機能が存在するかどうかを証明するものでは<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ありません</I
></SPAN
>。
疑わしい場合は、使用中のカーネルベンダのカーネル専門家に相談してください。
   </P
></BLOCKQUOTE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="LINUX-HUGE-PAGES"
>17.4.4. Linux huge pages</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>メモリの大きな連続チャンクを使用するときにhuge pagesを使用すると、オーバーヘッドが減少します。 <SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>でこの機能を有効にするには、kernelの<TT
CLASS="VARNAME"
>CONFIG_HUGETLBFS=y</TT
>と<TT
CLASS="VARNAME"
>CONFIG_HUGETLB_PAGE=y</TT
>が必要です。
またシステム設定<TT
CLASS="VARNAME"
>vm.nr_hugepages</TT
>を調整しなければなりません。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>に必要なhuge pages数を見積もるには、huge pagesを有効にせずに、procファイルシステムから<TT
CLASS="VARNAME"
>VmPeak</TT
>の値をチェックします。
</P><PRE
CLASS="PROGRAMLISTING"
>$ <KBD
CLASS="USERINPUT"
>head -1 /path/to/data/directory/postmaster.pid</KBD
>
4170
$ <KBD
CLASS="USERINPUT"
>grep ^VmPeak /proc/4170/status</KBD
>
VmPeak:  6490428 kB</PRE
><P>
     <TT
CLASS="LITERAL"
>6490428</TT
> / <TT
CLASS="LITERAL"
>2048</TT
>
（<TT
CLASS="VARNAME"
>PAGE_SIZE</TT
> はこのケースでは <TT
CLASS="LITERAL"
>2MB</TT
> ) は、おおよそ<TT
CLASS="LITERAL"
>3169.154</TT
>huge pagesなので、少なくとも <TT
CLASS="LITERAL"
>3170</TT
>のhuge pagesが必要になります。
</P><PRE
CLASS="PROGRAMLISTING"
>$ <KBD
CLASS="USERINPUT"
>sysctl -w vm.nr_hugepages=3170</KBD
></PRE
><P>
時には、カーネルは望ましいhuge pages数を割り当てることができませんので、そのコマンドを繰り返すか、再起動の必要があるかもしれません。
 再起動によって、この設定を永続化するために<TT
CLASS="FILENAME"
>/etc/sysctl.conf</TT
>にエントリを追加することを忘れないでください。
   </P
><P
>huge pagesを使用するデータベースサーバのオペレーティングシステムのユーザに権限を与える必要もあります。
これは、<SPAN
CLASS="APPLICATION"
>sysctl</SPAN
>を介して<TT
CLASS="VARNAME"
>vm.hugetlb_shm_group</TT
>で設定します。
また<TT
CLASS="COMMAND"
>ulimit -l</TT
>でメモリにロック出来る権限も必要です。
   </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のhuge pagesのデフォルトの動作は、可能な場合は使用し、失敗した場合は通常のページ使用にフォールバックします。
<A
HREF="runtime-config-resource.html#GUC-HUGE-PAGES"
><TT
CLASS="VARNAME"
>huge_pages</TT
></A
>を<TT
CLASS="LITERAL"
>on</TT
> に設定することでhuge pagesの使用を強制することができます。
この場合、十分なhuge pagesが確保できない場合、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の起動に失敗します。
   </P
><P
> <SPAN
CLASS="PRODUCTNAME"
>Linux</SPAN
>のhuge pagesの詳細は<A
HREF="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt"
TARGET="_top"
>https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</A
>を参照してください。
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="server-start.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="server-shutdown.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>データベースサーバの起動</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="runtime.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>サーバのシャットダウン</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
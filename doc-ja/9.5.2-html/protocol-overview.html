<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>概要</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="フロントエンド/バックエンドプロトコル"
HREF="protocol.html"><LINK
REL="PREVIOUS"
TITLE="フロントエンド/バックエンドプロトコル"
HREF="protocol.html"><LINK
REL="NEXT"
TITLE="メッセージの流れ"
HREF="protocol-flow.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="フロントエンド/バックエンドプロトコル"
HREF="protocol.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="protocol.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 50章フロントエンド/バックエンドプロトコル</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="メッセージの流れ"
HREF="protocol-flow.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="PROTOCOL-OVERVIEW"
>50.1. 概要</A
></H1
><P
>このプロトコルでは、接続開始と通常操作で段階が分かれています。
接続開始段階で、フロントエンドはサーバへの接続を開き、サーバの義務を履行できるよう自身を証明します。
（これは使用する認証方法に応じて、単一のメッセージになったり、複数のメッセージになったりします。）
すべてうまく行けば、サーバはフロントエンドに状態情報を送信し、最終的に通常操作段階に入ります。
初期の開始要求メッセージを除いて、プロトコルのこの部分はサーバによって駆動されます。
  </P
><P
>通常操作の間、フロントエンドは問い合わせやその他のコマンドをバックエンドに送信し、バックエンドは問い合わせ結果やその他の応答を返送します。
（<TT
CLASS="COMMAND"
>NOTIFY</TT
>のように）バックエンドから依頼されずにメッセージが送信されるまれな場合がありますが、セッションのこの部分のほとんどはフロントエンドの要求によって駆動されます。
  </P
><P
>セッションの終了は通常フロントエンドが選択することですが、特定の場合はバックエンドによって強制される可能性があります。
どちらの場合でも、バックエンドが接続を閉ざす時、終了前に実行中の（未完の）トランザクションをすべてロールバックします。
  </P
><P
>通常操作中は、SQLコマンドを２つのサブプロトコルのうちのいずれかによって実行することができます。
<SPAN
CLASS="QUOTE"
>"簡易問い合わせ"</SPAN
>プロトコルでは、フロントエンドはテキストで問い合わせ文字列を単に送信し、バックエンドによって解析され、即実行されます。
<SPAN
CLASS="QUOTE"
>"拡張問い合わせ"</SPAN
>プロトコルでは、問い合わせの処理は、解析、パラメータ値の結び付け、そして実行という複数の段階に分離されます。
これは複雑性が加わりますが、柔軟性と性能という点で利点が生まれます。
  </P
><P
>通常操作には、さらに、<TT
CLASS="COMMAND"
>COPY</TT
>のような特殊な操作向けのサブプロトコルがあります。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PROTOCOL-MESSAGE-CONCEPTS"
>50.1.1. メッセージ処理の概要</A
></H2
><P
>すべての通信はメッセージストリームを介します。
メッセージの先頭バイトはメッセージ種類を識別するもの、次の４バイトはメッセージの残りの長さを指定するものです
（この長さにはメッセージ種類バイトは含まれませんが、自身を含んで数えられます）。
残りのメッセージの内容は、メッセージ種類で決まります。
歴史的な理由のため、一番初めにクライアントから送信されるメッセージ（開始メッセージ）にはメッセージ種類バイトはありません。
  </P
><P
>メッセージストリームの同期ずれを防ぐために、サーバとクライアントの両方は、通常、メッセージの内容を処理し始める前に、（バイト数を使用して）メッセージ全体をバッファ内に読み込みます。
これにより、その内容を処理する時にエラーが検出された場合に、簡単に復旧することができます。
（メッセージをバッファするために十分なメモリがない場合のような）極限状況では、受信側はメッセージの読み取りを再開する前にどれだけの量の入力を飛ばすかどうかを決定するために、バイト数を活用することができます。
  </P
><P
>反対に、サーバとクライアントの両方は、不完全なメッセージを決して送信しないように注意しなければなりません。
これは通常、送信する前にバッファ内のメッセージ全体を整列させることで行われます。
メッセージの送受信の途中で通信エラーが発生した場合、メッセージ境界の同期を復旧できる望みはほとんどありませんので、実用的な唯一の応答は通信を中断することです。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PROTOCOL-QUERY-CONCEPTS"
>50.1.2. 拡張問い合わせの概要</A
></H2
><P
>拡張問い合わせプロトコルでは、SQLコマンドの実行は複数の段階に分割されます。
段階間で保持される状態は、<I
CLASS="FIRSTTERM"
>プリペアド文</I
>と<I
CLASS="FIRSTTERM"
>ポータル</I
>の２種類のオブジェクトで表現されます。
プリペアド文は、テキスト問い合わせ文字列の解析、意味解析を表現します。
プリペアド文は実行準備が整ったことを示すものではありません。
<I
CLASS="FIRSTTERM"
>パラメータ</I
>の特定の値が欠落しているかもしれないからです。
ポータルは、すべてのパラメータ値が設定され、実行準備が整った、あるいは、既に一部実行された文を表現します。
（<TT
CLASS="COMMAND"
>SELECT</TT
>文では、ポータルは開いているカーソルと等価です。
しかし、カーソルは<TT
CLASS="COMMAND"
>SELECT</TT
>以外の文を扱いませんので、ここでは異なる用語を使用するよう選択しました。）
   </P
><P
>実行サイクル全体は、テキストの問い合わせ文字列からプリペアド文を生成する<I
CLASS="FIRSTTERM"
>解析</I
>段階、プリペアド文と必要なパラメータ値によりポータルを作成する<I
CLASS="FIRSTTERM"
>バインド</I
>段階、ポータルの問い合わせを実行する<I
CLASS="FIRSTTERM"
>実行</I
>段階からなります。
行を返す問い合わせ（<TT
CLASS="COMMAND"
>SELECT</TT
>、<TT
CLASS="COMMAND"
>SHOW</TT
>など）の場合、操作を完了させるために複数の実行段階が必要とすることができるように、実行段階に限定された行数のみを取り出すよう指示することができます。
   </P
><P
>バックエンドは複数のプリペアド文とポータルの経過を追うことができます
（しかし、1つのセッション内でのみ存在可能です。複数のセッションで共有することはできません）。
存在するプリペアド文とポータルは、作成時に割り当てられた名前で参照されます。
さらに、<SPAN
CLASS="QUOTE"
>"無名の"</SPAN
>プリペアド文とポータルも存在します。
これらは名前付きのオブジェクトとほとんど同じ動きをしますが、問い合わせを一回だけ実行し、その後に破棄する場合に備えて、これらに対する操作は最適化されています。
一方、名前付きオブジェクトの操作は複数回の使用を想定して最適化されています。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PROTOCOL-FORMAT-CODES"
>50.1.3. 書式と書式コード</A
></H2
><P
>特定のデータ型のデータはいくつかの異なる<I
CLASS="FIRSTTERM"
>書式</I
>で転送することができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 7.4の時点でサポートしている書式は<SPAN
CLASS="QUOTE"
>"テキスト"</SPAN
>と<SPAN
CLASS="QUOTE"
>"バイナリ"</SPAN
>のみですが、プロトコルは将来の拡張に備えて準備をしています。
任意の値の必要な書式は<I
CLASS="FIRSTTERM"
>書式コード</I
>で指定されます。
クライアントは、転送されるパラメータ値それぞれに書式コードを指定することも、問い合わせ結果の列それぞれに書式コードを指定することもできます。
テキストは書式コード0、バイナリは書式コード1です。
他の書式コードは将来の定義用に予約されています。
   </P
><P
>値のテキスト表現は、特定のデータ型の入出力変換関数で生成され、受け付けられる何らかの文字列です。
転送時の表現では、ヌル終端文字はありません。
フロントエンドでC言語文字列として処理したい場合は、必ず受信した値にヌル終端文字を追加しなければなりません。
（ついでですが、テキスト書式ではヌルを埋め込むことはできません。）
   </P
><P
>整数用のバイナリ表現はネットワークバイト順（先頭に最上位バイト）を使用します。
他のデータ型のバイナリ表現については、文書もしくはソースコードを参照してください。
複雑なデータ型のバイナリ表現はサーバのバージョンによって異なる可能性があることに注意してください。
通常、テキスト書式がより移植性が高い選択肢です。
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="protocol.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="protocol-flow.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>フロントエンド/バックエンドプロトコル</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="protocol.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>メッセージの流れ</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
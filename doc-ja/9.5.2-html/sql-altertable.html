<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>ALTER TABLE</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SQLコマンド"
HREF="sql-commands.html"><LINK
REL="PREVIOUS"
TITLE="ALTER SYSTEM"
HREF="sql-altersystem.html"><LINK
REL="NEXT"
TITLE="ALTER TABLESPACE"
HREF="sql-altertablespace.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="REFENTRY"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="ALTER SYSTEM"
HREF="sql-altersystem.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="ALTER TABLESPACE"
HREF="sql-altertablespace.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><H1
><A
NAME="SQL-ALTERTABLE"
></A
>ALTER TABLE</H1
><DIV
CLASS="REFNAMEDIV"
><A
NAME="AEN71869"
></A
><H2
>名前</H2
>ALTER TABLE&nbsp;--&nbsp;テーブル定義を変更する</DIV
><DIV
CLASS="REFSYNOPSISDIV"
><A
NAME="AEN71872"
></A
><H2
>概要</H2
><PRE
CLASS="SYNOPSIS"
>ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ * ]
    <TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
> [, ... ]
ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ * ]
    RENAME [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> TO <TT
CLASS="REPLACEABLE"
><I
>new_column_name</I
></TT
>
ALTER TABLE [ IF EXISTS ] [ ONLY ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ * ]
    RENAME CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> TO <TT
CLASS="REPLACEABLE"
><I
>new_constraint_name</I
></TT
>
ALTER TABLE [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>
    RENAME TO <TT
CLASS="REPLACEABLE"
><I
>new_name</I
></TT
>
ALTER TABLE [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
>
    SET SCHEMA <TT
CLASS="REPLACEABLE"
><I
>new_schema</I
></TT
>
ALTER TABLE ALL IN TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
> [ OWNED BY <TT
CLASS="REPLACEABLE"
><I
>role_name</I
></TT
> [, ... ] ]
    SET TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>new_tablespace</I
></TT
> [ NOWAIT ]

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>ここで、<TT
CLASS="REPLACEABLE"
><I
>action</I
></TT
>は以下のいずれかです。</SPAN
></SPAN
>

    ADD [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ <TT
CLASS="REPLACEABLE"
><I
>column_constraint</I
></TT
> [ ... ] ]
    DROP [ COLUMN ] [ IF EXISTS ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> [ SET DATA ] TYPE <TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
> [ COLLATE <TT
CLASS="REPLACEABLE"
><I
>collation</I
></TT
> ] [ USING <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
> ]
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET DEFAULT <TT
CLASS="REPLACEABLE"
><I
>expression</I
></TT
>
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> DROP DEFAULT
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET STATISTICS <TT
CLASS="REPLACEABLE"
><I
>integer</I
></TT
>
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET ( <TT
CLASS="REPLACEABLE"
><I
>attribute_option</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] )
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> RESET ( <TT
CLASS="REPLACEABLE"
><I
>attribute_option</I
></TT
> [, ... ] )
    ALTER [ COLUMN ] <TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <TT
CLASS="REPLACEABLE"
><I
>table_constraint</I
></TT
> [ NOT VALID ]
    ADD <TT
CLASS="REPLACEABLE"
><I
>table_constraint_using_index</I
></TT
>
    ALTER CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]
    VALIDATE CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
>
    DROP CONSTRAINT [ IF EXISTS ]  <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> [ RESTRICT | CASCADE ]
    DISABLE TRIGGER [ <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
> | ALL | USER ]
    ENABLE TRIGGER [ <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
> | ALL | USER ]
    ENABLE REPLICA TRIGGER <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
>
    ENABLE ALWAYS TRIGGER <TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
>
    DISABLE RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    ENABLE RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    ENABLE REPLICA RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    ENABLE ALWAYS RULE <TT
CLASS="REPLACEABLE"
><I
>rewrite_rule_name</I
></TT
>
    DISABLE ROW LEVEL SECURITY
    ENABLE ROW LEVEL SECURITY
    FORCE ROW LEVEL SECURITY
    NO FORCE ROW LEVEL SECURITY
    CLUSTER ON <TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
>
    SET WITHOUT CLUSTER
    SET WITH OIDS
    SET WITHOUT OIDS
    SET TABLESPACE <TT
CLASS="REPLACEABLE"
><I
>new_tablespace</I
></TT
>
    SET { LOGGED | UNLOGGED }
    SET ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] )
    RESET ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> [, ... ] )
    INHERIT <TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
>
    NO INHERIT <TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
>
    OF <TT
CLASS="REPLACEABLE"
><I
>type_name</I
></TT
>
    NOT OF
    OWNER TO { <TT
CLASS="REPLACEABLE"
><I
>new_owner</I
></TT
> | CURRENT_USER | SESSION_USER }
    REPLICA IDENTITY { DEFAULT | USING INDEX <TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
> | FULL | NOTHING }

<SPAN
CLASS="phrase"
><SPAN
CLASS="PHRASE"
>また<TT
CLASS="REPLACEABLE"
><I
>table_constraint_using_index</I
></TT
>は以下の通りです。</SPAN
></SPAN
>

    [ CONSTRAINT <TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
> ]
    { UNIQUE | PRIMARY KEY } USING INDEX <TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
>
    [ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</PRE
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN71939"
></A
><H2
>説明</H2
><P
><TT
CLASS="COMMAND"
>ALTER TABLE</TT
>は既存のテーブルの定義を変更します。
以下のようにいくつかの副構文があります。
要求されるロックレベルはそれぞれの副構文によって異なることに注意してください。
特に記述がなければ<TT
CLASS="LITERAL"
>ACCESS EXCLUSIVE</TT
>ロックを取得します。
複数のサブコマンドが使われるときは、それらのサブコマンドが要求するうち、もっとも高いレベルのロックを取得します。

  <P
></P
></P><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>ADD COLUMN</TT
></DT
><DD
><P
>この構文を使用すると、<A
HREF="sql-createtable.html"
>CREATE TABLE</A
>と同じ構文を使って新しい列をテーブルに追加できます。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>DROP COLUMN [ IF EXISTS ]</TT
></DT
><DD
><P
>この構文を使用すると、テーブルから列を削除できます。
削除する列を含んでいるインデックスおよびテーブル制約も自動的に削除されます。
また、削除する列にテーブル以外が依存（例えば、外部キー制約、ビューなど）している場合、<TT
CLASS="LITERAL"
>CASCADE</TT
>を付ける必要があります。
<TT
CLASS="LITERAL"
>IF EXISTS</TT
>が指定されている場合、もしその列がなかったとしてもエラーにはなりません。
この場合は代わりに注意が出力されます。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET DATA TYPE</TT
></DT
><DD
><P
>この構文を使用すると、テーブルの列の型を変更できます。
その列を含むインデックスと簡単なテーブル制約は、元々与えられた式を再解析し、新しい型を使用するように自動的に変換されます。
<TT
CLASS="LITERAL"
>COLLATE</TT
>句を使うと、新しい列の照合順を指定できます。
省略時の照合順は新しい列の型のデフォルトになります。
<TT
CLASS="LITERAL"
>USING</TT
>句を使うと、古い列値をどのように新しい値に計算するかを指定できます。
省略された場合、デフォルトの変換は、古いデータ型から新しいデータ型への代入キャストと同じになります。
古いデータ型から新しいデータ型への暗黙キャストあるいは代入キャストがない場合、<TT
CLASS="LITERAL"
>USING</TT
>句を指定しなければなりません。

     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET</TT
>/<TT
CLASS="LITERAL"
>DROP DEFAULT</TT
></DT
><DD
><P
>これらの構文を使用すると、列のデフォルト値を設定または削除できます。
デフォルト値は、変更後に行われる<TT
CLASS="COMMAND"
>INSERT</TT
>または<TT
CLASS="COMMAND"
>UPDATE</TT
>コマンドにのみ適用されます。
テーブル内の既存の行は変更されません。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET</TT
>/<TT
CLASS="LITERAL"
>DROP NOT NULL</TT
></DT
><DD
><P
>これらの構文は、列の値としてNULL値を使用できるかどうか設定します。
<TT
CLASS="LITERAL"
>SET NOT NULL</TT
>は、その列にNULL値が1つもない場合にのみ設定可能です。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET STATISTICS</TT
></DT
><DD
><P
>この構文は、以後の<A
HREF="sql-analyze.html"
>ANALYZE</A
>操作において、列単位での統計情報収集対象を設定します。
対象として、0から10000までの範囲の値を設定可能です。
また、対象を-1に設定すると、システムのデフォルト統計情報対象（<A
HREF="runtime-config-query.html#GUC-DEFAULT-STATISTICS-TARGET"
>default_statistics_target</A
>）が使用されます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の問い合わせプランナによる統計情報の使用に関する詳細は、<A
HREF="planner-stats.html"
>項14.2</A
>を参照してください。
     </P
><P
><TT
CLASS="LITERAL"
>SET STATISTICS</TT
>は<TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>ロックを取得します。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET ( <TT
CLASS="REPLACEABLE"
><I
>attribute_option</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] )</TT
><BR><TT
CLASS="LITERAL"
>RESET ( <TT
CLASS="REPLACEABLE"
><I
>attribute_option</I
></TT
> [, ... ] )</TT
></DT
><DD
><P
>この構文は属性単位のオプションの設定または設定解除を行います。
現時点では属性単位のオプションで定義されているのは<TT
CLASS="LITERAL"
>n_distinct</TT
>および<TT
CLASS="LITERAL"
>n_distinct_inherited</TT
>のみです。
これらのオプションは、その後の<A
HREF="sql-analyze.html"
>ANALYZE</A
>操作により生成される個別値数の推定値を上書きします。
<TT
CLASS="LITERAL"
>n_distinct</TT
>はテーブル自身の統計情報に影響を与え、<TT
CLASS="LITERAL"
>n_distinct_inherited</TT
>はテーブルとそれを継承した子テーブルから集めた統計情報に影響を与えます。
正の値の場合、<TT
CLASS="COMMAND"
>ANALYZE</TT
>は、その列には、正確に指定された個数の非NULLの個別値が存在するものとみなします。
負の値の場合、この値は-1以上でなければなりませんが、<TT
CLASS="COMMAND"
>ANALYZE</TT
>は、その列内の非NULLの個別値はテーブルのサイズに線形であるとみなし、推定テーブルサイズに指定した値の絶対値を乗じた値が個別値数であるとみなします。
たとえば、-1という値は、列内のすべての値に重複がないことを意味し、-0.5という値は個々の値は平均して2回現れることを意味します。
テーブルの行数との乗算は問い合わせ計画を作成するまで行われませんので、テーブルサイズが変わり続けるような場合にこれは有用かもしれません。
0という値を指定することで、個別値数の推定を通常に戻します。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>問い合わせプランナにおける統計情報の使用に関しては<A
HREF="planner-stats.html"
>項14.2</A
>を参照してください。
     </P
><P
>属性単位のオプションの変更は<TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>ロックを取得します。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET STORAGE</TT
>
     </DT
><DD
><P
>この構文は、列の保管モードを設定します。
列をインラインで保持するか補助TOASTテーブルに保持するか、また、データを圧縮するかどうかを制御できます。
<TT
CLASS="LITERAL"
>PLAIN</TT
>は、<TT
CLASS="TYPE"
>integer</TT
>のような固定長の値に対して使用します。インラインで保持され、圧縮されません。
<TT
CLASS="LITERAL"
>MAIN</TT
>は、インラインで保持されていて、圧縮可能なデータに使用します。
<TT
CLASS="LITERAL"
>EXTERNAL</TT
>は圧縮されていない外部データに使用します。
<TT
CLASS="LITERAL"
>EXTENDED</TT
>は圧縮された外部データに使用します。
<TT
CLASS="LITERAL"
>EXTENDED</TT
>は、<TT
CLASS="LITERAL"
>PLAIN</TT
>以外の保管をサポートするほとんどのデータ型におけるデフォルトです。
<TT
CLASS="LITERAL"
>EXTERNAL</TT
>を使用すると、非常に長い<TT
CLASS="TYPE"
>text</TT
>および<TT
CLASS="TYPE"
>bytea</TT
>列に対する部分文字列操作の処理速度が向上しますが、必要な保管容量が増えるというデメリットがあります。
<TT
CLASS="LITERAL"
>SET STORAGE</TT
>自体はテーブルをまったく変更しないことに注意してください。
以後のテーブルの更新時に遂行する戦略を設定するだけです。
詳細は<A
HREF="storage-toast.html"
>項63.2</A
>を参照してください。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>ADD <TT
CLASS="REPLACEABLE"
><I
>table_constraint</I
></TT
> [ NOT VALID ]</TT
></DT
><DD
><P
>この構文は、<A
HREF="sql-createtable.html"
>CREATE TABLE</A
>と同じ構文に加え、現時点では外部キー制約と検査制約でのみ許される<TT
CLASS="LITERAL"
>NOT VALID</TT
>オプションを使って新しい制約をテーブルに追加します。
制約が<TT
CLASS="LITERAL"
>NOT VALID</TT
>と印付けされた場合、テーブル内のすべての行が制約を満たすかどうかを検証するための、時間がかかるかもしれない初期検査が飛ばされます。
しかし、制約はその後の挿入や更新に対して強制されます（つまり、外部キー制約の場合、被参照テーブルに一致する行が存在しない限り失敗します。指定された検査制約に一致する新しい行が存在しない限り失敗します）。
しかしデータベースは、<TT
CLASS="LITERAL"
>VALIDATE CONSTRAINT</TT
>オプションを使用して検証されるまで、テーブル内のすべての行で制約が保持されているとみなしません。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>ADD <TT
CLASS="REPLACEABLE"
><I
>table_constraint_using_index</I
></TT
></TT
></DT
><DD
><P
>この構文は、既存の一意性インデックスに基づき、テーブルに<TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>または<TT
CLASS="LITERAL"
>UNIQUE</TT
>制約を新たに追加します。
インデックスのすべての列がこの制約に含まれます。
     </P
><P
>このインデックスは式列を持つことはできず、また部分インデックスであってはいけません。
またこれはデフォルトのソート順序を持つB-Treeインデックスでなければなりません。
これらの制限により、このインデックスが通常の<TT
CLASS="LITERAL"
>ADD PRIMARY KEY</TT
>または<TT
CLASS="LITERAL"
>ADD UNIQUE</TT
>コマンドにより構築されたインデックスと等価であることを確実にします。
     </P
><P
><TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>が指定され、インデックスの列が<TT
CLASS="LITERAL"
>NOT NULL</TT
>と印付けされていない場合、このコマンドはこうした列のそれぞれに対して<TT
CLASS="LITERAL"
>ALTER COLUMN SET NOT NULL</TT
>の実施を試みます。
これは列にNULLが含まれないことを検証するために完全なテーブルスキャンを必要とします。
この他の場合においては、これが高速な操作です。
     </P
><P
>制約名が提供された場合、インデックスの名前は制約名に合うように変更されます。
提供されない場合は制約にはインデックスと同じ名前が付けられます。
     </P
><P
>このコマンドの実行後、インデックスは、制約により<SPAN
CLASS="QUOTE"
>"所有"</SPAN
>され、それはインデックスが通常の<TT
CLASS="LITERAL"
>ADD PRIMARY KEY</TT
>または<TT
CLASS="LITERAL"
>ADD UNIQUE</TT
>により構築された場合と同様です。
特にこの制約を削除するとインデックスも消えてしまいます。
     </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
>既存のインデックスを使用した制約の追加は、テーブル更新を長時間ブロックすることなく新しい制約を追加しなければならない場合に有用になる可能性があります。
このためには、<TT
CLASS="COMMAND"
>CREATE INDEX CONCURRENTLY</TT
>を用いてインデックスを作成し、この構文を使用して正式の制約としてインストールしてください。
後述の例を参照してください。
      </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>ALTER CONSTRAINT</TT
></DT
><DD
><P
>この構文は以前に作成された制約の属性を変更します。
現在は外部キー制約のみを変更できます。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>VALIDATE CONSTRAINT</TT
></DT
><DD
><P
>この構文は、以前に<TT
CLASS="LITERAL"
>NOT VALID</TT
>として作成された外部キー制約または検査制約を、これらの制約を満たさない行が存在しないことを確認するためにテーブルをスキャンして、検証します。
制約がすでに有効であると記録されている場合は何も起こりません。
     </P
><P
>検証は大きなテーブルに対して長いプロセスになることがあります。
制約の初期生成から検証を分離する利点は、より忙しくない時間まで検証を遅延させることができることや、新しいエラーを防ぎつつ、既存のエラーを修正する時間を用意するために使用することができることです。
また、検証それ自体は、その実行中に、テーブルに対する通常の書き込みコマンドを妨げないことにも注意してください。
     </P
><P
>検証は変更されるテーブルについて<TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>ロックしか取得しません。
制約が外部キーの時は、制約が参照するテーブルについて<TT
CLASS="LITERAL"
>ROW SHARE</TT
>ロックも取得します。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>DROP CONSTRAINT [ IF EXISTS ]</TT
></DT
><DD
><P
>この構文を使用すると、テーブル上の指定した制約を削除できます。
<TT
CLASS="LITERAL"
>IF EXISTS</TT
>が指定された場合、その制約がなくてもエラーになりません。
この場合は代わりに注意が出力されます。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>DISABLE</TT
>/<TT
CLASS="LITERAL"
>ENABLE [ REPLICA | ALWAYS ] TRIGGER</TT
></DT
><DD
><P
>この構文を使用すると、テーブルに属するトリガの発行について設定することができます。
無効にされたトリガはシステム上に存在し続けますが、トリガイベントが発生したとしても実行されません。
遅延トリガの場合、有効無効状態の確認は、トリガ関数を実際に実行しようとする時ではなく、イベントの発生時に行われます。
名前でトリガを1つ指定して有効または無効にすることもできますし、テーブル上のすべてのトリガを有効または無効にすることもできます。
また、ユーザトリガのみを有効または無効にすることも可能です
（このオプションは、外部キー制約、遅延可能な一意性および排他制約を実装するために使用される内部向けに生成される制約トリガを除外します。）
内部向けに生成される制約トリガを有効または無効にするにはスーパーユーザ権限が必要です。
トリガが実行されなかった場合は当然ながら制約の整合性が保証されませんので、制約トリガの無効化は注意して実行しなければなりません。
また、トリガ発行機構は設定変数<A
HREF="runtime-config-client.html#GUC-SESSION-REPLICATION-ROLE"
>session_replication_role</A
>の影響を受けます。
単に有効としたトリガでは、レプリケーションロールが<SPAN
CLASS="QUOTE"
>"origin"</SPAN
>（デフォルト）または<SPAN
CLASS="QUOTE"
>"local"</SPAN
>の場合に発行されます。
<TT
CLASS="LITERAL"
>ENABLE REPLICA</TT
>としたトリガでは、セッションが<SPAN
CLASS="QUOTE"
>"replica"</SPAN
>モードである場合のみ発行されます。
そして、<TT
CLASS="LITERAL"
>ENABLE ALWAYS</TT
>としたトリガでは、現在のレプリケーションモードに関係なく発行されます。
     </P
><P
>このコマンドは<TT
CLASS="LITERAL"
>SHARE ROW EXCLUSIVE</TT
>を取得します。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>DISABLE</TT
>/<TT
CLASS="LITERAL"
>ENABLE [ REPLICA | ALWAYS ] RULE</TT
></DT
><DD
><P
>この構文を使用すると、テーブルに属する書き換えルールの実行について設定することができます。
ルールは無効にしてもシステムに残りますが、問い合わせ書き換え時に適用されません。
この意味はトリガの有効化、無効化と同じです。
この設定は<TT
CLASS="LITERAL"
>ON SELECT</TT
>ルールでは無視されます。
現在のセッションがデフォルト以外のレプリケーションモードであったとしても、ビュー操作を維持するために常に適用されます。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>DISABLE</TT
>/<TT
CLASS="LITERAL"
>ENABLE ROW LEVEL SECURITY</TT
></DT
><DD
><P
>これらの構文は、テーブルの行セキュリティポリシーの適用を制御します。
有効にされ、かつテーブルにポリシーが存在しない場合は、デフォルトの拒絶ポリシーが適用されます。
行単位セキュリティが無効になっている場合でも、テーブルのセキュリティが存在し得ることに注意してください。
この場合、ポリシーは適用されず、無視されます。
<A
HREF="sql-createpolicy.html"
>CREATE POLICY</A
>も参照してください。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>NO FORCE</TT
>/<TT
CLASS="LITERAL"
>FORCE ROW LEVEL SECURITY</TT
></DT
><DD
><P
>これらの構文は、ユーザがテーブルの所有者である場合について、テーブルの行セキュリティポリシーの適用を制御します。
有効の場合、ユーザがテーブルの所有者であれば、行セキュリティポリシーが適用されます。
無効（デフォルト）の場合、ユーザがテーブルの所有者であれば、行セキュリティポリシーは適用されません。
<A
HREF="sql-createpolicy.html"
>CREATE POLICY</A
>も参照してください。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>CLUSTER ON</TT
></DT
><DD
><P
>この構文は、以後の<A
HREF="sql-cluster.html"
>CLUSTER</A
>操作用のデフォルトインデックスを選択します。
テーブルの再クラスタ化は実際には行いません。
     </P
><P
>clusterオプションの変更は<TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>ロックを取得します。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET WITHOUT CLUSTER</TT
></DT
><DD
><P
>この構文は、テーブルから、一番最後に適用された<A
HREF="sql-cluster.html"
>CLUSTER</A
>インデックス指定を削除します。
以後のインデックスを指定しないクラスタ操作に影響を及ぼします。
     </P
><P
>clusterオプションの変更は<TT
CLASS="LITERAL"
>SHARE UPDATE EXCLUSIVE</TT
>ロックを取得します。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET WITH OIDS</TT
></DT
><DD
><P
>この構文は<TT
CLASS="LITERAL"
>oid</TT
>システム列をテーブルに追加します（<A
HREF="ddl-system-columns.html"
>項5.4</A
>を参照してください）。
テーブルがすでにOIDを持つ場合は何も行いません。
     </P
><P
>これが、<TT
CLASS="LITERAL"
>ADD COLUMN oid oid</TT
>と同じではないことに注意してください。
後者はシステム列ではなく<TT
CLASS="LITERAL"
>oid</TT
>という名前が付いただけの通常の列を追加します。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET WITHOUT OIDS</TT
></DT
><DD
><P
>この構文は、テーブルから<TT
CLASS="LITERAL"
>oid</TT
>システム列を削除します。
既に<TT
CLASS="LITERAL"
>oid</TT
>列が存在しなくても警告が表示されない点を除けば、<TT
CLASS="LITERAL"
>DROP COLUMN oid RESTRICT</TT
>とまったく同等です。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET TABLESPACE</TT
></DT
><DD
><P
>この構文を使用すると、テーブルのテーブル空間を指定したテーブル空間に変更し、テーブルに関連するデータファイルを新しいテーブル空間に移動することができます。
テーブルにインデックスがあっても移動されません。
インデックスを移動するには、別途<TT
CLASS="LITERAL"
>SET TABLESPACE</TT
>コマンドを実行します。
<TT
CLASS="LITERAL"
>ALL IN TABLESPACE</TT
>構文を使うことで、テーブル空間内の現在のデータベースのすべてのテーブルを移動することができます。
この場合、移動されるすべてのテーブルがまずロックされ、それから一つずつ移動されます。
この構文は<TT
CLASS="LITERAL"
>OWNED BY</TT
>もサポートしており、これを使うと、指定のロールが所有しているテーブルだけを移動します。
<TT
CLASS="LITERAL"
>NOWAIT</TT
>を指定した場合、必要とするすべてのロックを即座に獲得できなければ、このコマンドは失敗します。
このコマンドではシステムカタログは移動されないことに注意し、必要なら代わりに<TT
CLASS="COMMAND"
>ALTER DATABASE</TT
>を使うか、あるいは<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>で明示的に指定してください。
<TT
CLASS="LITERAL"
>information_schema</TT
>のリレーションはシステムカタログとはみなされないので、移動されます。
<A
HREF="sql-createtablespace.html"
>CREATE TABLESPACE</A
>も参照してください。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET { LOGGED | UNLOGGED }</TT
></DT
><DD
><P
>この構文は、テーブルをログを取らないテーブルからログを取るテーブルに変更、あるいはその逆を行います（<A
HREF="sql-createtable.html#SQL-CREATETABLE-UNLOGGED"
><I
CLASS="TERM"
><TT
CLASS="LITERAL"
>UNLOGGED</TT
></I
></A
>参照）。
これは一時テーブルに対して使うことはできません。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> = <TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
> [, ... ] )</TT
></DT
><DD
><P
>この構文は、1つ以上のテーブルの格納パラメータを変更します。
設定可能なパラメータに関しては<A
HREF="sql-createtable.html#SQL-CREATETABLE-STORAGE-PARAMETERS"
><I
>格納パラメータ</I
></A
>を参照してください。
このコマンドによってテーブルの内容が即座に変更されない点に注意してください。
パラメータによりますが、期待する効果を得るためにテーブルを書き換える必要がある場合があります。
このためには、<A
HREF="sql-vacuum.html"
>VACUUM FULL</A
>、<A
HREF="sql-cluster.html"
>CLUSTER</A
>またはテーブルを強制的に書き換える<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>の構文のいずれかを使用してください。
     </P
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>注意: </B
><TT
CLASS="COMMAND"
>CREATE TABLE</TT
>では<TT
CLASS="LITERAL"
>OIDS</TT
>を<TT
CLASS="LITERAL"
>WITH (<TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
>)</TT
>構文で指定することができますが、<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>では<TT
CLASS="LITERAL"
>OIDS</TT
>を格納パラメータとして扱っていません。
OIDの状態を変更するためには代わりに<TT
CLASS="LITERAL"
>SET WITH OIDS</TT
>および<TT
CLASS="LITERAL"
>SET WITHOUT OIDS</TT
>構文を使用してください。
      </P
></BLOCKQUOTE
></DIV
></DD
><DT
><TT
CLASS="LITERAL"
>RESET ( <TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
> [, ... ] )</TT
></DT
><DD
><P
>この構文は、1つ以上の格納パラメータをデフォルト値に再設定します。
<TT
CLASS="LITERAL"
>SET</TT
>同様、テーブル全体を更新するためにテーブルの書き換えが必要になる場合があります。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>INHERIT <TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
></TT
></DT
><DD
><P
>&#13;この構文は、対象テーブルを指定した親テーブルの子テーブルとして追加します。
その後に行われる親テーブルへの問い合わせには対象テーブルの項目も含まれます。
子テーブルとして追加するためには、対象テーブルには親テーブルと同じ列がすべて含まれていなければなりません。
（この他の列を持つこともできます。）
これらの列のデータ型は一致している必要があり、親テーブルで<TT
CLASS="LITERAL"
>NOT NULL</TT
>制約がある場合は、子テーブルでも同様に<TT
CLASS="LITERAL"
>NOT NULL</TT
>制約を持たなければなりません。
     </P
><P
>また、親テーブルの<TT
CLASS="LITERAL"
>CHECK</TT
>制約すべてについても、一致する制約が子テーブルに存在しなければなりません。
ただし、親テーブルにおいて継承不可と印付けされている（つまり<TT
CLASS="LITERAL"
>ALTER TABLE ... ADD CONSTRAINT ... NO INHERIT</TT
>付きで作成された）制約は除きます(これらは無視されます)。
一致する子テーブルの制約はすべて継承不可であってはなりません。
現時点では<TT
CLASS="LITERAL"
>UNIQUE</TT
>、<TT
CLASS="LITERAL"
>PRIMARY KEY</TT
>、<TT
CLASS="LITERAL"
>FOREIGN KEY</TT
>制約は無視されますが、将来変更されるかもしれません。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>NO INHERIT <TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
></TT
></DT
><DD
><P
>この構文は、指定した親テーブルの子テーブル群から対象のテーブルを削除します。
親テーブルへの問い合わせでは、対象としたテーブルからのデータが含まれなくなります。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>OF <TT
CLASS="REPLACEABLE"
><I
>type_name</I
></TT
></TT
></DT
><DD
><P
>この構文は、<TT
CLASS="COMMAND"
>CREATE TABLE OF</TT
>で形成されたかのように、テーブルと複合型とを関連付けします。
テーブルの列名とその型のリストは、複合型のものと正確に一致していなければなりません。
ただし<TT
CLASS="LITERAL"
>oid</TT
>システム列の有無は異なっていても構いません。
テーブルはどのテーブルも継承していてはいけません。
これらの制限により<TT
CLASS="COMMAND"
>CREATE TABLE OF</TT
>により作成できるテーブル定義と同等になります。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>NOT OF</TT
></DT
><DD
><P
>この構文は型と型付けされたテーブルの関連を取り除きます。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>OWNER</TT
></DT
><DD
><P
>この構文を使用すると、テーブル、シーケンス、ビュー、マテリアライズドビュー、または外部テーブルの所有者を、指定したユーザに変更できます。
     </P
></DD
><DT
><A
NAME="SQL-CREATETABLE-REPLICA-IDENTITY"
></A
><TT
CLASS="LITERAL"
>REPLICA IDENTITY</TT
></DT
><DD
><P
>この構文を使用すると、更新あるいは削除された行を特定できるよう、先行書き込みログに書き込まれる情報を変更します。
このオプションは、論理レプリケーションが使われている場合以外は何の効果もありません。
<TT
CLASS="LITERAL"
>DEFAULT</TT
>はシステムテーブル以外についてのデフォルトで、主キー列があれば、その古い値を記録します。
<TT
CLASS="LITERAL"
>USING INDEX</TT
>は指定したインデックスに含まれる列の古い値を記録しますが、このインデックスは一意であり、部分インデックスや遅延可能インデックスではなく、また<TT
CLASS="LITERAL"
>NOT NULL</TT
>の列のみを含まなければなりません。
<TT
CLASS="LITERAL"
>FULL</TT
>は行のすべての列の古い値を記録します。
<TT
CLASS="LITERAL"
>NOTHING</TT
>は古い行の情報を何も記録しません(これがシステムテーブルについてのデフォルトです)。
どの場合についても、行の古いバージョンと新しいバージョンの間で、ログに記録される列のうち少なくとも1つが変わっていなければ、古い値はログに記録されません。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>RENAME</TT
></DT
><DD
><P
><TT
CLASS="LITERAL"
>RENAME</TT
>構文を使用すると、テーブル（もしくは、インデックス、シーケンス、ビュー、マテリアライズドビュー、外部テーブル）の名前、テーブルの個々の列名、テーブルの制約名を変更できます。
格納されているデータへの影響はありません。
     </P
></DD
><DT
><TT
CLASS="LITERAL"
>SET SCHEMA</TT
></DT
><DD
><P
>この構文を使用して、テーブルを別のスキーマに移動することができます。
関連するインデックスや制約、テーブル列により所有されるシーケンスも同様に移動されます。
     </P
></DD
></DL
></DIV
><P>
  </P
><P
><TT
CLASS="LITERAL"
>RENAME</TT
>、<TT
CLASS="LITERAL"
>SET TABLESPACE</TT
>および<TT
CLASS="LITERAL"
>SET SCHEMA</TT
>以外の全ての操作は、結合して複数の変更リストにまとめて、並行に処理することができます。
例えば、複数の列の追加、型の変更を単一のコマンドで実行することができます。
これは特に巨大なテーブルでは便利です。変更のために必要なテーブル全体の走査が1回で済むからです。
  </P
><P
><TT
CLASS="COMMAND"
>ALTER TABLE</TT
>コマンドを使用するには、変更するテーブルを所有している必要があります。
テーブルのスキーマあるいはテーブル空間を変更するには、新しいスキーマあるいはテーブル空間における<TT
CLASS="LITERAL"
>CREATE</TT
>権限も持っていなければなりません。
テーブルを親テーブルの新しい子テーブルとして追加するには、親テーブルも所有している必要があります。
また、所有者を変更するには、新しい所有ロールの直接あるいは間接的なメンバでなければならず、かつ、そのロールがテーブルのスキーマにおける<TT
CLASS="LITERAL"
>CREATE</TT
>権限を持たなければなりません
（この制限により、テーブルの削除と再作成を行ってもできないことが、所有者の変更によってもできないようにしています。
ただし、スーパーユーザはすべてのテーブルの所有者を変更することができます）。
列の追加、列の型の変更、<TT
CLASS="LITERAL"
>OF</TT
>句の使用を行うためには、データ型に対する<TT
CLASS="LITERAL"
>USAGE</TT
>権限を持たなければなりません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72274"
></A
><H2
>パラメータ</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>IF EXISTS</TT
></DT
><DD
><P
>テーブルが存在しない場合でもエラーとしません。
この場合は注意メッセージが発行されます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>name</I
></TT
></DT
><DD
><P
>変更対象となる既存のテーブルの名前です（スキーマ修飾名も可）。
テーブル名の前に<TT
CLASS="LITERAL"
>ONLY</TT
>が指定された場合、そのテーブルのみが変更されます。
<TT
CLASS="LITERAL"
>ONLY</TT
>が指定されていない場合、そのテーブルおよび（もしあれば）そのテーブルを継承する全てのテーブルが更新されます。
オプションで、テーブル名の後に<TT
CLASS="LITERAL"
>*</TT
>を指定することで、明示的に継承するテーブルも含まれることを示すことができます。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>column_name</I
></TT
></DT
><DD
><P
>新規または既存の列の名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>new_column_name</I
></TT
></DT
><DD
><P
>既存の列の新しい名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>new_name</I
></TT
></DT
><DD
><P
>テーブルの新しい名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>data_type</I
></TT
></DT
><DD
><P
>新しい列のデータ型、もしくは既存の列に対する新しいデータ型です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>table_constraint</I
></TT
></DT
><DD
><P
>テーブルの新しいテーブル制約です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>constraint_name</I
></TT
></DT
><DD
><P
>新しい、あるいは既存の制約の名前です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>CASCADE</TT
></DT
><DD
><P
>削除された列や制約に依存しているオブジェクト（例えば、削除された列を参照しているビューなど）を、自動的に削除します。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>RESTRICT</TT
></DT
><DD
><P
>依存しているオブジェクトがある場合、列または制約の削除要求を拒否します。
これがデフォルトの動作です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>trigger_name</I
></TT
></DT
><DD
><P
>有効または無効にする単一のトリガの名前です。
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>ALL</TT
></DT
><DD
><P
>テーブルに属するすべてのトリガを有効または無効にします。
（外部キー制約、遅延可能な一意性および排他制約を実装するために使用される、内部向けに生成される制約トリガが含まれる場合、スーパーユーザ権限が必要です。）
       </P
></DD
><DT
><TT
CLASS="LITERAL"
>USER</TT
></DT
><DD
><P
>外部キー制約、遅延可能な一意性および排他制約を実装するために使用される、内部向けに生成されるトリガを除く、テーブルに属するトリガすべてを有効または無効にします。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>index_name</I
></TT
></DT
><DD
><P
>既存のインデックスの名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>storage_parameter</I
></TT
></DT
><DD
><P
>テーブルの格納パラメータの名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>value</I
></TT
></DT
><DD
><P
>テーブルの格納パラメータの新しい値です。
パラメータによりこれは数値となることも文字列となることもあります。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>parent_table</I
></TT
></DT
><DD
><P
>このテーブルに関連付ける、または、このテーブルから関連付けを取り除く親テーブルです。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>new_owner</I
></TT
></DT
><DD
><P
>テーブルの新しい所有者のユーザ名です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>new_tablespace</I
></TT
></DT
><DD
><P
>テーブルを移動する先のテーブル空間の名前です。
       </P
></DD
><DT
><TT
CLASS="REPLACEABLE"
><I
>new_schema</I
></TT
></DT
><DD
><P
>テーブルを移動する先のスキーマの名前です。

       </P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72380"
></A
><H2
>注釈</H2
><P
><TT
CLASS="LITERAL"
>COLUMN</TT
>キーワードには意味がなく、省略可能です。
   </P
><P
><TT
CLASS="LITERAL"
>ADD COLUMN</TT
>によって列を追加した時、テーブル内の既存行に追加された列は、全てデフォルト値（<TT
CLASS="LITERAL"
>DEFAULT</TT
>が指定されていない場合はNULL）で初期化されます。
<TT
CLASS="LITERAL"
>DEFAULT</TT
>句がない場合、これは単なるメタデータの変更となり、即座にテーブルのデータを更新する必要はありません。
その代わりに、追加されるNULLの値は読み出し時に付加されます。
   </P
><P
><TT
CLASS="LITERAL"
>DEFAULT</TT
>句を持つ列を追加したり、既存の列の型を変更するには、テーブルとインデックス全体の書き換えが必要になります。
既存の列の型を変更する場合の例外として、<TT
CLASS="LITERAL"
>USING</TT
>句が列の内容を変更せず、かつ、古いデータ型が新しい型とバイナリ変換可能であるか新しい型全体に対する制約のないドメインである場合、テーブルの書き換えは必要ありません。
しかし影響を受ける列に対するインデックスはすべて再構築されなければなりません。
システム<TT
CLASS="LITERAL"
>oid</TT
>列の追加や削除も同様にテーブル全体の書き換えが必要です。
テーブルが巨大な場合、テーブル、インデックスまたはその両方の再構築に非常に時間がかかる可能性があります。
また、一時的に2倍のディスク容量が必要とされます。
   </P
><P
><TT
CLASS="LITERAL"
>CHECK</TT
>あるいは<TT
CLASS="LITERAL"
>NOT NULL</TT
>制約を追加する時は、既存の行が制約に従うかどうかを検証するためにテーブルの走査が必要になりますが、テーブルの書き換えは必要ありません。
   </P
><P
>単一の<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>内に複数の変更を指定できるオプションを提供する主な理由は、複数のテーブル走査や書き換えを1回のテーブル走査にまとめることができるようにすることです。
   </P
><P
><TT
CLASS="LITERAL"
>DROP COLUMN</TT
>構文は、列を物理的には削除せず、SQLの操作に対して不可視にします。
このコマンドを実行した後、テーブルに挿入または更新が行われると、削除した列にはNULLが格納されます。
したがって、列の削除は短時間で行えます。
しかし、削除された列が占めていた領域がまだ回収されていないため、テーブルのディスク上のサイズはすぐには小さくなりません。
この領域は、その後既存の行が更新されるにつれて回収されます。
（システム<TT
CLASS="LITERAL"
>oid</TT
>列を削除する場合は上記のことは適用されません。
これは即座の書き換えが行われます。）
   </P
><P
>削除した列が占有していたスペースを即座に再利用できるようにするには、テーブル全体を書き換える構文の<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>を使用することができます。
この結果、各行の削除される列がNULL値で再構成されます。
   </P
><P
>テーブルを書き換える構文の<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>はMVCC的に安全ではありません。
同時実行中のトランザクションが、テーブル書き換えが発生する前に取得したスナップショットを使っている場合、テーブルの書き換え後はそのトランザクションにはテーブルが空であるように見えます。
詳しくは<A
HREF="mvcc-caveats.html"
>項13.5</A
>を参照して下さい。
   </P
><P
><TT
CLASS="LITERAL"
>SET DATA TYPE</TT
>の<TT
CLASS="LITERAL"
>USING</TT
>オプションでは、その行の古い値を含め、どのような式でも指定できます。
つまり、変換対象の列と同様に、その他の列も参照することができます。
そのため、一般的な変換を<TT
CLASS="LITERAL"
>SET DATA TYPE</TT
>構文で行うことができます。
この柔軟性のため、<TT
CLASS="LITERAL"
>USING</TT
>式は列のデフォルト値には（仮に存在していても）適用されません。
結果が定数式にならない可能性があるためです（デフォルト値は定数式でなければいけません）。
したがって、古い型から新しい型への暗黙キャストや代入キャストが存在しない場合、<TT
CLASS="LITERAL"
>USING</TT
>が指定されていても、<TT
CLASS="LITERAL"
>SET DATA TYPE</TT
>がデフォルト値の変換に失敗する可能性があります。
この場合は、<TT
CLASS="LITERAL"
>DROP DEFAULT</TT
>でデフォルト値を削除し、<TT
CLASS="LITERAL"
>ALTER TYPE</TT
>を実行した後で、<TT
CLASS="LITERAL"
>SET DEFAULT</TT
>を使用して再度適切なデフォルト値を指定してください。
変更対象の列を含むインデックスと制約も同様の配慮が必要です。
   </P
><P
>そのテーブルを継承するテーブルがある場合、子テーブルに同じ処理を実行しなければ、親テーブルに対する列の追加、列の名前、列の型、継承された制約の名前の変更を実行することはできません。
つまり、<TT
CLASS="COMMAND"
>ALTER TABLE ONLY</TT
>コマンドは受け付けられません。
この制限により、子テーブルの列が常に親テーブルと一致していることが保証されます。
   </P
><P
>再帰的な<TT
CLASS="LITERAL"
>DROP COLUMN</TT
>操作では、子テーブルが他の親テーブルからその列を継承しておらず、かつ、その列について独立した定義を持っていない場合のみ、その子テーブルの列を削除します。
再帰的でない<TT
CLASS="LITERAL"
>DROP COLUMN</TT
>（つまり、<TT
CLASS="COMMAND"
>ALTER TABLE ONLY ... DROP COLUMN</TT
>）操作では、継承された列は削除されません。
削除する代わりに、その列は継承されておらず独立して定義されているという印を付けます。
   </P
><P
><TT
CLASS="LITERAL"
>TRIGGER</TT
>、<TT
CLASS="LITERAL"
>CLUSTER</TT
>、<TT
CLASS="LITERAL"
>OWNER</TT
>および<TT
CLASS="LITERAL"
>TABLESPACE</TT
>は子テーブルに再帰的に伝わりません。
つまり、常に<TT
CLASS="LITERAL"
>ONLY</TT
>が指定されているかのように動作します。
制約の追加は、<TT
CLASS="LITERAL"
>NO INHERIT</TT
>印がない<TT
CLASS="LITERAL"
>CHECK</TT
>制約に関してのみ再帰的に伝わります。
   </P
><P
>システムカタログテーブルについては、いかなる部分の変更も許可されていません。
   </P
><P
>有効なパラメータの詳しい説明は<A
HREF="sql-createtable.html"
>CREATE TABLE</A
>を参照してください。
<A
HREF="ddl.html"
>第5章</A
>に、継承に関するさらに詳しい情報があります。
   </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72433"
></A
><H2
>例</H2
><P
><TT
CLASS="TYPE"
>varchar</TT
>型の列をテーブルに追加します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD COLUMN address varchar(30);</PRE
><P>
  </P
><P
>   テーブルから列を削除します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors DROP COLUMN address RESTRICT;</PRE
><P>
  </P
><P
>1つの操作で既存の2つの列の型を変更します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors
    ALTER COLUMN address TYPE varchar(80),
    ALTER COLUMN name TYPE varchar(100);</PRE
><P>
  </P
><P
><TT
CLASS="LITERAL"
>USING</TT
>句を使用して、Unixタイムスタンプを持つinteger型の列を<TT
CLASS="TYPE"
>timestamp with time zone</TT
>に変更します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE foo
    ALTER COLUMN foo_timestamp SET DATA TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';</PRE
><P>
  </P
><P
>上と同じことをします。
ただし、その列は、自動的に新しいデータ型にキャストされないデフォルト式を持つ場合についてです。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE foo
    ALTER COLUMN foo_timestamp DROP DEFAULT,
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second',
    ALTER COLUMN foo_timestamp SET DEFAULT now();</PRE
><P>
  </P
><P
>既存の列の名前を変更します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors RENAME COLUMN address TO city;</PRE
><P>
  </P
><P
>既存のテーブルの名前を変更します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors RENAME TO suppliers;</PRE
><P>
  </P
><P
>既存の制約の名前を変更します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;</PRE
><P>
  </P
><P
>列に非NULL制約を付与します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;</PRE
><P>
列から非NULL制約を削除します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ALTER COLUMN street DROP NOT NULL;</PRE
><P>
  </P
><P
>テーブルとそのすべての子テーブルにCHECK制約を付与します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5);</PRE
><P>
  </P
><P
>そのテーブルのみに適用され、その子テーブルには適用されない検査制約を追加します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;</PRE
><P>
（この検査制約はこの後作成される子テーブルにも継承されません。）
  </P
><P
>テーブルとそのすべての子テーブルからCHECK制約を削除します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors DROP CONSTRAINT zipchk;</PRE
><P>
  </P
><P
>1つのテーブルのみから検査制約を削除します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;</PRE
><P>
（この検査制約はすべての子テーブルで残ったままです。）
  </P
><P
>テーブルに外部キー制約を付与します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address);</PRE
><P>
  </P
><P
>テーブルへの外部キーの追加で、他の作業への影響を最小限にするには、以下のようにします。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT distfk FOREIGN KEY (address) REFERENCES addresses (address) NOT VALID;
ALTER TABLE distributors VALIDATE CONSTRAINT distfk;</PRE
><P>
  </P
><P
>テーブルに（複数列の）一意性制約を付与します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD CONSTRAINT dist_id_zipcode_key UNIQUE (dist_id, zipcode);</PRE
><P>
  </P
><P
>自動的に命名される主キー制約をテーブルに付与します。
1つのテーブルが持てる主キーは1つだけであることに注意してください。

</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors ADD PRIMARY KEY (dist_id);</PRE
><P>
  </P
><P
>テーブルを別のテーブル空間に移動します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE distributors SET TABLESPACE fasttablespace;</PRE
><P>
  </P
><P
>テーブルを別のスキーマに移動します。
</P><PRE
CLASS="PROGRAMLISTING"
>ALTER TABLE myschema.distributors SET SCHEMA yourschema;</PRE
><P>
  </P
><P
>インデックスを再構築している間の更新をブロックすることなく、主キー制約を再作成します。
</P><PRE
CLASS="PROGRAMLISTING"
>CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
    ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;</PRE
><P></P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72479"
></A
><H2
>互換性</H2
><P
>（<TT
CLASS="LITERAL"
>USING INDEX</TT
>がない）<TT
CLASS="LITERAL"
>ADD</TT
>、<TT
CLASS="LITERAL"
>DROP</TT
>、<TT
CLASS="LITERAL"
>SET DEFAULT</TT
>、（<TT
CLASS="LITERAL"
>USING</TT
>がない）<TT
CLASS="LITERAL"
>SET DATA TYPE</TT
>構文は標準SQLに従います。
他の構文は標準SQLに対する<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。
また、単一の<TT
CLASS="COMMAND"
>ALTER TABLE</TT
>コマンド内に複数の操作を指定する機能も<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。
  </P
><P
><TT
CLASS="COMMAND"
>ALTER TABLE DROP COLUMN</TT
>を使って、1つしか列がないテーブルから列を削除して、列がないテーブルを作成することができます。
これは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の拡張です。SQLでは、列を持たないテーブルは認められていません。
  </P
></DIV
><DIV
CLASS="REFSECT1"
><A
NAME="AEN72494"
></A
><H2
>関連項目</H2
><A
HREF="sql-createtable.html"
>CREATE TABLE</A
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="sql-altersystem.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="sql-altertablespace.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>ALTER SYSTEM</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="sql-commands.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>ALTER TABLESPACE</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>実装</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="SP-GiSTインデックス"
HREF="spgist.html"><LINK
REL="PREVIOUS"
TITLE="拡張性"
HREF="spgist-extensibility.html"><LINK
REL="NEXT"
TITLE="例"
HREF="spgist-examples.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="拡張性"
HREF="spgist-extensibility.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="spgist.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 60章SP-GiSTインデックス</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="例"
HREF="spgist-examples.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="SPGIST-IMPLEMENTATION"
>60.4. 実装</A
></H1
><P
>この節では、<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>の演算子クラスを実装する人にとって知っていると役に立つ、実装についての詳細とその他の秘訣について説明します。
  </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPGIST-LIMITS"
>60.4.1. SP-GiSTの制限</A
></H2
><P
>それぞれのリーフタプルおよび内部タプルは1つのインデックスページ内(デフォルトで8KB)に収まらなければなりません。
従って、可変長のデータ型の値をインデックス付けするときは、長い値は基数木のようなメソッドによってのみサポートされます。つまり、ツリーのそれぞれのレベルではページに収まる短さの接頭辞を含み、最後のリーフレベルでは、やはりページに収まる短さの接尾辞を含む、というようなものです。
このようなことが発生する場合の対応の準備ができている場合のみ、演算子クラスは<TT
CLASS="STRUCTFIELD"
>longValuesOK</TT
>をTRUEにセットするべきです。
そうでなければ、<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>のコアは、インデックスページに収めるには大きすぎる値についてのインデックス付け要求を拒絶します。
  </P
><P
>同様に、内部タプルが大きくなりすぎてインデックスページに収まらない、ということにならないようにするのは、演算子クラスの責任です。
これにより、1つの内部タプルで使うことができる子ノードの数、および接頭辞の値の最大サイズが制限されます。
  </P
><P
>内部タプルのノードがリーフタプルの集合を指しているとき、それらのタプルはすべて同じインデックスページ内になければならない、という制限もあります。
(これは、シークの回数を減らし、そのようなタプルを一つにつなげるリンクに必要なスペースを減らす、という設計上の決定によるものです。)
リーフタプルの集合が大きくなって1ページに収まらなくなると、分割が実行され、中間の内部タプルが挿入されます。
これで問題を解決するためには、新しい内部タプルは、リーフの値の集合を2つ以上のノードのグループに分割し<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>なければなりません</I
></SPAN
>。
演算子クラスの<CODE
CLASS="FUNCTION"
>picksplit</CODE
>関数がそれをするのに失敗したときは、<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>のコアは、<A
HREF="spgist-implementation.html#SPGIST-ALL-THE-SAME"
>項60.4.3</A
>に記述されている特別な手段に頼ることになります。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPGIST-NULL-LABELS"
>60.4.2. ノードラベルのないSP-GiST</A
></H2
><P
>木構造のアルゴリズムには、それぞれの内部タプルに対して固定された集合のノードを使うものがあります。
例えば四分木では、内部タプルの中心点の周りの4つの象限に対応するちょうど4つのノードが必ずあります。
このような場合、コードは典型的には数字を使ったノードで動作し、明示的なノードラベルは必要ありません。
ノードラベルを使わない(そしてそれによりいくらかのスペースを節約する)ために、<CODE
CLASS="FUNCTION"
>picksplit</CODE
>関数は<TT
CLASS="STRUCTFIELD"
>nodeLabels</TT
>配列としてNULLを返すことができます。
この結果、その後の<CODE
CLASS="FUNCTION"
>choose</CODE
>関数および<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>関数の呼び出しにおいても<TT
CLASS="STRUCTFIELD"
>nodeLabels</TT
>はNULLになります。
原則として、ノードラベルは同じインデックス中の一部の内部タプルに使い、他の内部タプルには省略する、ということができます。
  </P
><P
>ラベルのないノードを持つ内部タプルを処理するときに、<CODE
CLASS="FUNCTION"
>choose</CODE
>が<TT
CLASS="LITERAL"
>spgAddNode</TT
>を返すのはエラーです。というのは、この場合、ノードの集合は固定されていると想定されるからです。
また、<TT
CLASS="LITERAL"
>spgSplitTuple</TT
>のアクションでラベルのないノードを生成する用意はありません。というのは、<TT
CLASS="LITERAL"
>spgAddNode</TT
>のアクションも必要になると考えられるからです。
  </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="SPGIST-ALL-THE-SAME"
>60.4.3. <SPAN
CLASS="QUOTE"
>"All-the-same"</SPAN
>内部タプル</A
></H2
><P
><CODE
CLASS="FUNCTION"
>picksplit</CODE
>が入力のリーフ値を少なくとも2つのノード分類に分割できなかった場合、<ACRONYM
CLASS="ACRONYM"
>SP-GiST</ACRONYM
>のコアは演算子クラスの<CODE
CLASS="FUNCTION"
>picksplit</CODE
>関数の結果を無効にすることがあります。
これが起きると、複数のノードを持つ新しい内部タプルが作成されます。それぞれのノードは、<CODE
CLASS="FUNCTION"
>picksplit</CODE
>が一つのノードに付与したもの(あれば)と同じラベルを持ち、リーフ値はこれらの等価なノード間でランダムに分割されます。
内部タプルには<TT
CLASS="LITERAL"
>allTheSame</TT
>のフラグがセットされ、<CODE
CLASS="FUNCTION"
>choose</CODE
>関数および<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>関数に対し、そのタプルが通常期待されるようなノードの集合を持っていないことを警告します。
  </P
><P
><TT
CLASS="LITERAL"
>allTheSame</TT
>の処理において、<CODE
CLASS="FUNCTION"
>choose</CODE
>の<TT
CLASS="LITERAL"
>spgMatchNode</TT
>という結果は、新しい値は等価なノードのどれに割り当てられても良い、という意味に解釈されます。
コアのコードは入力された<TT
CLASS="STRUCTFIELD"
>nodeN</TT
>の値を無視し、(ツリーの平衡を保つために)ノードの1つにランダムに降りていきます。
<CODE
CLASS="FUNCTION"
>choose</CODE
>が<TT
CLASS="LITERAL"
>spgAddNode</TT
>を返すのはエラーです。というのは、そうするとすべてのノードが等価ではなくなるからです。
挿入する値が既存のノードとマッチしない時は、<TT
CLASS="LITERAL"
>spgSplitTuple</TT
>のアクションを使わなければなりません。
  </P
><P
><TT
CLASS="LITERAL"
>allTheSame</TT
>のタプルの処理において、すべてのノードは等価なので、<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>関数は、インデックス検索を続けるためのターゲットとして、すべてのノードを返すか、ノードを1つも返さないかのいずれかであるべきです。
このために、特殊ケースを扱うコードが必要になるかもしれませんし、必要ないかもしれません。それは、<CODE
CLASS="FUNCTION"
>inner_consistent</CODE
>関数が、通常、ノードの意味についてどの程度のことを仮定しているかに依存します。
  </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="spgist-extensibility.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="spgist-examples.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>拡張性</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="spgist.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>例</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
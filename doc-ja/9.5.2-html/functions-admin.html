<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>システム管理関数</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="関数と演算子"
HREF="functions.html"><LINK
REL="PREVIOUS"
TITLE="システム情報関数"
HREF="functions-info.html"><LINK
REL="NEXT"
TITLE="トリガ関数"
HREF="functions-trigger.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="システム情報関数"
HREF="functions-info.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 9章関数と演算子</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="トリガ関数"
HREF="functions-trigger.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FUNCTIONS-ADMIN"
>9.26. システム管理関数</A
></H1
><P
>本節で説明する関数は、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>インストレーションの制御と監視を行うために使用されます。
   </P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-ADMIN-SET"
>9.26.1. 構成設定関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-SET-TABLE"
>表9-66</A
>は、実行時設定パラメータの問い合わせや変更に使用できる関数を示しています。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADMIN-SET-TABLE"
></A
><P
><B
>表 9-66. 構成設定関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>current_setting(<TT
CLASS="PARAMETER"
>setting_name</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>現在の設定値の取得</TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>set_config(<TT
CLASS="PARAMETER"
>setting_name</TT
>,
                             <TT
CLASS="PARAMETER"
>new_value</TT
>,
                             <TT
CLASS="PARAMETER"
>is_local</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>パラメータを設定し、新規値を返す</TD
></TR
></TBODY
></TABLE
></DIV
><P
>関数<CODE
CLASS="FUNCTION"
>current_setting</CODE
>は、設定<TT
CLASS="PARAMETER"
>setting_name</TT
>の現在の値を返します。
この関数は、<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>の<TT
CLASS="COMMAND"
>SHOW</TT
>コマンドと同じです。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT current_setting('datestyle');

 current_setting
-----------------
 ISO, MDY
(1 row)</PRE
><P>
   </P
><P
><CODE
CLASS="FUNCTION"
>set_config</CODE
>関数は、パラメータ<TT
CLASS="PARAMETER"
>setting_name</TT
>を<TT
CLASS="PARAMETER"
>new_value</TT
>に設定します。
ただし、<TT
CLASS="PARAMETER"
>is_local</TT
>が<TT
CLASS="LITERAL"
>true</TT
>の場合、新規値は現在のトランザクションにのみ適用されます。
新規値を現在のセッションに適用する場合は、代わりに<TT
CLASS="LITERAL"
>false</TT
>を使用してください。
この関数は、SQLの<TT
CLASS="COMMAND"
>SET</TT
>コマンドと同じです。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT set_config('log_statement_stats', 'off', false);

 set_config
------------
 off
(1 row)</PRE
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-ADMIN-SIGNAL"
>9.26.2. サーバシグナル送信関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-SIGNAL-TABLE"
>表9-67</A
>に示す関数は、制御用シグナルを他のサーバプロセスに送信します。
これらの関数の使用は、注記された例外を除き、大抵の場合スーパーユーザのみに制限されています。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADMIN-SIGNAL-TABLE"
></A
><P
><B
>表 9-67. サーバシグナル送信関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_cancel_backend(<TT
CLASS="PARAMETER"
>pid</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>バックエンドの現在の問い合わせを取り消す。
       関数を呼ぶユーザが取り消す対象のバックエンドのロールのメンバーであるときも実行できます。
       ただし、スーパーユーザのバックエンドはスーパーユーザのみが取り消せます。
        </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_reload_conf()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>サーバプロセスに構成ファイルの再読み込みをさせる</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_rotate_logfile()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>サーバログファイルを循環させる</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_terminate_backend(<TT
CLASS="PARAMETER"
>pid</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>バックエンドを終了する。
       関数を呼ぶユーザが終了対象のバックエンドのロールのメンバーであるときも実行できます。
       ただし、スーパーユーザのバックエンドはスーパーユーザのみが終了できます。
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
>これらのそれぞれの関数は成功の場合<TT
CLASS="LITERAL"
>true</TT
>（真）を返し、そうでない場合は<TT
CLASS="LITERAL"
>false</TT
>（偽）を返します。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_cancel_backend</CODE
>と<CODE
CLASS="FUNCTION"
>pg_terminate_backend</CODE
>は（それぞれ、<SPAN
CLASS="SYSTEMITEM"
>SIGINT</SPAN
>または<SPAN
CLASS="SYSTEMITEM"
>SIGTERM</SPAN
>）シグナルをプロセス識別子で特定されたバックエンドプロセスに送ります。
使用中のバックエンドのプロセス識別子は<TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>ビューの<TT
CLASS="STRUCTFIELD"
>pid</TT
>列から、もしくは、（Unixでは<SPAN
CLASS="APPLICATION"
>ps</SPAN
>、<SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>では<SPAN
CLASS="APPLICATION"
>Task Manager</SPAN
>により）サーバ上の<TT
CLASS="COMMAND"
>postgres</TT
>プロセスをリストすることで見つけられます。
実行中のバックエンドのロールは<TT
CLASS="STRUCTNAME"
>pg_stat_activity</TT
>の<TT
CLASS="STRUCTFIELD"
>usename</TT
>列から確認することができます。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_reload_conf</CODE
>は<SPAN
CLASS="SYSTEMITEM"
>SIGHUP</SPAN
>シグナルをサーバに送り、その結果全てのサーバプロセスが構成ファイルを再読み込みすることになります。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_rotate_logfile</CODE
>はログファイルマネージャに即座に新規出力ファイルに切替えるよう信号を送ります。
これは組み込みログ取得が起動している場合のみ有効です。起動していない場合はログファイルマネージャの子プロセスが存在しない理由からです。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-ADMIN-BACKUP"
>9.26.3. バックアップ制御関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE"
>表9-68</A
>に示す関数はオンラインバックアップの作成を支援するものです。
これらの関数は、リカバリ中には実行できません(<CODE
CLASS="FUNCTION"
>pg_is_in_backup</CODE
>、<CODE
CLASS="FUNCTION"
>pg_backup_start_time</CODE
>、および<CODE
CLASS="FUNCTION"
>pg_xlog_location_diff</CODE
>は除く)。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADMIN-BACKUP-TABLE"
></A
><P
><B
>表 9-68. バックアップ制御関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_create_restore_point(<TT
CLASS="PARAMETER"
>name</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>リストア実行用に名前付けされたポイントを作成(スーパーユーザのみ実施可能です)</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_current_xlog_insert_location()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>現在のトランザクションログの挿入位置の取得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_current_xlog_location()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>現在のトランザクションログの書き込み位置を取得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_start_backup(<TT
CLASS="PARAMETER"
>label</TT
> <TT
CLASS="TYPE"
>text</TT
> [<SPAN
CLASS="OPTIONAL"
>, <TT
CLASS="PARAMETER"
>fast</TT
> <TT
CLASS="TYPE"
>boolean</TT
> </SPAN
>])</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>オンラインバックアップの実行準備(スーパーユーザかレプリケーション用のロールでのみ実施可能です)</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stop_backup()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>オンラインバックアップの実行の終了(スーパーユーザかレプリケーション用のロールでのみ実施可能です)</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_is_in_backup()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
>オンラインでの排他的バックアップが実行中は真。</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_backup_start_time()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>実行中のオンライン排他的バックアップの開始時刻を取得。</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_switch_xlog()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>新しいトランザクションログファイルへの強制移行(スーパユーザのみ実施可能です)</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_xlogfile_name(<TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>トランザクションログの位置を表す文字列をファイル名に変換</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_xlogfile_name_offset(<TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>トランザクションログの位置を表す文字列を、ファイル名とファイル内の10進のバイトオフセットに変換</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_xlog_location_diff(<TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>numeric</TT
></TD
><TD
>2つのトランザクションログの位置差分を算出</TD
></TR
></TBODY
></TABLE
></DIV
><P
><CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>は、ユーザが任意に定義したバックアップラベルを受け付けます。
（通常、格納に使用するバックアップダンプファイルにちなんだ名前が付けられます。）
この関数は、データベースクラスタのデータディレクトリにバックアップラベルファイル（<TT
CLASS="FILENAME"
>backup_label</TT
>）および<TT
CLASS="FILENAME"
>pg_tblspc/</TT
>ディレクトリにリンクがあるならテーブル空間マップファイル（<TT
CLASS="FILENAME"
>tablespace_map</TT
>）を書き出し、チェックポイントを実行し、トランザクションログのバックアップ開始位置をテキスト形式で返します。
ユーザはこの結果値を無視することができますが、便利なこともあるので提供されています。
</P><PRE
CLASS="PROGRAMLISTING"
>postgres=# select pg_start_backup('label_goes_here');
 pg_start_backup
-----------------
 0/D4445B8
(1 row)</PRE
><P>
オプションの<TT
CLASS="TYPE"
>boolean</TT
>型パラメータがあります。
<TT
CLASS="LITERAL"
>true</TT
>であれば、できる限り高速に<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>を実行します。
これは、即時のチェックポイントを強制するため、I/O 操作の急激な増加を引き起こし、実行中の問い合わせ全てを遅延させることがあります。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_stop_backup</CODE
>は、<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>で作成されたラベルファイルおよび、もしあれば<TT
CLASS="FILENAME"
>tablespace_map</TT
>ファイルを削除し、トランザクションログ格納領域にバックアップ履歴ファイルを作成します。
履歴ファイルには<CODE
CLASS="FUNCTION"
>pg_start_backup</CODE
>で付与されたラベル、バックアップのトランザクションログの位置の開始位置、終了位置、バックアップ開始時刻、終了時刻が含まれます。
戻り値は、バックアップの終了トランザクションログの位置です（これも同様に無視可能です）。
終了位置を記録した後、現在のトランザクションログの挿入位置は自動的に、次のトランザクションログファイルに進みます。ですので、終了トランザクションログファイルをすぐにアーカイブし、バックアップを完了させることができます。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_switch_xlog</CODE
>は、次のトランザクションログファイルに移動し、現在のファイルをアーカイブできるようにします（継続的アーカイブを使用することを前提とします）。
戻り値は、完了した現在のトランザクションログファイル内の終了トランザクションログの位置に1を加えたものです。
前回のトランザクションログファイルの切り替えからトランザクションログに変化がなければ、<CODE
CLASS="FUNCTION"
>pg_switch_xlog</CODE
>は何もせずに、現在使用中のトランザクションログファイルの開始位置を返します。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_create_restore_point</CODE
>はリカバリターゲットとして使用可能な名前付けされたトランザクションログレコードを生成し、それに該当するログ位置を返します。
与えられた名前は、どこまでリカバリをするかを明示的に指定する<A
HREF="recovery-target-settings.html#RECOVERY-TARGET-NAME"
>recovery_target_name</A
>パラメータに使用することができます。
リカバリ処理はリカバリターゲットに指定した名前と一致した最初の時点で終了するため、同じ名前で複数のリストアポイントを作成することは避けてください。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_current_xlog_location</CODE
>は、上記の関数で使用される同一の書式で現在のトランザクションログの書き込み位置を表示します。
同様に<CODE
CLASS="FUNCTION"
>pg_current_xlog_insert_location</CODE
>は、現在のトランザクションログの挿入位置を表示します。
挿入位置は <SPAN
CLASS="QUOTE"
>"論理的"</SPAN
>な任意の時点のトランザクションログの終了位置です。一方、書き込み位置は、サーバの内部バッファから書き出された実際の終了位置です。
書き込み位置はサーバ外部から検証可能なものの終端です。通常は、部分的に完了したトランザクションログファイルのアーカイブ処理を行いたい場合に必要とされるものです。
挿入位置はサーバをデバッグする際に主に使用されます。
これらはどちらも読み取りのみの操作であり、スーパーユーザ権限を必要としません。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_xlogfile_name_offset</CODE
>を使用して、上記いずれの関数の結果からも、対応するトランザクションログファイルとバイトオフセットを取り出すことができます。
以下に例を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());
        file_name         | file_offset 
--------------------------+-------------
 00000001000000000000000D |     4039624
(1 row)</PRE
><P>
同様に、<CODE
CLASS="FUNCTION"
>pg_xlogfile_name</CODE
>は、トランザクションログファイル名のみを取り出します。
指定したトランザクションログの位置が正確にトランザクションログファイルの境界であった場合、これらの両関数は前のトランザクションログファイルの名前を返します。
通常これは、トランザクションログファイルのアーカイブ動作では好まれる動作です。前のファイルが現在のアーカイブで必要とする最後のファイルであるからです。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_xlog_location_diff</CODE
>は、2つのトランザクションログの位置の差分をバイト数で算出します。
この関数は<TT
CLASS="STRUCTNAME"
>pg_stat_replication</TT
>や<A
HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP-TABLE"
>表9-68</A
>に示される関数と併用することで、レプリケーションの遅延の確認に使用できます。
   </P
><P
>これらの関数の正しい使用方法については、<A
HREF="continuous-archiving.html"
>項24.3</A
>を参照してください。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-RECOVERY-CONTROL"
>9.26.4. リカバリ制御関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-RECOVERY-INFO-TABLE"
>表9-69</A
>に示される関数は、スタンバイサーバの現在のステータス情報を提供します。
これらの関数はリカバリ中、および通常稼動時に実行することができるでしょう。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-RECOVERY-INFO-TABLE"
></A
><P
><B
>表 9-69. リカバリ情報関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_is_in_recovery()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
>まだリカバリ実施中であれば真を返します。
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_last_xlog_receive_location()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>ストリーミングレプリケーションにより受信されディスクに書き込みされた、トランザクションログの最後の位置を取得します。ストリーミングレプリケーションが実施されている場合は、この値が単調に増加していくでしょう。リカバリが完了した場合、受信されディスクに書き込まれた最後のWALレコードの位置の値がそのまま残ります。ストリーミングレプリケーションが無効、もしくは開始されていない場合、この関数はNULLを返します。
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_last_xlog_replay_location()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>pg_lsn</TT
></TD
><TD
>リカバリ中に再生された最後のトランザクションログの位置を取得します。リカバリが実施されている場合は、この値が単調に増加していくでしょう。リカバリが完了した場合は、リカバリ時に適用された最後のWALレコードの値がそのまま残ります。もしサーバがリカバリ無しで普通に起動された場合、この関数はNULLを返します。
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_last_xact_replay_timestamp()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>timestamp with time zone</TT
></TD
><TD
>リカバリ中に再生された最後のトランザクションのタイムスタンプを取得します。
このタイムスタンプは、プライマリにて該当するトランザクションがコミット、もしくはアボートされた際のWALレコードが生成された時間です。
リカバリ中に何のトランザクションも再生されていない場合、この関数はNULLを返します。
リカバリがまだ実行中の場合、この関数の戻り値は単調に増加します。
リカバリが完了している場合、この関数の戻り値はリカバリ中に再生した最後のトランザクションの時間のまま変化しません。
サーバがリカバリ処理無しに正常に開始された場合、この関数はNULLを返します。
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
><A
HREF="functions-admin.html#FUNCTIONS-RECOVERY-CONTROL-TABLE"
>表9-70</A
>に示す関数は、リカバリの進行を制御する関数です。
これらの関数はリカバリ中のみ実行することが可能です。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-RECOVERY-CONTROL-TABLE"
></A
><P
><B
>表 9-70. リカバリ制御関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_is_xlog_replay_paused()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bool</TT
></TD
><TD
>リカバリが停止中であれば真を返す
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_xlog_replay_pause()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>即座にリカバリを停止する(スーパーユーザに限定)
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_xlog_replay_resume()</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>もしリカバリ停止中であれば再開する(スーパーユーザに限定)
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
>リカバリ停止中は、それ以降のデータベースへの変更は適用されません。
ホットスタンバイ側では、新しい問い合わせはすべて、同じ一貫性を持ったデータベースのスナップショットを参照することになります。
そしてリカバリが再開されるまで、これ以上の問い合わせの競合は発生しません。
   </P
><P
>ストリーミングレプリケーションが無効の場合、停止状態はいつまでも問題なく継続するでしょう。
ストリーミングレプリケーションの実行中は、WALレコードの受信が継続され、停止時間、WALの生成速度、ディスクの残存容量によりますが、ディスク溢れが発生する可能性があります。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-SNAPSHOT-SYNCHRONIZATION"
>9.26.5. スナップショット同期関数</A
></H2
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はデータベースのセッションに対して、それらのスナップショットを同期させることが可能です。
<I
CLASS="FIRSTTERM"
>スナップショット</I
>は、そのスナップショットを使用しているトランザクションにどのデータが可視かを決定します。
同期スナップショットは、2つ以上のセッションにおいて、全く同じデータベース内容を見たい場合に必要となります。
単に2つのセッションが独立してそれぞれのトランザクションを開始するだけでは、第3のトランザクションのコミットが、2つのトランザクションの<TT
CLASS="COMMAND"
>START TRANSACTION</TT
>の狭間で実行され、そのため一方のトランザクションではそのコミット結果が見え、他方では見えないという可能性が常にあります。
   </P
><P
>このような問題を解決するため、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>ではトランザクションが使用しているスナップショットを<I
CLASS="FIRSTTERM"
>エクスポート</I
>できるようになっています。エクスポートしたトランザクションが開かれ続けている限り、他のトランザクションがそれを<I
CLASS="FIRSTTERM"
>インポート</I
>することができ、
そしてこれにより最初のトランザクションと正確に同じとなるデータベースの可視性を保証されます。ただし、これらの(スナップショットを共有している)トランザクションによって発生したデータベースへの変更は、コミットされていないトランザクションによる変更と同様に、(スナップショットを共有している)他のトランザクションには見えないままです。
つまり、既存データに対しては同期されますが、それら自身による変更については通常の振る舞いをします。
   </P
><P
>スナップショットは、<A
HREF="functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE"
>表9-71</A
>に示す<CODE
CLASS="FUNCTION"
>pg_export_snapshot</CODE
>関数を用いてエクスポートされ、<A
HREF="sql-set-transaction.html"
>SET TRANSACTION</A
>コマンドを用いてインポートされます。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-SNAPSHOT-SYNCHRONIZATION-TABLE"
></A
><P
><B
>表 9-71. スナップショット同期関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り値型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_export_snapshot()</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>現在のスナップショットを保存し、その識別子を返す</TD
></TR
></TBODY
></TABLE
></DIV
><P
><CODE
CLASS="FUNCTION"
>pg_export_snapshot</CODE
>関数は現在のスナップショットを保存し、そのスナップショットを識別する<TT
CLASS="TYPE"
>text</TT
>文字列を返します。
この文字列はスナップショットをインポートしたい(データベース外の)クライアントに渡されなければなりません。
エクスポートしたトランザクションが終わるまでの間のみ、そのスナップショットをインポートすることができます。
必要ならばトランザクションは複数のスナップショットをエクスポートできます。
<TT
CLASS="LITERAL"
>REPEATABLE READ</TT
>や上位の隔離レベルでは、トランザクションはその有効期間の間同じスナップショットを使用しますので、これは<TT
CLASS="LITERAL"
>READ COMMITTED</TT
>トランザクションでのみ有用であることに注意してください。
一旦スナップショットをエクスポートしたトランザクションでは、<A
HREF="sql-prepare-transaction.html"
>PREPARE TRANSACTION</A
>による準備を使用することができなくなります。
   </P
><P
>エクスポートしたトランザクションの使用方法の詳細については<A
HREF="sql-set-transaction.html"
>SET TRANSACTION</A
>を参照してください。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-REPLICATION"
>9.26.6. レプリケーション関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-REPLICATION-TABLE"
>表9-72</A
>に示す関数はレプリケーション機能を制御したり、情報を取得したりするためのものです。
基盤となっている機能の情報に関しては<A
HREF="warm-standby.html#STREAMING-REPLICATION"
>項25.2.5</A
>、<A
HREF="warm-standby.html#STREAMING-REPLICATION-SLOTS"
>項25.2.6</A
>、<A
HREF="replication-origins.html"
>第47章</A
>を参照してください。
これらの関数の使用はスーパユーザに限定されています。
   </P
><P
>これらの関数の多くには、レプリケーションプロトコルに等価なコマンドがあります。
<A
HREF="protocol-replication.html"
>項50.3</A
>を参照してください。
   </P
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-BACKUP"
>項9.26.3</A
>、<A
HREF="functions-admin.html#FUNCTIONS-RECOVERY-CONTROL"
>項9.26.4</A
>、<A
HREF="functions-admin.html#FUNCTIONS-SNAPSHOT-SYNCHRONIZATION"
>項9.26.5</A
>に書かれている関数もレプリケーションに関係するものです。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-REPLICATION-TABLE"
></A
><P
><B
>表 9-72. レプリケーション<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>関数</TH
><TH
>戻り値型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_create_physical_replication_slot(<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
       </TD
><TD
>        (<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>, <TT
CLASS="PARAMETER"
>xlog_position</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>)
       </TD
><TD
><TT
CLASS="PARAMETER"
>slot_name</TT
>という名前の新しい物理レプリケーションスロットを作成します。
物理スロットからのストリーミングの変更はストリーミングレプリケーションプロトコルでのみ可能です。<A
HREF="protocol-replication.html"
>項50.3</A
>を参照してください。
レプリケーションプロトコルコマンド<TT
CLASS="LITERAL"
>CREATE_REPLICATION_SLOT ... PHYSICAL</TT
>に対応します。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_drop_replication_slot(<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
       </TD
><TD
>        <TT
CLASS="TYPE"
>void</TT
>
       </TD
><TD
><TT
CLASS="PARAMETER"
>slot_name</TT
>という名前の物理もしくは論理レプリケーションスロットを削除します。
レプリケーションプロトコルコマンド<TT
CLASS="LITERAL"
>DROP_REPLICATION_SLOT</TT
>と同じです。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_create_logical_replication_slot(<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>, <TT
CLASS="PARAMETER"
>plugin</TT
> <TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
       </TD
><TD
>        (<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>, <TT
CLASS="PARAMETER"
>xlog_position</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>)
       </TD
><TD
>出力プラグイン<TT
CLASS="PARAMETER"
>plugin</TT
>を使用して、<TT
CLASS="PARAMETER"
>slot_name</TT
>という名前の新しい論理(デコード)レプリケーションスロットを作成します。
この関数を呼び出すのはレプリケーションプロトコルコマンド<TT
CLASS="LITERAL"
>CREATE_REPLICATION_SLOT ... LOGICAL</TT
>と同じ効果があります。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_logical_slot_get_changes(<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>, <TT
CLASS="PARAMETER"
>upto_lsn</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>upto_nchanges</TT
> <TT
CLASS="TYPE"
>int</TT
>, VARIADIC <TT
CLASS="PARAMETER"
>options</TT
> <TT
CLASS="TYPE"
>text[]</TT
>)</CODE
></TT
>
       </TD
><TD
>        (<TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>xid</TT
> <TT
CLASS="TYPE"
>xid</TT
>, <TT
CLASS="PARAMETER"
>data</TT
> <TT
CLASS="TYPE"
>text</TT
>)
       </TD
><TD
>変更が最後に消費された時点から開始して、スロット<TT
CLASS="PARAMETER"
>slot_name</TT
>の変更を返します。
<TT
CLASS="PARAMETER"
>upto_lsn</TT
>と<TT
CLASS="PARAMETER"
>upto_nchanges</TT
>がNULLならば論理デコードはWALの最後まで続きます。
<TT
CLASS="PARAMETER"
>upto_lsn</TT
>が非NULLであれば、デコードは指定されたLSNより前にコミットされたトランザクションのみを含みます。
<TT
CLASS="PARAMETER"
>upto_nchanges</TT
>が非NULLであれば、デコードにより生成された行の数が指定された値を越えたときに、デコードは止まります。
しかしながら、新しいトランザクションの各コミットをデコードして生成された行を追加した後でしかこの制限は確認されませんので、実際に返される行の数は大きいかもしれないことに注意してください。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_logical_slot_peek_changes(<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>, <TT
CLASS="PARAMETER"
>upto_lsn</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>upto_nchanges</TT
> <TT
CLASS="TYPE"
>int</TT
>, VARIADIC <TT
CLASS="PARAMETER"
>options</TT
> <TT
CLASS="TYPE"
>text[]</TT
>)</CODE
></TT
>
       </TD
><TD
>        (<TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>xid</TT
> <TT
CLASS="TYPE"
>xid</TT
>, <TT
CLASS="PARAMETER"
>data</TT
> <TT
CLASS="TYPE"
>text</TT
>)
       </TD
><TD
>        変更が消費されないということを除いて、<CODE
CLASS="FUNCTION"
>pg_logical_slot_get_changes()</CODE
>関数と同じように振る舞います。すなわち、将来の呼び出しでは再び同じものが返ります。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_logical_slot_get_binary_changes(<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>, <TT
CLASS="PARAMETER"
>upto_lsn</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>upto_nchanges</TT
> <TT
CLASS="TYPE"
>int</TT
>, VARIADIC <TT
CLASS="PARAMETER"
>options</TT
> <TT
CLASS="TYPE"
>text[]</TT
>)</CODE
></TT
>
       </TD
><TD
>        (<TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>xid</TT
> <TT
CLASS="TYPE"
>xid</TT
>, <TT
CLASS="PARAMETER"
>data</TT
> <TT
CLASS="TYPE"
>bytea</TT
>)
       </TD
><TD
>        変更は<TT
CLASS="TYPE"
>bytea</TT
>として返されるということを除いて<CODE
CLASS="FUNCTION"
>pg_logical_slot_get_changes()</CODE
>関数と同じように振る舞います。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_logical_slot_peek_binary_changes(<TT
CLASS="PARAMETER"
>slot_name</TT
> <TT
CLASS="TYPE"
>name</TT
>, <TT
CLASS="PARAMETER"
>upto_lsn</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>upto_nchanges</TT
> <TT
CLASS="TYPE"
>int</TT
>, VARIADIC <TT
CLASS="PARAMETER"
>options</TT
> <TT
CLASS="TYPE"
>text[]</TT
>)</CODE
></TT
>
       </TD
><TD
>        (<TT
CLASS="PARAMETER"
>location</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>xid</TT
> <TT
CLASS="TYPE"
>xid</TT
>, <TT
CLASS="PARAMETER"
>data</TT
> <TT
CLASS="TYPE"
>bytea</TT
>)
       </TD
><TD
>        変更は<TT
CLASS="TYPE"
>bytea</TT
>として返され消費されないということを除いて<CODE
CLASS="FUNCTION"
>pg_logical_slot_get_changes()</CODE
>関数と同じように振る舞います。すなわち、将来の呼び出しでは再び同じものが返ります。
       </TD
></TR
><TR
><A
NAME="PG-REPLICATION-ORIGIN-CREATE"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_create(<TT
CLASS="PARAMETER"
>node_name</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
>        <TT
CLASS="TYPE"
>oid</TT
>
       </TD
><TD
>指定した外部名でレプリケーション起点を作成し、割り当てられた内部IDを返します。
       </TD
></TR
><TR
><A
NAME="PG-REPLICATION-ORIGIN-DROP"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_drop(<TT
CLASS="PARAMETER"
>node_name</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
>        void
       </TD
><TD
>以前に作成されたレプリケーション起点を、それに関連するすべての再生の進捗も含めて削除します。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_oid(<TT
CLASS="PARAMETER"
>node_name</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
>        <TT
CLASS="TYPE"
>oid</TT
>
       </TD
><TD
>レプリケーション起点を名前で検索し、内部IDを返します。
相当するレプリケーション起点が見つからない場合はエラーが発生します。
       </TD
></TR
><TR
><A
NAME="PG-REPLICATION-ORIGIN-SESSION-SETUP"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_session_setup(<TT
CLASS="PARAMETER"
>node_name</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
       </TD
><TD
>        void
       </TD
><TD
>現在のセッションに、指定の起点から再生中であると印を付け、再生の進捗が追跡できるようにします。
元に戻すには<CODE
CLASS="FUNCTION"
>pg_replication_origin_session_reset</CODE
>を使って下さい。
以前に起点が設定されていない場合にのみ使うことができます。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_session_reset()</CODE
></TT
>
       </TD
><TD
>        void
       </TD
><TD
><CODE
CLASS="FUNCTION"
>pg_replication_origin_session_setup()</CODE
>の効果を取り消します。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_session_is_setup()</CODE
></TT
>
       </TD
><TD
>        <TT
CLASS="TYPE"
>bool</TT
>
       </TD
><TD
>現在のセッションで、レプリケーション起点が設定されたかどうかを返します。
       </TD
></TR
><TR
><A
NAME="PG-REPLICATION-ORIGIN-SESSION-PROGRESS"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_session_progress(<TT
CLASS="PARAMETER"
>flush</TT
> <TT
CLASS="TYPE"
>bool</TT
>)</CODE
></TT
>
       </TD
><TD
>        <TT
CLASS="TYPE"
>pg_lsn</TT
>
       </TD
><TD
>現在のセッションで設定されたレプリケーション起点の再生位置を返します。
パラメータ<TT
CLASS="PARAMETER"
>flush</TT
>により、対応するローカルトランザクションがディスクにフラッシュされていることが保証されるかどうかを決定します。
       </TD
></TR
><TR
><A
NAME="PG-REPLICATION-ORIGIN-XACT-SETUP"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_xact_setup(<TT
CLASS="PARAMETER"
>origin_lsn</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>, <TT
CLASS="PARAMETER"
>origin_timestamp</TT
> <TT
CLASS="TYPE"
>timestamptz</TT
>)</CODE
></TT
>
       </TD
><TD
>        void
       </TD
><TD
>現在のトランザクションに、指定の<ACRONYM
CLASS="ACRONYM"
>LSN</ACRONYM
>およびタイムスタンプでコミットしたトランザクションを再生中であると印をつけます。
事前にレプリケーション起点が<CODE
CLASS="FUNCTION"
>pg_replication_origin_session_setup()</CODE
>を使って設定されている場合にのみ呼び出せます。
       </TD
></TR
><TR
><A
NAME="PG-REPLICATION-ORIGIN-XACT-RESET"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_xact_reset()</CODE
></TT
>
       </TD
><TD
>        void
       </TD
><TD
><CODE
CLASS="FUNCTION"
>pg_replication_origin_xact_setup()</CODE
>の効果を取り消します。
       </TD
></TR
><TR
><TD
>        
        <TT
CLASS="LITERAL"
>pg_replication_origin_advance<CODE
CLASS="FUNCTION"
>(<TT
CLASS="PARAMETER"
>node_name</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>pos</TT
> <TT
CLASS="TYPE"
>pg_lsn</TT
>)</CODE
></TT
>
       </TD
><TD
>        void
       </TD
><TD
>指定したノードのレプリケーションの進捗を、指定の位置に設定します。
これは主に設定変更の後で初期位置や新しい位置を設定するときなどに役立ちます。
この関数を不注意に使うと、レプリケーションデータが一貫性を失うかもしれないことに注意して下さい。
       </TD
></TR
><TR
><A
NAME="PG-REPLICATION-ORIGIN-PROGRESS"
></A
><TD
>        
        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_replication_origin_progress(<TT
CLASS="PARAMETER"
>node_name</TT
> <TT
CLASS="TYPE"
>text</TT
>, <TT
CLASS="PARAMETER"
>flush</TT
> <TT
CLASS="TYPE"
>bool</TT
>)</CODE
></TT
>
       </TD
><TD
>        <TT
CLASS="TYPE"
>pg_lsn</TT
>
       </TD
><TD
>指定したレプリケーション起点の再生位置を返します。
パラメータ<TT
CLASS="PARAMETER"
>flush</TT
>により、対応するローカルトランザクションがディスクにフラッシュされていることが保証されるかどうかを決定します。
       </TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-ADMIN-DBOBJECT"
>9.26.7. データベースオブジェクト管理関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-DBSIZE"
>表9-73</A
>で示された関数はデータベースオブジェクトのディスク領域を計算します。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADMIN-DBSIZE"
></A
><P
><B
>表 9-73. データベースオブジェクト容量関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
><TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_column_size(<TT
CLASS="TYPE"
>any</TT
>)</CODE
></TT
></TD
><TD
><TT
CLASS="TYPE"
>int</TT
></TD
><TD
>特定の値を格納するのに使用される（場合により圧縮された）バイト数</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_database_size(<TT
CLASS="TYPE"
>oid</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定されたOIDのデータベースで使用されるディスク容量</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_database_size(<TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定された名前のデータベースで使用されるディスク容量</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_indexes_size(<TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定されテーブルに付与されたインデックスで使用される総ディスク容量。
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_relation_size(<TT
CLASS="PARAMETER"
>relation</TT
> <TT
CLASS="TYPE"
>regclass</TT
>, <TT
CLASS="PARAMETER"
>fork</TT
> <TT
CLASS="TYPE"
>text</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定されたテーブルまたはインデックスの指定されたフォーク（<TT
CLASS="LITERAL"
>'main'</TT
>、<TT
CLASS="LITERAL"
>'fsm'</TT
>、<TT
CLASS="LITERAL"
>'vm'</TT
>または<TT
CLASS="LITERAL"
>'init'</TT
>）で使用されるディスク容量
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_relation_size(<TT
CLASS="PARAMETER"
>relation</TT
> <TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
><TT
CLASS="LITERAL"
>pg_relation_size(..., 'main')</TT
>の省略表現
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_size_pretty(<TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>64ビット整数で表現されたサイズ（バイト数）を、サイズの単位をつけた可読性が高い書式に変換
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_size_pretty(<TT
CLASS="TYPE"
>numeric</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>numeric値で表現されたサイズ（バイト数）を、サイズの単位をつけた可読性が高い書式に変換
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_table_size(<TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定されたテーブルで使用されるディスク容量、インデックスは除外する（しかしTOAST、空き領域マップ、可視性マップは含む）
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_tablespace_size(<TT
CLASS="TYPE"
>oid</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定されたOIDを持つテーブル空間で使用されるディスク容量</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_tablespace_size(<TT
CLASS="TYPE"
>name</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定された名前を持つテーブル空間で使用されるディスク容量</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_total_relation_size(<TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>bigint</TT
></TD
><TD
>指定されたテーブルで使用される、すべてのインデックスと<ACRONYM
CLASS="ACRONYM"
>TOAST</ACRONYM
>データを含むディスク総容量
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
>    <CODE
CLASS="FUNCTION"
>pg_column_size</CODE
>は任意の個別のデータ値を格納するのに使用されている領域を示します。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_total_relation_size</CODE
>は、テーブルまたはTOASTテーブルのOIDまたは名前を受け付け、指定されたテーブルと関連する全てのインデックスで使用される総ディスク容量を返します。
この関数は<CODE
CLASS="FUNCTION"
>pg_table_size</CODE
> <TT
CLASS="LITERAL"
>+</TT
> <CODE
CLASS="FUNCTION"
>pg_indexes_size</CODE
> の結果と等しいです。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_table_size</CODE
>は、テーブルのOIDまたは名前を受け付け、インデックスを除いたテーブルのみで使用されるディスク容量を返します。
(TOAST領域、空き領域マップ、可視性マップは含みます。)
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_indexes_size</CODE
>は、テーブルのOIDまたは名前を受け付け、指定されたテーブル付与されている全てのインデックスで使用されるディスク容量を返します。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_database_size</CODE
>と<CODE
CLASS="FUNCTION"
>pg_tablespace_size</CODE
>はデータベースまたはテーブル空間の名前またはOIDを受付け、そこで使用される総容量を返します。
<CODE
CLASS="FUNCTION"
>pg_database_size</CODE
>を使うためには、指定されたデータベースに<TT
CLASS="LITERAL"
>CONNECT</TT
>権限(デフォルトで付与されている)を持っていなければなりません。
<CODE
CLASS="FUNCTION"
>pg_tablespace_size</CODE
>を使うためには、それが現在のデータベースのデフォルトテーブル空間でない限り、指定されたテーブル空間に<TT
CLASS="LITERAL"
>CREATE</TT
>権限を持っていなければなりません。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_relation_size</CODE
>は、テーブル、インデックス、またはTOASTテーブルのOIDまたは名前を受け付け、そのリレーションの1つのフォークのディスク容量をバイト単位で返します。
(たいていの目的には、高位の関数<CODE
CLASS="FUNCTION"
>pg_total_relation_size</CODE
>や<CODE
CLASS="FUNCTION"
>pg_table_size</CODE
>を使うのがより便利であることに注意してください。高位の関数はフォークすべての容量を合計します。)
引数1つでは、そのリレーションの主データフォークの容量を返します。
2番目の引数はどのフォークを調査するかを指定するために設定できます。
    <P
></P
></P><UL
COMPACT="COMPACT"
><LI
><P
><TT
CLASS="LITERAL"
>'main'</TT
>を指定すると、そのリレーションの主データフォークの容量を返します。
      </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>'fsm'</TT
>を指定すると、リレーションに関連した空き領域マップ(<A
HREF="storage-fsm.html"
>項63.3</A
>を参照)を返します。
      </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>'vm'</TT
>を指定すると、リレーションに関連した可視性マップ(<A
HREF="storage-vm.html"
>項63.4</A
>を参照)の容量を返します。
      </P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>'init'</TT
>を指定すると、もしあれば、リレーションに関連した初期化フォークの容量を返します。
      </P
></LI
></UL
><P>
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_size_pretty</CODE
>は、適切にkB、MB、GB、もしくはTB単位を使用して目で見て判るようにその他の関数の1つの結果を整形するのに使用可能です。
   </P
><P
>上記の関数において、テーブルやインデックスを<TT
CLASS="TYPE"
>regclass</TT
>引数として受け取って処理するものがありますが、この引数は単に<TT
CLASS="STRUCTNAME"
>pg_class</TT
>システムカタログにあるテーブルやインデックスのOIDです。
ただし、<TT
CLASS="TYPE"
>regclass</TT
>データ型が自動で入力変換を行うため、ユーザが手動で該当するOIDを調べる必要はありません。リテラル定数のようにシングルクォートで囲んだテーブル名を記述するだけです。
通常のSQL名に対する処理互換のため、テーブル名をダブルクォートで囲わない限り、テーブル名として入力された文字列は小文字に変換されます。
   </P
><P
>上記の関数に対し、既存オブジェクトに該当するものがないOIDが渡された場合はNULLが返されます。
   </P
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-DBLOCATION"
>表9-74</A
> に示される関数は、データベースオブジェクトに関連する特定のディスクファイルを確認する際の手助けとなります。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADMIN-DBLOCATION"
></A
><P
><B
>表 9-74. データベースオブジェクト位置関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_relation_filenode(<TT
CLASS="PARAMETER"
>relation</TT
> <TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>oid</TT
></TD
><TD
>        指定されたリレーションのファイルノード番号
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_relation_filepath(<TT
CLASS="PARAMETER"
>relation</TT
> <TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>        指定されたリレーションのファイルパス
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_filenode_relation(<TT
CLASS="PARAMETER"
>tablespace</TT
> <TT
CLASS="TYPE"
>oid</TT
>, <TT
CLASS="PARAMETER"
>filenode</TT
> <TT
CLASS="TYPE"
>oid</TT
>)</CODE
></TT
>
        </TD
><TD
><TT
CLASS="TYPE"
>regclass</TT
></TD
><TD
>        与えられたテーブル空間とファイルノードに関連するリレーションを見つける
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
><CODE
CLASS="FUNCTION"
>pg_relation_filenode</CODE
>は、テーブル、インデックス、シーケンス、もしくはTOASTテーブルのOIDまたは名前を受け付け、現在それに充てられている<SPAN
CLASS="QUOTE"
>"ファイルノード"</SPAN
>番号を返します。
ファイルノードは、リレーションに使用しているファイル名の基礎部分です(詳しくは<A
HREF="storage-file-layout.html"
>項63.1</A
>を参照して下さい)。
ほとんどのテーブルについては、結果が<TT
CLASS="STRUCTNAME"
>pg_class</TT
>.<TT
CLASS="STRUCTFIELD"
>relfilenode</TT
>と同じになります。ただし、いくつかのシステムカタログでは<TT
CLASS="STRUCTFIELD"
>relfilenode</TT
>が0になるため、これらのシステムカタログの正しいファイルノードを取得するには、この関数を使用しなければいけません。
この関数は、ビューの様にストレージに格納されないリレーションが指定された場合はNULLを返します。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_relation_filepath</CODE
>は<CODE
CLASS="FUNCTION"
>pg_relation_filenode</CODE
>と似ていますが、こちらはリレーションのファイルパス名(データベースクラスタのディレクトリである<TT
CLASS="VARNAME"
>PGDATA</TT
>からの相対パス)を返します。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_filenode_relation</CODE
>は<CODE
CLASS="FUNCTION"
>pg_relation_filenode</CODE
>の逆です。
<SPAN
CLASS="QUOTE"
>"テーブル空間"</SPAN
>OIDと<SPAN
CLASS="QUOTE"
>"ファイルノード"</SPAN
>を与えると、関連するリレーションのOIDを返します。
データベースのデフォルトテーブル空間内のテーブルに対しては、テーブル空間は0と指定できます。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-ADMIN-INDEX"
>9.26.8. インデックス保守関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-INDEX-TABLE"
>表9-75</A
>にインデックスの保守タスクに使用できる関数を示します。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADMIN-INDEX-TABLE"
></A
><P
><B
>表 9-75. インデックス保守関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>brin_summarize_new_values(<TT
CLASS="PARAMETER"
>index_oid</TT
> <TT
CLASS="TYPE"
>regclass</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>integer</TT
></TD
><TD
>まだ要約されていないページ範囲を要約する</TD
></TR
></TBODY
></TABLE
></DIV
><P
><CODE
CLASS="FUNCTION"
>brin_summarize_new_values</CODE
>は引数としてBRINインデックスのOIDを受け取り、インデックスを検査してベーステーブル内のインデックスによって現在要約されていないページ範囲を探します。
そのような範囲があれば、テーブルのページをスキャンして新しい要約インデックスタプルを作成します。
インデックスに挿入された新しいページ範囲要約の数を返します。
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-ADMIN-GENFILE"
>9.26.9. 汎用ファイルアクセス関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADMIN-GENFILE-TABLE"
>表9-76</A
>で示されている関数はサーバをホスティングしているマシン上のファイルに対し、ネイティブのアクセスを提供します。
データベースクラスタディレクトリと<TT
CLASS="VARNAME"
>log_directory</TT
>に存在するファイルのみがアクセス可能です。
クラスタディレクトリ内のファイルに対して相対パスを、そしてログファイルに対しては<TT
CLASS="VARNAME"
>log_directory</TT
>構成設定に一致するパスを使用してください。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADMIN-GENFILE-TABLE"
></A
><P
><B
>表 9-76. 汎用ファイルアクセス関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_ls_dir(<TT
CLASS="PARAMETER"
>dirname</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>missing_ok</TT
> <TT
CLASS="TYPE"
>boolean</TT
>, <TT
CLASS="PARAMETER"
>include_dot_dirs</TT
> <TT
CLASS="TYPE"
>boolean</TT
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>setof text</TT
></TD
><TD
>ディレクトリの内容を一覧表示する
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_read_file(<TT
CLASS="PARAMETER"
>filename</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>offset</TT
> <TT
CLASS="TYPE"
>bigint</TT
>, <TT
CLASS="PARAMETER"
>length</TT
> <TT
CLASS="TYPE"
>bigint</TT
> [, <TT
CLASS="PARAMETER"
>missing_ok</TT
> <TT
CLASS="TYPE"
>boolean</TT
>] ])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>text</TT
></TD
><TD
>テキストファイルの内容を返す
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_read_binary_file(<TT
CLASS="PARAMETER"
>filename</TT
> <TT
CLASS="TYPE"
>text</TT
> [, <TT
CLASS="PARAMETER"
>offset</TT
> <TT
CLASS="TYPE"
>bigint</TT
>, <TT
CLASS="PARAMETER"
>length</TT
> <TT
CLASS="TYPE"
>bigint</TT
> [, <TT
CLASS="PARAMETER"
>missing_ok</TT
> <TT
CLASS="TYPE"
>boolean</TT
>] ])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>bytea</TT
></TD
><TD
>ファイルの内容を返す
       </TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_stat_file(<TT
CLASS="PARAMETER"
>filename</TT
> <TT
CLASS="TYPE"
>text</TT
>[, <TT
CLASS="PARAMETER"
>missing_ok</TT
> <TT
CLASS="TYPE"
>boolean</TT
>])</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>record</TT
></TD
><TD
>ファイルについての情報を返す
       </TD
></TR
></TBODY
></TABLE
></DIV
><P
>これらの関数はいずれもオプションで<TT
CLASS="PARAMETER"
>missing_ok</TT
>パラメータをとり、ファイルまたはディレクトリが存在しない場合の動作を指定できます。
<TT
CLASS="LITERAL"
>true</TT
>の場合、関数はNULLを返します（ただし、<CODE
CLASS="FUNCTION"
>pg_ls_dir</CODE
>は空の結果集合を返します）。
<TT
CLASS="LITERAL"
>false</TT
>の場合はエラーが発生します。
デフォルトは<TT
CLASS="LITERAL"
>false</TT
>です。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_ls_dir</CODE
>は、指定されたディレクトリ内のすべてのファイル（およびディレクトリと他の特殊ファイル）の名前を返します。
<TT
CLASS="PARAMETER"
>include_dot_dirs</TT
>は<SPAN
CLASS="QUOTE"
>"."</SPAN
>と<SPAN
CLASS="QUOTE"
>".."</SPAN
>が結果集合に含まれるかどうかを指定します。
デフォルト(<TT
CLASS="LITERAL"
>false</TT
>)ではそれらを除外しますが、それらを含めると、<TT
CLASS="PARAMETER"
>missing_ok</TT
>が<TT
CLASS="LITERAL"
>true</TT
>の場合は、空のディレクトリと存在しないディレクトリを区別するために役立つでしょう。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_read_file</CODE
>は与えられた<TT
CLASS="PARAMETER"
>offset</TT
>から始まり、最大<TT
CLASS="PARAMETER"
>length</TT
>バイト（先にファイルの終りに到達すればこれより少なくなります）テキストファイルの一部分を返します。
<TT
CLASS="PARAMETER"
>offset</TT
>が負の場合にはファイルの終りから数えた位置から読み出します。
<TT
CLASS="PARAMETER"
>offset</TT
>と<TT
CLASS="PARAMETER"
>length</TT
>が省略された場合、ファイル全体が返されます。
ファイルから読み込まれたバイトは、そのサーバの符号化方式での文字列として解釈されます。
読み込んだバイト列がその符号化方式において有効でない場合にはエラーが投げられます。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_read_binary_file</CODE
>は、結果が<TT
CLASS="TYPE"
>bytea</TT
>値となり、従って符号化の検査がされないことを除き、<CODE
CLASS="FUNCTION"
>pg_read_file</CODE
>と似ています。
<CODE
CLASS="FUNCTION"
>convert_from</CODE
>関数と組み合わせることで、この関数を、指定した符号化方式でファイルの読み込むために使うことができます。
    
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');</PRE
><P>
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_stat_file</CODE
>はファイル容量、最終アクセス時刻、最終更新時刻、最後にファイルステータスを変更した時刻（これはUnixプラットフォームのみ）、ファイル作成時刻（Windowsのみ）および、ディレクトリかどうかを示す<TT
CLASS="TYPE"
>boolean</TT
>を返します。
典型的な使用方法を示します。
</P><PRE
CLASS="PROGRAMLISTING"
>SELECT * FROM pg_stat_file('filename');
SELECT (pg_stat_file('filename')).modification;</PRE
><P>
   </P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FUNCTIONS-ADVISORY-LOCKS"
>9.26.10. 勧告的ロック用関数</A
></H2
><P
><A
HREF="functions-admin.html#FUNCTIONS-ADVISORY-LOCKS-TABLE"
>表9-77</A
>に示す関数は勧告的ロックを管理します。
これらの関数の適切な使用方法についての詳細は、<A
HREF="explicit-locking.html#ADVISORY-LOCKS"
>項13.3.5</A
>を参照してください。
   </P
><DIV
CLASS="TABLE"
><A
NAME="FUNCTIONS-ADVISORY-LOCKS-TABLE"
></A
><P
><B
>表 9-77. 勧告的ロック用関数</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><COL><COL><COL><THEAD
><TR
><TH
>名前</TH
><TH
>戻り型</TH
><TH
>説明</TH
></TR
></THEAD
><TBODY
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_lock(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>セッションレベルの排他勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_lock(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>セッションレベルの排他勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_lock_shared(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>セッションレベルの共有勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_lock_shared(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>セッションレベルの共有勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>セッションレベルの排他勧告的ロックを解放</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>セッションレベルの排他勧告的ロックを解放</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock_all()</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>現在のセッションで保持している全てのセッションレベルの勧告的ロックを解放</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock_shared(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>セッションレベルの共有勧告的ロックを解放</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock_shared(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>セッションレベルの共有勧告的ロックの解放</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_xact_lock(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>トランザクションレベルの排他勧告的ロックの獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_xact_lock(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>トランザクションレベルの排他勧告的ロックの獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_xact_lock_shared(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>トランザクションレベルの共有勧告的ロックの獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_advisory_xact_lock_shared(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>void</TT
></TD
><TD
>トランザクションレベルの共有勧告的ロックの獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_lock(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばセッションレベルの排他勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_lock(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばセッションレベルの排他勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_lock_shared(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばセッションレベルの共有勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_lock_shared(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばセッションレベルの共有勧告的ロックを獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_xact_lock(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばトランザクションレベルの排他勧告的ロックの獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_xact_lock(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばトランザクションレベルの排他勧告的ロックの獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_xact_lock_shared(<TT
CLASS="PARAMETER"
>key</TT
> <TT
CLASS="TYPE"
>bigint</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばトランザクションレベルの共有勧告的ロックの獲得</TD
></TR
><TR
><TD
>        <TT
CLASS="LITERAL"
><CODE
CLASS="FUNCTION"
>pg_try_advisory_xact_lock_shared(<TT
CLASS="PARAMETER"
>key1</TT
> <TT
CLASS="TYPE"
>int</TT
>, <TT
CLASS="PARAMETER"
>key2</TT
> <TT
CLASS="TYPE"
>int</TT
>)</CODE
></TT
>
       </TD
><TD
><TT
CLASS="TYPE"
>boolean</TT
></TD
><TD
>可能ならばトランザクションレベルの共有勧告的ロックの獲得</TD
></TR
></TBODY
></TABLE
></DIV
><P
><CODE
CLASS="FUNCTION"
>pg_advisory_lock</CODE
>は、アプリケーションが定義したリソースをロックします。キーは単一の64ビットキー値、または、２つの32ビットキー（この2つのキー空間は重複しないことに注意）によって識別されます。
もし、別のセッションが同一リソースに対するロックを保持している場合、関数はリソースが利用可能になるまで待機します。ロックは排他ロックです。
複数のロック要求があればスタックに積まれるため、同一リソースが３回ロックされた場合、他のセッションが使用できるように解放するためにはロック解除を３回行わなければなりません。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_advisory_lock_shared</CODE
>の動作は<CODE
CLASS="FUNCTION"
>pg_advisory_lock</CODE
>と同じですが、他のセッションの共有ロックと共有できるロックである点が異なります。
排他ロック要求のみ締め出されます。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_try_advisory_lock</CODE
>は<CODE
CLASS="FUNCTION"
>pg_advisory_lock</CODE
>と同様ですが、この関数の場合、ロックが利用可能になるまで待機しません。
ロックを即座に取得し<TT
CLASS="LITERAL"
>true</TT
>を返すか、ロックを即座に獲得できなかった場合に<TT
CLASS="LITERAL"
>false</TT
>を返すかのいずれかです。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_try_advisory_lock_shared</CODE
>の動作は <CODE
CLASS="FUNCTION"
>pg_try_advisory_lock</CODE
>と同じですが、排他ロックではなく共有ロックの獲得を試みます。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock</CODE
>は、事前に獲得したセッションレベルの勧告的排他ロックを解放します。ロックの解放に成功した場合、<TT
CLASS="LITERAL"
>true</TT
>を返します。ロックを保持していない場合、<TT
CLASS="LITERAL"
>false</TT
>を返し、さらに、SQL警告がサーバから報告されます。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock_shared</CODE
>の動作は<CODE
CLASS="FUNCTION"
>pg_advisory_unlock</CODE
>と同じですが、セッションレベルの勧告的共有ロックを解放する点が異なります。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_advisory_unlock_all</CODE
>は、現在のセッションで保持するセッションレベルの勧告的ロックをすべて解放します。
（この関数は、クライアントとの接続がぶざまに切れた場合でも、セッション終了時に暗黙的に呼び出されます。)
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_advisory_xact_lock</CODE
>の動作は<CODE
CLASS="FUNCTION"
>pg_advisory_lock</CODE
>と同じですが、現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_advisory_xact_lock_shared</CODE
>の動作は<CODE
CLASS="FUNCTION"
>pg_advisory_lock_shared</CODE
>と同じですが、現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_try_advisory_xact_lock</CODE
>の動作は<CODE
CLASS="FUNCTION"
>pg_try_advisory_lock</CODE
>と同じですが、ロックが獲得できた場合は現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </P
><P
><CODE
CLASS="FUNCTION"
>pg_try_advisory_xact_lock_shared</CODE
>の動作は<CODE
CLASS="FUNCTION"
>pg_try_advisory_lock_shared</CODE
>と同じですが、ロックが獲得できた場合は現在のトランザクションの終了時に自動的にロックが解放され、明示的なロックの解放はできません。
   </P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="functions-info.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="functions-trigger.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>システム情報関数</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="functions.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>トリガ関数</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
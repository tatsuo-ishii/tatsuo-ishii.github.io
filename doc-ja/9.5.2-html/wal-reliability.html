<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>信頼性</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="信頼性とログ先行書き込み"
HREF="wal.html"><LINK
REL="PREVIOUS"
TITLE="信頼性とログ先行書き込み"
HREF="wal.html"><LINK
REL="NEXT"
TITLE="ログ先行書き込み(WAL)"
HREF="wal-intro.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="信頼性とログ先行書き込み"
HREF="wal.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="wal.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 29章信頼性とログ先行書き込み</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="ログ先行書き込み(WAL)"
HREF="wal-intro.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WAL-RELIABILITY"
>29.1. 信頼性</A
></H1
><P
>信頼性は、すべての本格的なデータベースシステムで重要な特性です。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は信頼できる操作を保証するためにできることは何でもします。
信頼できる操作の一面は、コミットされたトランザクションにより記録されたデータはすべて不揮発性の領域に格納され、電源断、オペレーティングシステムの障害、ハードウェアの障害（当然ですが、不揮発性の領域自体の障害は除きます。）があっても安全であるという点です。
通常、コンピュータの永続的格納領域（ディスク装置など）へのデータ書き込みの成功がこの条件を満たします。
実際、コンピュータに致命的な障害が発生したとしても、もしディスク装置が無事ならば、類似のハードウェアを持つ別のコンピュータに移すことができ、コミットされたトランザクションを元通りに復元できます。
  </P
><P
>データを周期的にディスクプラッタに書き出すことは簡単な操作に思われるかもしれませんが、そうではありません。
ディスク装置は主メモリ、CPU、コンピュータの主メモリとディスクプラッタの間にある各種のキャッシュ層と比べ非常に低速であるからです。
まず、オペレーティングシステムのバッファキャッシュが存在します。
これは頻繁にアクセス要求があるディスクブロックをキャッシュし、ディスクへの書き込みをまとめます。
好運にもすべてのオペレーティングシステムがバッファキャッシュをディスクに強制書き込みさせる方法をアプリケーションに提供しています。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はこの機能を使用します。
（これを調整する方法については<A
HREF="runtime-config-wal.html#GUC-WAL-SYNC-METHOD"
>wal_sync_method</A
>パラメータを参照してください。）
  </P
><P
>次に、ディスク装置のコントローラキャッシュが存在する可能性があります。
特に、<ACRONYM
CLASS="ACRONYM"
>RAID</ACRONYM
>コントローラカードでは、これは一般的です。
これらの中には<I
CLASS="FIRSTTERM"
>write-through</I
>キャッシュがあり、つまり、データが届いた時に即座に書き込みがディスク装置に対して行なわれます。
他には<I
CLASS="FIRSTTERM"
>write-back</I
>キャッシュがあり、多少遅れて書き込みがディスク装置に対して行なわれます。
こうしたキャッシュでは、ディスクコントローラキャッシュが揮発性で、電源障害の際にその内容が失われてしまい、信頼性に関して致命的な問題になる可能性があります。
より優れたコントローラカードには<I
CLASS="FIRSTTERM"
>バッテリバックアップ付き装置</I
>(<ACRONYM
CLASS="ACRONYM"
>BBU</ACRONYM
>s)があり、システムの電源が落ちた場合もキャッシュに電源を供給します。
後で電源が復旧した後に、データがディスク装置に書き出されます。
  </P
><P
>最後に、ほとんどのディスク装置がキャッシュを持っています。一部はwrite-throughであり、一部はwrite-backです。
ディスクコントローラキャッシュの場合と同様にwrite-backのディスク装置キャッシュの場合にはデータが損失する恐れがあります。
一般消費者向けのIDEおよびSATA装置では、電源障害時にデータが残らないwrite-backキャッシュを使用している可能性がとりわけ高いです。
多くのソリッドステートドライブ(SSD)も同様に揮発性のwrite-backキャッシュを持っています。
  </P
><P
>これらのキャッシュは、大抵は無効にできます。しかしながらオペレーティングシステムやドライブの種類によってその方法は異なります。
  </P
><P
></P
><UL
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>Linux</SPAN
>上で<TT
CLASS="COMMAND"
>hdparm -I</TT
>を使用することでIDEおよびSATAドライブのキャッシュについて調べることができます。
<TT
CLASS="LITERAL"
>Write cache</TT
>の次に <TT
CLASS="LITERAL"
>*</TT
>があれば書き込みキャッシュが有効になっています。
<TT
CLASS="COMMAND"
>hdparm -W 0</TT
>により書き込みキャッシュを無効にできます。
SCSIドライブであれば<A
HREF="http://sg.danny.cz/sg/sdparm.html"
TARGET="_top"
><SPAN
CLASS="APPLICATION"
>sdparm</SPAN
></A
>を使うことで調査が可能です。
<TT
CLASS="COMMAND"
>sdparm --get=WCE</TT
>によりキャッシュが有効かどうかの確認ができ、<TT
CLASS="COMMAND"
>sdparm --clear=WCE</TT
>により無効にすることができます。
      </P
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>FreeBSD</SPAN
>では、IDEドライブに対して<TT
CLASS="COMMAND"
>atacontrol</TT
>により確認ができ、そして書き込みキャッシュを無効にするには<TT
CLASS="FILENAME"
>/boot/loader.conf</TT
>の<TT
CLASS="LITERAL"
>hw.ata.wc=0</TT
>を利用します。SCSIドライブに対しては<TT
CLASS="COMMAND"
>camcontrol identify</TT
>を確認に使用することができ、<TT
CLASS="COMMAND"
>sdparm</TT
>を使用できる場合にはそれを用いて書き込みキャッシュの確認と変更が可能です。
      </P
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>Solaris</SPAN
>では、ディスクの書き込みキャッシュは<TT
CLASS="COMMAND"
>format -e</TT
>で制御できます。
(Solarisの<ACRONYM
CLASS="ACRONYM"
>ZFS</ACRONYM
>ファイルシステムは、独自のディスクキャッシュ書き出しコマンドを発行しているため、ディスクの書き込みキャッシュを有効にしても安全です。)
      </P
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>Windows</SPAN
>では、もし<TT
CLASS="VARNAME"
>wal_sync_method</TT
>が<TT
CLASS="LITERAL"
>open_datasync</TT
>(デフォルト)の場合、
<TT
CLASS="LITERAL"
>My Computer\Open\<TT
CLASS="REPLACEABLE"
><I
>disk drive</I
></TT
>\Properties\Hardware\Properties\Policies\Enable write caching on the disk</TT
>のチェックを外すことで、書き込みキャッシュを無効にできます。
もう一つの方法としては、<TT
CLASS="VARNAME"
>wal_sync_method</TT
>を<TT
CLASS="LITERAL"
>fsync</TT
>か<TT
CLASS="LITERAL"
>fsync_writethrough</TT
>に設定し、書き込みキャッシュを使用しないようにします。
      </P
></LI
><LI
><P
><SPAN
CLASS="PRODUCTNAME"
>OS X</SPAN
>では、<TT
CLASS="VARNAME"
>wal_sync_method</TT
>を<TT
CLASS="LITERAL"
>fsync_writethrough</TT
>に設定することで書き込みキャッシュを使用しないようにします。
      </P
></LI
></UL
><P
>最近のSATAドライブ(<ACRONYM
CLASS="ACRONYM"
>ATAPI-6</ACRONYM
>またはそれ以降)はドライブキャッシュの書き出しコマンド(<TT
CLASS="COMMAND"
>FLUSH CACHE EXT</TT
>)を提供している一方、
SCSIドライブでは従来から類似の<TT
CLASS="COMMAND"
>SYNCHRONIZE CACHE</TT
>コマンドをサポートしていました。
これらのコマンドは、直接PostgreSQLに発行されませんが、いくつかのファイルシステム(例えば<ACRONYM
CLASS="ACRONYM"
>ZFS</ACRONYM
>や<ACRONYM
CLASS="ACRONYM"
>ext4</ACRONYM
>)では、
それらをwrite-backが有効なドライブへデータを書き出すために使います。
不幸なことに、このようなwriteバリアを持つファイルシステムは、バッテリバックアップ付き装置
(<ACRONYM
CLASS="ACRONYM"
>BBU</ACRONYM
>)のディスクコントローラと組み合わせた際に、好ましい動作をしません。
このような処理の流れにおいて、同期コマンドはコントローラキャッシュにあるデータを全てディスクへ強制的に書き込みを行うため、
BBUのメリットの大半を失わせています。<A
HREF="pgtestfsync.html"
><SPAN
CLASS="APPLICATION"
>pg_test_fsync</SPAN
></A
>プログラムを
使うことで、あなたの環境が影響を受けるかどうかを確認できます。もし影響を受けるようであれば、
ファイルシステムのwriteバリアを無効にするか、(オプションがあれば)ディスクコントローラを再設定することで、
BBUによる性能上の効果を得ることできるでしょう。もしwriteバリアを無効にした場合は、バッテリが
動作していることを確認しておきましょう。バッテリの欠陥はデータロスの可能性に繋がります。
ファイルシステムやディスクコントローラの設計者が、いずれはこの動作を修正してくれることが望まれます。
  </P
><P
>オペレーティングシステムが、ストレージハードウェアに書き込み要求を送信した時、データが不揮発性のストレージ領域に本当に届いたかどうかを確認することはほぼできません。
ですので、全てのストレージ構成品がデータとファイルシステムのメタデータの整合性を保証することをよく確認しておくことは、管理者の責任です。
バッテリバックアップされた書き込みキャッシュを持たないコントローラの使用は避けてください。
装置レベルでは、もし装置が停止前にデータが書き出されることを保証できないのであれば、write-backキャッシュを無効にしてください。
もしSSDを使っている場合、多くのドライブはデフォルトでキャッシュ書き出しコマンドを無視することに注意して下さい。
<A
HREF="http://brad.livejournal.com/2116715.html"
TARGET="_top"
><TT
CLASS="FILENAME"
>diskchecker.pl</TT
></A
>を使うことで、I/Oサブシステムの動作の信頼性をテストすることができます。
  </P
><P
>ディスクプラッタの書き込み操作自体によってもデータ損失が発生することがあります。
ディスクプラッタは、通常512バイトのセクタに分割されています。
物理的な読み込み操作、書き込み操作はすべて、セクタ全体を処理します。
書き込み要求がディスクに達した時、その要求は512バイトの倍数になるでしょう(<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>では大抵一度に8192バイトすなわち16セクタを書き込みます)。そして電源断により、任意のタイミングで書き込み処理が失敗することがありえます。これは一部の512バイトのセクタに書き込みが行なわれたのに、残りのセクタには書き込みが行なわれていない状況を意味します。
こうした問題の対策として、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、ディスク上の実際のページを変更する<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>前</I
></SPAN
>に定期的にページ全体のイメージを永続的なWAL格納領域に書き出します。
これにより、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はクラッシュリカバリ時に部分的に書き出されたページをWALから復旧させることができます。
もし、部分的なページ書き込みを防止できるファイルシステムソフトウェア（例えばZFS）を使うのであれば、<A
HREF="runtime-config-wal.html#GUC-FULL-PAGE-WRITES"
>full_page_writes</A
>を無効にしてページイメージ作成を無効にすることができます。バッテリバックアップ付き（BBU）のディスクコントローラでは、フルページ（8kB）がBBUへ書き込まれることを保証できなければ、部分的なページ書き出しを防止できません。
  </P
><P
>さらに<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は、ハードウェアエラーや経時変化によるメディア障害により発生する、ごみデータ読み書きしてしまうようなストレージ装置内のある種のデータ破損を防ぎます。
   <P
></P
></P><UL
><LI
><P
>WALファイルのそれぞれのレコードは、レコードの内容が正確かどうかを伝えるためCRC-32 (32-bit)チェックにより保護されています。
CRCの値はそれぞれのWALレコードを書き込み、クラッシュ回復の過程で検証され、アーカイブの回復とレプリケーション時に設定されます。
     </P
></LI
><LI
><P
>今のところ、デフォルトではデータページはチェックサム計算はされませんが、WALレコードに記録されているページ全体のイメージは保護されます。
詳細は<A
HREF="app-initdb.html#APP-INITDB-DATA-CHECKSUMS"
><SPAN
CLASS="APPLICATION"
>initdb</SPAN
></A
>を参照してください。
     </P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>pg_clog</TT
>、<TT
CLASS="FILENAME"
>pg_subtrans</TT
>、<TT
CLASS="FILENAME"
>pg_multixact</TT
>、<TT
CLASS="FILENAME"
>pg_serial</TT
>、<TT
CLASS="FILENAME"
>pg_notify</TT
>、<TT
CLASS="FILENAME"
>pg_stat</TT
>、<TT
CLASS="FILENAME"
>pg_snapshots</TT
>のような内部データ構造は直接チェックサム計算もされず、全ページ書き込みによる保護もされていません。
しかし、そのようなデータ構造が持続する場所は、WALレコードはクラッシュ回復時に正確に最新の変更を行えるようWALレコードが書き出され、それらのWALレコードは上記のように保護されます。
     </P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>pg_twophase</TT
>にある個別の状態ファイルはCRC-32で保護されています。
     </P
></LI
><LI
><P
>大きな問い合わせの中でソート、具現化、および中間結果用に使用される暫定的なデータファイルは現在チェックサム計算されず、それらのファイルに対する変更もWALレコードに書き込まれません。
     </P
></LI
></UL
><P>
  </P
><P
><SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は修復可能なメモリーエラーに対して保護を行いません。工業規格の誤り検出訂正（Error Correcting Codes -ECC-）またはバッテリー保護付きのRAM使用が想定されています。
  </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="wal.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="wal-intro.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>信頼性とログ先行書き込み</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="wal.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>ログ先行書き込み(<ACRONYM
CLASS="ACRONYM"
>WAL</ACRONYM
>)</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
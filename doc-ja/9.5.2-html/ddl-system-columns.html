<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>システム列</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="データ定義"
HREF="ddl.html"><LINK
REL="PREVIOUS"
TITLE="制約"
HREF="ddl-constraints.html"><LINK
REL="NEXT"
TITLE="テーブルの変更"
HREF="ddl-alter.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="制約"
HREF="ddl-constraints.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="ddl.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 5章データ定義</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="テーブルの変更"
HREF="ddl-alter.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DDL-SYSTEM-COLUMNS"
>5.4. システム列</A
></H1
><P
>全てのテーブルには、システムによって暗黙的に定義された<I
CLASS="FIRSTTERM"
>システム列</I
>がいくつかあります。
そのため、システム列の名前はユーザ定義列の名前として使うことはできません。
（これらの制約は名前がキーワードであるかどうかとは関係ありません。
つまり、名前を引用符で囲んでもこの制約を回避することはできません。）
システム列については、あまり意識する必要はありません。
これらが存在することを知っていれば十分です。
  </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="STRUCTFIELD"
>oid</TT
></DT
><DD
><P
>      
行のオブジェクト識別子（オブジェクトID）です。
この列は<TT
CLASS="LITERAL"
>WITH OIDS</TT
>を付けてテーブルが作成された場合、あるいはテーブル作成時に<A
HREF="runtime-config-compatible.html#GUC-DEFAULT-WITH-OIDS"
>default_with_oids</A
>設定変数が設定されていた場合にのみ存在します。
この列の型は<TT
CLASS="LITERAL"
>oid</TT
>（列名と同じ）です。この型についての詳細は<A
HREF="datatype-oid.html"
>項8.18</A
>を参照してください。
     </P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
>tableoid</TT
></DT
><DD
><P
>この行を含むテーブルのOIDです。
この列は特に、継承階層からの選択問い合わせでは便利です（<A
HREF="ddl-inherit.html"
>項5.9</A
>を参照してください）。
この列がないと、どのテーブルからその行が来たのかわかりにくいからです。
<TT
CLASS="STRUCTFIELD"
>tableoid</TT
>を<CODE
CLASS="CLASSNAME"
>pg_class</CODE
>の<TT
CLASS="STRUCTFIELD"
>oid</TT
>列に結合することでテーブル名を得ることができます。
     </P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
>xmin</TT
></DT
><DD
><P
>この行バージョンの挿入トランザクションの識別情報（トランザクションID）です。
（行バージョンとは、行の個別の状態です。
行が更新される度に、同一の論理的な行に対する新しい行バージョンが作成されます。）
     </P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
>cmin</TT
></DT
><DD
><P
>挿入トランザクション内の（0から始まる）コマンド識別子です。
     </P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
>xmax</TT
></DT
><DD
><P
>削除トランザクションの識別情報（トランザクションID）です。
削除されていない行バージョンではゼロです。
可視の行バージョンでこの列が非ゼロの場合があります。
これは通常、削除トランザクションがまだコミットされていないこと、または、削除の試行がロールバックされたことを意味しています。
     </P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
>cmax</TT
></DT
><DD
><P
>削除トランザクション内のコマンド識別子、もしくはゼロです。
     </P
></DD
><DT
><TT
CLASS="STRUCTFIELD"
>ctid</TT
></DT
><DD
><P
>テーブル内における、行バージョンの物理的位置を表します。
<TT
CLASS="STRUCTFIELD"
>ctid</TT
>は行バージョンを素早く見つけるために使うことができますが、行の<TT
CLASS="STRUCTFIELD"
>ctid</TT
>は<TT
CLASS="COMMAND"
>VACUUM FULL</TT
>により更新あるいは移動させられると変わります。
したがって、<TT
CLASS="STRUCTFIELD"
>ctid</TT
>は長期の行識別子としては使えません。
論理行を識別するためには、OID、あるいはさらに良いのはユーザ定義の通番数を使うべきです。
     </P
></DD
></DL
></DIV
><P
>OIDは32ビット数であり、クラスタ全体で1つのカウンタです。
大規模、もしくは長期間使用するデータベースでは、カウンタが一周してしまう可能性があります。
そのため、一意性を確保するための手順を踏んでいない限り、OIDが一意であると仮定してはなりません。
もしテーブル内の行を同定する必要がある場合は、シーケンスジェネレータを使用することを強く推奨します。
しかし、OIDはいくつかの注意を払うことによりシーケンスと同様に使用することができます。

    <P
></P
></P><UL
><LI
><P
>OIDを行の特定のために使用するテーブルについては、OID列に一意性制約を作成するべきです。
このような一意性制約（もしくは一意インデックス）が存在する場合は、システムは既存の行に一致するようなOIDを生成しません。
（もちろん、これはテーブルの行数が2<SUP
>32</SUP
>（40億）より少ない場合に可能となります。性能を考慮すると、実際には行数はそれよりずっと少ない方がよいでしょう。）
      </P
></LI
><LI
><P
>OIDは複数のテーブルをまたがって一意であると仮定してはなりません。
データベース全体での識別子が必要な場合は<TT
CLASS="STRUCTFIELD"
>tableoid</TT
>と行OIDを組み合わせて使用してください。
      </P
></LI
><LI
><P
>もちろん、問題にしているテーブルは、<TT
CLASS="LITERAL"
>WITH OIDS</TT
>を使用して作成されなくてはいけません。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
> 8.1から<TT
CLASS="LITERAL"
>WITHOUT OIDS</TT
>がデフォルトです。
      </P
></LI
></UL
><P>
   </P
><P
>トランザクション識別子も32ビット量です。
長期間使用するデータベースでは、トランザクションIDが一周してしまう可能性があります。
これは、適切な保守作業を行うことで、致命的な問題にはなりません。
詳細は<A
HREF="maintenance.html"
>第23章</A
>を参照してください。
しかし、長期（10億トランザクション以上）にわたってトランザクションIDの一意性に依存することは賢明ではありません。
   </P
><P
>コマンド識別子もまた、32ビット量です。
このため、単一トランザクション内のコマンド数には2<SUP
>32</SUP
>（40億）個までという制限が発生します。
実際、この制限は問題にはなりません。
これは<ACRONYM
CLASS="ACRONYM"
>SQL</ACRONYM
>コマンド数に対する制限であり、処理される行数に対する制限ではないことに注意してください。
また、データベースの内容を実際に変更するコマンドのみがコマンド識別子を消費します。
   </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="ddl-constraints.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="ddl-alter.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>制約</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="ddl.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>テーブルの変更</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>外部データラッパでの行ロック</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REV="MADE"
HREF="mailto:pgsql-docs@postgresql.org"><LINK
REL="HOME"
TITLE="PostgreSQL 9.5.2文書"
HREF="index.html"><LINK
REL="UP"
TITLE="外部データラッパの作成"
HREF="fdwhandler.html"><LINK
REL="PREVIOUS"
TITLE="外部データラッパのクエリプラン作成"
HREF="fdw-planning.html"><LINK
REL="NEXT"
TITLE="テーブルサンプリングメソッドの書き方"
HREF="tablesample-method.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="stylesheet.css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=utf-8"><META
NAME="creation"
CONTENT="2016-05-13T05:09:04"></HEAD
><BODY
CLASS="SECT1"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="4"
ALIGN="center"
VALIGN="bottom"
><A
HREF="index.html"
>PostgreSQL 9.5.2文書</A
></TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
TITLE="外部データラッパのクエリプラン作成"
HREF="fdw-planning.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="top"
><A
HREF="fdwhandler.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="60%"
ALIGN="center"
VALIGN="bottom"
>第 54章外部データラッパの作成</TD
><TD
WIDTH="20%"
ALIGN="right"
VALIGN="top"
><A
TITLE="テーブルサンプリングメソッドの書き方"
HREF="tablesample-method.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="FDW-ROW-LOCKING"
>54.5. 外部データラッパでの行ロック</A
></H1
><P
>FDWの元になる記憶機構が、行の同時更新を防ぐために個々の行をロックするという概念を持っているなら、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の通常のテーブルで使われている意味にできる限り現実的で近い行単位のロックをFDWが実施することは価値があるでしょう。
これに関していくつかの考慮点があります。
    </P
><P
>なされるべき重要な決定の一つは、<I
CLASS="FIRSTTERM"
>早いロック</I
>を実行するか<I
CLASS="FIRSTTERM"
>遅いロック</I
>を実行するか、です。
早いロックでは、行は、元となる記憶機構から最初に取り出されたときにロックされます。
一方、遅いロックでは、行は、それがロックされる必要があることがわかってからロックされます。
（この違いは、一部の行がローカルで検査される制約や結合条件によって除外されるために発生します。）
早いロックの方がずっと単純ですし、リモートの記憶機構との間の余分なやりとりもなくて済みますが、ロックしなくても良い行をロックするかもしれませんし、結果的に同時実行性が低下したり、予期しないデッドロックさえ発生します。
一方で、遅いロックは、ロックすべき行が後で一意に再識別できる場合にのみ可能です。
できれば、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>のTIDがそうしているように、行識別子は行の特定のバージョンを識別できるのが望ましいです。
    </P
><P
>デフォルトでは<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>はFDWとのやりとりにおいてロックの考慮をしませんが、FDWはコアのコードからの明示的なサポートなしに、早いロックを実行することができます。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>バージョン9.5で追加された<A
HREF="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING"
>項54.2.4</A
>に記載されたAPI関数を使うことで、望むならFDWで遅いロックを使うことも可能です。
    </P
><P
>さらなる考慮点は、<TT
CLASS="LITERAL"
>READ COMMITTED</TT
>分離モードにおいて、<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>は対象のタプルの更新されたバージョンに対して制約と結合条件の再検査を行う必要があるかもしれないということです。
結合条件を再検査するには、前回取得対象のタプルと結合された、取得対象外の行の複製を再取得する必要があります。
<SPAN
CLASS="PRODUCTNAME"
>PostgreSQL</SPAN
>の標準テーブルを使うときは、結合を通じて生成される列リストに対象でないテーブルのTIDを含めて、必要な時には対象でない行を再フェッチすることで解決しています。
この方法は結合のデータセットを小さくできますが、安価な再フェッチ機能と再フェッチすべきバージョンの行を一意に特定できるTIDが必要になります。
そのためデフォルトで外部テーブルに対して使われる方法は、外部テーブルからフェッチされた凝然体を結合を通じて生成した列リストに含めるというものです。
これによりFDWに対する特別な要請はなくなりますが、マージ結合およびハッシュ結合に置いてパフォーマンスが低下する結果となるかもしれません。
再フェッチの要求を満たすことができるFDWでは最初の方法を選択するのも良いでしょう。
    </P
><P
>外部テーブルに対する<TT
CLASS="COMMAND"
>UPDATE</TT
>や<TT
CLASS="COMMAND"
>DELETE</TT
>では、対象テーブルに対する<TT
CLASS="LITERAL"
>ForeignScan</TT
>操作はフェッチする行を、恐らくは<TT
CLASS="COMMAND"
>SELECT FOR UPDATE</TT
>と同等なものを用いてロックすることが推奨されます。
FDWはテーブルが<TT
CLASS="COMMAND"
>UPDATE</TT
>または<TT
CLASS="COMMAND"
>DELETE</TT
>の対象かどうかを、計画時にそのrelidを<TT
CLASS="LITERAL"
>root-&gt;parse-&gt;resultRelation</TT
>と比較することで、あるいは実行時に<CODE
CLASS="FUNCTION"
>ExecRelationIsTargetRelation()</CODE
>を使うことで検知できます。
これに代わる可能性として、<CODE
CLASS="FUNCTION"
>ExecForeignUpdate</CODE
>または<CODE
CLASS="FUNCTION"
>ExecForeignDelete</CODE
>のコールバック内で遅いロックを実行することがありますが、これについて特別なサポートは提供されません。
    </P
><P
><TT
CLASS="COMMAND"
>SELECT FOR UPDATE/SHARE</TT
>コマンドによりロックすることが指定された外部テーブルについて、<TT
CLASS="LITERAL"
>ForeignScan</TT
>の操作では<TT
CLASS="COMMAND"
>SELECT FOR UPDATE/SHARE</TT
>と同等なものを使ってタプルをフェッチすることで、ここでも早いロックを実行できます。
逆に遅いロックを実行するには、<A
HREF="fdw-callbacks.html#FDW-CALLBACKS-ROW-LOCKING"
>項54.2.4</A
>で定義されるコールバック関数を提供して下さい。
<CODE
CLASS="FUNCTION"
>GetForeignRowMarkType</CODE
>では、要求されたロックの強度に応じて、rowmarkのオプション<TT
CLASS="LITERAL"
>ROW_MARK_EXCLUSIVE</TT
>、<TT
CLASS="LITERAL"
>ROW_MARK_NOKEYEXCLUSIVE</TT
>、<TT
CLASS="LITERAL"
>ROW_MARK_SHARE</TT
>または<TT
CLASS="LITERAL"
>ROW_MARK_KEYSHARE</TT
>を選択して下さい。
（コアのコードは、この4つのオプションのどれが選ばれたかに関係なく、同じ動作をします。）
その他には、この種のコマンドによって外部テーブルのロックが指定されたかどうかを、計画時に<CODE
CLASS="FUNCTION"
>get_plan_rowmark</CODE
>を使うことで、あるいは実行時に<CODE
CLASS="FUNCTION"
>ExecFindRowMark</CODE
>を使うことで検知できます。
このとき、nullでないrowmark構造体が戻されるかどうかだけでなく、その<TT
CLASS="STRUCTFIELD"
>strength</TT
>フィールドが<TT
CLASS="LITERAL"
>LCS_NONE</TT
>でないことも確認しなければなりません。
    </P
><P
>最後に、<TT
CLASS="COMMAND"
>UPDATE</TT
>、<TT
CLASS="COMMAND"
>DELETE</TT
>または<TT
CLASS="COMMAND"
>SELECT FOR UPDATE/SHARE</TT
>コマンドで使用されたが、行ロックの指定はされなかった外部テーブルについて、ロック強度が<TT
CLASS="LITERAL"
>LCS_NONE</TT
>になっているときに<CODE
CLASS="FUNCTION"
>GetForeignRowMarkType</CODE
>でオプション<TT
CLASS="LITERAL"
>ROW_MARK_REFERENCE</TT
>を選択すれば、すべての行を複製するというデフォルトの動作を変更することができます。
これにより、<TT
CLASS="STRUCTFIELD"
>markType</TT
>にその値を入れて<CODE
CLASS="FUNCTION"
>RefetchForeignRow</CODE
>が呼び出されるようになります。
このとき、新しいロックを取得することなく行を再取得します。
（<CODE
CLASS="FUNCTION"
>GetForeignRowMarkType</CODE
>関数を使うが、ロックしていない行を再フェッチしたくない場合は、<TT
CLASS="LITERAL"
>LCS_NONE</TT
>についてオプション<TT
CLASS="LITERAL"
>ROW_MARK_COPY</TT
>を選択して下さい。）
    </P
><P
>さらなる情報は、<TT
CLASS="FILENAME"
>src/include/nodes/lockoptions.h</TT
>、<TT
CLASS="FILENAME"
>src/include/nodes/plannodes.h</TT
>での<TT
CLASS="TYPE"
>RowMarkType</TT
>と<TT
CLASS="TYPE"
>PlanRowMark</TT
>についてのコメント、<TT
CLASS="FILENAME"
>src/include/nodes/execnodes.h</TT
>での<TT
CLASS="TYPE"
>ExecRowMark</TT
>についてのコメントを参照して下さい。
    </P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="fdw-planning.html"
ACCESSKEY="P"
>前のページ</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>ホーム</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="tablesample-method.html"
ACCESSKEY="N"
>次のページ</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>外部データラッパのクエリプラン作成</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="fdwhandler.html"
ACCESSKEY="U"
>上に戻る</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>テーブルサンプリングメソッドの書き方</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>